import { r as __export } from "./chunk-DgPTj83v.js";
import { n as init_dist, t as Buffer } from "./dist-B_PGMnbI.js";
import { n as process$1, t as init_dist$1 } from "./dist-Dmaes8r4.js";
import { _ as number$5, a as copy$2, b as ascending$2, c as number$4, d as precisionFixed_default, f as tickStep, g as bisect_default, h as bisectRight$1, l as precisionRound_default, m as bisectLeft$1, n as linearish, o as identity$1, p as ticks, r as tickFormat$1, s as transformer$2, t as linear$1, u as precisionPrefix_default, v as numbers$2, y as bisector } from "./linear-Csp1_tTx.js";
import { n as ordinal, r as InternSet, t as implicit } from "./ordinal-CN4lqhtQ.js";
import { A as nice$1, C as utcDay, D as utcMinute, E as timeMinute, M as max, O as second, S as timeDay, T as utcHour, _ as timeSunday, a as utcFormat$1, c as utcTickInterval, d as utcYear, f as timeMonth, i as timeParse$1, j as min$1, k as millisecond, l as utcTicks, n as time$1, o as utcParse$1, p as utcMonth, r as timeFormat$2, s as formatLocale, t as calendar, u as timeYear, w as timeHour, x as utcSunday } from "./time-ovHtQUyN.js";
import { t as range$3 } from "./range-Dqg-lOu1.js";
import { _ as hsl, a as piecewise, h as lab, i as src_exports$1, l as round_default, m as hcl, n as now, r as timer$1, t as Timer$1, u as value_default, v as rgb, y as dispatch_default } from "./timer-Bp1bAW5T.js";
import { n as constant_default, r as path, t as withPath } from "./path-D7waZtl4.js";
import { i as formatSpecifier, n as formatPrefix, r as locale_default, t as format$3 } from "./defaultLocale-BBsRvltv.js";
import { a as slice_default, c as constantZero, d as Node, f as computeHeight, i as squarify_default, l as constant_default$1, n as phi, o as dice_default, p as hierarchy, r as squarifyRatio, s as round_default$1, t as treemap_default, u as optional } from "./treemap-Hrg27P20.js";
import { n as initRange, t as initInterpolator } from "./init-ULMCeUqd.js";
import { t as colors_default } from "./colors-BDBoy-xL.js";
import { f as sqrt$1, p as tau$1, u as pi$1 } from "./math-BN2TBOwX.js";
import { t as arc_default } from "./arc-cZaP7Il9.js";
import { t as array_default } from "./array-BlABR2MP.js";
import { _ as basis_default, a as monotoneX, c as catmullRomOpen_default, d as cardinalOpen_default, f as cardinalClosed_default, g as basisClosed_default, h as basisOpen_default, i as natural_default, l as catmullRomClosed_default, m as bundle_default, n as stepBefore, o as monotoneY, p as cardinal_default, r as step_default, s as linearClosed_default, t as stepAfter, u as catmullRom_default, v as linear_default } from "./step-DmjVsfVE.js";
import { n as x$1, r as y$1, t as line_default } from "./line-Cl_B2mnJ.js";
function variance(t, n) {
	let r = 0, i, o = 0, s = 0;
	if (n === void 0) for (let n of t) n != null && (n = +n) >= n && (i = n - o, o += i / ++r, s += i * (n - o));
	else {
		let l = -1;
		for (let u of t) (u = n(u, ++l, t)) != null && (u = +u) >= u && (i = u - o, o += i / ++r, s += i * (u - o));
	}
	if (r > 1) return s / (r - 1);
}
function deviation(t, n) {
	let r = variance(t, n);
	return r && Math.sqrt(r);
}
var Adder = class {
	constructor() {
		this._partials = new Float64Array(32), this._n = 0;
	}
	add(t) {
		let n = this._partials, r = 0;
		for (let i = 0; i < this._n && i < 32; i++) {
			let o = n[i], s = t + o, l = Math.abs(t) < Math.abs(o) ? t - (s - o) : o - (s - t);
			l && (n[r++] = l), t = s;
		}
		return n[r] = t, this._n = r + 1, this;
	}
	valueOf() {
		let t = this._partials, n = this._n, r, i, o, s = 0;
		if (n > 0) {
			for (s = t[--n]; n > 0 && (r = s, i = t[--n], s = r + i, o = i - (s - r), !o););
			n > 0 && (o < 0 && t[n - 1] < 0 || o > 0 && t[n - 1] > 0) && (i = o * 2, r = s + i, i == r - s && (s = r));
		}
		return s;
	}
};
function permute(t, n) {
	return Array.from(n, (n) => t[n]);
}
function compareDefined(t = ascending$2) {
	if (t === ascending$2) return ascendingDefined;
	if (typeof t != "function") throw TypeError("compare is not a function");
	return (n, r) => {
		let i = t(n, r);
		return i || i === 0 ? i : (t(r, r) === 0) - (t(n, n) === 0);
	};
}
function ascendingDefined(t, n) {
	return (t == null || !(t >= t)) - (n == null || !(n >= n)) || (t < n ? -1 : t > n ? 1 : 0);
}
function quickselect(t, n, r = 0, i = Infinity, o) {
	if (n = Math.floor(n), r = Math.floor(Math.max(0, r)), i = Math.floor(Math.min(t.length - 1, i)), !(r <= n && n <= i)) return t;
	for (o = o === void 0 ? ascendingDefined : compareDefined(o); i > r;) {
		if (i - r > 600) {
			let s = i - r + 1, l = n - r + 1, u = Math.log(s), d = .5 * Math.exp(2 * u / 3), f = .5 * Math.sqrt(u * d * (s - d) / s) * (l - s / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - l * d / s + f)), g = Math.min(i, Math.floor(n + (s - l) * d / s + f));
			quickselect(t, n, p, g, o);
		}
		let s = t[n], l = r, u = i;
		for (swap$1(t, r, n), o(t[i], s) > 0 && swap$1(t, r, i); l < u;) {
			for (swap$1(t, l, u), ++l, --u; o(t[l], s) < 0;) ++l;
			for (; o(t[u], s) > 0;) --u;
		}
		o(t[r], s) === 0 ? swap$1(t, r, u) : (++u, swap$1(t, u, i)), u <= n && (r = u + 1), n <= u && (i = u - 1);
	}
	return t;
}
function swap$1(t, n, r) {
	let i = t[n];
	t[n] = t[r], t[r] = i;
}
function quantile(t, n, r) {
	if (t = Float64Array.from(numbers$2(t, r)), !(!(i = t.length) || isNaN(n = +n))) {
		if (n <= 0 || i < 2) return min$1(t);
		if (n >= 1) return max(t);
		var i, o = (i - 1) * n, s = Math.floor(o), l = max(quickselect(t, s).subarray(0, s + 1));
		return l + (min$1(t.subarray(s + 1)) - l) * (o - s);
	}
}
function quantileSorted(t, n, r = number$5) {
	if (!(!(i = t.length) || isNaN(n = +n))) {
		if (n <= 0 || i < 2) return +r(t[0], 0, t);
		if (n >= 1) return +r(t[i - 1], i - 1, t);
		var i, o = (i - 1) * n, l = Math.floor(o), u = +r(t[l], l, t);
		return u + (+r(t[l + 1], l + 1, t) - u) * (o - l);
	}
}
function mean(t, n) {
	let r = 0, i = 0;
	if (n === void 0) for (let n of t) n != null && (n = +n) >= n && (++r, i += n);
	else {
		let o = -1;
		for (let s of t) (s = n(s, ++o, t)) != null && (s = +s) >= s && (++r, i += s);
	}
	if (r) return i / r;
}
function median(t, n) {
	return quantile(t, .5, n);
}
function* flatten(t) {
	for (let n of t) yield* n;
}
function merge$3(t) {
	return Array.from(flatten(t));
}
function sum(t, n) {
	let r = 0;
	if (n === void 0) for (let n of t) (n = +n) && (r += n);
	else {
		let i = -1;
		for (let o of t) (o = +n(o, ++i, t)) && (r += o);
	}
	return r;
}
function intersection(t, ...n) {
	t = new InternSet(t), n = n.map(set$4);
	out: for (let r of t) for (let i of n) if (!i.has(r)) {
		t.delete(r);
		continue out;
	}
	return t;
}
function set$4(t) {
	return t instanceof InternSet ? t : new InternSet(t);
}
function union(...t) {
	let n = new InternSet();
	for (let r of t) for (let t of r) n.add(t);
	return n;
}
function interval_default(t, n, r) {
	var i = new Timer$1(), o = n;
	return n == null ? (i.restart(t, n, r), i) : (i._restart = i.restart, i.restart = function(t, n, r) {
		n = +n, r = r == null ? now() : +r, i._restart(function s(l) {
			l += o, i._restart(s, o += n, r), t(l);
		}, n, r);
	}, i.restart(t, n, r), i);
}
const epsilon$4 = 11102230246251565e-32, splitter = 134217729;
(3 + 8 * epsilon$4) * epsilon$4;
function sum$1(t, n, r, i, o) {
	let s, l, u, d, f = n[0], p = i[0], g = 0, _ = 0;
	p > f == p > -f ? (s = f, f = n[++g]) : (s = p, p = i[++_]);
	let v = 0;
	if (g < t && _ < r) for (p > f == p > -f ? (l = f + s, u = s - (l - f), f = n[++g]) : (l = p + s, u = s - (l - p), p = i[++_]), s = l, u !== 0 && (o[v++] = u); g < t && _ < r;) p > f == p > -f ? (l = s + f, d = l - s, u = s - (l - d) + (f - d), f = n[++g]) : (l = s + p, d = l - s, u = s - (l - d) + (p - d), p = i[++_]), s = l, u !== 0 && (o[v++] = u);
	for (; g < t;) l = s + f, d = l - s, u = s - (l - d) + (f - d), f = n[++g], s = l, u !== 0 && (o[v++] = u);
	for (; _ < r;) l = s + p, d = l - s, u = s - (l - d) + (p - d), p = i[++_], s = l, u !== 0 && (o[v++] = u);
	return (s !== 0 || v === 0) && (o[v++] = s), v;
}
function estimate(t, n) {
	let r = n[0];
	for (let i = 1; i < t; i++) r += n[i];
	return r;
}
function vec(t) {
	return new Float64Array(t);
}
var ccwerrboundA = (3 + 16 * epsilon$4) * epsilon$4, ccwerrboundB = (2 + 12 * epsilon$4) * epsilon$4, ccwerrboundC = (9 + 64 * epsilon$4) * epsilon$4 * epsilon$4, B = vec(4), C1 = vec(8), C2 = vec(12), D = vec(16), u$2 = vec(4);
function orient2dadapt(t, n, r, i, o, s, l) {
	let u, d, f, p, g, _, v, S, T, E, O, k, A, j, N, P, F, I, L = t - o, R = r - o, z = n - s, V = i - s;
	j = L * V, _ = splitter * L, v = _ - (_ - L), S = L - v, _ = splitter * V, T = _ - (_ - V), E = V - T, N = S * E - (j - v * T - S * T - v * E), P = z * R, _ = splitter * z, v = _ - (_ - z), S = z - v, _ = splitter * R, T = _ - (_ - R), E = R - T, F = S * E - (P - v * T - S * T - v * E), O = N - F, g = N - O, B[0] = N - (O + g) + (g - F), k = j + O, g = k - j, A = j - (k - g) + (O - g), O = A - P, g = A - O, B[1] = A - (O + g) + (g - P), I = k + O, g = I - k, B[2] = k - (I - g) + (O - g), B[3] = I;
	let H = estimate(4, B), U = ccwerrboundB * l;
	if (H >= U || -H >= U || (g = t - L, u = t - (L + g) + (g - o), g = r - R, f = r - (R + g) + (g - o), g = n - z, d = n - (z + g) + (g - s), g = i - V, p = i - (V + g) + (g - s), u === 0 && d === 0 && f === 0 && p === 0) || (U = ccwerrboundC * l + 33306690738754706e-32 * Math.abs(H), H += L * p + V * u - (z * f + R * d), H >= U || -H >= U)) return H;
	j = u * V, _ = splitter * u, v = _ - (_ - u), S = u - v, _ = splitter * V, T = _ - (_ - V), E = V - T, N = S * E - (j - v * T - S * T - v * E), P = d * R, _ = splitter * d, v = _ - (_ - d), S = d - v, _ = splitter * R, T = _ - (_ - R), E = R - T, F = S * E - (P - v * T - S * T - v * E), O = N - F, g = N - O, u$2[0] = N - (O + g) + (g - F), k = j + O, g = k - j, A = j - (k - g) + (O - g), O = A - P, g = A - O, u$2[1] = A - (O + g) + (g - P), I = k + O, g = I - k, u$2[2] = k - (I - g) + (O - g), u$2[3] = I;
	let W = sum$1(4, B, 4, u$2, C1);
	j = L * p, _ = splitter * L, v = _ - (_ - L), S = L - v, _ = splitter * p, T = _ - (_ - p), E = p - T, N = S * E - (j - v * T - S * T - v * E), P = z * f, _ = splitter * z, v = _ - (_ - z), S = z - v, _ = splitter * f, T = _ - (_ - f), E = f - T, F = S * E - (P - v * T - S * T - v * E), O = N - F, g = N - O, u$2[0] = N - (O + g) + (g - F), k = j + O, g = k - j, A = j - (k - g) + (O - g), O = A - P, g = A - O, u$2[1] = A - (O + g) + (g - P), I = k + O, g = I - k, u$2[2] = k - (I - g) + (O - g), u$2[3] = I;
	let G = sum$1(W, C1, 4, u$2, C2);
	return j = u * p, _ = splitter * u, v = _ - (_ - u), S = u - v, _ = splitter * p, T = _ - (_ - p), E = p - T, N = S * E - (j - v * T - S * T - v * E), P = d * f, _ = splitter * d, v = _ - (_ - d), S = d - v, _ = splitter * f, T = _ - (_ - f), E = f - T, F = S * E - (P - v * T - S * T - v * E), O = N - F, g = N - O, u$2[0] = N - (O + g) + (g - F), k = j + O, g = k - j, A = j - (k - g) + (O - g), O = A - P, g = A - O, u$2[1] = A - (O + g) + (g - P), I = k + O, g = I - k, u$2[2] = k - (I - g) + (O - g), u$2[3] = I, D[sum$1(G, C2, 4, u$2, D) - 1];
}
function orient2d(t, n, r, i, o, s) {
	let l = (n - s) * (r - o), u = (t - o) * (i - s), d = l - u, f = Math.abs(l + u);
	return Math.abs(d) >= ccwerrboundA * f ? d : -orient2dadapt(t, n, r, i, o, s, f);
}
(7 + 56 * epsilon$4) * epsilon$4, (3 + 28 * epsilon$4) * epsilon$4, (26 + 288 * epsilon$4) * epsilon$4 * epsilon$4, vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(8), vec(8), vec(8), vec(4), vec(8), vec(8), vec(8), vec(12), vec(192), vec(192), (10 + 96 * epsilon$4) * epsilon$4, (4 + 48 * epsilon$4) * epsilon$4, (44 + 576 * epsilon$4) * epsilon$4 * epsilon$4, vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(8), vec(8), vec(8), vec(8), vec(8), vec(8), vec(8), vec(8), vec(8), vec(4), vec(4), vec(4), vec(8), vec(16), vec(16), vec(16), vec(32), vec(32), vec(48), vec(64), vec(1152), vec(1152), (16 + 224 * epsilon$4) * epsilon$4, (5 + 72 * epsilon$4) * epsilon$4, (71 + 1408 * epsilon$4) * epsilon$4 * epsilon$4, vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(24), vec(24), vec(24), vec(24), vec(24), vec(24), vec(24), vec(24), vec(24), vec(24), vec(1152), vec(1152), vec(1152), vec(1152), vec(1152), vec(2304), vec(2304), vec(3456), vec(5760), vec(8), vec(8), vec(8), vec(16), vec(24), vec(48), vec(48), vec(96), vec(192), vec(384), vec(384), vec(384), vec(768), vec(96), vec(96), vec(96), vec(1152);
var EPSILON$2 = 2 ** -52, EDGE_STACK = new Uint32Array(512), Delaunator = class t {
	static from(n, r = defaultGetX, i = defaultGetY) {
		let o = n.length, s = new Float64Array(o * 2);
		for (let t = 0; t < o; t++) {
			let o = n[t];
			s[2 * t] = r(o), s[2 * t + 1] = i(o);
		}
		return new t(s);
	}
	constructor(t) {
		let n = t.length >> 1;
		if (n > 0 && typeof t[0] != "number") throw Error("Expected coords to contain numbers.");
		this.coords = t;
		let r = Math.max(2 * n - 5, 0);
		this._triangles = new Uint32Array(r * 3), this._halfedges = new Int32Array(r * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update();
	}
	update() {
		let { coords: t, _hullPrev: n, _hullNext: r, _hullTri: i, _hullHash: o } = this, s = t.length >> 1, l = Infinity, u = Infinity, d = -Infinity, f = -Infinity;
		for (let n = 0; n < s; n++) {
			let r = t[2 * n], i = t[2 * n + 1];
			r < l && (l = r), i < u && (u = i), r > d && (d = r), i > f && (f = i), this._ids[n] = n;
		}
		let p = (l + d) / 2, g = (u + f) / 2, _, v, S;
		for (let n = 0, r = Infinity; n < s; n++) {
			let i = dist(p, g, t[2 * n], t[2 * n + 1]);
			i < r && (_ = n, r = i);
		}
		let T = t[2 * _], E = t[2 * _ + 1];
		for (let n = 0, r = Infinity; n < s; n++) {
			if (n === _) continue;
			let i = dist(T, E, t[2 * n], t[2 * n + 1]);
			i < r && i > 0 && (v = n, r = i);
		}
		let O = t[2 * v], k = t[2 * v + 1], A = Infinity;
		for (let n = 0; n < s; n++) {
			if (n === _ || n === v) continue;
			let r = circumradius(T, E, O, k, t[2 * n], t[2 * n + 1]);
			r < A && (S = n, A = r);
		}
		let j = t[2 * S], N = t[2 * S + 1];
		if (A === Infinity) {
			for (let n = 0; n < s; n++) this._dists[n] = t[2 * n] - t[0] || t[2 * n + 1] - t[1];
			quicksort(this._ids, this._dists, 0, s - 1);
			let n = new Uint32Array(s), r = 0;
			for (let t = 0, i = -Infinity; t < s; t++) {
				let o = this._ids[t], s = this._dists[o];
				s > i && (n[r++] = o, i = s);
			}
			this.hull = n.subarray(0, r), this.triangles = new Uint32Array(), this.halfedges = new Uint32Array();
			return;
		}
		if (orient2d(T, E, O, k, j, N) < 0) {
			let t = v, n = O, r = k;
			v = S, O = j, k = N, S = t, j = n, N = r;
		}
		let P = circumcenter(T, E, O, k, j, N);
		this._cx = P.x, this._cy = P.y;
		for (let n = 0; n < s; n++) this._dists[n] = dist(t[2 * n], t[2 * n + 1], P.x, P.y);
		quicksort(this._ids, this._dists, 0, s - 1), this._hullStart = _;
		let F = 3;
		r[_] = n[S] = v, r[v] = n[_] = S, r[S] = n[v] = _, i[_] = 0, i[v] = 1, i[S] = 2, o.fill(-1), o[this._hashKey(T, E)] = _, o[this._hashKey(O, k)] = v, o[this._hashKey(j, N)] = S, this.trianglesLen = 0, this._addTriangle(_, v, S, -1, -1, -1);
		for (let s = 0, l, u; s < this._ids.length; s++) {
			let d = this._ids[s], f = t[2 * d], p = t[2 * d + 1];
			if (s > 0 && Math.abs(f - l) <= EPSILON$2 && Math.abs(p - u) <= EPSILON$2 || (l = f, u = p, d === _ || d === v || d === S)) continue;
			let g = 0;
			for (let t = 0, n = this._hashKey(f, p); t < this._hashSize && (g = o[(n + t) % this._hashSize], !(g !== -1 && g !== r[g])); t++);
			g = n[g];
			let T = g, E;
			for (; E = r[T], orient2d(f, p, t[2 * T], t[2 * T + 1], t[2 * E], t[2 * E + 1]) >= 0;) if (T = E, T === g) {
				T = -1;
				break;
			}
			if (T === -1) continue;
			let O = this._addTriangle(T, d, r[T], -1, -1, i[T]);
			i[d] = this._legalize(O + 2), i[T] = O, F++;
			let k = r[T];
			for (; E = r[k], orient2d(f, p, t[2 * k], t[2 * k + 1], t[2 * E], t[2 * E + 1]) < 0;) O = this._addTriangle(k, d, E, i[d], -1, i[k]), i[d] = this._legalize(O + 2), r[k] = k, F--, k = E;
			if (T === g) for (; E = n[T], orient2d(f, p, t[2 * E], t[2 * E + 1], t[2 * T], t[2 * T + 1]) < 0;) O = this._addTriangle(E, d, T, -1, i[T], i[E]), this._legalize(O + 2), i[E] = O, r[T] = T, F--, T = E;
			this._hullStart = n[d] = T, r[T] = n[k] = d, r[d] = k, o[this._hashKey(f, p)] = d, o[this._hashKey(t[2 * T], t[2 * T + 1])] = T;
		}
		this.hull = new Uint32Array(F);
		for (let t = 0, n = this._hullStart; t < F; t++) this.hull[t] = n, n = r[n];
		this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
	}
	_hashKey(t, n) {
		return Math.floor(pseudoAngle(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize;
	}
	_legalize(t) {
		let { _triangles: n, _halfedges: r, coords: i } = this, o = 0, s = 0;
		for (;;) {
			let l = r[t], u = t - t % 3;
			if (s = u + (t + 2) % 3, l === -1) {
				if (o === 0) break;
				t = EDGE_STACK[--o];
				continue;
			}
			let d = l - l % 3, f = u + (t + 1) % 3, p = d + (l + 2) % 3, g = n[s], _ = n[t], v = n[f], S = n[p];
			if (inCircle(i[2 * g], i[2 * g + 1], i[2 * _], i[2 * _ + 1], i[2 * v], i[2 * v + 1], i[2 * S], i[2 * S + 1])) {
				n[t] = S, n[l] = g;
				let i = r[p];
				if (i === -1) {
					let n = this._hullStart;
					do {
						if (this._hullTri[n] === p) {
							this._hullTri[n] = t;
							break;
						}
						n = this._hullPrev[n];
					} while (n !== this._hullStart);
				}
				this._link(t, i), this._link(l, r[s]), this._link(s, p);
				let u = d + (l + 1) % 3;
				o < EDGE_STACK.length && (EDGE_STACK[o++] = u);
			} else {
				if (o === 0) break;
				t = EDGE_STACK[--o];
			}
		}
		return s;
	}
	_link(t, n) {
		this._halfedges[t] = n, n !== -1 && (this._halfedges[n] = t);
	}
	_addTriangle(t, n, r, i, o, s) {
		let l = this.trianglesLen;
		return this._triangles[l] = t, this._triangles[l + 1] = n, this._triangles[l + 2] = r, this._link(l, i), this._link(l + 1, o), this._link(l + 2, s), this.trianglesLen += 3, l;
	}
};
function pseudoAngle(t, n) {
	let r = t / (Math.abs(t) + Math.abs(n));
	return (n > 0 ? 3 - r : 1 + r) / 4;
}
function dist(t, n, r, i) {
	let o = t - r, s = n - i;
	return o * o + s * s;
}
function inCircle(t, n, r, i, o, s, l, u) {
	let d = t - l, f = n - u, p = r - l, g = i - u, _ = o - l, v = s - u, S = d * d + f * f, T = p * p + g * g, E = _ * _ + v * v;
	return d * (g * E - T * v) - f * (p * E - T * _) + S * (p * v - g * _) < 0;
}
function circumradius(t, n, r, i, o, s) {
	let l = r - t, u = i - n, d = o - t, f = s - n, p = l * l + u * u, g = d * d + f * f, _ = .5 / (l * f - u * d), v = (f * p - u * g) * _, S = (l * g - d * p) * _;
	return v * v + S * S;
}
function circumcenter(t, n, r, i, o, s) {
	let l = r - t, u = i - n, d = o - t, f = s - n, p = l * l + u * u, g = d * d + f * f, _ = .5 / (l * f - u * d);
	return {
		x: t + (f * p - u * g) * _,
		y: n + (l * g - d * p) * _
	};
}
function quicksort(t, n, r, i) {
	if (i - r <= 20) for (let o = r + 1; o <= i; o++) {
		let i = t[o], s = n[i], l = o - 1;
		for (; l >= r && n[t[l]] > s;) t[l + 1] = t[l--];
		t[l + 1] = i;
	}
	else {
		let o = r + i >> 1, s = r + 1, l = i;
		swap(t, o, s), n[t[r]] > n[t[i]] && swap(t, r, i), n[t[s]] > n[t[i]] && swap(t, s, i), n[t[r]] > n[t[s]] && swap(t, r, s);
		let u = t[s], d = n[u];
		for (;;) {
			do
				s++;
			while (n[t[s]] < d);
			do
				l--;
			while (n[t[l]] > d);
			if (l < s) break;
			swap(t, s, l);
		}
		t[r + 1] = t[l], t[l] = u, i - s + 1 >= l - r ? (quicksort(t, n, s, i), quicksort(t, n, r, l - 1)) : (quicksort(t, n, r, l - 1), quicksort(t, n, s, i));
	}
}
function swap(t, n, r) {
	let i = t[n];
	t[n] = t[r], t[r] = i;
}
function defaultGetX(t) {
	return t[0];
}
function defaultGetY(t) {
	return t[1];
}
var epsilon$3 = 1e-6, Path = class {
	constructor() {
		this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "";
	}
	moveTo(t, n) {
		this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
	}
	closePath() {
		this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
	}
	lineTo(t, n) {
		this._ += `L${this._x1 = +t},${this._y1 = +n}`;
	}
	arc(t, n, r) {
		t = +t, n = +n, r = +r;
		let i = t + r, o = n;
		if (r < 0) throw Error("negative radius");
		this._x1 === null ? this._ += `M${i},${o}` : (Math.abs(this._x1 - i) > epsilon$3 || Math.abs(this._y1 - o) > epsilon$3) && (this._ += "L" + i + "," + o), r && (this._ += `A${r},${r},0,1,1,${t - r},${n}A${r},${r},0,1,1,${this._x1 = i},${this._y1 = o}`);
	}
	rect(t, n, r, i) {
		this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${+r}v${+i}h${-r}Z`;
	}
	value() {
		return this._ || null;
	}
}, Polygon = class {
	constructor() {
		this._ = [];
	}
	moveTo(t, n) {
		this._.push([t, n]);
	}
	closePath() {
		this._.push(this._[0].slice());
	}
	lineTo(t, n) {
		this._.push([t, n]);
	}
	value() {
		return this._.length ? this._ : null;
	}
}, Voronoi$1 = class {
	constructor(t, [n, r, i, o] = [
		0,
		0,
		960,
		500
	]) {
		if (!((i = +i) >= (n = +n)) || !((o = +o) >= (r = +r))) throw Error("invalid bounds");
		this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = i, this.xmin = n, this.ymax = o, this.ymin = r, this._init();
	}
	update() {
		return this.delaunay.update(), this._init(), this;
	}
	_init() {
		let { delaunay: { points: t, hull: n, triangles: r }, vectors: i } = this, o, s, l = this.circumcenters = this._circumcenters.subarray(0, r.length / 3 * 2);
		for (let i = 0, u = 0, d = r.length, f, p; i < d; i += 3, u += 2) {
			let d = r[i] * 2, g = r[i + 1] * 2, _ = r[i + 2] * 2, v = t[d], S = t[d + 1], T = t[g], E = t[g + 1], O = t[_], k = t[_ + 1], A = T - v, j = E - S, N = O - v, P = k - S, F = (A * P - j * N) * 2;
			if (Math.abs(F) < 1e-9) {
				if (o === void 0) {
					o = s = 0;
					for (let r of n) o += t[r * 2], s += t[r * 2 + 1];
					o /= n.length, s /= n.length;
				}
				let r = 1e9 * Math.sign((o - v) * P - (s - S) * N);
				f = (v + O) / 2 - r * P, p = (S + k) / 2 + r * N;
			} else {
				let t = 1 / F, n = A * A + j * j, r = N * N + P * P;
				f = v + (P * n - j * r) * t, p = S + (A * r - N * n) * t;
			}
			l[u] = f, l[u + 1] = p;
		}
		let u = n[n.length - 1], d, f = u * 4, p, g = t[2 * u], _, v = t[2 * u + 1];
		i.fill(0);
		for (let r = 0; r < n.length; ++r) u = n[r], d = f, p = g, _ = v, f = u * 4, g = t[2 * u], v = t[2 * u + 1], i[d + 2] = i[f] = _ - v, i[d + 3] = i[f + 1] = g - p;
	}
	render(t) {
		let n = t == null ? t = new Path() : void 0, { delaunay: { halfedges: r, inedges: i, hull: o }, circumcenters: s, vectors: l } = this;
		if (o.length <= 1) return null;
		for (let n = 0, i = r.length; n < i; ++n) {
			let i = r[n];
			if (i < n) continue;
			let o = Math.floor(n / 3) * 2, l = Math.floor(i / 3) * 2, u = s[o], d = s[o + 1], f = s[l], p = s[l + 1];
			this._renderSegment(u, d, f, p, t);
		}
		let u, d = o[o.length - 1];
		for (let n = 0; n < o.length; ++n) {
			u = d, d = o[n];
			let r = Math.floor(i[d] / 3) * 2, f = s[r], p = s[r + 1], g = u * 4, _ = this._project(f, p, l[g + 2], l[g + 3]);
			_ && this._renderSegment(f, p, _[0], _[1], t);
		}
		return n && n.value();
	}
	renderBounds(t) {
		let n = t == null ? t = new Path() : void 0;
		return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value();
	}
	renderCell(t, n) {
		let r = n == null ? n = new Path() : void 0, i = this._clip(t);
		if (i === null || !i.length) return;
		n.moveTo(i[0], i[1]);
		let o = i.length;
		for (; i[0] === i[o - 2] && i[1] === i[o - 1] && o > 1;) o -= 2;
		for (let t = 2; t < o; t += 2) (i[t] !== i[t - 2] || i[t + 1] !== i[t - 1]) && n.lineTo(i[t], i[t + 1]);
		return n.closePath(), r && r.value();
	}
	*cellPolygons() {
		let { delaunay: { points: t } } = this;
		for (let n = 0, r = t.length / 2; n < r; ++n) {
			let t = this.cellPolygon(n);
			t && (t.index = n, yield t);
		}
	}
	cellPolygon(t) {
		let n = new Polygon();
		return this.renderCell(t, n), n.value();
	}
	_renderSegment(t, n, r, i, o) {
		let s, l = this._regioncode(t, n), u = this._regioncode(r, i);
		l === 0 && u === 0 ? (o.moveTo(t, n), o.lineTo(r, i)) : (s = this._clipSegment(t, n, r, i, l, u)) && (o.moveTo(s[0], s[1]), o.lineTo(s[2], s[3]));
	}
	contains(t, n, r) {
		return (n = +n, n !== n) || (r = +r, r !== r) ? !1 : this.delaunay._step(t, n, r) === t;
	}
	*neighbors(t) {
		let n = this._clip(t);
		if (n) for (let r of this.delaunay.neighbors(t)) {
			let t = this._clip(r);
			if (t) {
				loop: for (let i = 0, o = n.length; i < o; i += 2) for (let s = 0, l = t.length; s < l; s += 2) if (n[i] === t[s] && n[i + 1] === t[s + 1] && n[(i + 2) % o] === t[(s + l - 2) % l] && n[(i + 3) % o] === t[(s + l - 1) % l]) {
					yield r;
					break loop;
				}
			}
		}
	}
	_cell(t) {
		let { circumcenters: n, delaunay: { inedges: r, halfedges: i, triangles: o } } = this, s = r[t];
		if (s === -1) return null;
		let l = [], u = s;
		do {
			let r = Math.floor(u / 3);
			if (l.push(n[r * 2], n[r * 2 + 1]), u = u % 3 == 2 ? u - 2 : u + 1, o[u] !== t) break;
			u = i[u];
		} while (u !== s && u !== -1);
		return l;
	}
	_clip(t) {
		if (t === 0 && this.delaunay.hull.length === 1) return [
			this.xmax,
			this.ymin,
			this.xmax,
			this.ymax,
			this.xmin,
			this.ymax,
			this.xmin,
			this.ymin
		];
		let n = this._cell(t);
		if (n === null) return null;
		let { vectors: r } = this, i = t * 4;
		return this._simplify(r[i] || r[i + 1] ? this._clipInfinite(t, n, r[i], r[i + 1], r[i + 2], r[i + 3]) : this._clipFinite(t, n));
	}
	_clipFinite(t, n) {
		let r = n.length, i = null, o, s, l = n[r - 2], u = n[r - 1], d, f = this._regioncode(l, u), p, g = 0;
		for (let _ = 0; _ < r; _ += 2) if (o = l, s = u, l = n[_], u = n[_ + 1], d = f, f = this._regioncode(l, u), d === 0 && f === 0) p = g, g = 0, i ? i.push(l, u) : i = [l, u];
		else {
			let n, r, _, v, S;
			if (d === 0) {
				if ((n = this._clipSegment(o, s, l, u, d, f)) === null) continue;
				[r, _, v, S] = n;
			} else {
				if ((n = this._clipSegment(l, u, o, s, f, d)) === null) continue;
				[v, S, r, _] = n, p = g, g = this._edgecode(r, _), p && g && this._edge(t, p, g, i, i.length), i ? i.push(r, _) : i = [r, _];
			}
			p = g, g = this._edgecode(v, S), p && g && this._edge(t, p, g, i, i.length), i ? i.push(v, S) : i = [v, S];
		}
		if (i) p = g, g = this._edgecode(i[0], i[1]), p && g && this._edge(t, p, g, i, i.length);
		else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) return [
			this.xmax,
			this.ymin,
			this.xmax,
			this.ymax,
			this.xmin,
			this.ymax,
			this.xmin,
			this.ymin
		];
		return i;
	}
	_clipSegment(t, n, r, i, o, s) {
		let l = o < s;
		for (l && ([t, n, r, i, o, s] = [
			r,
			i,
			t,
			n,
			s,
			o
		]);;) {
			if (o === 0 && s === 0) return l ? [
				r,
				i,
				t,
				n
			] : [
				t,
				n,
				r,
				i
			];
			if (o & s) return null;
			let u, d, f = o || s;
			f & 8 ? (u = t + (r - t) * (this.ymax - n) / (i - n), d = this.ymax) : f & 4 ? (u = t + (r - t) * (this.ymin - n) / (i - n), d = this.ymin) : f & 2 ? (d = n + (i - n) * (this.xmax - t) / (r - t), u = this.xmax) : (d = n + (i - n) * (this.xmin - t) / (r - t), u = this.xmin), o ? (t = u, n = d, o = this._regioncode(t, n)) : (r = u, i = d, s = this._regioncode(r, i));
		}
	}
	_clipInfinite(t, n, r, i, o, s) {
		let l = Array.from(n), u;
		if ((u = this._project(l[0], l[1], r, i)) && l.unshift(u[0], u[1]), (u = this._project(l[l.length - 2], l[l.length - 1], o, s)) && l.push(u[0], u[1]), l = this._clipFinite(t, l)) for (let n = 0, r = l.length, i, o = this._edgecode(l[r - 2], l[r - 1]); n < r; n += 2) i = o, o = this._edgecode(l[n], l[n + 1]), i && o && (n = this._edge(t, i, o, l, n), r = l.length);
		else this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (l = [
			this.xmin,
			this.ymin,
			this.xmax,
			this.ymin,
			this.xmax,
			this.ymax,
			this.xmin,
			this.ymax
		]);
		return l;
	}
	_edge(t, n, r, i, o) {
		for (; n !== r;) {
			let r, s;
			switch (n) {
				case 5:
					n = 4;
					continue;
				case 4:
					n = 6, r = this.xmax, s = this.ymin;
					break;
				case 6:
					n = 2;
					continue;
				case 2:
					n = 10, r = this.xmax, s = this.ymax;
					break;
				case 10:
					n = 8;
					continue;
				case 8:
					n = 9, r = this.xmin, s = this.ymax;
					break;
				case 9:
					n = 1;
					continue;
				case 1:
					n = 5, r = this.xmin, s = this.ymin;
					break;
			}
			(i[o] !== r || i[o + 1] !== s) && this.contains(t, r, s) && (i.splice(o, 0, r, s), o += 2);
		}
		return o;
	}
	_project(t, n, r, i) {
		let o = Infinity, s, l, u;
		if (i < 0) {
			if (n <= this.ymin) return null;
			(s = (this.ymin - n) / i) < o && (u = this.ymin, l = t + (o = s) * r);
		} else if (i > 0) {
			if (n >= this.ymax) return null;
			(s = (this.ymax - n) / i) < o && (u = this.ymax, l = t + (o = s) * r);
		}
		if (r > 0) {
			if (t >= this.xmax) return null;
			(s = (this.xmax - t) / r) < o && (l = this.xmax, u = n + (o = s) * i);
		} else if (r < 0) {
			if (t <= this.xmin) return null;
			(s = (this.xmin - t) / r) < o && (l = this.xmin, u = n + (o = s) * i);
		}
		return [l, u];
	}
	_edgecode(t, n) {
		return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0);
	}
	_regioncode(t, n) {
		return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0);
	}
	_simplify(t) {
		if (t && t.length > 4) {
			for (let n = 0; n < t.length; n += 2) {
				let r = (n + 2) % t.length, i = (n + 4) % t.length;
				(t[n] === t[r] && t[r] === t[i] || t[n + 1] === t[r + 1] && t[r + 1] === t[i + 1]) && (t.splice(r, 2), n -= 2);
			}
			t.length || (t = null);
		}
		return t;
	}
}, tau$3 = 2 * Math.PI, pow$4 = Math.pow;
function pointX(t) {
	return t[0];
}
function pointY(t) {
	return t[1];
}
function collinear$1(t) {
	let { triangles: n, coords: r } = t;
	for (let t = 0; t < n.length; t += 3) {
		let i = 2 * n[t], o = 2 * n[t + 1], s = 2 * n[t + 2];
		if ((r[s] - r[i]) * (r[o + 1] - r[i + 1]) - (r[o] - r[i]) * (r[s + 1] - r[i + 1]) > 1e-10) return !1;
	}
	return !0;
}
function jitter(t, n, r) {
	return [t + Math.sin(t + n) * r, n + Math.cos(t - n) * r];
}
var Delaunay = class t {
	static from(n, r = pointX, i = pointY, o) {
		return new t("length" in n ? flatArray(n, r, i, o) : Float64Array.from(flatIterable(n, r, i, o)));
	}
	constructor(t) {
		this._delaunator = new Delaunator(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init();
	}
	update() {
		return this._delaunator.update(), this._init(), this;
	}
	_init() {
		let t = this._delaunator, n = this.points;
		if (t.hull && t.hull.length > 2 && collinear$1(t)) {
			this.collinear = Int32Array.from({ length: n.length / 2 }, (t, n) => n).sort((t, r) => n[2 * t] - n[2 * r] || n[2 * t + 1] - n[2 * r + 1]);
			let t = this.collinear[0], r = this.collinear[this.collinear.length - 1], i = [
				n[2 * t],
				n[2 * t + 1],
				n[2 * r],
				n[2 * r + 1]
			], o = 1e-8 * Math.hypot(i[3] - i[1], i[2] - i[0]);
			for (let t = 0, r = n.length / 2; t < r; ++t) {
				let r = jitter(n[2 * t], n[2 * t + 1], o);
				n[2 * t] = r[0], n[2 * t + 1] = r[1];
			}
			this._delaunator = new Delaunator(n);
		} else delete this.collinear;
		let r = this.halfedges = this._delaunator.halfedges, i = this.hull = this._delaunator.hull, o = this.triangles = this._delaunator.triangles, s = this.inedges.fill(-1), l = this._hullIndex.fill(-1);
		for (let t = 0, n = r.length; t < n; ++t) {
			let n = o[t % 3 == 2 ? t - 2 : t + 1];
			(r[t] === -1 || s[n] === -1) && (s[n] = t);
		}
		for (let t = 0, n = i.length; t < n; ++t) l[i[t]] = t;
		i.length <= 2 && i.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = i[0], s[i[0]] = 1, i.length === 2 && (s[i[1]] = 0, this.triangles[1] = i[1], this.triangles[2] = i[1]));
	}
	voronoi(t) {
		return new Voronoi$1(this, t);
	}
	*neighbors(t) {
		let { inedges: n, hull: r, _hullIndex: i, halfedges: o, triangles: s, collinear: l } = this;
		if (l) {
			let n = l.indexOf(t);
			n > 0 && (yield l[n - 1]), n < l.length - 1 && (yield l[n + 1]);
			return;
		}
		let u = n[t];
		if (u === -1) return;
		let d = u, f = -1;
		do {
			if (yield f = s[d], d = d % 3 == 2 ? d - 2 : d + 1, s[d] !== t) return;
			if (d = o[d], d === -1) {
				let n = r[(i[t] + 1) % r.length];
				n !== f && (yield n);
				return;
			}
		} while (d !== u);
	}
	find(t, n, r = 0) {
		if ((t = +t, t !== t) || (n = +n, n !== n)) return -1;
		let i = r, o;
		for (; (o = this._step(r, t, n)) >= 0 && o !== r && o !== i;) r = o;
		return o;
	}
	_step(t, n, r) {
		let { inedges: i, hull: o, _hullIndex: s, halfedges: l, triangles: u, points: d } = this;
		if (i[t] === -1 || !d.length) return (t + 1) % (d.length >> 1);
		let f = t, p = pow$4(n - d[t * 2], 2) + pow$4(r - d[t * 2 + 1], 2), g = i[t], _ = g;
		do {
			let i = u[_], g = pow$4(n - d[i * 2], 2) + pow$4(r - d[i * 2 + 1], 2);
			if (g < p && (p = g, f = i), _ = _ % 3 == 2 ? _ - 2 : _ + 1, u[_] !== t) break;
			if (_ = l[_], _ === -1) {
				if (_ = o[(s[t] + 1) % o.length], _ !== i && pow$4(n - d[_ * 2], 2) + pow$4(r - d[_ * 2 + 1], 2) < p) return _;
				break;
			}
		} while (_ !== g);
		return f;
	}
	render(t) {
		let n = t == null ? t = new Path() : void 0, { points: r, halfedges: i, triangles: o } = this;
		for (let n = 0, s = i.length; n < s; ++n) {
			let s = i[n];
			if (s < n) continue;
			let l = o[n] * 2, u = o[s] * 2;
			t.moveTo(r[l], r[l + 1]), t.lineTo(r[u], r[u + 1]);
		}
		return this.renderHull(t), n && n.value();
	}
	renderPoints(t, n) {
		n === void 0 && (!t || typeof t.moveTo != "function") && (n = t, t = null), n = n == null ? 2 : +n;
		let r = t == null ? t = new Path() : void 0, { points: i } = this;
		for (let r = 0, o = i.length; r < o; r += 2) {
			let o = i[r], s = i[r + 1];
			t.moveTo(o + n, s), t.arc(o, s, n, 0, tau$3);
		}
		return r && r.value();
	}
	renderHull(t) {
		let n = t == null ? t = new Path() : void 0, { hull: r, points: i } = this, o = r[0] * 2, s = r.length;
		t.moveTo(i[o], i[o + 1]);
		for (let n = 1; n < s; ++n) {
			let o = 2 * r[n];
			t.lineTo(i[o], i[o + 1]);
		}
		return t.closePath(), n && n.value();
	}
	hullPolygon() {
		let t = new Polygon();
		return this.renderHull(t), t.value();
	}
	renderTriangle(t, n) {
		let r = n == null ? n = new Path() : void 0, { points: i, triangles: o } = this, s = o[t *= 3] * 2, l = o[t + 1] * 2, u = o[t + 2] * 2;
		return n.moveTo(i[s], i[s + 1]), n.lineTo(i[l], i[l + 1]), n.lineTo(i[u], i[u + 1]), n.closePath(), r && r.value();
	}
	*trianglePolygons() {
		let { triangles: t } = this;
		for (let n = 0, r = t.length / 3; n < r; ++n) yield this.trianglePolygon(n);
	}
	trianglePolygon(t) {
		let n = new Polygon();
		return this.renderTriangle(t, n), n.value();
	}
};
function flatArray(t, n, r, i) {
	let o = t.length, s = new Float64Array(o * 2);
	for (let l = 0; l < o; ++l) {
		let o = t[l];
		s[l * 2] = n.call(i, o, l, t), s[l * 2 + 1] = r.call(i, o, l, t);
	}
	return s;
}
function* flatIterable(t, n, r, i) {
	let o = 0;
	for (let s of t) yield n.call(i, s, o, t), yield r.call(i, s, o, t), ++o;
}
var EOL = {}, EOF = {}, QUOTE = 34, NEWLINE = 10, RETURN = 13;
function objectConverter(t) {
	return Function("d", "return {" + t.map(function(t, n) {
		return JSON.stringify(t) + ": d[" + n + "] || \"\"";
	}).join(",") + "}");
}
function customConverter(t, n) {
	var r = objectConverter(t);
	return function(i, o) {
		return n(r(i), o, t);
	};
}
function inferColumns(t) {
	var n = Object.create(null), r = [];
	return t.forEach(function(t) {
		for (var i in t) i in n || r.push(n[i] = i);
	}), r;
}
function pad$1(t, n) {
	var r = t + "", i = r.length;
	return i < n ? Array(n - i + 1).join(0) + r : r;
}
function formatYear(t) {
	return t < 0 ? "-" + pad$1(-t, 6) : t > 9999 ? "+" + pad$1(t, 6) : pad$1(t, 4);
}
function formatDate(t) {
	var n = t.getUTCHours(), r = t.getUTCMinutes(), i = t.getUTCSeconds(), o = t.getUTCMilliseconds();
	return isNaN(t) ? "Invalid Date" : formatYear(t.getUTCFullYear(), 4) + "-" + pad$1(t.getUTCMonth() + 1, 2) + "-" + pad$1(t.getUTCDate(), 2) + (o ? "T" + pad$1(n, 2) + ":" + pad$1(r, 2) + ":" + pad$1(i, 2) + "." + pad$1(o, 3) + "Z" : i ? "T" + pad$1(n, 2) + ":" + pad$1(r, 2) + ":" + pad$1(i, 2) + "Z" : r || n ? "T" + pad$1(n, 2) + ":" + pad$1(r, 2) + "Z" : "");
}
function dsv_default(t) {
	var n = /* @__PURE__ */ RegExp("[\"" + t + "\n\r]"), r = t.charCodeAt(0);
	function i(t, n) {
		var r, i, s = o(t, function(t, o) {
			if (r) return r(t, o - 1);
			i = t, r = n ? customConverter(t, n) : objectConverter(t);
		});
		return s.columns = i || [], s;
	}
	function o(t, n) {
		var i = [], o = t.length, s = 0, l = 0, u, d = o <= 0, f = !1;
		t.charCodeAt(o - 1) === NEWLINE && --o, t.charCodeAt(o - 1) === RETURN && --o;
		function p() {
			if (d) return EOF;
			if (f) return f = !1, EOL;
			var n, i = s, l;
			if (t.charCodeAt(i) === QUOTE) {
				for (; s++ < o && t.charCodeAt(s) !== QUOTE || t.charCodeAt(++s) === QUOTE;);
				return (n = s) >= o ? d = !0 : (l = t.charCodeAt(s++)) === NEWLINE ? f = !0 : l === RETURN && (f = !0, t.charCodeAt(s) === NEWLINE && ++s), t.slice(i + 1, n - 1).replace(/""/g, "\"");
			}
			for (; s < o;) {
				if ((l = t.charCodeAt(n = s++)) === NEWLINE) f = !0;
				else if (l === RETURN) f = !0, t.charCodeAt(s) === NEWLINE && ++s;
				else if (l !== r) continue;
				return t.slice(i, n);
			}
			return d = !0, t.slice(i, o);
		}
		for (; (u = p()) !== EOF;) {
			for (var g = []; u !== EOL && u !== EOF;) g.push(u), u = p();
			n && (g = n(g, l++)) == null || i.push(g);
		}
		return i;
	}
	function s(n, r) {
		return n.map(function(n) {
			return r.map(function(t) {
				return p(n[t]);
			}).join(t);
		});
	}
	function l(n, r) {
		return r ??= inferColumns(n), [r.map(p).join(t)].concat(s(n, r)).join("\n");
	}
	function u(t, n) {
		return n ??= inferColumns(t), s(t, n).join("\n");
	}
	function d(t) {
		return t.map(f).join("\n");
	}
	function f(n) {
		return n.map(p).join(t);
	}
	function p(t) {
		return t == null ? "" : t instanceof Date ? formatDate(t) : n.test(t += "") ? "\"" + t.replace(/"/g, "\"\"") + "\"" : t;
	}
	return {
		parse: i,
		parseRows: o,
		format: l,
		formatBody: u,
		formatRows: d,
		formatRow: f,
		formatValue: p
	};
}
function center_default(t, n) {
	var r, i = 1;
	t ??= 0, n ??= 0;
	function o() {
		var o, s = r.length, l, u = 0, d = 0;
		for (o = 0; o < s; ++o) l = r[o], u += l.x, d += l.y;
		for (u = (u / s - t) * i, d = (d / s - n) * i, o = 0; o < s; ++o) l = r[o], l.x -= u, l.y -= d;
	}
	return o.initialize = function(t) {
		r = t;
	}, o.x = function(n) {
		return arguments.length ? (t = +n, o) : t;
	}, o.y = function(t) {
		return arguments.length ? (n = +t, o) : n;
	}, o.strength = function(t) {
		return arguments.length ? (i = +t, o) : i;
	}, o;
}
function add_default(t) {
	let n = +this._x.call(null, t), r = +this._y.call(null, t);
	return add$4(this.cover(n, r), n, r, t);
}
function add$4(t, n, r, i) {
	if (isNaN(n) || isNaN(r)) return t;
	var o, s = t._root, l = { data: i }, u = t._x0, d = t._y0, f = t._x1, p = t._y1, g, _, v, S, T, E, O, k;
	if (!s) return t._root = l, t;
	for (; s.length;) if ((T = n >= (g = (u + f) / 2)) ? u = g : f = g, (E = r >= (_ = (d + p) / 2)) ? d = _ : p = _, o = s, !(s = s[O = E << 1 | T])) return o[O] = l, t;
	if (v = +t._x.call(null, s.data), S = +t._y.call(null, s.data), n === v && r === S) return l.next = s, o ? o[O] = l : t._root = l, t;
	do
		o = o ? o[O] = [
			,
			,
			,
			,
		] : t._root = [
			,
			,
			,
			,
		], (T = n >= (g = (u + f) / 2)) ? u = g : f = g, (E = r >= (_ = (d + p) / 2)) ? d = _ : p = _;
	while ((O = E << 1 | T) == (k = (S >= _) << 1 | v >= g));
	return o[k] = s, o[O] = l, t;
}
function addAll(t) {
	var n, r, i = t.length, o, s, l = Array(i), u = Array(i), d = Infinity, f = Infinity, p = -Infinity, g = -Infinity;
	for (r = 0; r < i; ++r) isNaN(o = +this._x.call(null, n = t[r])) || isNaN(s = +this._y.call(null, n)) || (l[r] = o, u[r] = s, o < d && (d = o), o > p && (p = o), s < f && (f = s), s > g && (g = s));
	if (d > p || f > g) return this;
	for (this.cover(d, f).cover(p, g), r = 0; r < i; ++r) add$4(this, l[r], u[r], t[r]);
	return this;
}
function cover_default(t, n) {
	if (isNaN(t = +t) || isNaN(n = +n)) return this;
	var r = this._x0, i = this._y0, o = this._x1, s = this._y1;
	if (isNaN(r)) o = (r = Math.floor(t)) + 1, s = (i = Math.floor(n)) + 1;
	else {
		for (var l = o - r || 1, u = this._root, d, f; r > t || t >= o || i > n || n >= s;) switch (f = (n < i) << 1 | t < r, d = [
			,
			,
			,
			,
		], d[f] = u, u = d, l *= 2, f) {
			case 0:
				o = r + l, s = i + l;
				break;
			case 1:
				r = o - l, s = i + l;
				break;
			case 2:
				o = r + l, i = s - l;
				break;
			case 3:
				r = o - l, i = s - l;
				break;
		}
		this._root && this._root.length && (this._root = u);
	}
	return this._x0 = r, this._y0 = i, this._x1 = o, this._y1 = s, this;
}
function data_default() {
	var t = [];
	return this.visit(function(n) {
		if (!n.length) do
			t.push(n.data);
		while (n = n.next);
	}), t;
}
function extent_default(t) {
	return arguments.length ? this.cover(+t[0][0], +t[0][1]).cover(+t[1][0], +t[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function quad_default(t, n, r, i, o) {
	this.node = t, this.x0 = n, this.y0 = r, this.x1 = i, this.y1 = o;
}
function find_default(t, n, r) {
	var i, o = this._x0, s = this._y0, l, u, d, f, p = this._x1, g = this._y1, _ = [], v = this._root, S, T;
	for (v && _.push(new quad_default(v, o, s, p, g)), r == null ? r = Infinity : (o = t - r, s = n - r, p = t + r, g = n + r, r *= r); S = _.pop();) if (!(!(v = S.node) || (l = S.x0) > p || (u = S.y0) > g || (d = S.x1) < o || (f = S.y1) < s)) if (v.length) {
		var E = (l + d) / 2, O = (u + f) / 2;
		_.push(new quad_default(v[3], E, O, d, f), new quad_default(v[2], l, O, E, f), new quad_default(v[1], E, u, d, O), new quad_default(v[0], l, u, E, O)), (T = (n >= O) << 1 | t >= E) && (S = _[_.length - 1], _[_.length - 1] = _[_.length - 1 - T], _[_.length - 1 - T] = S);
	} else {
		var k = t - +this._x.call(null, v.data), A = n - +this._y.call(null, v.data), j = k * k + A * A;
		if (j < r) {
			var N = Math.sqrt(r = j);
			o = t - N, s = n - N, p = t + N, g = n + N, i = v.data;
		}
	}
	return i;
}
function remove_default(t) {
	if (isNaN(p = +this._x.call(null, t)) || isNaN(g = +this._y.call(null, t))) return this;
	var n, r = this._root, i, o, s, l = this._x0, u = this._y0, d = this._x1, f = this._y1, p, g, _, v, S, T, E, O;
	if (!r) return this;
	if (r.length) for (;;) {
		if ((S = p >= (_ = (l + d) / 2)) ? l = _ : d = _, (T = g >= (v = (u + f) / 2)) ? u = v : f = v, n = r, !(r = r[E = T << 1 | S])) return this;
		if (!r.length) break;
		(n[E + 1 & 3] || n[E + 2 & 3] || n[E + 3 & 3]) && (i = n, O = E);
	}
	for (; r.data !== t;) if (o = r, !(r = r.next)) return this;
	return (s = r.next) && delete r.next, o ? (s ? o.next = s : delete o.next, this) : n ? (s ? n[E] = s : delete n[E], (r = n[0] || n[1] || n[2] || n[3]) && r === (n[3] || n[2] || n[1] || n[0]) && !r.length && (i ? i[O] = r : this._root = r), this) : (this._root = s, this);
}
function removeAll(t) {
	for (var n = 0, r = t.length; n < r; ++n) this.remove(t[n]);
	return this;
}
function root_default() {
	return this._root;
}
function size_default() {
	var t = 0;
	return this.visit(function(n) {
		if (!n.length) do
			++t;
		while (n = n.next);
	}), t;
}
function visit_default(t) {
	var n = [], r, i = this._root, o, s, l, u, d;
	for (i && n.push(new quad_default(i, this._x0, this._y0, this._x1, this._y1)); r = n.pop();) if (!t(i = r.node, s = r.x0, l = r.y0, u = r.x1, d = r.y1) && i.length) {
		var f = (s + u) / 2, p = (l + d) / 2;
		(o = i[3]) && n.push(new quad_default(o, f, p, u, d)), (o = i[2]) && n.push(new quad_default(o, s, p, f, d)), (o = i[1]) && n.push(new quad_default(o, f, l, u, p)), (o = i[0]) && n.push(new quad_default(o, s, l, f, p));
	}
	return this;
}
function visitAfter_default(t) {
	var n = [], r = [], i;
	for (this._root && n.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1)); i = n.pop();) {
		var o = i.node;
		if (o.length) {
			var s, l = i.x0, u = i.y0, d = i.x1, f = i.y1, p = (l + d) / 2, g = (u + f) / 2;
			(s = o[0]) && n.push(new quad_default(s, l, u, p, g)), (s = o[1]) && n.push(new quad_default(s, p, u, d, g)), (s = o[2]) && n.push(new quad_default(s, l, g, p, f)), (s = o[3]) && n.push(new quad_default(s, p, g, d, f));
		}
		r.push(i);
	}
	for (; i = r.pop();) t(i.node, i.x0, i.y0, i.x1, i.y1);
	return this;
}
function defaultX(t) {
	return t[0];
}
function x_default$1(t) {
	return arguments.length ? (this._x = t, this) : this._x;
}
function defaultY(t) {
	return t[1];
}
function y_default$1(t) {
	return arguments.length ? (this._y = t, this) : this._y;
}
function quadtree(t, n, r) {
	var i = new Quadtree(n ?? defaultX, r ?? defaultY, NaN, NaN, NaN, NaN);
	return t == null ? i : i.addAll(t);
}
function Quadtree(t, n, r, i, o, s) {
	this._x = t, this._y = n, this._x0 = r, this._y0 = i, this._x1 = o, this._y1 = s, this._root = void 0;
}
function leaf_copy(t) {
	for (var n = { data: t.data }, r = n; t = t.next;) r = r.next = { data: t.data };
	return n;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
	var t = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), n = this._root, r, i;
	if (!n) return t;
	if (!n.length) return t._root = leaf_copy(n), t;
	for (r = [{
		source: n,
		target: t._root = [
			,
			,
			,
			,
		]
	}]; n = r.pop();) for (var o = 0; o < 4; ++o) (i = n.source[o]) && (i.length ? r.push({
		source: i,
		target: n.target[o] = [
			,
			,
			,
			,
		]
	}) : n.target[o] = leaf_copy(i));
	return t;
}, treeProto.add = add_default, treeProto.addAll = addAll, treeProto.cover = cover_default, treeProto.data = data_default, treeProto.extent = extent_default, treeProto.find = find_default, treeProto.remove = remove_default, treeProto.removeAll = removeAll, treeProto.root = root_default, treeProto.size = size_default, treeProto.visit = visit_default, treeProto.visitAfter = visitAfter_default, treeProto.x = x_default$1, treeProto.y = y_default$1;
function constant_default$2(t) {
	return function() {
		return t;
	};
}
function jiggle_default(t) {
	return (t() - .5) * 1e-6;
}
function x$3(t) {
	return t.x + t.vx;
}
function y$3(t) {
	return t.y + t.vy;
}
function collide_default(t) {
	var n, r, i, o = 1, s = 1;
	typeof t != "function" && (t = constant_default$2(t == null ? 1 : +t));
	function l() {
		for (var t, l = n.length, d, f, p, g, _, v, S = 0; S < s; ++S) for (d = quadtree(n, x$3, y$3).visitAfter(u), t = 0; t < l; ++t) f = n[t], _ = r[f.index], v = _ * _, p = f.x + f.vx, g = f.y + f.vy, d.visit(T);
		function T(t, n, r, s, l) {
			var u = t.data, d = t.r, S = _ + d;
			if (u) {
				if (u.index > f.index) {
					var T = p - u.x - u.vx, E = g - u.y - u.vy, O = T * T + E * E;
					O < S * S && (T === 0 && (T = jiggle_default(i), O += T * T), E === 0 && (E = jiggle_default(i), O += E * E), O = (S - (O = Math.sqrt(O))) / O * o, f.vx += (T *= O) * (S = (d *= d) / (v + d)), f.vy += (E *= O) * S, u.vx -= T * (S = 1 - S), u.vy -= E * S);
				}
				return;
			}
			return n > p + S || s < p - S || r > g + S || l < g - S;
		}
	}
	function u(t) {
		if (t.data) return t.r = r[t.data.index];
		for (var n = t.r = 0; n < 4; ++n) t[n] && t[n].r > t.r && (t.r = t[n].r);
	}
	function d() {
		if (n) {
			var i, o = n.length, s;
			for (r = Array(o), i = 0; i < o; ++i) s = n[i], r[s.index] = +t(s, i, n);
		}
	}
	return l.initialize = function(t, r) {
		n = t, i = r, d();
	}, l.iterations = function(t) {
		return arguments.length ? (s = +t, l) : s;
	}, l.strength = function(t) {
		return arguments.length ? (o = +t, l) : o;
	}, l.radius = function(n) {
		return arguments.length ? (t = typeof n == "function" ? n : constant_default$2(+n), d(), l) : t;
	}, l;
}
function index$1(t) {
	return t.index;
}
function find$2(t, n) {
	var r = t.get(n);
	if (!r) throw Error("node not found: " + n);
	return r;
}
function link_default(t) {
	var n = index$1, r = g, i, o = constant_default$2(30), s, l, u, d, f, p = 1;
	t ??= [];
	function g(t) {
		return 1 / Math.min(u[t.source.index], u[t.target.index]);
	}
	function _(n) {
		for (var r = 0, o = t.length; r < p; ++r) for (var l = 0, u, g, _, v, S, T, E; l < o; ++l) u = t[l], g = u.source, _ = u.target, v = _.x + _.vx - g.x - g.vx || jiggle_default(f), S = _.y + _.vy - g.y - g.vy || jiggle_default(f), T = Math.sqrt(v * v + S * S), T = (T - s[l]) / T * n * i[l], v *= T, S *= T, _.vx -= v * (E = d[l]), _.vy -= S * E, g.vx += v * (E = 1 - E), g.vy += S * E;
	}
	function v() {
		if (l) {
			var r, o = l.length, f = t.length, p = new Map(l.map((t, r) => [n(t, r, l), t])), g;
			for (r = 0, u = Array(o); r < f; ++r) g = t[r], g.index = r, typeof g.source != "object" && (g.source = find$2(p, g.source)), typeof g.target != "object" && (g.target = find$2(p, g.target)), u[g.source.index] = (u[g.source.index] || 0) + 1, u[g.target.index] = (u[g.target.index] || 0) + 1;
			for (r = 0, d = Array(f); r < f; ++r) g = t[r], d[r] = u[g.source.index] / (u[g.source.index] + u[g.target.index]);
			i = Array(f), S(), s = Array(f), T();
		}
	}
	function S() {
		if (l) for (var n = 0, o = t.length; n < o; ++n) i[n] = +r(t[n], n, t);
	}
	function T() {
		if (l) for (var n = 0, r = t.length; n < r; ++n) s[n] = +o(t[n], n, t);
	}
	return _.initialize = function(t, n) {
		l = t, f = n, v();
	}, _.links = function(n) {
		return arguments.length ? (t = n, v(), _) : t;
	}, _.id = function(t) {
		return arguments.length ? (n = t, _) : n;
	}, _.iterations = function(t) {
		return arguments.length ? (p = +t, _) : p;
	}, _.strength = function(t) {
		return arguments.length ? (r = typeof t == "function" ? t : constant_default$2(+t), S(), _) : r;
	}, _.distance = function(t) {
		return arguments.length ? (o = typeof t == "function" ? t : constant_default$2(+t), T(), _) : o;
	}, _;
}
var a$1 = 1664525, c$1 = 1013904223, m$1 = 4294967296;
function lcg_default$1() {
	let t = 1;
	return () => (t = (a$1 * t + c$1) % m$1) / m$1;
}
function x$2(t) {
	return t.x;
}
function y$2(t) {
	return t.y;
}
var initialRadius = 10, initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(t) {
	var n, r = 1, i = .001, o = 1 - i ** (1 / 300), s = 0, l = .6, u = /* @__PURE__ */ new Map(), d = timer$1(g), f = dispatch_default("tick", "end"), p = lcg_default$1();
	t ??= [];
	function g() {
		_(), f.call("tick", n), r < i && (d.stop(), f.call("end", n));
	}
	function _(i) {
		var d, f = t.length, p;
		i === void 0 && (i = 1);
		for (var g = 0; g < i; ++g) for (r += (s - r) * o, u.forEach(function(t) {
			t(r);
		}), d = 0; d < f; ++d) p = t[d], p.fx == null ? p.x += p.vx *= l : (p.x = p.fx, p.vx = 0), p.fy == null ? p.y += p.vy *= l : (p.y = p.fy, p.vy = 0);
		return n;
	}
	function v() {
		for (var n = 0, r = t.length, i; n < r; ++n) {
			if (i = t[n], i.index = n, i.fx != null && (i.x = i.fx), i.fy != null && (i.y = i.fy), isNaN(i.x) || isNaN(i.y)) {
				var o = initialRadius * Math.sqrt(.5 + n), s = n * initialAngle;
				i.x = o * Math.cos(s), i.y = o * Math.sin(s);
			}
			(isNaN(i.vx) || isNaN(i.vy)) && (i.vx = i.vy = 0);
		}
	}
	function S(n) {
		return n.initialize && n.initialize(t, p), n;
	}
	return v(), n = {
		tick: _,
		restart: function() {
			return d.restart(g), n;
		},
		stop: function() {
			return d.stop(), n;
		},
		nodes: function(r) {
			return arguments.length ? (t = r, v(), u.forEach(S), n) : t;
		},
		alpha: function(t) {
			return arguments.length ? (r = +t, n) : r;
		},
		alphaMin: function(t) {
			return arguments.length ? (i = +t, n) : i;
		},
		alphaDecay: function(t) {
			return arguments.length ? (o = +t, n) : +o;
		},
		alphaTarget: function(t) {
			return arguments.length ? (s = +t, n) : s;
		},
		velocityDecay: function(t) {
			return arguments.length ? (l = 1 - t, n) : 1 - l;
		},
		randomSource: function(t) {
			return arguments.length ? (p = t, u.forEach(S), n) : p;
		},
		force: function(t, r) {
			return arguments.length > 1 ? (r == null ? u.delete(t) : u.set(t, S(r)), n) : u.get(t);
		},
		find: function(n, r, i) {
			var o = 0, s = t.length, l, u, d, f, p;
			for (i == null ? i = Infinity : i *= i, o = 0; o < s; ++o) f = t[o], l = n - f.x, u = r - f.y, d = l * l + u * u, d < i && (p = f, i = d);
			return p;
		},
		on: function(t, r) {
			return arguments.length > 1 ? (f.on(t, r), n) : f.on(t);
		}
	};
}
function manyBody_default() {
	var t, n, r, i, o = constant_default$2(-30), s, l = 1, u = Infinity, d = .81;
	function f(r) {
		var o, s = t.length, l = quadtree(t, x$2, y$2).visitAfter(g);
		for (i = r, o = 0; o < s; ++o) n = t[o], l.visit(_);
	}
	function p() {
		if (t) {
			var n, r = t.length, i;
			for (s = Array(r), n = 0; n < r; ++n) i = t[n], s[i.index] = +o(i, n, t);
		}
	}
	function g(t) {
		var n = 0, r, i, o = 0, l, u, d;
		if (t.length) {
			for (l = u = d = 0; d < 4; ++d) (r = t[d]) && (i = Math.abs(r.value)) && (n += r.value, o += i, l += i * r.x, u += i * r.y);
			t.x = l / o, t.y = u / o;
		} else {
			r = t, r.x = r.data.x, r.y = r.data.y;
			do
				n += s[r.data.index];
			while (r = r.next);
		}
		t.value = n;
	}
	function _(t, o, f, p) {
		if (!t.value) return !0;
		var g = t.x - n.x, _ = t.y - n.y, v = p - o, S = g * g + _ * _;
		if (v * v / d < S) return S < u && (g === 0 && (g = jiggle_default(r), S += g * g), _ === 0 && (_ = jiggle_default(r), S += _ * _), S < l && (S = Math.sqrt(l * S)), n.vx += g * t.value * i / S, n.vy += _ * t.value * i / S), !0;
		if (!(t.length || S >= u)) {
			(t.data !== n || t.next) && (g === 0 && (g = jiggle_default(r), S += g * g), _ === 0 && (_ = jiggle_default(r), S += _ * _), S < l && (S = Math.sqrt(l * S)));
			do
				t.data !== n && (v = s[t.data.index] * i / S, n.vx += g * v, n.vy += _ * v);
			while (t = t.next);
		}
	}
	return f.initialize = function(n, i) {
		t = n, r = i, p();
	}, f.strength = function(t) {
		return arguments.length ? (o = typeof t == "function" ? t : constant_default$2(+t), p(), f) : o;
	}, f.distanceMin = function(t) {
		return arguments.length ? (l = t * t, f) : Math.sqrt(l);
	}, f.distanceMax = function(t) {
		return arguments.length ? (u = t * t, f) : Math.sqrt(u);
	}, f.theta = function(t) {
		return arguments.length ? (d = t * t, f) : Math.sqrt(d);
	}, f;
}
function x_default(t) {
	var n = constant_default$2(.1), r, i, o;
	typeof t != "function" && (t = constant_default$2(t == null ? 0 : +t));
	function s(t) {
		for (var n = 0, s = r.length, l; n < s; ++n) l = r[n], l.vx += (o[n] - l.x) * i[n] * t;
	}
	function l() {
		if (r) {
			var s, l = r.length;
			for (i = Array(l), o = Array(l), s = 0; s < l; ++s) i[s] = isNaN(o[s] = +t(r[s], s, r)) ? 0 : +n(r[s], s, r);
		}
	}
	return s.initialize = function(t) {
		r = t, l();
	}, s.strength = function(t) {
		return arguments.length ? (n = typeof t == "function" ? t : constant_default$2(+t), l(), s) : n;
	}, s.x = function(n) {
		return arguments.length ? (t = typeof n == "function" ? n : constant_default$2(+n), l(), s) : t;
	}, s;
}
function y_default(t) {
	var n = constant_default$2(.1), r, i, o;
	typeof t != "function" && (t = constant_default$2(t == null ? 0 : +t));
	function s(t) {
		for (var n = 0, s = r.length, l; n < s; ++n) l = r[n], l.vy += (o[n] - l.y) * i[n] * t;
	}
	function l() {
		if (r) {
			var s, l = r.length;
			for (i = Array(l), o = Array(l), s = 0; s < l; ++s) i[s] = isNaN(o[s] = +t(r[s], s, r)) ? 0 : +n(r[s], s, r);
		}
	}
	return s.initialize = function(t) {
		r = t, l();
	}, s.strength = function(t) {
		return arguments.length ? (n = typeof t == "function" ? t : constant_default$2(+t), l(), s) : n;
	}, s.y = function(n) {
		return arguments.length ? (t = typeof n == "function" ? n : constant_default$2(+n), l(), s) : t;
	}, s;
}
var epsilon$2 = 1e-6, pi$2 = Math.PI, halfPi$1 = pi$2 / 2, quarterPi$1 = pi$2 / 4, tau$2 = pi$2 * 2, degrees$1 = 180 / pi$2, radians$1 = pi$2 / 180, abs$1 = Math.abs, atan = Math.atan, atan2 = Math.atan2, cos$1 = Math.cos, ceil = Math.ceil, exp$2 = Math.exp, hypot = Math.hypot, log$4 = Math.log, pow$3 = Math.pow, sin$1 = Math.sin, sign = Math.sign || function(t) {
	return t > 0 ? 1 : t < 0 ? -1 : 0;
}, sqrt$3 = Math.sqrt, tan = Math.tan;
function acos(t) {
	return t > 1 ? 0 : t < -1 ? pi$2 : Math.acos(t);
}
function asin$1(t) {
	return t > 1 ? halfPi$1 : t < -1 ? -halfPi$1 : Math.asin(t);
}
function noop$2() {}
function streamGeometry(t, n) {
	t && streamGeometryType.hasOwnProperty(t.type) && streamGeometryType[t.type](t, n);
}
var streamObjectType = {
	Feature: function(t, n) {
		streamGeometry(t.geometry, n);
	},
	FeatureCollection: function(t, n) {
		for (var r = t.features, i = -1, o = r.length; ++i < o;) streamGeometry(r[i].geometry, n);
	}
}, streamGeometryType = {
	Sphere: function(t, n) {
		n.sphere();
	},
	Point: function(t, n) {
		t = t.coordinates, n.point(t[0], t[1], t[2]);
	},
	MultiPoint: function(t, n) {
		for (var r = t.coordinates, i = -1, o = r.length; ++i < o;) t = r[i], n.point(t[0], t[1], t[2]);
	},
	LineString: function(t, n) {
		streamLine(t.coordinates, n, 0);
	},
	MultiLineString: function(t, n) {
		for (var r = t.coordinates, i = -1, o = r.length; ++i < o;) streamLine(r[i], n, 0);
	},
	Polygon: function(t, n) {
		streamPolygon(t.coordinates, n);
	},
	MultiPolygon: function(t, n) {
		for (var r = t.coordinates, i = -1, o = r.length; ++i < o;) streamPolygon(r[i], n);
	},
	GeometryCollection: function(t, n) {
		for (var r = t.geometries, i = -1, o = r.length; ++i < o;) streamGeometry(r[i], n);
	}
};
function streamLine(t, n, r) {
	var i = -1, o = t.length - r, s;
	for (n.lineStart(); ++i < o;) s = t[i], n.point(s[0], s[1], s[2]);
	n.lineEnd();
}
function streamPolygon(t, n) {
	var r = -1, i = t.length;
	for (n.polygonStart(); ++r < i;) streamLine(t[r], n, 1);
	n.polygonEnd();
}
function stream_default(t, n) {
	t && streamObjectType.hasOwnProperty(t.type) ? streamObjectType[t.type](t, n) : streamGeometry(t, n);
}
var areaRingSum$1 = new Adder(), areaSum$1 = new Adder(), lambda00$2, phi00$2, lambda0$1, cosPhi0, sinPhi0, areaStream$1 = {
	point: noop$2,
	lineStart: noop$2,
	lineEnd: noop$2,
	polygonStart: function() {
		areaRingSum$1 = new Adder(), areaStream$1.lineStart = areaRingStart$1, areaStream$1.lineEnd = areaRingEnd$1;
	},
	polygonEnd: function() {
		var t = +areaRingSum$1;
		areaSum$1.add(t < 0 ? tau$2 + t : t), this.lineStart = this.lineEnd = this.point = noop$2;
	},
	sphere: function() {
		areaSum$1.add(tau$2);
	}
};
function areaRingStart$1() {
	areaStream$1.point = areaPointFirst$1;
}
function areaRingEnd$1() {
	areaPoint$1(lambda00$2, phi00$2);
}
function areaPointFirst$1(t, n) {
	areaStream$1.point = areaPoint$1, lambda00$2 = t, phi00$2 = n, t *= radians$1, n *= radians$1, lambda0$1 = t, cosPhi0 = cos$1(n = n / 2 + quarterPi$1), sinPhi0 = sin$1(n);
}
function areaPoint$1(t, n) {
	t *= radians$1, n *= radians$1, n = n / 2 + quarterPi$1;
	var r = t - lambda0$1, i = r >= 0 ? 1 : -1, o = i * r, s = cos$1(n), l = sin$1(n), u = sinPhi0 * l, d = cosPhi0 * s + u * cos$1(o), f = u * i * sin$1(o);
	areaRingSum$1.add(atan2(f, d)), lambda0$1 = t, cosPhi0 = s, sinPhi0 = l;
}
function area_default(t) {
	return areaSum$1 = new Adder(), stream_default(t, areaStream$1), areaSum$1 * 2;
}
function spherical(t) {
	return [atan2(t[1], t[0]), asin$1(t[2])];
}
function cartesian(t) {
	var n = t[0], r = t[1], i = cos$1(r);
	return [
		i * cos$1(n),
		i * sin$1(n),
		sin$1(r)
	];
}
function cartesianDot(t, n) {
	return t[0] * n[0] + t[1] * n[1] + t[2] * n[2];
}
function cartesianCross(t, n) {
	return [
		t[1] * n[2] - t[2] * n[1],
		t[2] * n[0] - t[0] * n[2],
		t[0] * n[1] - t[1] * n[0]
	];
}
function cartesianAddInPlace(t, n) {
	t[0] += n[0], t[1] += n[1], t[2] += n[2];
}
function cartesianScale(t, n) {
	return [
		t[0] * n,
		t[1] * n,
		t[2] * n
	];
}
function cartesianNormalizeInPlace(t) {
	var n = sqrt$3(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
	t[0] /= n, t[1] /= n, t[2] /= n;
}
var lambda0, phi0, lambda1, phi1, lambda2, lambda00$1, phi00$1, p0, deltaSum, ranges, range$5, boundsStream$1 = {
	point: boundsPoint$1,
	lineStart: boundsLineStart,
	lineEnd: boundsLineEnd,
	polygonStart: function() {
		boundsStream$1.point = boundsRingPoint, boundsStream$1.lineStart = boundsRingStart, boundsStream$1.lineEnd = boundsRingEnd, deltaSum = new Adder(), areaStream$1.polygonStart();
	},
	polygonEnd: function() {
		areaStream$1.polygonEnd(), boundsStream$1.point = boundsPoint$1, boundsStream$1.lineStart = boundsLineStart, boundsStream$1.lineEnd = boundsLineEnd, areaRingSum$1 < 0 ? (lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90)) : deltaSum > 1e-6 ? phi1 = 90 : deltaSum < -1e-6 && (phi0 = -90), range$5[0] = lambda0, range$5[1] = lambda1;
	},
	sphere: function() {
		lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
	}
};
function boundsPoint$1(t, n) {
	ranges.push(range$5 = [lambda0 = t, lambda1 = t]), n < phi0 && (phi0 = n), n > phi1 && (phi1 = n);
}
function linePoint(t, n) {
	var r = cartesian([t * radians$1, n * radians$1]);
	if (p0) {
		var i = cartesianCross(p0, r), o = cartesianCross([
			i[1],
			-i[0],
			0
		], i);
		cartesianNormalizeInPlace(o), o = spherical(o);
		var s = t - lambda2, l = s > 0 ? 1 : -1, u = o[0] * degrees$1 * l, d, f = abs$1(s) > 180;
		f ^ (l * lambda2 < u && u < l * t) ? (d = o[1] * degrees$1, d > phi1 && (phi1 = d)) : (u = (u + 360) % 360 - 180, f ^ (l * lambda2 < u && u < l * t) ? (d = -o[1] * degrees$1, d < phi0 && (phi0 = d)) : (n < phi0 && (phi0 = n), n > phi1 && (phi1 = n))), f ? t < lambda2 ? angle(lambda0, t) > angle(lambda0, lambda1) && (lambda1 = t) : angle(t, lambda1) > angle(lambda0, lambda1) && (lambda0 = t) : lambda1 >= lambda0 ? (t < lambda0 && (lambda0 = t), t > lambda1 && (lambda1 = t)) : t > lambda2 ? angle(lambda0, t) > angle(lambda0, lambda1) && (lambda1 = t) : angle(t, lambda1) > angle(lambda0, lambda1) && (lambda0 = t);
	} else ranges.push(range$5 = [lambda0 = t, lambda1 = t]);
	n < phi0 && (phi0 = n), n > phi1 && (phi1 = n), p0 = r, lambda2 = t;
}
function boundsLineStart() {
	boundsStream$1.point = linePoint;
}
function boundsLineEnd() {
	range$5[0] = lambda0, range$5[1] = lambda1, boundsStream$1.point = boundsPoint$1, p0 = null;
}
function boundsRingPoint(t, n) {
	if (p0) {
		var r = t - lambda2;
		deltaSum.add(abs$1(r) > 180 ? r + (r > 0 ? 360 : -360) : r);
	} else lambda00$1 = t, phi00$1 = n;
	areaStream$1.point(t, n), linePoint(t, n);
}
function boundsRingStart() {
	areaStream$1.lineStart();
}
function boundsRingEnd() {
	boundsRingPoint(lambda00$1, phi00$1), areaStream$1.lineEnd(), abs$1(deltaSum) > 1e-6 && (lambda0 = -(lambda1 = 180)), range$5[0] = lambda0, range$5[1] = lambda1, p0 = null;
}
function angle(t, n) {
	return (n -= t) < 0 ? n + 360 : n;
}
function rangeCompare(t, n) {
	return t[0] - n[0];
}
function rangeContains(t, n) {
	return t[0] <= t[1] ? t[0] <= n && n <= t[1] : n < t[0] || t[1] < n;
}
function bounds_default(t) {
	var n, r, i, o, s, l, u;
	if (phi1 = lambda1 = -(lambda0 = phi0 = Infinity), ranges = [], stream_default(t, boundsStream$1), r = ranges.length) {
		for (ranges.sort(rangeCompare), n = 1, i = ranges[0], s = [i]; n < r; ++n) o = ranges[n], rangeContains(i, o[0]) || rangeContains(i, o[1]) ? (angle(i[0], o[1]) > angle(i[0], i[1]) && (i[1] = o[1]), angle(o[0], i[1]) > angle(i[0], i[1]) && (i[0] = o[0])) : s.push(i = o);
		for (l = -Infinity, r = s.length - 1, n = 0, i = s[r]; n <= r; i = o, ++n) o = s[n], (u = angle(i[1], o[0])) > l && (l = u, lambda0 = o[0], lambda1 = i[1]);
	}
	return ranges = range$5 = null, lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];
}
var W0, W1, X0$1, Y0$1, Z0$1, X1$1, Y1$1, Z1$1, X2$2, Y2$2, Z2$1, lambda00, phi00, x0$4, y0$4, z0, centroidStream$1 = {
	sphere: noop$2,
	point: centroidPoint$1,
	lineStart: centroidLineStart$1,
	lineEnd: centroidLineEnd$1,
	polygonStart: function() {
		centroidStream$1.lineStart = centroidRingStart$1, centroidStream$1.lineEnd = centroidRingEnd$1;
	},
	polygonEnd: function() {
		centroidStream$1.lineStart = centroidLineStart$1, centroidStream$1.lineEnd = centroidLineEnd$1;
	}
};
function centroidPoint$1(t, n) {
	t *= radians$1, n *= radians$1;
	var r = cos$1(n);
	centroidPointCartesian(r * cos$1(t), r * sin$1(t), sin$1(n));
}
function centroidPointCartesian(t, n, r) {
	++W0, X0$1 += (t - X0$1) / W0, Y0$1 += (n - Y0$1) / W0, Z0$1 += (r - Z0$1) / W0;
}
function centroidLineStart$1() {
	centroidStream$1.point = centroidLinePointFirst;
}
function centroidLinePointFirst(t, n) {
	t *= radians$1, n *= radians$1;
	var r = cos$1(n);
	x0$4 = r * cos$1(t), y0$4 = r * sin$1(t), z0 = sin$1(n), centroidStream$1.point = centroidLinePoint, centroidPointCartesian(x0$4, y0$4, z0);
}
function centroidLinePoint(t, n) {
	t *= radians$1, n *= radians$1;
	var r = cos$1(n), i = r * cos$1(t), o = r * sin$1(t), s = sin$1(n), l = atan2(sqrt$3((l = y0$4 * s - z0 * o) * l + (l = z0 * i - x0$4 * s) * l + (l = x0$4 * o - y0$4 * i) * l), x0$4 * i + y0$4 * o + z0 * s);
	W1 += l, X1$1 += l * (x0$4 + (x0$4 = i)), Y1$1 += l * (y0$4 + (y0$4 = o)), Z1$1 += l * (z0 + (z0 = s)), centroidPointCartesian(x0$4, y0$4, z0);
}
function centroidLineEnd$1() {
	centroidStream$1.point = centroidPoint$1;
}
function centroidRingStart$1() {
	centroidStream$1.point = centroidRingPointFirst;
}
function centroidRingEnd$1() {
	centroidRingPoint(lambda00, phi00), centroidStream$1.point = centroidPoint$1;
}
function centroidRingPointFirst(t, n) {
	lambda00 = t, phi00 = n, t *= radians$1, n *= radians$1, centroidStream$1.point = centroidRingPoint;
	var r = cos$1(n);
	x0$4 = r * cos$1(t), y0$4 = r * sin$1(t), z0 = sin$1(n), centroidPointCartesian(x0$4, y0$4, z0);
}
function centroidRingPoint(t, n) {
	t *= radians$1, n *= radians$1;
	var r = cos$1(n), i = r * cos$1(t), o = r * sin$1(t), s = sin$1(n), l = y0$4 * s - z0 * o, u = z0 * i - x0$4 * s, d = x0$4 * o - y0$4 * i, f = hypot(l, u, d), p = asin$1(f), g = f && -p / f;
	X2$2.add(g * l), Y2$2.add(g * u), Z2$1.add(g * d), W1 += p, X1$1 += p * (x0$4 + (x0$4 = i)), Y1$1 += p * (y0$4 + (y0$4 = o)), Z1$1 += p * (z0 + (z0 = s)), centroidPointCartesian(x0$4, y0$4, z0);
}
function centroid_default(t) {
	W0 = W1 = X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = 0, X2$2 = new Adder(), Y2$2 = new Adder(), Z2$1 = new Adder(), stream_default(t, centroidStream$1);
	var n = +X2$2, r = +Y2$2, i = +Z2$1, o = hypot(n, r, i);
	return o < 1e-12 && (n = X1$1, r = Y1$1, i = Z1$1, W1 < 1e-6 && (n = X0$1, r = Y0$1, i = Z0$1), o = hypot(n, r, i), o < 1e-12) ? [NaN, NaN] : [atan2(r, n) * degrees$1, asin$1(i / o) * degrees$1];
}
function compose_default(t, n) {
	function r(r, i) {
		return r = t(r, i), n(r[0], r[1]);
	}
	return t.invert && n.invert && (r.invert = function(r, i) {
		return r = n.invert(r, i), r && t.invert(r[0], r[1]);
	}), r;
}
function rotationIdentity(t, n) {
	return abs$1(t) > pi$2 && (t -= Math.round(t / tau$2) * tau$2), [t, n];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(t, n, r) {
	return (t %= tau$2) ? n || r ? compose_default(rotationLambda(t), rotationPhiGamma(n, r)) : rotationLambda(t) : n || r ? rotationPhiGamma(n, r) : rotationIdentity;
}
function forwardRotationLambda(t) {
	return function(n, r) {
		return n += t, abs$1(n) > pi$2 && (n -= Math.round(n / tau$2) * tau$2), [n, r];
	};
}
function rotationLambda(t) {
	var n = forwardRotationLambda(t);
	return n.invert = forwardRotationLambda(-t), n;
}
function rotationPhiGamma(t, n) {
	var r = cos$1(t), i = sin$1(t), o = cos$1(n), s = sin$1(n);
	function l(t, n) {
		var l = cos$1(n), u = cos$1(t) * l, d = sin$1(t) * l, f = sin$1(n), p = f * r + u * i;
		return [atan2(d * o - p * s, u * r - f * i), asin$1(p * o + d * s)];
	}
	return l.invert = function(t, n) {
		var l = cos$1(n), u = cos$1(t) * l, d = sin$1(t) * l, f = sin$1(n), p = f * o - d * s;
		return [atan2(d * o + f * s, u * r + p * i), asin$1(p * r - u * i)];
	}, l;
}
function rotation_default(t) {
	t = rotateRadians(t[0] * radians$1, t[1] * radians$1, t.length > 2 ? t[2] * radians$1 : 0);
	function n(n) {
		return n = t(n[0] * radians$1, n[1] * radians$1), n[0] *= degrees$1, n[1] *= degrees$1, n;
	}
	return n.invert = function(n) {
		return n = t.invert(n[0] * radians$1, n[1] * radians$1), n[0] *= degrees$1, n[1] *= degrees$1, n;
	}, n;
}
function circleStream(t, n, r, i, o, s) {
	if (r) {
		var l = cos$1(n), u = sin$1(n), d = i * r;
		o == null ? (o = n + i * tau$2, s = n - d / 2) : (o = circleRadius(l, o), s = circleRadius(l, s), (i > 0 ? o < s : o > s) && (o += i * tau$2));
		for (var f, p = o; i > 0 ? p > s : p < s; p -= d) f = spherical([
			l,
			-u * cos$1(p),
			-u * sin$1(p)
		]), t.point(f[0], f[1]);
	}
}
function circleRadius(t, n) {
	n = cartesian(n), n[0] -= t, cartesianNormalizeInPlace(n);
	var r = acos(-n[1]);
	return ((-n[2] < 0 ? -r : r) + tau$2 - epsilon$2) % tau$2;
}
function buffer_default() {
	var t = [], n;
	return {
		point: function(t, r, i) {
			n.push([
				t,
				r,
				i
			]);
		},
		lineStart: function() {
			t.push(n = []);
		},
		lineEnd: noop$2,
		rejoin: function() {
			t.length > 1 && t.push(t.pop().concat(t.shift()));
		},
		result: function() {
			var r = t;
			return t = [], n = null, r;
		}
	};
}
function pointEqual_default(t, n) {
	return abs$1(t[0] - n[0]) < 1e-6 && abs$1(t[1] - n[1]) < 1e-6;
}
function Intersection(t, n, r, i) {
	this.x = t, this.z = n, this.o = r, this.e = i, this.v = !1, this.n = this.p = null;
}
function rejoin_default(t, n, r, i, o) {
	var s = [], l = [], u, d;
	if (t.forEach(function(t) {
		if (!((n = t.length - 1) <= 0)) {
			var n, r = t[0], i = t[n], d;
			if (pointEqual_default(r, i)) {
				if (!r[2] && !i[2]) {
					for (o.lineStart(), u = 0; u < n; ++u) o.point((r = t[u])[0], r[1]);
					o.lineEnd();
					return;
				}
				i[0] += 2 * epsilon$2;
			}
			s.push(d = new Intersection(r, t, null, !0)), l.push(d.o = new Intersection(r, null, d, !1)), s.push(d = new Intersection(i, t, null, !1)), l.push(d.o = new Intersection(i, null, d, !0));
		}
	}), s.length) {
		for (l.sort(n), link(s), link(l), u = 0, d = l.length; u < d; ++u) l[u].e = r = !r;
		for (var f = s[0], p, g;;) {
			for (var _ = f, v = !0; _.v;) if ((_ = _.n) === f) return;
			p = _.z, o.lineStart();
			do {
				if (_.v = _.o.v = !0, _.e) {
					if (v) for (u = 0, d = p.length; u < d; ++u) o.point((g = p[u])[0], g[1]);
					else i(_.x, _.n.x, 1, o);
					_ = _.n;
				} else {
					if (v) for (p = _.p.z, u = p.length - 1; u >= 0; --u) o.point((g = p[u])[0], g[1]);
					else i(_.x, _.p.x, -1, o);
					_ = _.p;
				}
				_ = _.o, p = _.z, v = !v;
			} while (!_.v);
			o.lineEnd();
		}
	}
}
function link(t) {
	if (n = t.length) {
		for (var n, r = 0, i = t[0], o; ++r < n;) i.n = o = t[r], o.p = i, i = o;
		i.n = o = t[0], o.p = i;
	}
}
function longitude(t) {
	return abs$1(t[0]) <= pi$2 ? t[0] : sign(t[0]) * ((abs$1(t[0]) + pi$2) % tau$2 - pi$2);
}
function polygonContains_default(t, n) {
	var r = longitude(n), i = n[1], o = sin$1(i), s = [
		sin$1(r),
		-cos$1(r),
		0
	], l = 0, u = 0, d = new Adder();
	o === 1 ? i = halfPi$1 + epsilon$2 : o === -1 && (i = -halfPi$1 - epsilon$2);
	for (var f = 0, p = t.length; f < p; ++f) if (_ = (g = t[f]).length) for (var g, _, v = g[_ - 1], S = longitude(v), T = v[1] / 2 + quarterPi$1, E = sin$1(T), O = cos$1(T), k = 0; k < _; ++k, S = j, E = P, O = F, v = A) {
		var A = g[k], j = longitude(A), N = A[1] / 2 + quarterPi$1, P = sin$1(N), F = cos$1(N), I = j - S, L = I >= 0 ? 1 : -1, R = L * I, z = R > pi$2, V = E * P;
		if (d.add(atan2(V * L * sin$1(R), O * F + V * cos$1(R))), l += z ? I + L * tau$2 : I, z ^ S >= r ^ j >= r) {
			var H = cartesianCross(cartesian(v), cartesian(A));
			cartesianNormalizeInPlace(H);
			var U = cartesianCross(s, H);
			cartesianNormalizeInPlace(U);
			var W = (z ^ I >= 0 ? -1 : 1) * asin$1(U[2]);
			(i > W || i === W && (H[0] || H[1])) && (u += z ^ I >= 0 ? 1 : -1);
		}
	}
	return (l < -1e-6 || l < 1e-6 && d < -1e-12) ^ u & 1;
}
function clip_default(t, n, r, i) {
	return function(o) {
		var s = n(o), l = buffer_default(), u = n(l), d = !1, f, p, g, _ = {
			point: v,
			lineStart: T,
			lineEnd: E,
			polygonStart: function() {
				_.point = O, _.lineStart = k, _.lineEnd = A, p = [], f = [];
			},
			polygonEnd: function() {
				_.point = v, _.lineStart = T, _.lineEnd = E, p = merge$3(p);
				var t = polygonContains_default(f, i);
				p.length ? (d ||= (o.polygonStart(), !0), rejoin_default(p, compareIntersection, t, r, o)) : t && (d ||= (o.polygonStart(), !0), o.lineStart(), r(null, null, 1, o), o.lineEnd()), d &&= (o.polygonEnd(), !1), p = f = null;
			},
			sphere: function() {
				o.polygonStart(), o.lineStart(), r(null, null, 1, o), o.lineEnd(), o.polygonEnd();
			}
		};
		function v(n, r) {
			t(n, r) && o.point(n, r);
		}
		function S(t, n) {
			s.point(t, n);
		}
		function T() {
			_.point = S, s.lineStart();
		}
		function E() {
			_.point = v, s.lineEnd();
		}
		function O(t, n) {
			g.push([t, n]), u.point(t, n);
		}
		function k() {
			u.lineStart(), g = [];
		}
		function A() {
			O(g[0][0], g[0][1]), u.lineEnd();
			var t = u.clean(), n = l.result(), r, i = n.length, s, _, v;
			if (g.pop(), f.push(g), g = null, i) {
				if (t & 1) {
					if (_ = n[0], (s = _.length - 1) > 0) {
						for (d ||= (o.polygonStart(), !0), o.lineStart(), r = 0; r < s; ++r) o.point((v = _[r])[0], v[1]);
						o.lineEnd();
					}
					return;
				}
				i > 1 && t & 2 && n.push(n.pop().concat(n.shift())), p.push(n.filter(validSegment));
			}
		}
		return _;
	};
}
function validSegment(t) {
	return t.length > 1;
}
function compareIntersection(t, n) {
	return ((t = t.x)[0] < 0 ? t[1] - halfPi$1 - epsilon$2 : halfPi$1 - t[1]) - ((n = n.x)[0] < 0 ? n[1] - halfPi$1 - epsilon$2 : halfPi$1 - n[1]);
}
var antimeridian_default = clip_default(function() {
	return !0;
}, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi$2, -halfPi$1]);
function clipAntimeridianLine(t) {
	var n = NaN, r = NaN, i = NaN, o;
	return {
		lineStart: function() {
			t.lineStart(), o = 1;
		},
		point: function(s, l) {
			var u = s > 0 ? pi$2 : -pi$2, d = abs$1(s - n);
			abs$1(d - pi$2) < 1e-6 ? (t.point(n, r = (r + l) / 2 > 0 ? halfPi$1 : -halfPi$1), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(u, r), t.point(s, r), o = 0) : i !== u && d >= pi$2 && (abs$1(n - i) < 1e-6 && (n -= i * epsilon$2), abs$1(s - u) < 1e-6 && (s -= u * epsilon$2), r = clipAntimeridianIntersect(n, r, s, l), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(u, r), o = 0), t.point(n = s, r = l), i = u;
		},
		lineEnd: function() {
			t.lineEnd(), n = r = NaN;
		},
		clean: function() {
			return 2 - o;
		}
	};
}
function clipAntimeridianIntersect(t, n, r, i) {
	var o, s, l = sin$1(t - r);
	return abs$1(l) > 1e-6 ? atan((sin$1(n) * (s = cos$1(i)) * sin$1(r) - sin$1(i) * (o = cos$1(n)) * sin$1(t)) / (o * s * l)) : (n + i) / 2;
}
function clipAntimeridianInterpolate(t, n, r, i) {
	var o;
	if (t == null) o = r * halfPi$1, i.point(-pi$2, o), i.point(0, o), i.point(pi$2, o), i.point(pi$2, 0), i.point(pi$2, -o), i.point(0, -o), i.point(-pi$2, -o), i.point(-pi$2, 0), i.point(-pi$2, o);
	else if (abs$1(t[0] - n[0]) > 1e-6) {
		var s = t[0] < n[0] ? pi$2 : -pi$2;
		o = r * s / 2, i.point(-s, o), i.point(0, o), i.point(s, o);
	} else i.point(n[0], n[1]);
}
function circle_default$1(t) {
	var n = cos$1(t), r = 2 * radians$1, i = n > 0, o = abs$1(n) > epsilon$2;
	function s(n, i, o, s) {
		circleStream(s, t, r, o, n, i);
	}
	function l(t, r) {
		return cos$1(t) * cos$1(r) > n;
	}
	function u(t) {
		var n, r, s, u, p;
		return {
			lineStart: function() {
				u = s = !1, p = 1;
			},
			point: function(g, _) {
				var v = [g, _], S, T = l(g, _), E = i ? T ? 0 : f(g, _) : T ? f(g + (g < 0 ? pi$2 : -pi$2), _) : 0;
				if (!n && (u = s = T) && t.lineStart(), T !== s && (S = d(n, v), (!S || pointEqual_default(n, S) || pointEqual_default(v, S)) && (v[2] = 1)), T !== s) p = 0, T ? (t.lineStart(), S = d(v, n), t.point(S[0], S[1])) : (S = d(n, v), t.point(S[0], S[1], 2), t.lineEnd()), n = S;
				else if (o && n && i ^ T) {
					var O;
					!(E & r) && (O = d(v, n, !0)) && (p = 0, i ? (t.lineStart(), t.point(O[0][0], O[0][1]), t.point(O[1][0], O[1][1]), t.lineEnd()) : (t.point(O[1][0], O[1][1]), t.lineEnd(), t.lineStart(), t.point(O[0][0], O[0][1], 3)));
				}
				T && (!n || !pointEqual_default(n, v)) && t.point(v[0], v[1]), n = v, s = T, r = E;
			},
			lineEnd: function() {
				s && t.lineEnd(), n = null;
			},
			clean: function() {
				return p | (u && s) << 1;
			}
		};
	}
	function d(t, r, i) {
		var o = cartesian(t), s = cartesian(r), l = [
			1,
			0,
			0
		], u = cartesianCross(o, s), d = cartesianDot(u, u), f = u[0], p = d - f * f;
		if (!p) return !i && t;
		var g = n * d / p, _ = -n * f / p, v = cartesianCross(l, u), S = cartesianScale(l, g);
		cartesianAddInPlace(S, cartesianScale(u, _));
		var T = v, E = cartesianDot(S, T), O = cartesianDot(T, T), k = E * E - O * (cartesianDot(S, S) - 1);
		if (!(k < 0)) {
			var A = sqrt$3(k), j = cartesianScale(T, (-E - A) / O);
			if (cartesianAddInPlace(j, S), j = spherical(j), !i) return j;
			var N = t[0], P = r[0], F = t[1], I = r[1], L;
			P < N && (L = N, N = P, P = L);
			var R = P - N, z = abs$1(R - pi$2) < epsilon$2, V = z || R < 1e-6;
			if (!z && I < F && (L = F, F = I, I = L), V ? z ? F + I > 0 ^ j[1] < (abs$1(j[0] - N) < 1e-6 ? F : I) : F <= j[1] && j[1] <= I : R > pi$2 ^ (N <= j[0] && j[0] <= P)) {
				var H = cartesianScale(T, (-E + A) / O);
				return cartesianAddInPlace(H, S), [j, spherical(H)];
			}
		}
	}
	function f(n, r) {
		var o = i ? t : pi$2 - t, s = 0;
		return n < -o ? s |= 1 : n > o && (s |= 2), r < -o ? s |= 4 : r > o && (s |= 8), s;
	}
	return clip_default(l, u, s, i ? [0, -t] : [-pi$2, t - pi$2]);
}
function line_default$1(t, n, r, i, o, s) {
	var l = t[0], u = t[1], d = n[0], f = n[1], p = 0, g = 1, _ = d - l, v = f - u, S = r - l;
	if (!(!_ && S > 0)) {
		if (S /= _, _ < 0) {
			if (S < p) return;
			S < g && (g = S);
		} else if (_ > 0) {
			if (S > g) return;
			S > p && (p = S);
		}
		if (S = o - l, !(!_ && S < 0)) {
			if (S /= _, _ < 0) {
				if (S > g) return;
				S > p && (p = S);
			} else if (_ > 0) {
				if (S < p) return;
				S < g && (g = S);
			}
			if (S = i - u, !(!v && S > 0)) {
				if (S /= v, v < 0) {
					if (S < p) return;
					S < g && (g = S);
				} else if (v > 0) {
					if (S > g) return;
					S > p && (p = S);
				}
				if (S = s - u, !(!v && S < 0)) {
					if (S /= v, v < 0) {
						if (S > g) return;
						S > p && (p = S);
					} else if (v > 0) {
						if (S < p) return;
						S < g && (g = S);
					}
					return p > 0 && (t[0] = l + p * _, t[1] = u + p * v), g < 1 && (n[0] = l + g * _, n[1] = u + g * v), !0;
				}
			}
		}
	}
}
var clipMax = 1e9, clipMin = -clipMax;
function clipRectangle(t, n, r, i) {
	function o(o, s) {
		return t <= o && o <= r && n <= s && s <= i;
	}
	function s(o, s, u, f) {
		var p = 0, g = 0;
		if (o == null || (p = l(o, u)) !== (g = l(s, u)) || d(o, s) < 0 ^ u > 0) do
			f.point(p === 0 || p === 3 ? t : r, p > 1 ? i : n);
		while ((p = (p + u + 4) % 4) !== g);
		else f.point(s[0], s[1]);
	}
	function l(i, o) {
		return abs$1(i[0] - t) < 1e-6 ? o > 0 ? 0 : 3 : abs$1(i[0] - r) < 1e-6 ? o > 0 ? 2 : 1 : abs$1(i[1] - n) < 1e-6 ? o > 0 ? 1 : 0 : o > 0 ? 3 : 2;
	}
	function u(t, n) {
		return d(t.x, n.x);
	}
	function d(t, n) {
		var r = l(t, 1), i = l(n, 1);
		return r === i ? r === 0 ? n[1] - t[1] : r === 1 ? t[0] - n[0] : r === 2 ? t[1] - n[1] : n[0] - t[0] : r - i;
	}
	return function(l) {
		var d = l, f = buffer_default(), p, g, _, v, S, T, E, O, k, A, j, N = {
			point: P,
			lineStart: R,
			lineEnd: z,
			polygonStart: I,
			polygonEnd: L
		};
		function P(t, n) {
			o(t, n) && d.point(t, n);
		}
		function F() {
			for (var n = 0, r = 0, o = g.length; r < o; ++r) for (var s = g[r], l = 1, u = s.length, d = s[0], f, p, _ = d[0], v = d[1]; l < u; ++l) f = _, p = v, d = s[l], _ = d[0], v = d[1], p <= i ? v > i && (_ - f) * (i - p) > (v - p) * (t - f) && ++n : v <= i && (_ - f) * (i - p) < (v - p) * (t - f) && --n;
			return n;
		}
		function I() {
			d = f, p = [], g = [], j = !0;
		}
		function L() {
			var t = F(), n = j && t, r = (p = merge$3(p)).length;
			(n || r) && (l.polygonStart(), n && (l.lineStart(), s(null, null, 1, l), l.lineEnd()), r && rejoin_default(p, u, t, s, l), l.polygonEnd()), d = l, p = g = _ = null;
		}
		function R() {
			N.point = V, g && g.push(_ = []), A = !0, k = !1, E = O = NaN;
		}
		function z() {
			p && (V(v, S), T && k && f.rejoin(), p.push(f.result())), N.point = P, k && d.lineEnd();
		}
		function V(s, l) {
			var u = o(s, l);
			if (g && _.push([s, l]), A) v = s, S = l, T = u, A = !1, u && (d.lineStart(), d.point(s, l));
			else if (u && k) d.point(s, l);
			else {
				var f = [E = Math.max(clipMin, Math.min(clipMax, E)), O = Math.max(clipMin, Math.min(clipMax, O))], p = [s = Math.max(clipMin, Math.min(clipMax, s)), l = Math.max(clipMin, Math.min(clipMax, l))];
				line_default$1(f, p, t, n, r, i) ? (k || (d.lineStart(), d.point(f[0], f[1])), d.point(p[0], p[1]), u || d.lineEnd(), j = !1) : u && (d.lineStart(), d.point(s, l), j = !1);
			}
			E = s, O = l, k = u;
		}
		return N;
	};
}
function graticuleX(t, n, r) {
	var i = range$3(t, n - epsilon$2, r).concat(n);
	return function(t) {
		return i.map(function(n) {
			return [t, n];
		});
	};
}
function graticuleY(t, n, r) {
	var i = range$3(t, n - epsilon$2, r).concat(n);
	return function(t) {
		return i.map(function(n) {
			return [n, t];
		});
	};
}
function graticule() {
	var t, n, r, i, o, s, l, u, d = 10, f = d, p = 90, g = 360, _, v, S, T, E = 2.5;
	function O() {
		return {
			type: "MultiLineString",
			coordinates: k()
		};
	}
	function k() {
		return range$3(ceil(i / p) * p, r, p).map(S).concat(range$3(ceil(u / g) * g, l, g).map(T)).concat(range$3(ceil(n / d) * d, t, d).filter(function(t) {
			return abs$1(t % p) > epsilon$2;
		}).map(_)).concat(range$3(ceil(s / f) * f, o, f).filter(function(t) {
			return abs$1(t % g) > epsilon$2;
		}).map(v));
	}
	return O.lines = function() {
		return k().map(function(t) {
			return {
				type: "LineString",
				coordinates: t
			};
		});
	}, O.outline = function() {
		return {
			type: "Polygon",
			coordinates: [S(i).concat(T(l).slice(1), S(r).reverse().slice(1), T(u).reverse().slice(1))]
		};
	}, O.extent = function(t) {
		return arguments.length ? O.extentMajor(t).extentMinor(t) : O.extentMinor();
	}, O.extentMajor = function(t) {
		return arguments.length ? (i = +t[0][0], r = +t[1][0], u = +t[0][1], l = +t[1][1], i > r && (t = i, i = r, r = t), u > l && (t = u, u = l, l = t), O.precision(E)) : [[i, u], [r, l]];
	}, O.extentMinor = function(r) {
		return arguments.length ? (n = +r[0][0], t = +r[1][0], s = +r[0][1], o = +r[1][1], n > t && (r = n, n = t, t = r), s > o && (r = s, s = o, o = r), O.precision(E)) : [[n, s], [t, o]];
	}, O.step = function(t) {
		return arguments.length ? O.stepMajor(t).stepMinor(t) : O.stepMinor();
	}, O.stepMajor = function(t) {
		return arguments.length ? (p = +t[0], g = +t[1], O) : [p, g];
	}, O.stepMinor = function(t) {
		return arguments.length ? (d = +t[0], f = +t[1], O) : [d, f];
	}, O.precision = function(d) {
		return arguments.length ? (E = +d, _ = graticuleX(s, o, 90), v = graticuleY(n, t, E), S = graticuleX(u, l, 90), T = graticuleY(i, r, E), O) : E;
	}, O.extentMajor([[-180, -90 + epsilon$2], [180, 90 - epsilon$2]]).extentMinor([[-180, -80 - epsilon$2], [180, 80 + epsilon$2]]);
}
var identity_default$2 = (t) => t, areaSum = new Adder(), areaRingSum = new Adder(), x00$2, y00$2, x0$3, y0$3, areaStream = {
	point: noop$2,
	lineStart: noop$2,
	lineEnd: noop$2,
	polygonStart: function() {
		areaStream.lineStart = areaRingStart, areaStream.lineEnd = areaRingEnd;
	},
	polygonEnd: function() {
		areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$2, areaSum.add(abs$1(areaRingSum)), areaRingSum = new Adder();
	},
	result: function() {
		var t = areaSum / 2;
		return areaSum = new Adder(), t;
	}
};
function areaRingStart() {
	areaStream.point = areaPointFirst;
}
function areaPointFirst(t, n) {
	areaStream.point = areaPoint, x00$2 = x0$3 = t, y00$2 = y0$3 = n;
}
function areaPoint(t, n) {
	areaRingSum.add(y0$3 * t - x0$3 * n), x0$3 = t, y0$3 = n;
}
function areaRingEnd() {
	areaPoint(x00$2, y00$2);
}
var area_default$2 = areaStream, x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1, boundsStream = {
	point: boundsPoint,
	lineStart: noop$2,
	lineEnd: noop$2,
	polygonStart: noop$2,
	polygonEnd: noop$2,
	result: function() {
		var t = [[x0$2, y0$2], [x1, y1]];
		return x1 = y1 = -(y0$2 = x0$2 = Infinity), t;
	}
};
function boundsPoint(t, n) {
	t < x0$2 && (x0$2 = t), t > x1 && (x1 = t), n < y0$2 && (y0$2 = n), n > y1 && (y1 = n);
}
var bounds_default$1 = boundsStream, X0 = 0, Y0 = 0, Z0 = 0, X1 = 0, Y1 = 0, Z1 = 0, X2$1 = 0, Y2$1 = 0, Z2 = 0, x00$1, y00$1, x0$1, y0$1, centroidStream = {
	point: centroidPoint,
	lineStart: centroidLineStart,
	lineEnd: centroidLineEnd,
	polygonStart: function() {
		centroidStream.lineStart = centroidRingStart, centroidStream.lineEnd = centroidRingEnd;
	},
	polygonEnd: function() {
		centroidStream.point = centroidPoint, centroidStream.lineStart = centroidLineStart, centroidStream.lineEnd = centroidLineEnd;
	},
	result: function() {
		var t = Z2 ? [X2$1 / Z2, Y2$1 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
		return X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2$1 = Y2$1 = Z2 = 0, t;
	}
};
function centroidPoint(t, n) {
	X0 += t, Y0 += n, ++Z0;
}
function centroidLineStart() {
	centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(t, n) {
	centroidStream.point = centroidPointLine, centroidPoint(x0$1 = t, y0$1 = n);
}
function centroidPointLine(t, n) {
	var r = t - x0$1, i = n - y0$1, o = sqrt$3(r * r + i * i);
	X1 += o * (x0$1 + t) / 2, Y1 += o * (y0$1 + n) / 2, Z1 += o, centroidPoint(x0$1 = t, y0$1 = n);
}
function centroidLineEnd() {
	centroidStream.point = centroidPoint;
}
function centroidRingStart() {
	centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
	centroidPointRing(x00$1, y00$1);
}
function centroidPointFirstRing(t, n) {
	centroidStream.point = centroidPointRing, centroidPoint(x00$1 = x0$1 = t, y00$1 = y0$1 = n);
}
function centroidPointRing(t, n) {
	var r = t - x0$1, i = n - y0$1, o = sqrt$3(r * r + i * i);
	X1 += o * (x0$1 + t) / 2, Y1 += o * (y0$1 + n) / 2, Z1 += o, o = y0$1 * t - x0$1 * n, X2$1 += o * (x0$1 + t), Y2$1 += o * (y0$1 + n), Z2 += o * 3, centroidPoint(x0$1 = t, y0$1 = n);
}
var centroid_default$1 = centroidStream;
function PathContext(t) {
	this._context = t;
}
PathContext.prototype = {
	_radius: 4.5,
	pointRadius: function(t) {
		return this._radius = t, this;
	},
	polygonStart: function() {
		this._line = 0;
	},
	polygonEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._point = 0;
	},
	lineEnd: function() {
		this._line === 0 && this._context.closePath(), this._point = NaN;
	},
	point: function(t, n) {
		switch (this._point) {
			case 0:
				this._context.moveTo(t, n), this._point = 1;
				break;
			case 1:
				this._context.lineTo(t, n);
				break;
			default:
				this._context.moveTo(t + this._radius, n), this._context.arc(t, n, this._radius, 0, tau$2);
				break;
		}
	},
	result: noop$2
};
var lengthSum = new Adder(), lengthRing, x00, y00, x0, y0, lengthStream = {
	point: noop$2,
	lineStart: function() {
		lengthStream.point = lengthPointFirst;
	},
	lineEnd: function() {
		lengthRing && lengthPoint(x00, y00), lengthStream.point = noop$2;
	},
	polygonStart: function() {
		lengthRing = !0;
	},
	polygonEnd: function() {
		lengthRing = null;
	},
	result: function() {
		var t = +lengthSum;
		return lengthSum = new Adder(), t;
	}
};
function lengthPointFirst(t, n) {
	lengthStream.point = lengthPoint, x00 = x0 = t, y00 = y0 = n;
}
function lengthPoint(t, n) {
	x0 -= t, y0 -= n, lengthSum.add(sqrt$3(x0 * x0 + y0 * y0)), x0 = t, y0 = n;
}
var measure_default = lengthStream, cacheDigits, cacheAppend, cacheRadius, cacheCircle, PathString = class {
	constructor(t) {
		this._append = t == null ? append : appendRound(t), this._radius = 4.5, this._ = "";
	}
	pointRadius(t) {
		return this._radius = +t, this;
	}
	polygonStart() {
		this._line = 0;
	}
	polygonEnd() {
		this._line = NaN;
	}
	lineStart() {
		this._point = 0;
	}
	lineEnd() {
		this._line === 0 && (this._ += "Z"), this._point = NaN;
	}
	point(t, n) {
		switch (this._point) {
			case 0:
				this._append`M${t},${n}`, this._point = 1;
				break;
			case 1:
				this._append`L${t},${n}`;
				break;
			default:
				if (this._append`M${t},${n}`, this._radius !== cacheRadius || this._append !== cacheAppend) {
					let t = this._radius, n = this._;
					this._ = "", this._append`m0,${t}a${t},${t} 0 1,1 0,${-2 * t}a${t},${t} 0 1,1 0,${2 * t}z`, cacheRadius = t, cacheAppend = this._append, cacheCircle = this._, this._ = n;
				}
				this._ += cacheCircle;
				break;
		}
	}
	result() {
		let t = this._;
		return this._ = "", t.length ? t : null;
	}
};
function append(t) {
	let n = 1;
	this._ += t[0];
	for (let r = t.length; n < r; ++n) this._ += arguments[n] + t[n];
}
function appendRound(t) {
	let n = Math.floor(t);
	if (!(n >= 0)) throw RangeError(`invalid digits: ${t}`);
	if (n > 15) return append;
	if (n !== cacheDigits) {
		let t = 10 ** n;
		cacheDigits = n, cacheAppend = function(n) {
			let r = 1;
			this._ += n[0];
			for (let i = n.length; r < i; ++r) this._ += Math.round(arguments[r] * t) / t + n[r];
		};
	}
	return cacheAppend;
}
function path_default(t, n) {
	let r = 3, i = 4.5, o, s;
	function l(t) {
		return t && (typeof i == "function" && s.pointRadius(+i.apply(this, arguments)), stream_default(t, o(s))), s.result();
	}
	return l.area = function(t) {
		return stream_default(t, o(area_default$2)), area_default$2.result();
	}, l.measure = function(t) {
		return stream_default(t, o(measure_default)), measure_default.result();
	}, l.bounds = function(t) {
		return stream_default(t, o(bounds_default$1)), bounds_default$1.result();
	}, l.centroid = function(t) {
		return stream_default(t, o(centroid_default$1)), centroid_default$1.result();
	}, l.projection = function(n) {
		return arguments.length ? (o = n == null ? (t = null, identity_default$2) : (t = n).stream, l) : t;
	}, l.context = function(t) {
		return arguments.length ? (s = t == null ? (n = null, new PathString(r)) : new PathContext(n = t), typeof i != "function" && s.pointRadius(i), l) : n;
	}, l.pointRadius = function(t) {
		return arguments.length ? (i = typeof t == "function" ? t : (s.pointRadius(+t), +t), l) : i;
	}, l.digits = function(t) {
		if (!arguments.length) return r;
		if (t == null) r = null;
		else {
			let n = Math.floor(t);
			if (!(n >= 0)) throw RangeError(`invalid digits: ${t}`);
			r = n;
		}
		return n === null && (s = new PathString(r)), l;
	}, l.projection(t).digits(r).context(n);
}
function transformer$3(t) {
	return function(n) {
		var r = new TransformStream();
		for (var i in t) r[i] = t[i];
		return r.stream = n, r;
	};
}
function TransformStream() {}
TransformStream.prototype = {
	constructor: TransformStream,
	point: function(t, n) {
		this.stream.point(t, n);
	},
	sphere: function() {
		this.stream.sphere();
	},
	lineStart: function() {
		this.stream.lineStart();
	},
	lineEnd: function() {
		this.stream.lineEnd();
	},
	polygonStart: function() {
		this.stream.polygonStart();
	},
	polygonEnd: function() {
		this.stream.polygonEnd();
	}
};
function fit$1(t, n, r) {
	var i = t.clipExtent && t.clipExtent();
	return t.scale(150).translate([0, 0]), i != null && t.clipExtent(null), stream_default(r, t.stream(bounds_default$1)), n(bounds_default$1.result()), i != null && t.clipExtent(i), t;
}
function fitExtent(t, n, r) {
	return fit$1(t, function(r) {
		var i = n[1][0] - n[0][0], o = n[1][1] - n[0][1], s = Math.min(i / (r[1][0] - r[0][0]), o / (r[1][1] - r[0][1])), l = +n[0][0] + (i - s * (r[1][0] + r[0][0])) / 2, u = +n[0][1] + (o - s * (r[1][1] + r[0][1])) / 2;
		t.scale(150 * s).translate([l, u]);
	}, r);
}
function fitSize(t, n, r) {
	return fitExtent(t, [[0, 0], n], r);
}
function fitWidth(t, n, r) {
	return fit$1(t, function(r) {
		var i = +n, o = i / (r[1][0] - r[0][0]), s = (i - o * (r[1][0] + r[0][0])) / 2, l = -o * r[0][1];
		t.scale(150 * o).translate([s, l]);
	}, r);
}
function fitHeight(t, n, r) {
	return fit$1(t, function(r) {
		var i = +n, o = i / (r[1][1] - r[0][1]), s = -o * r[0][0], l = (i - o * (r[1][1] + r[0][1])) / 2;
		t.scale(150 * o).translate([s, l]);
	}, r);
}
var maxDepth = 16, cosMinDistance = cos$1(30 * radians$1);
function resample_default(t, n) {
	return +n ? resample(t, n) : resampleNone(t);
}
function resampleNone(t) {
	return transformer$3({ point: function(n, r) {
		n = t(n, r), this.stream.point(n[0], n[1]);
	} });
}
function resample(t, n) {
	function r(i, o, s, l, u, d, f, p, g, _, v, S, T, E) {
		var O = f - i, k = p - o, A = O * O + k * k;
		if (A > 4 * n && T--) {
			var j = l + _, N = u + v, P = d + S, F = sqrt$3(j * j + N * N + P * P), I = asin$1(P /= F), L = abs$1(abs$1(P) - 1) < 1e-6 || abs$1(s - g) < 1e-6 ? (s + g) / 2 : atan2(N, j), R = t(L, I), z = R[0], V = R[1], H = z - i, U = V - o, W = k * H - O * U;
			(W * W / A > n || abs$1((O * H + k * U) / A - .5) > .3 || l * _ + u * v + d * S < cosMinDistance) && (r(i, o, s, l, u, d, z, V, L, j /= F, N /= F, P, T, E), E.point(z, V), r(z, V, L, j, N, P, f, p, g, _, v, S, T, E));
		}
	}
	return function(n) {
		var i, o, s, l, u, d, f, p, g, _, v, S, T = {
			point: E,
			lineStart: O,
			lineEnd: A,
			polygonStart: function() {
				n.polygonStart(), T.lineStart = j;
			},
			polygonEnd: function() {
				n.polygonEnd(), T.lineStart = O;
			}
		};
		function E(r, i) {
			r = t(r, i), n.point(r[0], r[1]);
		}
		function O() {
			p = NaN, T.point = k, n.lineStart();
		}
		function k(i, o) {
			var s = cartesian([i, o]), l = t(i, o);
			r(p, g, f, _, v, S, p = l[0], g = l[1], f = i, _ = s[0], v = s[1], S = s[2], maxDepth, n), n.point(p, g);
		}
		function A() {
			T.point = E, n.lineEnd();
		}
		function j() {
			O(), T.point = N, T.lineEnd = P;
		}
		function N(t, n) {
			k(i = t, n), o = p, s = g, l = _, u = v, d = S, T.point = k;
		}
		function P() {
			r(p, g, f, _, v, S, o, s, i, l, u, d, maxDepth, n), T.lineEnd = A, A();
		}
		return T;
	};
}
var transformRadians = transformer$3({ point: function(t, n) {
	this.stream.point(t * radians$1, n * radians$1);
} });
function transformRotate(t) {
	return transformer$3({ point: function(n, r) {
		var i = t(n, r);
		return this.stream.point(i[0], i[1]);
	} });
}
function scaleTranslate(t, n, r, i, o) {
	function s(s, l) {
		return s *= i, l *= o, [n + t * s, r - t * l];
	}
	return s.invert = function(s, l) {
		return [(s - n) / t * i, (r - l) / t * o];
	}, s;
}
function scaleTranslateRotate(t, n, r, i, o, s) {
	if (!s) return scaleTranslate(t, n, r, i, o);
	var l = cos$1(s), u = sin$1(s), d = l * t, f = u * t, p = l / t, g = u / t, _ = (u * r - l * n) / t, v = (u * n + l * r) / t;
	function S(t, s) {
		return t *= i, s *= o, [d * t - f * s + n, r - f * t - d * s];
	}
	return S.invert = function(t, n) {
		return [i * (p * t - g * n + _), o * (v - g * t - p * n)];
	}, S;
}
function projection$1(t) {
	return projectionMutator(function() {
		return t;
	})();
}
function projectionMutator(t) {
	var n, r = 150, i = 480, o = 250, s = 0, l = 0, u = 0, d = 0, f = 0, p, g = 0, _ = 1, v = 1, S = null, T = antimeridian_default, E = null, O, k, A, j = identity_default$2, N = .5, P, F, I, L, R;
	function z(t) {
		return I(t[0] * radians$1, t[1] * radians$1);
	}
	function V(t) {
		return t = I.invert(t[0], t[1]), t && [t[0] * degrees$1, t[1] * degrees$1];
	}
	z.stream = function(t) {
		return L && R === t ? L : L = transformRadians(transformRotate(p)(T(P(j(R = t)))));
	}, z.preclip = function(t) {
		return arguments.length ? (T = t, S = void 0, U()) : T;
	}, z.postclip = function(t) {
		return arguments.length ? (j = t, E = O = k = A = null, U()) : j;
	}, z.clipAngle = function(t) {
		return arguments.length ? (T = +t ? circle_default$1(S = t * radians$1) : (S = null, antimeridian_default), U()) : S * degrees$1;
	}, z.clipExtent = function(t) {
		return arguments.length ? (j = t == null ? (E = O = k = A = null, identity_default$2) : clipRectangle(E = +t[0][0], O = +t[0][1], k = +t[1][0], A = +t[1][1]), U()) : E == null ? null : [[E, O], [k, A]];
	}, z.scale = function(t) {
		return arguments.length ? (r = +t, H()) : r;
	}, z.translate = function(t) {
		return arguments.length ? (i = +t[0], o = +t[1], H()) : [i, o];
	}, z.center = function(t) {
		return arguments.length ? (s = t[0] % 360 * radians$1, l = t[1] % 360 * radians$1, H()) : [s * degrees$1, l * degrees$1];
	}, z.rotate = function(t) {
		return arguments.length ? (u = t[0] % 360 * radians$1, d = t[1] % 360 * radians$1, f = t.length > 2 ? t[2] % 360 * radians$1 : 0, H()) : [
			u * degrees$1,
			d * degrees$1,
			f * degrees$1
		];
	}, z.angle = function(t) {
		return arguments.length ? (g = t % 360 * radians$1, H()) : g * degrees$1;
	}, z.reflectX = function(t) {
		return arguments.length ? (_ = t ? -1 : 1, H()) : _ < 0;
	}, z.reflectY = function(t) {
		return arguments.length ? (v = t ? -1 : 1, H()) : v < 0;
	}, z.precision = function(t) {
		return arguments.length ? (P = resample_default(F, N = t * t), U()) : sqrt$3(N);
	}, z.fitExtent = function(t, n) {
		return fitExtent(z, t, n);
	}, z.fitSize = function(t, n) {
		return fitSize(z, t, n);
	}, z.fitWidth = function(t, n) {
		return fitWidth(z, t, n);
	}, z.fitHeight = function(t, n) {
		return fitHeight(z, t, n);
	};
	function H() {
		var t = scaleTranslateRotate(r, 0, 0, _, v, g).apply(null, n(s, l)), S = scaleTranslateRotate(r, i - t[0], o - t[1], _, v, g);
		return p = rotateRadians(u, d, f), F = compose_default(n, S), I = compose_default(p, F), P = resample_default(F, N), U();
	}
	function U() {
		return L = R = null, z;
	}
	return function() {
		return n = t.apply(this, arguments), z.invert = n.invert && V, H();
	};
}
function conicProjection(t) {
	var n = 0, r = pi$2 / 3, i = projectionMutator(t), o = i(n, r);
	return o.parallels = function(t) {
		return arguments.length ? i(n = t[0] * radians$1, r = t[1] * radians$1) : [n * degrees$1, r * degrees$1];
	}, o;
}
function cylindricalEqualAreaRaw(t) {
	var n = cos$1(t);
	function r(t, r) {
		return [t * n, sin$1(r) / n];
	}
	return r.invert = function(t, r) {
		return [t / n, asin$1(r * n)];
	}, r;
}
function conicEqualAreaRaw(t, n) {
	var r = sin$1(t), i = (r + sin$1(n)) / 2;
	if (abs$1(i) < 1e-6) return cylindricalEqualAreaRaw(t);
	var o = 1 + r * (2 * i - r), s = sqrt$3(o) / i;
	function l(t, n) {
		var r = sqrt$3(o - 2 * i * sin$1(n)) / i;
		return [r * sin$1(t *= i), s - r * cos$1(t)];
	}
	return l.invert = function(t, n) {
		var r = s - n, l = atan2(t, abs$1(r)) * sign(r);
		return r * i < 0 && (l -= pi$2 * sign(t) * sign(r)), [l / i, asin$1((o - (t * t + r * r) * i * i) / (2 * i))];
	}, l;
}
function conicEqualArea_default() {
	return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}
function albers_default() {
	return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-.6, 38.7]);
}
function multiplex(t) {
	var n = t.length;
	return {
		point: function(r, i) {
			for (var o = -1; ++o < n;) t[o].point(r, i);
		},
		sphere: function() {
			for (var r = -1; ++r < n;) t[r].sphere();
		},
		lineStart: function() {
			for (var r = -1; ++r < n;) t[r].lineStart();
		},
		lineEnd: function() {
			for (var r = -1; ++r < n;) t[r].lineEnd();
		},
		polygonStart: function() {
			for (var r = -1; ++r < n;) t[r].polygonStart();
		},
		polygonEnd: function() {
			for (var r = -1; ++r < n;) t[r].polygonEnd();
		}
	};
}
function albersUsa_default() {
	var t, n, r = albers_default(), i, o = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), s, l = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), u, d, f = { point: function(t, n) {
		d = [t, n];
	} };
	function p(t) {
		var n = t[0], r = t[1];
		return d = null, (i.point(n, r), d) || (s.point(n, r), d) || (u.point(n, r), d);
	}
	p.invert = function(t) {
		var n = r.scale(), i = r.translate(), s = (t[0] - i[0]) / n, u = (t[1] - i[1]) / n;
		return (u >= .12 && u < .234 && s >= -.425 && s < -.214 ? o : u >= .166 && u < .234 && s >= -.214 && s < -.115 ? l : r).invert(t);
	}, p.stream = function(i) {
		return t && n === i ? t : t = multiplex([
			r.stream(n = i),
			o.stream(i),
			l.stream(i)
		]);
	}, p.precision = function(t) {
		return arguments.length ? (r.precision(t), o.precision(t), l.precision(t), g()) : r.precision();
	}, p.scale = function(t) {
		return arguments.length ? (r.scale(t), o.scale(t * .35), l.scale(t), p.translate(r.translate())) : r.scale();
	}, p.translate = function(t) {
		if (!arguments.length) return r.translate();
		var n = r.scale(), d = +t[0], p = +t[1];
		return i = r.translate(t).clipExtent([[d - .455 * n, p - .238 * n], [d + .455 * n, p + .238 * n]]).stream(f), s = o.translate([d - .307 * n, p + .201 * n]).clipExtent([[d - .425 * n + epsilon$2, p + .12 * n + epsilon$2], [d - .214 * n - epsilon$2, p + .234 * n - epsilon$2]]).stream(f), u = l.translate([d - .205 * n, p + .212 * n]).clipExtent([[d - .214 * n + epsilon$2, p + .166 * n + epsilon$2], [d - .115 * n - epsilon$2, p + .234 * n - epsilon$2]]).stream(f), g();
	}, p.fitExtent = function(t, n) {
		return fitExtent(p, t, n);
	}, p.fitSize = function(t, n) {
		return fitSize(p, t, n);
	}, p.fitWidth = function(t, n) {
		return fitWidth(p, t, n);
	}, p.fitHeight = function(t, n) {
		return fitHeight(p, t, n);
	};
	function g() {
		return t = n = null, p;
	}
	return p.scale(1070);
}
function azimuthalRaw(t) {
	return function(n, r) {
		var i = cos$1(n), o = cos$1(r), s = t(i * o);
		return s === Infinity ? [2, 0] : [s * o * sin$1(n), s * sin$1(r)];
	};
}
function azimuthalInvert(t) {
	return function(n, r) {
		var i = sqrt$3(n * n + r * r), o = t(i), s = sin$1(o), l = cos$1(o);
		return [atan2(n * s, i * l), asin$1(i && r * s / i)];
	};
}
var azimuthalEqualAreaRaw = azimuthalRaw(function(t) {
	return sqrt$3(2 / (1 + t));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(t) {
	return 2 * asin$1(t / 2);
});
function azimuthalEqualArea_default() {
	return projection$1(azimuthalEqualAreaRaw).scale(124.75).clipAngle(179.999);
}
var azimuthalEquidistantRaw = azimuthalRaw(function(t) {
	return (t = acos(t)) && t / sin$1(t);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(t) {
	return t;
});
function azimuthalEquidistant_default() {
	return projection$1(azimuthalEquidistantRaw).scale(79.4188).clipAngle(179.999);
}
function mercatorRaw(t, n) {
	return [t, log$4(tan((halfPi$1 + n) / 2))];
}
mercatorRaw.invert = function(t, n) {
	return [t, 2 * atan(exp$2(n)) - halfPi$1];
};
function mercator_default() {
	return mercatorProjection(mercatorRaw).scale(961 / tau$2);
}
function mercatorProjection(t) {
	var n = projection$1(t), r = n.center, i = n.scale, o = n.translate, s = n.clipExtent, l = null, u, d, f;
	n.scale = function(t) {
		return arguments.length ? (i(t), p()) : i();
	}, n.translate = function(t) {
		return arguments.length ? (o(t), p()) : o();
	}, n.center = function(t) {
		return arguments.length ? (r(t), p()) : r();
	}, n.clipExtent = function(t) {
		return arguments.length ? (t == null ? l = u = d = f = null : (l = +t[0][0], u = +t[0][1], d = +t[1][0], f = +t[1][1]), p()) : l == null ? null : [[l, u], [d, f]];
	};
	function p() {
		var r = pi$2 * i(), o = n(rotation_default(n.rotate()).invert([0, 0]));
		return s(l == null ? [[o[0] - r, o[1] - r], [o[0] + r, o[1] + r]] : t === mercatorRaw ? [[Math.max(o[0] - r, l), u], [Math.min(o[0] + r, d), f]] : [[l, Math.max(o[1] - r, u)], [d, Math.min(o[1] + r, f)]]);
	}
	return p();
}
function tany(t) {
	return tan((halfPi$1 + t) / 2);
}
function conicConformalRaw(t, n) {
	var r = cos$1(t), i = t === n ? sin$1(t) : log$4(r / cos$1(n)) / log$4(tany(n) / tany(t)), o = r * pow$3(tany(t), i) / i;
	if (!i) return mercatorRaw;
	function s(t, n) {
		o > 0 ? n < -halfPi$1 + 1e-6 && (n = -halfPi$1 + epsilon$2) : n > halfPi$1 - 1e-6 && (n = halfPi$1 - epsilon$2);
		var r = o / pow$3(tany(n), i);
		return [r * sin$1(i * t), o - r * cos$1(i * t)];
	}
	return s.invert = function(t, n) {
		var r = o - n, s = sign(i) * sqrt$3(t * t + r * r), l = atan2(t, abs$1(r)) * sign(r);
		return r * i < 0 && (l -= pi$2 * sign(t) * sign(r)), [l / i, 2 * atan(pow$3(o / s, 1 / i)) - halfPi$1];
	}, s;
}
function conicConformal_default() {
	return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}
function equirectangularRaw(t, n) {
	return [t, n];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
	return projection$1(equirectangularRaw).scale(152.63);
}
function conicEquidistantRaw(t, n) {
	var r = cos$1(t), i = t === n ? sin$1(t) : (r - cos$1(n)) / (n - t), o = r / i + t;
	if (abs$1(i) < 1e-6) return equirectangularRaw;
	function s(t, n) {
		var r = o - n, s = i * t;
		return [r * sin$1(s), o - r * cos$1(s)];
	}
	return s.invert = function(t, n) {
		var r = o - n, s = atan2(t, abs$1(r)) * sign(r);
		return r * i < 0 && (s -= pi$2 * sign(t) * sign(r)), [s / i, o - sign(i) * sqrt$3(t * t + r * r)];
	}, s;
}
function conicEquidistant_default() {
	return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}
var A1 = 1.340264, A2 = -.081106, A3 = 893e-6, A4 = .003796, M = sqrt$3(3) / 2, iterations = 12;
function equalEarthRaw(t, n) {
	var r = asin$1(M * sin$1(n)), i = r * r, o = i * i * i;
	return [t * cos$1(r) / (M * (A1 + 3 * A2 * i + o * (7 * A3 + 9 * A4 * i))), r * (A1 + A2 * i + o * (A3 + A4 * i))];
}
equalEarthRaw.invert = function(t, n) {
	for (var r = n, i = r * r, o = i * i * i, s = 0, l, u, d; s < iterations && (u = r * (A1 + A2 * i + o * (A3 + A4 * i)) - n, d = A1 + 3 * A2 * i + o * (7 * A3 + 9 * A4 * i), r -= l = u / d, i = r * r, o = i * i * i, !(abs$1(l) < 1e-12)); ++s);
	return [M * t * (A1 + 3 * A2 * i + o * (7 * A3 + 9 * A4 * i)) / cos$1(r), asin$1(sin$1(r) / M)];
};
function equalEarth_default() {
	return projection$1(equalEarthRaw).scale(177.158);
}
function gnomonicRaw(t, n) {
	var r = cos$1(n), i = cos$1(t) * r;
	return [r * sin$1(t) / i, sin$1(n) / i];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
	return projection$1(gnomonicRaw).scale(144.049).clipAngle(60);
}
function identity_default() {
	var t = 1, n = 0, r = 0, i = 1, o = 1, s = 0, l, u, d = null, f, p, g, _ = 1, v = 1, S = transformer$3({ point: function(t, n) {
		var r = A([t, n]);
		this.stream.point(r[0], r[1]);
	} }), T = identity_default$2, E, O;
	function k() {
		return _ = t * i, v = t * o, E = O = null, A;
	}
	function A(t) {
		var i = t[0] * _, o = t[1] * v;
		if (s) {
			var d = o * l - i * u;
			i = i * l + o * u, o = d;
		}
		return [i + n, o + r];
	}
	return A.invert = function(t) {
		var i = t[0] - n, o = t[1] - r;
		if (s) {
			var d = o * l + i * u;
			i = i * l - o * u, o = d;
		}
		return [i / _, o / v];
	}, A.stream = function(t) {
		return E && O === t ? E : E = S(T(O = t));
	}, A.postclip = function(t) {
		return arguments.length ? (T = t, d = f = p = g = null, k()) : T;
	}, A.clipExtent = function(t) {
		return arguments.length ? (T = t == null ? (d = f = p = g = null, identity_default$2) : clipRectangle(d = +t[0][0], f = +t[0][1], p = +t[1][0], g = +t[1][1]), k()) : d == null ? null : [[d, f], [p, g]];
	}, A.scale = function(n) {
		return arguments.length ? (t = +n, k()) : t;
	}, A.translate = function(t) {
		return arguments.length ? (n = +t[0], r = +t[1], k()) : [n, r];
	}, A.angle = function(t) {
		return arguments.length ? (s = t % 360 * radians$1, u = sin$1(s), l = cos$1(s), k()) : s * degrees$1;
	}, A.reflectX = function(t) {
		return arguments.length ? (i = t ? -1 : 1, k()) : i < 0;
	}, A.reflectY = function(t) {
		return arguments.length ? (o = t ? -1 : 1, k()) : o < 0;
	}, A.fitExtent = function(t, n) {
		return fitExtent(A, t, n);
	}, A.fitSize = function(t, n) {
		return fitSize(A, t, n);
	}, A.fitWidth = function(t, n) {
		return fitWidth(A, t, n);
	}, A.fitHeight = function(t, n) {
		return fitHeight(A, t, n);
	}, A;
}
function naturalEarth1Raw(t, n) {
	var r = n * n, i = r * r;
	return [t * (.8707 - .131979 * r + i * (-.013791 + i * (.003971 * r - .001529 * i))), n * (1.007226 + r * (.015085 + i * (-.044475 + .028874 * r - .005916 * i)))];
}
naturalEarth1Raw.invert = function(t, n) {
	var r = n, i = 25, o;
	do {
		var s = r * r, l = s * s;
		r -= o = (r * (1.007226 + s * (.015085 + l * (-.044475 + .028874 * s - .005916 * l))) - n) / (1.007226 + s * (.015085 * 3 + l * (-.044475 * 7 + .028874 * 9 * s - .005916 * 11 * l)));
	} while (abs$1(o) > 1e-6 && --i > 0);
	return [t / (.8707 + (s = r * r) * (-.131979 + s * (-.013791 + s * s * s * (.003971 - .001529 * s)))), r];
};
function naturalEarth1_default() {
	return projection$1(naturalEarth1Raw).scale(175.295);
}
function orthographicRaw(t, n) {
	return [cos$1(n) * sin$1(t), sin$1(n)];
}
orthographicRaw.invert = azimuthalInvert(asin$1);
function orthographic_default() {
	return projection$1(orthographicRaw).scale(249.5).clipAngle(90 + epsilon$2);
}
function stereographicRaw(t, n) {
	var r = cos$1(n), i = 1 + cos$1(t) * r;
	return [r * sin$1(t) / i, sin$1(n) / i];
}
stereographicRaw.invert = azimuthalInvert(function(t) {
	return 2 * atan(t);
});
function stereographic_default() {
	return projection$1(stereographicRaw).scale(250).clipAngle(142);
}
function transverseMercatorRaw(t, n) {
	return [log$4(tan((halfPi$1 + n) / 2)), -t];
}
transverseMercatorRaw.invert = function(t, n) {
	return [-n, 2 * atan(exp$2(t)) - halfPi$1];
};
function transverseMercator_default() {
	var t = mercatorProjection(transverseMercatorRaw), n = t.center, r = t.rotate;
	return t.center = function(t) {
		return arguments.length ? n([-t[1], t[0]]) : (t = n(), [t[1], -t[0]]);
	}, t.rotate = function(t) {
		return arguments.length ? r([
			t[0],
			t[1],
			t.length > 2 ? t[2] + 90 : 90
		]) : (t = r(), [
			t[0],
			t[1],
			t[2] - 90
		]);
	}, r([
		0,
		0,
		90
	]).scale(159.155);
}
function defaultSeparation$2(t, n) {
	return t.parent === n.parent ? 1 : 2;
}
function meanX(t) {
	return t.reduce(meanXReduce, 0) / t.length;
}
function meanXReduce(t, n) {
	return t + n.x;
}
function maxY(t) {
	return 1 + t.reduce(maxYReduce, 0);
}
function maxYReduce(t, n) {
	return Math.max(t, n.y);
}
function leafLeft(t) {
	for (var n; n = t.children;) t = n[0];
	return t;
}
function leafRight(t) {
	for (var n; n = t.children;) t = n[n.length - 1];
	return t;
}
function cluster_default() {
	var t = defaultSeparation$2, n = 1, r = 1, i = !1;
	function o(o) {
		var s, l = 0;
		o.eachAfter(function(n) {
			var r = n.children;
			r ? (n.x = meanX(r), n.y = maxY(r)) : (n.x = s ? l += t(n, s) : 0, n.y = 0, s = n);
		});
		var u = leafLeft(o), d = leafRight(o), f = u.x - t(u, d) / 2, p = d.x + t(d, u) / 2;
		return o.eachAfter(i ? function(t) {
			t.x = (t.x - o.x) * n, t.y = (o.y - t.y) * r;
		} : function(t) {
			t.x = (t.x - f) / (p - f) * n, t.y = (1 - (o.y ? t.y / o.y : 1)) * r;
		});
	}
	return o.separation = function(n) {
		return arguments.length ? (t = n, o) : t;
	}, o.size = function(t) {
		return arguments.length ? (i = !1, n = +t[0], r = +t[1], o) : i ? null : [n, r];
	}, o.nodeSize = function(t) {
		return arguments.length ? (i = !0, n = +t[0], r = +t[1], o) : i ? [n, r] : null;
	}, o;
}
var a = 1664525, c = 1013904223, m = 4294967296;
function lcg_default() {
	let t = 1;
	return () => (t = (a * t + c) % m) / m;
}
function array_default$1(t) {
	return typeof t == "object" && "length" in t ? t : Array.from(t);
}
function shuffle(t, n) {
	let r = t.length, i, o;
	for (; r;) o = n() * r-- | 0, i = t[r], t[r] = t[o], t[o] = i;
	return t;
}
function packEncloseRandom(t, n) {
	for (var r = 0, i = (t = shuffle(Array.from(t), n)).length, o = [], s, l; r < i;) s = t[r], l && enclosesWeak(l, s) ? ++r : (l = encloseBasis(o = extendBasis(o, s)), r = 0);
	return l;
}
function extendBasis(t, n) {
	var r, i;
	if (enclosesWeakAll(n, t)) return [n];
	for (r = 0; r < t.length; ++r) if (enclosesNot(n, t[r]) && enclosesWeakAll(encloseBasis2(t[r], n), t)) return [t[r], n];
	for (r = 0; r < t.length - 1; ++r) for (i = r + 1; i < t.length; ++i) if (enclosesNot(encloseBasis2(t[r], t[i]), n) && enclosesNot(encloseBasis2(t[r], n), t[i]) && enclosesNot(encloseBasis2(t[i], n), t[r]) && enclosesWeakAll(encloseBasis3(t[r], t[i], n), t)) return [
		t[r],
		t[i],
		n
	];
	throw Error();
}
function enclosesNot(t, n) {
	var r = t.r - n.r, i = n.x - t.x, o = n.y - t.y;
	return r < 0 || r * r < i * i + o * o;
}
function enclosesWeak(t, n) {
	var r = t.r - n.r + Math.max(t.r, n.r, 1) * 1e-9, i = n.x - t.x, o = n.y - t.y;
	return r > 0 && r * r > i * i + o * o;
}
function enclosesWeakAll(t, n) {
	for (var r = 0; r < n.length; ++r) if (!enclosesWeak(t, n[r])) return !1;
	return !0;
}
function encloseBasis(t) {
	switch (t.length) {
		case 1: return encloseBasis1(t[0]);
		case 2: return encloseBasis2(t[0], t[1]);
		case 3: return encloseBasis3(t[0], t[1], t[2]);
	}
}
function encloseBasis1(t) {
	return {
		x: t.x,
		y: t.y,
		r: t.r
	};
}
function encloseBasis2(t, n) {
	var r = t.x, i = t.y, o = t.r, s = n.x, l = n.y, u = n.r, d = s - r, f = l - i, p = u - o, g = Math.sqrt(d * d + f * f);
	return {
		x: (r + s + d / g * p) / 2,
		y: (i + l + f / g * p) / 2,
		r: (g + o + u) / 2
	};
}
function encloseBasis3(t, n, r) {
	var i = t.x, o = t.y, s = t.r, l = n.x, u = n.y, d = n.r, f = r.x, p = r.y, g = r.r, _ = i - l, v = i - f, S = o - u, T = o - p, E = d - s, O = g - s, k = i * i + o * o - s * s, A = k - l * l - u * u + d * d, j = k - f * f - p * p + g * g, N = v * S - _ * T, P = (S * j - T * A) / (N * 2) - i, F = (T * E - S * O) / N, I = (v * A - _ * j) / (N * 2) - o, L = (_ * O - v * E) / N, R = F * F + L * L - 1, z = 2 * (s + P * F + I * L), V = P * P + I * I - s * s, H = -(Math.abs(R) > 1e-6 ? (z + Math.sqrt(z * z - 4 * R * V)) / (2 * R) : V / z);
	return {
		x: i + P + F * H,
		y: o + I + L * H,
		r: H
	};
}
function place(t, n, r) {
	var i = t.x - n.x, o, s, l = t.y - n.y, u, d, f = i * i + l * l;
	f ? (s = n.r + r.r, s *= s, d = t.r + r.r, d *= d, s > d ? (o = (f + d - s) / (2 * f), u = Math.sqrt(Math.max(0, d / f - o * o)), r.x = t.x - o * i - u * l, r.y = t.y - o * l + u * i) : (o = (f + s - d) / (2 * f), u = Math.sqrt(Math.max(0, s / f - o * o)), r.x = n.x + o * i - u * l, r.y = n.y + o * l + u * i)) : (r.x = n.x + r.r, r.y = n.y);
}
function intersects(t, n) {
	var r = t.r + n.r - 1e-6, i = n.x - t.x, o = n.y - t.y;
	return r > 0 && r * r > i * i + o * o;
}
function score(t) {
	var n = t._, r = t.next._, i = n.r + r.r, o = (n.x * r.r + r.x * n.r) / i, s = (n.y * r.r + r.y * n.r) / i;
	return o * o + s * s;
}
function Node$1(t) {
	this._ = t, this.next = null, this.previous = null;
}
function packSiblingsRandom(t, n) {
	if (!(s = (t = array_default$1(t)).length)) return 0;
	var r = t[0], i, o, s, l, u, d, f, p, g, _;
	if (r.x = 0, r.y = 0, !(s > 1)) return r.r;
	if (i = t[1], r.x = -i.r, i.x = r.r, i.y = 0, !(s > 2)) return r.r + i.r;
	place(i, r, o = t[2]), r = new Node$1(r), i = new Node$1(i), o = new Node$1(o), r.next = o.previous = i, i.next = r.previous = o, o.next = i.previous = r;
	pack: for (d = 3; d < s; ++d) {
		place(r._, i._, o = t[d]), o = new Node$1(o), f = i.next, p = r.previous, g = i._.r, _ = r._.r;
		do
			if (g <= _) {
				if (intersects(f._, o._)) {
					i = f, r.next = i, i.previous = r, --d;
					continue pack;
				}
				g += f._.r, f = f.next;
			} else {
				if (intersects(p._, o._)) {
					r = p, r.next = i, i.previous = r, --d;
					continue pack;
				}
				_ += p._.r, p = p.previous;
			}
		while (f !== p.next);
		for (o.previous = r, o.next = i, r.next = i.previous = i = o, l = score(r); (o = o.next) !== i;) (u = score(o)) < l && (r = o, l = u);
		i = r.next;
	}
	for (r = [i._], o = i; (o = o.next) !== i;) r.push(o._);
	for (o = packEncloseRandom(r, n), d = 0; d < s; ++d) r = t[d], r.x -= o.x, r.y -= o.y;
	return o.r;
}
function defaultRadius(t) {
	return Math.sqrt(t.value);
}
function pack_default() {
	var t = null, n = 1, r = 1, i = constantZero;
	function o(o) {
		let s = lcg_default();
		return o.x = n / 2, o.y = r / 2, t ? o.eachBefore(radiusLeaf(t)).eachAfter(packChildrenRandom(i, .5, s)).eachBefore(translateChild(1)) : o.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, s)).eachAfter(packChildrenRandom(i, o.r / Math.min(n, r), s)).eachBefore(translateChild(Math.min(n, r) / (2 * o.r))), o;
	}
	return o.radius = function(n) {
		return arguments.length ? (t = optional(n), o) : t;
	}, o.size = function(t) {
		return arguments.length ? (n = +t[0], r = +t[1], o) : [n, r];
	}, o.padding = function(t) {
		return arguments.length ? (i = typeof t == "function" ? t : constant_default$1(+t), o) : i;
	}, o;
}
function radiusLeaf(t) {
	return function(n) {
		n.children || (n.r = Math.max(0, +t(n) || 0));
	};
}
function packChildrenRandom(t, n, r) {
	return function(i) {
		if (o = i.children) {
			var o, s, l = o.length, u = t(i) * n || 0, d;
			if (u) for (s = 0; s < l; ++s) o[s].r += u;
			if (d = packSiblingsRandom(o, r), u) for (s = 0; s < l; ++s) o[s].r -= u;
			i.r = d + u;
		}
	};
}
function translateChild(t) {
	return function(n) {
		var r = n.parent;
		n.r *= t, r && (n.x = r.x + t * n.x, n.y = r.y + t * n.y);
	};
}
function partition_default() {
	var t = 1, n = 1, r = 0, i = !1;
	function o(o) {
		var l = o.height + 1;
		return o.x0 = o.y0 = r, o.x1 = t, o.y1 = n / l, o.eachBefore(s(n, l)), i && o.eachBefore(round_default$1), o;
	}
	function s(t, n) {
		return function(i) {
			i.children && dice_default(i, i.x0, t * (i.depth + 1) / n, i.x1, t * (i.depth + 2) / n);
			var o = i.x0, s = i.y0, l = i.x1 - r, u = i.y1 - r;
			l < o && (o = l = (o + l) / 2), u < s && (s = u = (s + u) / 2), i.x0 = o, i.y0 = s, i.x1 = l, i.y1 = u;
		};
	}
	return o.round = function(t) {
		return arguments.length ? (i = !!t, o) : i;
	}, o.size = function(r) {
		return arguments.length ? (t = +r[0], n = +r[1], o) : [t, n];
	}, o.padding = function(t) {
		return arguments.length ? (r = +t, o) : r;
	}, o;
}
var preroot = { depth: -1 }, ambiguous = {}, imputed = {};
function defaultId(t) {
	return t.id;
}
function defaultParentId(t) {
	return t.parentId;
}
function stratify_default() {
	var t = defaultId, n = defaultParentId, r;
	function i(i) {
		var o = Array.from(i), s = t, l = n, u, d, f, p, g, _, v, S, T = /* @__PURE__ */ new Map();
		if (r != null) {
			let t = o.map((t, n) => normalize$1(r(t, n, i))), n = t.map(parentof), u = new Set(t).add("");
			for (let r of n) u.has(r) || (u.add(r), t.push(r), n.push(parentof(r)), o.push(imputed));
			s = (n, r) => t[r], l = (t, r) => n[r];
		}
		for (f = 0, u = o.length; f < u; ++f) d = o[f], _ = o[f] = new Node(d), (v = s(d, f, i)) != null && (v += "") && (S = _.id = v, T.set(S, T.has(S) ? ambiguous : _)), (v = l(d, f, i)) != null && (v += "") && (_.parent = v);
		for (f = 0; f < u; ++f) if (_ = o[f], v = _.parent) {
			if (g = T.get(v), !g) throw Error("missing: " + v);
			if (g === ambiguous) throw Error("ambiguous: " + v);
			g.children ? g.children.push(_) : g.children = [_], _.parent = g;
		} else {
			if (p) throw Error("multiple roots");
			p = _;
		}
		if (!p) throw Error("no root");
		if (r != null) {
			for (; p.data === imputed && p.children.length === 1;) p = p.children[0], --u;
			for (let t = o.length - 1; t >= 0 && (_ = o[t], _.data === imputed); --t) _.data = null;
		}
		if (p.parent = preroot, p.eachBefore(function(t) {
			t.depth = t.parent.depth + 1, --u;
		}).eachBefore(computeHeight), p.parent = null, u > 0) throw Error("cycle");
		return p;
	}
	return i.id = function(n) {
		return arguments.length ? (t = optional(n), i) : t;
	}, i.parentId = function(t) {
		return arguments.length ? (n = optional(t), i) : n;
	}, i.path = function(t) {
		return arguments.length ? (r = optional(t), i) : r;
	}, i;
}
function normalize$1(t) {
	t = `${t}`;
	let n = t.length;
	return slash(t, n - 1) && !slash(t, n - 2) && (t = t.slice(0, -1)), t[0] === "/" ? t : `/${t}`;
}
function parentof(t) {
	let n = t.length;
	if (n < 2) return "";
	for (; --n > 1 && !slash(t, n););
	return t.slice(0, n);
}
function slash(t, n) {
	if (t[n] === "/") {
		let r = 0;
		for (; n > 0 && t[--n] === "\\";) ++r;
		if (!(r & 1)) return !0;
	}
	return !1;
}
function defaultSeparation$1(t, n) {
	return t.parent === n.parent ? 1 : 2;
}
function nextLeft(t) {
	var n = t.children;
	return n ? n[0] : t.t;
}
function nextRight(t) {
	var n = t.children;
	return n ? n[n.length - 1] : t.t;
}
function moveSubtree(t, n, r) {
	var i = r / (n.i - t.i);
	n.c -= i, n.s += r, t.c += i, n.z += r, n.m += r;
}
function executeShifts(t) {
	for (var n = 0, r = 0, i = t.children, o = i.length, s; --o >= 0;) s = i[o], s.z += n, s.m += n, n += s.s + (r += s.c);
}
function nextAncestor(t, n, r) {
	return t.a.parent === n.parent ? t.a : r;
}
function TreeNode(t, n) {
	this._ = t, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = n;
}
TreeNode.prototype = Object.create(Node.prototype);
function treeRoot(t) {
	for (var n = new TreeNode(t, 0), r, i = [n], o, s, l, u; r = i.pop();) if (s = r._.children) for (r.children = Array(u = s.length), l = u - 1; l >= 0; --l) i.push(o = r.children[l] = new TreeNode(s[l], l)), o.parent = r;
	return (n.parent = new TreeNode(null, 0)).children = [n], n;
}
function tree_default() {
	var t = defaultSeparation$1, n = 1, r = 1, i = null;
	function o(o) {
		var u = treeRoot(o);
		if (u.eachAfter(s), u.parent.m = -u.z, u.eachBefore(l), i) o.eachBefore(d);
		else {
			var f = o, p = o, g = o;
			o.eachBefore(function(t) {
				t.x < f.x && (f = t), t.x > p.x && (p = t), t.depth > g.depth && (g = t);
			});
			var _ = f === p ? 1 : t(f, p) / 2, v = _ - f.x, S = n / (p.x + _ + v), T = r / (g.depth || 1);
			o.eachBefore(function(t) {
				t.x = (t.x + v) * S, t.y = t.depth * T;
			});
		}
		return o;
	}
	function s(n) {
		var r = n.children, i = n.parent.children, o = n.i ? i[n.i - 1] : null;
		if (r) {
			executeShifts(n);
			var s = (r[0].z + r[r.length - 1].z) / 2;
			o ? (n.z = o.z + t(n._, o._), n.m = n.z - s) : n.z = s;
		} else o && (n.z = o.z + t(n._, o._));
		n.parent.A = u(n, o, n.parent.A || i[0]);
	}
	function l(t) {
		t._.x = t.z + t.parent.m, t.m += t.parent.m;
	}
	function u(n, r, i) {
		if (r) {
			for (var o = n, s = n, l = r, u = o.parent.children[0], d = o.m, f = s.m, p = l.m, g = u.m, _; l = nextRight(l), o = nextLeft(o), l && o;) u = nextLeft(u), s = nextRight(s), s.a = n, _ = l.z + p - o.z - d + t(l._, o._), _ > 0 && (moveSubtree(nextAncestor(l, n, i), n, _), d += _, f += _), p += l.m, d += o.m, g += u.m, f += s.m;
			l && !nextRight(s) && (s.t = l, s.m += p - f), o && !nextLeft(u) && (u.t = o, u.m += d - g, i = n);
		}
		return i;
	}
	function d(t) {
		t.x *= n, t.y = t.depth * r;
	}
	return o.separation = function(n) {
		return arguments.length ? (t = n, o) : t;
	}, o.size = function(t) {
		return arguments.length ? (i = !1, n = +t[0], r = +t[1], o) : i ? null : [n, r];
	}, o.nodeSize = function(t) {
		return arguments.length ? (i = !0, n = +t[0], r = +t[1], o) : i ? [n, r] : null;
	}, o;
}
function binary_default(t, n, r, i, o) {
	var s = t.children, l, u = s.length, d, f = Array(u + 1);
	for (f[0] = d = l = 0; l < u; ++l) f[l + 1] = d += s[l].value;
	p(0, u, t.value, n, r, i, o);
	function p(t, n, r, i, o, l, u) {
		if (t >= n - 1) {
			var d = s[t];
			d.x0 = i, d.y0 = o, d.x1 = l, d.y1 = u;
			return;
		}
		for (var g = f[t], _ = r / 2 + g, v = t + 1, S = n - 1; v < S;) {
			var T = v + S >>> 1;
			f[T] < _ ? v = T + 1 : S = T;
		}
		_ - f[v - 1] < f[v] - _ && t + 1 < v && --v;
		var E = f[v] - g, O = r - E;
		if (l - i > u - o) {
			var k = r ? (i * O + l * E) / r : l;
			p(t, v, E, i, o, k, u), p(v, n, O, k, o, l, u);
		} else {
			var A = r ? (o * O + u * E) / r : u;
			p(t, v, E, i, o, l, A), p(v, n, O, i, A, l, u);
		}
	}
}
function sliceDice_default(t, n, r, i, o) {
	(t.depth & 1 ? slice_default : dice_default)(t, n, r, i, o);
}
var resquarify_default = (function t(n) {
	function r(t, r, i, o, s) {
		if ((l = t._squarify) && l.ratio === n) for (var l, u, d, f, p = -1, g, _ = l.length, v = t.value; ++p < _;) {
			for (u = l[p], d = u.children, f = u.value = 0, g = d.length; f < g; ++f) u.value += d[f].value;
			u.dice ? dice_default(u, r, i, o, v ? i += (s - i) * u.value / v : s) : slice_default(u, r, i, v ? r += (o - r) * u.value / v : o, s), v -= u.value;
		}
		else t._squarify = l = squarifyRatio(n, t, r, i, o, s), l.ratio = n;
	}
	return r.ratio = function(n) {
		return t((n = +n) > 1 ? n : 1);
	}, r;
})(phi);
function identity$2(t) {
	var n;
	function r(t) {
		return t == null || isNaN(t = +t) ? n : t;
	}
	return r.invert = r, r.domain = r.range = function(n) {
		return arguments.length ? (t = Array.from(n, number$4), r) : t.slice();
	}, r.unknown = function(t) {
		return arguments.length ? (n = t, r) : n;
	}, r.copy = function() {
		return identity$2(t).unknown(n);
	}, t = arguments.length ? Array.from(t, number$4) : [0, 1], linearish(r);
}
function transformLog(t) {
	return Math.log(t);
}
function transformExp(t) {
	return Math.exp(t);
}
function transformLogn(t) {
	return -Math.log(-t);
}
function transformExpn(t) {
	return -Math.exp(-t);
}
function pow10(t) {
	return isFinite(t) ? +("1e" + t) : t < 0 ? 0 : t;
}
function powp(t) {
	return t === 10 ? pow10 : t === Math.E ? Math.exp : (n) => t ** +n;
}
function logp(t) {
	return t === Math.E ? Math.log : t === 10 && Math.log10 || t === 2 && Math.log2 || (t = Math.log(t), (n) => Math.log(n) / t);
}
function reflect(t) {
	return (n, r) => -t(-n, r);
}
function loggish(t) {
	let n = t(transformLog, transformExp), r = n.domain, i = 10, o, s;
	function l() {
		return o = logp(i), s = powp(i), r()[0] < 0 ? (o = reflect(o), s = reflect(s), t(transformLogn, transformExpn)) : t(transformLog, transformExp), n;
	}
	return n.base = function(t) {
		return arguments.length ? (i = +t, l()) : i;
	}, n.domain = function(t) {
		return arguments.length ? (r(t), l()) : r();
	}, n.ticks = (t) => {
		let n = r(), l = n[0], u = n[n.length - 1], d = u < l;
		d && ([l, u] = [u, l]);
		let f = o(l), p = o(u), g, _, v = t == null ? 10 : +t, S = [];
		if (!(i % 1) && p - f < v) {
			if (f = Math.floor(f), p = Math.ceil(p), l > 0) {
				for (; f <= p; ++f) for (g = 1; g < i; ++g) if (_ = f < 0 ? g / s(-f) : g * s(f), !(_ < l)) {
					if (_ > u) break;
					S.push(_);
				}
			} else for (; f <= p; ++f) for (g = i - 1; g >= 1; --g) if (_ = f > 0 ? g / s(-f) : g * s(f), !(_ < l)) {
				if (_ > u) break;
				S.push(_);
			}
			S.length * 2 < v && (S = ticks(l, u, v));
		} else S = ticks(f, p, Math.min(p - f, v)).map(s);
		return d ? S.reverse() : S;
	}, n.tickFormat = (t, r) => {
		if (t ??= 10, r ??= i === 10 ? "s" : ",", typeof r != "function" && (!(i % 1) && (r = formatSpecifier(r)).precision == null && (r.trim = !0), r = format$3(r)), t === Infinity) return r;
		let l = Math.max(1, i * t / n.ticks().length);
		return (t) => {
			let n = t / s(Math.round(o(t)));
			return n * i < i - .5 && (n *= i), n <= l ? r(t) : "";
		};
	}, n.nice = () => r(nice$1(r(), {
		floor: (t) => s(Math.floor(o(t))),
		ceil: (t) => s(Math.ceil(o(t)))
	})), n;
}
function log$3() {
	let t = loggish(transformer$2()).domain([1, 10]);
	return t.copy = () => copy$2(t, log$3()).base(t.base()), initRange.apply(t, arguments), t;
}
function transformSymlog(t) {
	return function(n) {
		return Math.sign(n) * Math.log1p(Math.abs(n / t));
	};
}
function transformSymexp(t) {
	return function(n) {
		return Math.sign(n) * Math.expm1(Math.abs(n)) * t;
	};
}
function symlogish(t) {
	var n = 1, r = t(transformSymlog(n), transformSymexp(n));
	return r.constant = function(r) {
		return arguments.length ? t(transformSymlog(n = +r), transformSymexp(n)) : n;
	}, linearish(r);
}
function symlog$1() {
	var t = symlogish(transformer$2());
	return t.copy = function() {
		return copy$2(t, symlog$1()).constant(t.constant());
	}, initRange.apply(t, arguments);
}
function transformPow(t) {
	return function(n) {
		return n < 0 ? -((-n) ** +t) : n ** +t;
	};
}
function transformSqrt(t) {
	return t < 0 ? -Math.sqrt(-t) : Math.sqrt(t);
}
function transformSquare(t) {
	return t < 0 ? -t * t : t * t;
}
function powish(t) {
	var n = t(identity$1, identity$1), r = 1;
	function i() {
		return r === 1 ? t(identity$1, identity$1) : r === .5 ? t(transformSqrt, transformSquare) : t(transformPow(r), transformPow(1 / r));
	}
	return n.exponent = function(t) {
		return arguments.length ? (r = +t, i()) : r;
	}, linearish(n);
}
function pow$2() {
	var t = powish(transformer$2());
	return t.copy = function() {
		return copy$2(t, pow$2()).exponent(t.exponent());
	}, initRange.apply(t, arguments), t;
}
function sqrt$2() {
	return pow$2.apply(null, arguments).exponent(.5);
}
function quantile$1() {
	var t = [], n = [], r = [], i;
	function o() {
		var i = 0, o = Math.max(1, n.length);
		for (r = Array(o - 1); ++i < o;) r[i - 1] = quantileSorted(t, i / o);
		return s;
	}
	function s(t) {
		return t == null || isNaN(t = +t) ? i : n[bisect_default(r, t)];
	}
	return s.invertExtent = function(i) {
		var o = n.indexOf(i);
		return o < 0 ? [NaN, NaN] : [o > 0 ? r[o - 1] : t[0], o < r.length ? r[o] : t[t.length - 1]];
	}, s.domain = function(n) {
		if (!arguments.length) return t.slice();
		t = [];
		for (let r of n) r != null && !isNaN(r = +r) && t.push(r);
		return t.sort(ascending$2), o();
	}, s.range = function(t) {
		return arguments.length ? (n = Array.from(t), o()) : n.slice();
	}, s.unknown = function(t) {
		return arguments.length ? (i = t, s) : i;
	}, s.quantiles = function() {
		return r.slice();
	}, s.copy = function() {
		return quantile$1().domain(t).range(n).unknown(i);
	}, initRange.apply(s, arguments);
}
function quantize$1() {
	var t = 0, n = 1, r = 1, i = [.5], o = [0, 1], s;
	function l(t) {
		return t != null && t <= t ? o[bisect_default(i, t, 0, r)] : s;
	}
	function u() {
		var o = -1;
		for (i = Array(r); ++o < r;) i[o] = ((o + 1) * n - (o - r) * t) / (r + 1);
		return l;
	}
	return l.domain = function(r) {
		return arguments.length ? ([t, n] = r, t = +t, n = +n, u()) : [t, n];
	}, l.range = function(t) {
		return arguments.length ? (r = (o = Array.from(t)).length - 1, u()) : o.slice();
	}, l.invertExtent = function(s) {
		var l = o.indexOf(s);
		return l < 0 ? [NaN, NaN] : l < 1 ? [t, i[0]] : l >= r ? [i[r - 1], n] : [i[l - 1], i[l]];
	}, l.unknown = function(t) {
		return arguments.length && (s = t), l;
	}, l.thresholds = function() {
		return i.slice();
	}, l.copy = function() {
		return quantize$1().domain([t, n]).range(o).unknown(s);
	}, initRange.apply(linearish(l), arguments);
}
function threshold() {
	var t = [.5], n = [0, 1], r, i = 1;
	function o(o) {
		return o != null && o <= o ? n[bisect_default(t, o, 0, i)] : r;
	}
	return o.domain = function(r) {
		return arguments.length ? (t = Array.from(r), i = Math.min(t.length, n.length - 1), o) : t.slice();
	}, o.range = function(r) {
		return arguments.length ? (n = Array.from(r), i = Math.min(t.length, n.length - 1), o) : n.slice();
	}, o.invertExtent = function(r) {
		var i = n.indexOf(r);
		return [t[i - 1], t[i]];
	}, o.unknown = function(t) {
		return arguments.length ? (r = t, o) : r;
	}, o.copy = function() {
		return threshold().domain(t).range(n).unknown(r);
	}, initRange.apply(o, arguments);
}
function utcTime() {
	return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat$1).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function transformer$1() {
	var t = 0, n = 1, r, i, o, s, l = identity$1, u = !1, d;
	function f(t) {
		return t == null || isNaN(t = +t) ? d : l(o === 0 ? .5 : (t = (s(t) - r) * o, u ? Math.max(0, Math.min(1, t)) : t));
	}
	f.domain = function(l) {
		return arguments.length ? ([t, n] = l, r = s(t = +t), i = s(n = +n), o = r === i ? 0 : 1 / (i - r), f) : [t, n];
	}, f.clamp = function(t) {
		return arguments.length ? (u = !!t, f) : u;
	}, f.interpolator = function(t) {
		return arguments.length ? (l = t, f) : l;
	};
	function p(t) {
		return function(n) {
			var r, i;
			return arguments.length ? ([r, i] = n, l = t(r, i), f) : [l(0), l(1)];
		};
	}
	return f.range = p(value_default), f.rangeRound = p(round_default), f.unknown = function(t) {
		return arguments.length ? (d = t, f) : d;
	}, function(l) {
		return s = l, r = l(t), i = l(n), o = r === i ? 0 : 1 / (i - r), f;
	};
}
function copy$1(t, n) {
	return n.domain(t.domain()).interpolator(t.interpolator()).clamp(t.clamp()).unknown(t.unknown());
}
function sequential() {
	var t = linearish(transformer$1()(identity$1));
	return t.copy = function() {
		return copy$1(t, sequential());
	}, initInterpolator.apply(t, arguments);
}
function sequentialLog() {
	var t = loggish(transformer$1()).domain([1, 10]);
	return t.copy = function() {
		return copy$1(t, sequentialLog()).base(t.base());
	}, initInterpolator.apply(t, arguments);
}
function sequentialSymlog() {
	var t = symlogish(transformer$1());
	return t.copy = function() {
		return copy$1(t, sequentialSymlog()).constant(t.constant());
	}, initInterpolator.apply(t, arguments);
}
function sequentialPow() {
	var t = powish(transformer$1());
	return t.copy = function() {
		return copy$1(t, sequentialPow()).exponent(t.exponent());
	}, initInterpolator.apply(t, arguments);
}
function sequentialSqrt() {
	return sequentialPow.apply(null, arguments).exponent(.5);
}
function transformer() {
	var t = 0, n = .5, r = 1, i = 1, o, s, l, u, d, f = identity$1, p, g = !1, _;
	function v(t) {
		return isNaN(t = +t) ? _ : (t = .5 + ((t = +p(t)) - s) * (i * t < i * s ? u : d), f(g ? Math.max(0, Math.min(1, t)) : t));
	}
	v.domain = function(f) {
		return arguments.length ? ([t, n, r] = f, o = p(t = +t), s = p(n = +n), l = p(r = +r), u = o === s ? 0 : .5 / (s - o), d = s === l ? 0 : .5 / (l - s), i = s < o ? -1 : 1, v) : [
			t,
			n,
			r
		];
	}, v.clamp = function(t) {
		return arguments.length ? (g = !!t, v) : g;
	}, v.interpolator = function(t) {
		return arguments.length ? (f = t, v) : f;
	};
	function S(t) {
		return function(n) {
			var r, i, o;
			return arguments.length ? ([r, i, o] = n, f = piecewise(t, [
				r,
				i,
				o
			]), v) : [
				f(0),
				f(.5),
				f(1)
			];
		};
	}
	return v.range = S(value_default), v.rangeRound = S(round_default), v.unknown = function(t) {
		return arguments.length ? (_ = t, v) : _;
	}, function(f) {
		return p = f, o = f(t), s = f(n), l = f(r), u = o === s ? 0 : .5 / (s - o), d = s === l ? 0 : .5 / (l - s), i = s < o ? -1 : 1, v;
	};
}
function diverging() {
	var t = linearish(transformer()(identity$1));
	return t.copy = function() {
		return copy$1(t, diverging());
	}, initInterpolator.apply(t, arguments);
}
function divergingLog() {
	var t = loggish(transformer()).domain([
		.1,
		1,
		10
	]);
	return t.copy = function() {
		return copy$1(t, divergingLog()).base(t.base());
	}, initInterpolator.apply(t, arguments);
}
function divergingSymlog() {
	var t = symlogish(transformer());
	return t.copy = function() {
		return copy$1(t, divergingSymlog()).constant(t.constant());
	}, initInterpolator.apply(t, arguments);
}
function divergingPow() {
	var t = powish(transformer());
	return t.copy = function() {
		return copy$1(t, divergingPow()).exponent(t.exponent());
	}, initInterpolator.apply(t, arguments);
}
function divergingSqrt() {
	return divergingPow.apply(null, arguments).exponent(.5);
}
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"), Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"), Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"), observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0"), Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"), Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"), Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"), Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"), Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"), Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
function area_default$1(t, n, r) {
	var i = null, o = constant_default(!0), s = null, l = linear_default, u = null, d = withPath(f);
	t = typeof t == "function" ? t : t === void 0 ? x$1 : constant_default(+t), n = typeof n == "function" ? n : constant_default(n === void 0 ? 0 : +n), r = typeof r == "function" ? r : r === void 0 ? y$1 : constant_default(+r);
	function f(f) {
		var p, g, _, v = (f = array_default(f)).length, S, T = !1, E, O = Array(v), k = Array(v);
		for (s ?? (u = l(E = d())), p = 0; p <= v; ++p) {
			if (!(p < v && o(S = f[p], p, f)) === T) if (T = !T) g = p, u.areaStart(), u.lineStart();
			else {
				for (u.lineEnd(), u.lineStart(), _ = p - 1; _ >= g; --_) u.point(O[_], k[_]);
				u.lineEnd(), u.areaEnd();
			}
			T && (O[p] = +t(S, p, f), k[p] = +n(S, p, f), u.point(i ? +i(S, p, f) : O[p], r ? +r(S, p, f) : k[p]));
		}
		if (E) return u = null, E + "" || null;
	}
	function p() {
		return line_default().defined(o).curve(l).context(s);
	}
	return f.x = function(n) {
		return arguments.length ? (t = typeof n == "function" ? n : constant_default(+n), i = null, f) : t;
	}, f.x0 = function(n) {
		return arguments.length ? (t = typeof n == "function" ? n : constant_default(+n), f) : t;
	}, f.x1 = function(t) {
		return arguments.length ? (i = t == null ? null : typeof t == "function" ? t : constant_default(+t), f) : i;
	}, f.y = function(t) {
		return arguments.length ? (n = typeof t == "function" ? t : constant_default(+t), r = null, f) : n;
	}, f.y0 = function(t) {
		return arguments.length ? (n = typeof t == "function" ? t : constant_default(+t), f) : n;
	}, f.y1 = function(t) {
		return arguments.length ? (r = t == null ? null : typeof t == "function" ? t : constant_default(+t), f) : r;
	}, f.lineX0 = f.lineY0 = function() {
		return p().x(t).y(n);
	}, f.lineY1 = function() {
		return p().x(t).y(r);
	}, f.lineX1 = function() {
		return p().x(i).y(n);
	}, f.defined = function(t) {
		return arguments.length ? (o = typeof t == "function" ? t : constant_default(!!t), f) : o;
	}, f.curve = function(t) {
		return arguments.length ? (l = t, s != null && (u = l(s)), f) : l;
	}, f.context = function(t) {
		return arguments.length ? (t == null ? s = u = null : u = l(s = t), f) : s;
	}, f;
}
var circle_default = { draw(t, n) {
	let r = sqrt$1(n / pi$1);
	t.moveTo(r, 0), t.arc(0, 0, r, 0, tau$1);
} };
function Symbol$1(t, n) {
	let r = null, i = withPath(o);
	t = typeof t == "function" ? t : constant_default(t || circle_default), n = typeof n == "function" ? n : constant_default(n === void 0 ? 64 : +n);
	function o() {
		let o;
		if (r ||= o = i(), t.apply(this, arguments).draw(r, +n.apply(this, arguments)), o) return r = null, o + "" || null;
	}
	return o.type = function(n) {
		return arguments.length ? (t = typeof n == "function" ? n : constant_default(n), o) : t;
	}, o.size = function(t) {
		return arguments.length ? (n = typeof t == "function" ? t : constant_default(+t), o) : n;
	}, o.context = function(t) {
		return arguments.length ? (r = t ?? null, o) : r;
	}, o;
}
init_dist$1();
var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;
function stringify(t, n = {}) {
	let r = JSON.stringify([1], void 0, n.indent === void 0 ? 2 : n.indent).slice(2, -3), i = r === "" ? Infinity : n.maxLength === void 0 ? 80 : n.maxLength, { replacer: o } = n;
	return (function t(n, s, l) {
		n && typeof n.toJSON == "function" && (n = n.toJSON());
		let u = JSON.stringify(n, o);
		if (u === void 0) return u;
		let d = i - s.length - l;
		if (u.length <= d) {
			let t = u.replace(stringOrChar, (t, n) => n || `${t} `);
			if (t.length <= d) return t;
		}
		if (o != null && (n = JSON.parse(u), o = void 0), typeof n == "object" && n) {
			let i = s + r, o = [], l = 0, u, d;
			if (Array.isArray(n)) {
				u = "[", d = "]";
				let { length: r } = n;
				for (; l < r; l++) o.push(t(n[l], i, l === r - 1 ? 0 : 1) || "null");
			} else {
				u = "{", d = "}";
				let r = Object.keys(n), { length: s } = r;
				for (; l < s; l++) {
					let u = r[l], d = `${JSON.stringify(u)}: `, f = t(n[u], i, d.length + (l === s - 1 ? 0 : 1));
					f !== void 0 && o.push(d + f);
				}
			}
			if (o.length > 0) return [
				u,
				r + o.join(`,\n${i}`),
				d
			].join(`\n${s}`);
		}
		return u;
	})(t, "", 0);
}
function accessor(t, n, r) {
	return t.fields = n || [], t.fname = r, t;
}
function accessorName(t) {
	return t == null ? null : t.fname;
}
function accessorFields(t) {
	return t == null ? null : t.fields;
}
function getter$1(t) {
	return t.length === 1 ? get1(t[0]) : getN(t);
}
var get1 = (t) => function(n) {
	return n[t];
}, getN = (t) => {
	let n = t.length;
	return function(r) {
		for (let i = 0; i < n; ++i) r = r[t[i]];
		return r;
	};
};
function error$1(t) {
	throw Error(t);
}
function splitAccessPath(t) {
	let n = [], r = t.length, i = null, o = 0, s = "", l, u, d;
	t += "";
	function f() {
		n.push(s + t.substring(l, u)), s = "", l = u + 1;
	}
	for (l = u = 0; u < r; ++u) if (d = t[u], d === "\\") s += t.substring(l, u++), l = u;
	else if (d === i) f(), i = null, o = -1;
	else if (i) continue;
	else l === o && d === "\"" || l === o && d === "'" ? (l = u + 1, i = d) : d === "." && !o ? u > l ? f() : l = u + 1 : d === "[" ? (u > l && f(), o = l = u + 1) : d === "]" && (o || error$1("Access path missing open bracket: " + t), o > 0 && f(), o = 0, l = u + 1);
	return o && error$1("Access path missing closing bracket: " + t), i && error$1("Access path missing closing quote: " + t), u > l && (u++, f()), n;
}
function field$1(t, n, r) {
	let i = splitAccessPath(t);
	return t = i.length === 1 ? i[0] : t, accessor((r && r.get || getter$1)(i), [t], n || t);
}
var id = field$1("id"), identity = accessor((t) => t, [], "identity"), zero$2 = accessor(() => 0, [], "zero"), one$1 = accessor(() => 1, [], "one"), truthy = accessor(() => !0, [], "true"), falsy = accessor(() => !1, [], "false"), DisallowedObjectProperties = new Set([...Object.getOwnPropertyNames(Object.prototype).filter((t) => typeof Object.prototype[t] == "function"), "__proto__"]);
function log$1$1(t, n, r) {
	let i = [n].concat([].slice.call(r));
	console[t].apply(console, i);
}
function logger(t, n, r = log$1$1) {
	let i = t || 0;
	return {
		level(t) {
			return arguments.length ? (i = +t, this) : i;
		},
		error() {
			return i >= 1 && r(n || "error", "ERROR", arguments), this;
		},
		warn() {
			return i >= 2 && r(n || "warn", "WARN", arguments), this;
		},
		info() {
			return i >= 3 && r(n || "log", "INFO", arguments), this;
		},
		debug() {
			return i >= 4 && r(n || "log", "DEBUG", arguments), this;
		}
	};
}
var isArray = Array.isArray;
function isObject(t) {
	return t === Object(t);
}
var isLegalKey = (t) => t !== "__proto__";
function mergeConfig(...t) {
	return t.reduce((t, n) => {
		for (let r in n) if (r === "signals") t.signals = mergeNamed(t.signals, n.signals);
		else {
			let i = r === "legend" ? { layout: 1 } : r === "style" ? !0 : null;
			writeConfig(t, r, n[r], i);
		}
		return t;
	}, {});
}
function writeConfig(t, n, r, i) {
	if (!isLegalKey(n)) return;
	let o, s;
	if (isObject(r) && !isArray(r)) for (o in s = isObject(t[n]) ? t[n] : t[n] = {}, r) i && (i === !0 || i[o]) ? writeConfig(s, o, r[o]) : isLegalKey(o) && (s[o] = r[o]);
	else t[n] = r;
}
function mergeNamed(t, n) {
	if (t == null) return n;
	let r = {}, i = [];
	function o(t) {
		r[t.name] || (r[t.name] = 1, i.push(t));
	}
	return n.forEach(o), t.forEach(o), i;
}
function peek(t) {
	return t[t.length - 1];
}
function toNumber(t) {
	return t == null || t === "" ? null : +t;
}
var exp$1 = (t) => (n) => t * Math.exp(n), log$2 = (t) => (n) => Math.log(t * n), symlog = (t) => (n) => Math.sign(n) * Math.log1p(Math.abs(n / t)), symexp = (t) => (n) => Math.sign(n) * Math.expm1(Math.abs(n)) * t, pow$1 = (t) => (n) => n < 0 ? -((-n) ** +t) : n ** +t;
function pan(t, n, r, i) {
	let o = r(t[0]), s = r(peek(t)), l = (s - o) * n;
	return [i(o - l), i(s - l)];
}
function panLinear(t, n) {
	return pan(t, n, toNumber, identity);
}
function panLog(t, n) {
	var r = Math.sign(t[0]);
	return pan(t, n, log$2(r), exp$1(r));
}
function panPow(t, n, r) {
	return pan(t, n, pow$1(r), pow$1(1 / r));
}
function panSymlog(t, n, r) {
	return pan(t, n, symlog(r), symexp(r));
}
function zoom$1(t, n, r, i, o) {
	let s = i(t[0]), l = i(peek(t)), u = n == null ? (s + l) / 2 : i(n);
	return [o(u + (s - u) * r), o(u + (l - u) * r)];
}
function zoomLinear(t, n, r) {
	return zoom$1(t, n, r, toNumber, identity);
}
function zoomLog(t, n, r) {
	let i = Math.sign(t[0]);
	return zoom$1(t, n, r, log$2(i), exp$1(i));
}
function zoomPow(t, n, r, i) {
	return zoom$1(t, n, r, pow$1(i), pow$1(1 / i));
}
function zoomSymlog(t, n, r, i) {
	return zoom$1(t, n, r, symlog(i), symexp(i));
}
function quarter(t) {
	return 1 + ~~(new Date(t).getMonth() / 3);
}
function utcquarter(t) {
	return 1 + ~~(new Date(t).getUTCMonth() / 3);
}
function array(t) {
	return t == null ? [] : isArray(t) ? t : [t];
}
function clampRange(t, n, r) {
	let i = t[0], o = t[1], s;
	return o < i && (s = o, o = i, i = s), s = o - i, s >= r - n ? [n, r] : [i = Math.min(Math.max(i, n), r - s), i + s];
}
function isFunction(t) {
	return typeof t == "function";
}
var DESCENDING = "descending";
function compare$1(t, n, r) {
	r ||= {}, n = array(n) || [];
	let i = [], o = [], s = {}, l = r.comparator || comparator$1;
	return array(t).forEach((t, l) => {
		t != null && (i.push(n[l] === DESCENDING ? -1 : 1), o.push(t = isFunction(t) ? t : field$1(t, null, r)), (accessorFields(t) || []).forEach((t) => s[t] = 1));
	}), o.length === 0 ? null : accessor(l(o, i), Object.keys(s));
}
var ascending = (t, n) => (t < n || t == null) && n != null ? -1 : (t > n || n == null) && t != null ? 1 : (n = n instanceof Date ? +n : n, t = t instanceof Date ? +t : t) !== t && n === n ? -1 : n !== n && t === t ? 1 : 0, comparator$1 = (t, n) => t.length === 1 ? compare1(t[0], n[0]) : compareN(t, n, t.length), compare1 = (t, n) => function(r, i) {
	return ascending(t(r), t(i)) * n;
}, compareN = (t, n, r) => (n.push(0), function(i, o) {
	let s, l = 0, u = -1;
	for (; l === 0 && ++u < r;) s = t[u], l = ascending(s(i), s(o));
	return l * n[u];
});
function constant(t) {
	return isFunction(t) ? t : () => t;
}
function debounce(t, n) {
	let r;
	return (i) => {
		r && clearTimeout(r), r = setTimeout(() => (n(i), r = null), t);
	};
}
function extend(t) {
	for (let n, r, i = 1, o = arguments.length; i < o; ++i) for (r in n = arguments[i], n) t[r] = n[r];
	return t;
}
function extent(t, n) {
	let r = 0, i, o, s, l;
	if (t && (i = t.length)) if (n == null) {
		for (o = t[r]; r < i && (o == null || o !== o); o = t[++r]);
		for (s = l = o; r < i; ++r) o = t[r], o != null && (o < s && (s = o), o > l && (l = o));
	} else {
		for (o = n(t[r]); r < i && (o == null || o !== o); o = n(t[++r]));
		for (s = l = o; r < i; ++r) o = n(t[r]), o != null && (o < s && (s = o), o > l && (l = o));
	}
	return [s, l];
}
function extentIndex(t, n) {
	let r = t.length, i = -1, o, s, l, u, d;
	if (n == null) {
		for (; ++i < r;) if (s = t[i], s != null && s >= s) {
			o = l = s;
			break;
		}
		if (i === r) return [-1, -1];
		for (u = d = i; ++i < r;) s = t[i], s != null && (o > s && (o = s, u = i), l < s && (l = s, d = i));
	} else {
		for (; ++i < r;) if (s = n(t[i], i, t), s != null && s >= s) {
			o = l = s;
			break;
		}
		if (i === r) return [-1, -1];
		for (u = d = i; ++i < r;) s = n(t[i], i, t), s != null && (o > s && (o = s, u = i), l < s && (l = s, d = i));
	}
	return [u, d];
}
function has(t, n) {
	return Object.hasOwn(t, n);
}
var NULL = {};
function fastmap(t) {
	let n = {}, r;
	function i(t) {
		return has(n, t) && n[t] !== NULL;
	}
	let o = {
		size: 0,
		empty: 0,
		object: n,
		has: i,
		get(t) {
			return i(t) ? n[t] : void 0;
		},
		set(t, r) {
			return i(t) || (++o.size, n[t] === NULL && --o.empty), n[t] = r, this;
		},
		delete(t) {
			return i(t) && (--o.size, ++o.empty, n[t] = NULL), this;
		},
		clear() {
			o.size = o.empty = 0, o.object = n = {};
		},
		test(t) {
			return arguments.length ? (r = t, o) : r;
		},
		clean() {
			let t = {}, i = 0;
			for (let o in n) {
				let s = n[o];
				s !== NULL && (!r || !r(s)) && (t[o] = s, ++i);
			}
			o.size = i, o.empty = 0, o.object = n = t;
		}
	};
	return t && Object.keys(t).forEach((n) => {
		o.set(n, t[n]);
	}), o;
}
function flush(t, n, r, i, o, s) {
	if (!r && r !== 0) return s;
	let l = +r, u = t[0], d = peek(t), f;
	d < u && (f = u, u = d, d = f), f = Math.abs(n - u);
	let p = Math.abs(d - n);
	return f < p && f <= l ? i : p <= l ? o : s;
}
function inherits(t, n, r) {
	let i = t.prototype = Object.create(n.prototype);
	return Object.defineProperty(i, "constructor", {
		value: t,
		writable: !0,
		enumerable: !0,
		configurable: !0
	}), extend(i, r);
}
function inrange(t, n, r, i) {
	let o = n[0], s = n[n.length - 1], l;
	return o > s && (l = o, o = s, s = l), r = r === void 0 || r, i = i === void 0 || i, (r ? o <= t : o < t) && (i ? t <= s : t < s);
}
function isBoolean(t) {
	return typeof t == "boolean";
}
function isDate(t) {
	return Object.prototype.toString.call(t) === "[object Date]";
}
function isIterable(t) {
	return t && isFunction(t[Symbol.iterator]);
}
function isNumber(t) {
	return typeof t == "number";
}
function isRegExp(t) {
	return Object.prototype.toString.call(t) === "[object RegExp]";
}
function isString(t) {
	return typeof t == "string";
}
function key(t, n, r) {
	t &&= n ? array(t).map((t) => t.replace(/\\(.)/g, "$1")) : array(t);
	let i = t && t.length, o = r && r.get || getter$1, s = (t) => o(n ? [t] : splitAccessPath(t)), l;
	if (!i) l = function() {
		return "";
	};
	else if (i === 1) {
		let n = s(t[0]);
		l = function(t) {
			return "" + n(t);
		};
	} else {
		let n = t.map(s);
		l = function(t) {
			let r = "" + n[0](t), o = 0;
			for (; ++o < i;) r += "|" + n[o](t);
			return r;
		};
	}
	return accessor(l, t, "key");
}
function lerp(t, n) {
	let r = t[0], i = peek(t), o = +n;
	return o ? o === 1 ? i : r + o * (i - r) : r;
}
var DEFAULT_MAX_SIZE = 1e4;
function lruCache(t) {
	t = +t || DEFAULT_MAX_SIZE;
	let n, r, i, o = () => {
		n = {}, r = {}, i = 0;
	}, s = (o, s) => (++i > t && (r = n, n = {}, i = 1), n[o] = s);
	return o(), {
		clear: o,
		has: (t) => has(n, t) || has(r, t),
		get: (t) => has(n, t) ? n[t] : has(r, t) ? s(t, r[t]) : void 0,
		set: (t, r) => has(n, t) ? n[t] = r : s(t, r)
	};
}
function merge$2(t, n, r, i) {
	let o = n.length, s = r.length;
	if (!s) return n;
	if (!o) return r;
	let l = i || new n.constructor(o + s), u = 0, d = 0, f = 0;
	for (; u < o && d < s; ++f) l[f] = t(n[u], r[d]) > 0 ? r[d++] : n[u++];
	for (; u < o; ++u, ++f) l[f] = n[u];
	for (; d < s; ++d, ++f) l[f] = r[d];
	return l;
}
function repeat(t, n) {
	let r = "";
	for (; --n >= 0;) r += t;
	return r;
}
function pad(t, n, r, i) {
	let o = r || " ", s = t + "", l = n - s.length;
	return l <= 0 ? s : i === "left" ? repeat(o, l) + s : i === "center" ? repeat(o, ~~(l / 2)) + s + repeat(o, Math.ceil(l / 2)) : s + repeat(o, l);
}
function span(t) {
	return t && peek(t) - t[0] || 0;
}
function $(t) {
	return isArray(t) ? `[${t.map((t) => t === null ? "null" : $(t))}]` : isObject(t) || isString(t) ? JSON.stringify(t).replaceAll("\u2028", "\\u2028").replaceAll("\u2029", "\\u2029") : t;
}
function toBoolean(t) {
	return t == null || t === "" ? null : !t || t === "false" || t === "0" ? !1 : !!t;
}
var defaultParser = (t) => isNumber(t) || isDate(t) ? t : Date.parse(t);
function toDate(t, n) {
	return n ||= defaultParser, t == null || t === "" ? null : n(t);
}
function toString(t) {
	return t == null || t === "" ? null : t + "";
}
function toSet(t) {
	let n = {}, r = t.length;
	for (let i = 0; i < r; ++i) n[t[i]] = !0;
	return n;
}
function truncate(t, n, r, i) {
	let o = i ?? "…", s = t + "", l = s.length, u = Math.max(0, n - o.length);
	return l <= n ? s : r === "left" ? o + s.slice(l - u) : r === "center" ? s.slice(0, Math.ceil(u / 2)) + o + s.slice(l - ~~(u / 2)) : s.slice(0, u) + o;
}
function visitArray(t, n, r) {
	if (t) if (n) {
		let i = t.length;
		for (let o = 0; o < i; ++o) {
			let i = n(t[o]);
			i && r(i, o, t);
		}
	} else t.forEach(r);
}
function identity_default$1(t) {
	return t;
}
function transform_default(t) {
	if (t == null) return identity_default$1;
	var n, r, i = t.scale[0], o = t.scale[1], s = t.translate[0], l = t.translate[1];
	return function(t, u) {
		u || (n = r = 0);
		var d = 2, f = t.length, p = Array(f);
		for (p[0] = (n += t[0]) * i + s, p[1] = (r += t[1]) * o + l; d < f;) p[d] = t[d], ++d;
		return p;
	};
}
function reverse_default(t, n) {
	for (var r, i = t.length, o = i - n; o < --i;) r = t[o], t[o++] = t[i], t[i] = r;
}
function feature_default(t, n) {
	return typeof n == "string" && (n = t.objects[n]), n.type === "GeometryCollection" ? {
		type: "FeatureCollection",
		features: n.geometries.map(function(n) {
			return feature(t, n);
		})
	} : feature(t, n);
}
function feature(t, n) {
	var r = n.id, i = n.bbox, o = n.properties == null ? {} : n.properties, s = object(t, n);
	return r == null && i == null ? {
		type: "Feature",
		properties: o,
		geometry: s
	} : i == null ? {
		type: "Feature",
		id: r,
		properties: o,
		geometry: s
	} : {
		type: "Feature",
		id: r,
		bbox: i,
		properties: o,
		geometry: s
	};
}
function object(t, n) {
	var r = transform_default(t.transform), i = t.arcs;
	function o(t, n) {
		n.length && n.pop();
		for (var o = i[t < 0 ? ~t : t], s = 0, l = o.length; s < l; ++s) n.push(r(o[s], s));
		t < 0 && reverse_default(n, l);
	}
	function s(t) {
		return r(t);
	}
	function l(t) {
		for (var n = [], r = 0, i = t.length; r < i; ++r) o(t[r], n);
		return n.length < 2 && n.push(n[0]), n;
	}
	function u(t) {
		for (var n = l(t); n.length < 4;) n.push(n[0]);
		return n;
	}
	function d(t) {
		return t.map(u);
	}
	function f(t) {
		var n = t.type, r;
		switch (n) {
			case "GeometryCollection": return {
				type: n,
				geometries: t.geometries.map(f)
			};
			case "Point":
				r = s(t.coordinates);
				break;
			case "MultiPoint":
				r = t.coordinates.map(s);
				break;
			case "LineString":
				r = l(t.arcs);
				break;
			case "MultiLineString":
				r = t.arcs.map(l);
				break;
			case "Polygon":
				r = d(t.arcs);
				break;
			case "MultiPolygon":
				r = t.arcs.map(d);
				break;
			default: return null;
		}
		return {
			type: n,
			coordinates: r
		};
	}
	return f(n);
}
function stitch_default(t, n) {
	var r = {}, i = {}, o = {}, s = [], l = -1;
	n.forEach(function(r, i) {
		var o = t.arcs[r < 0 ? ~r : r], s;
		o.length < 3 && !o[1][0] && !o[1][1] && (s = n[++l], n[l] = r, n[i] = s);
	}), n.forEach(function(t) {
		var n = u(t), r = n[0], s = n[1], l, d;
		if (l = o[r]) if (delete o[l.end], l.push(t), l.end = s, d = i[s]) {
			delete i[d.start];
			var f = d === l ? l : l.concat(d);
			i[f.start = l.start] = o[f.end = d.end] = f;
		} else i[l.start] = o[l.end] = l;
		else if (l = i[s]) if (delete i[l.start], l.unshift(t), l.start = r, d = o[r]) {
			delete o[d.end];
			var p = d === l ? l : d.concat(l);
			i[p.start = d.start] = o[p.end = l.end] = p;
		} else i[l.start] = o[l.end] = l;
		else l = [t], i[l.start = r] = o[l.end = s] = l;
	});
	function u(n) {
		var r = t.arcs[n < 0 ? ~n : n], i = r[0], o;
		return t.transform ? (o = [0, 0], r.forEach(function(t) {
			o[0] += t[0], o[1] += t[1];
		})) : o = r[r.length - 1], n < 0 ? [o, i] : [i, o];
	}
	function d(t, n) {
		for (var i in t) {
			var o = t[i];
			delete n[o.start], delete o.start, delete o.end, o.forEach(function(t) {
				r[t < 0 ? ~t : t] = 1;
			}), s.push(o);
		}
	}
	return d(o, i), d(i, o), n.forEach(function(t) {
		r[t < 0 ? ~t : t] || s.push([t]);
	}), s;
}
function mesh_default(t) {
	return object(t, meshArcs.apply(this, arguments));
}
function meshArcs(t, n, r) {
	var i, o, s;
	if (arguments.length > 1) i = extractArcs(t, n, r);
	else for (o = 0, i = Array(s = t.arcs.length); o < s; ++o) i[o] = o;
	return {
		type: "MultiLineString",
		arcs: stitch_default(t, i)
	};
}
function extractArcs(t, n, r) {
	var i = [], o = [], s;
	function l(t) {
		var n = t < 0 ? ~t : t;
		(o[n] || (o[n] = [])).push({
			i: t,
			g: s
		});
	}
	function u(t) {
		t.forEach(l);
	}
	function d(t) {
		t.forEach(u);
	}
	function f(t) {
		t.forEach(d);
	}
	function p(t) {
		switch (s = t, t.type) {
			case "GeometryCollection":
				t.geometries.forEach(p);
				break;
			case "LineString":
				u(t.arcs);
				break;
			case "MultiLineString":
			case "Polygon":
				d(t.arcs);
				break;
			case "MultiPolygon":
				f(t.arcs);
				break;
		}
	}
	return p(n), o.forEach(r == null ? function(t) {
		i.push(t[0].i);
	} : function(t) {
		r(t[0].g, t[t.length - 1].g) && i.push(t[0].i);
	}), i;
}
init_dist();
var YEAR = "year", QUARTER = "quarter", MONTH = "month", WEEK = "week", DATE = "date", DAYOFYEAR = "dayofyear", HOURS = "hours", MINUTES = "minutes", SECONDS = "seconds", MILLISECONDS = "milliseconds", TIME_UNITS = [
	YEAR,
	QUARTER,
	MONTH,
	WEEK,
	DATE,
	"day",
	DAYOFYEAR,
	HOURS,
	MINUTES,
	SECONDS,
	MILLISECONDS
], UNITS = TIME_UNITS.reduce((t, n, r) => (t[n] = 1 + r, t), {});
function timeUnits(t) {
	let n = array(t).slice(), r = {};
	return n.length || error$1("Missing time unit."), n.forEach((t) => {
		has(UNITS, t) ? r[t] = 1 : error$1(`Invalid time unit: ${t}.`);
	}), (r.week || r.day ? 1 : 0) + (r.quarter || r.month || r.date ? 1 : 0) + (r.dayofyear ? 1 : 0) > 1 && error$1(`Incompatible time units: ${t}`), n.sort((t, n) => UNITS[t] - UNITS[n]), n;
}
var defaultSpecifiers = {
	[YEAR]: "%Y ",
	[QUARTER]: "Q%q ",
	[MONTH]: "%b ",
	[DATE]: "%d ",
	[WEEK]: "W%U ",
	day: "%a ",
	[DAYOFYEAR]: "%j ",
	[HOURS]: "%H:00",
	[MINUTES]: "00:%M",
	[SECONDS]: ":%S",
	[MILLISECONDS]: ".%L",
	[`${YEAR}-${MONTH}`]: "%Y-%m ",
	[`${YEAR}-${MONTH}-${DATE}`]: "%Y-%m-%d ",
	[`${HOURS}-${MINUTES}`]: "%H:%M"
};
function timeUnitSpecifier(t, n) {
	let r = extend({}, defaultSpecifiers, n), i = timeUnits(t), o = i.length, s = "", l = 0, u, d;
	for (l = 0; l < o;) for (u = i.length; u > l; --u) if (d = i.slice(l, u).join("-"), r[d] != null) {
		s += r[d], l = u;
		break;
	}
	return s.trim();
}
var t0 = /* @__PURE__ */ new Date();
function localYear(t) {
	return t0.setFullYear(t), t0.setMonth(0), t0.setDate(1), t0.setHours(0, 0, 0, 0), t0;
}
function dayofyear(t) {
	return localDayOfYear(new Date(t));
}
function week(t) {
	return localWeekNum(new Date(t));
}
function localDayOfYear(t) {
	return timeDay.count(localYear(t.getFullYear()) - 1, t);
}
function localWeekNum(t) {
	return timeSunday.count(localYear(t.getFullYear()) - 1, t);
}
function localFirst(t) {
	return localYear(t).getDay();
}
function localDate(t, n, r, i, o, s, l) {
	if (0 <= t && t < 100) {
		let u = new Date(-1, n, r, i, o, s, l);
		return u.setFullYear(t), u;
	}
	return new Date(t, n, r, i, o, s, l);
}
function utcdayofyear(t) {
	return utcDayOfYear(new Date(t));
}
function utcweek(t) {
	return utcWeekNum(new Date(t));
}
function utcDayOfYear(t) {
	let n = Date.UTC(t.getUTCFullYear(), 0, 1);
	return utcDay.count(n - 1, t);
}
function utcWeekNum(t) {
	let n = Date.UTC(t.getUTCFullYear(), 0, 1);
	return utcSunday.count(n - 1, t);
}
function utcFirst(t) {
	return t0.setTime(Date.UTC(t, 0, 1)), t0.getUTCDay();
}
function utcDate(t, n, r, i, o, s, l) {
	if (0 <= t && t < 100) {
		let t = new Date(Date.UTC(-1, n, r, i, o, s, l));
		return t.setUTCFullYear(r.y), t;
	}
	return new Date(Date.UTC(t, n, r, i, o, s, l));
}
function floor(t, n, r, i, o) {
	let s = n || 1, l = peek(t), u = (t, n, o) => (o ||= t, getUnit(r[o], i[o], t === l && s, n)), d = /* @__PURE__ */ new Date(), f = toSet(t), p = f.year ? u(YEAR) : constant(2012), g = f.month ? u(MONTH) : f.quarter ? u(QUARTER) : zero$2, _ = f.week && f.day ? u("day", 1, WEEK + "day") : f.week ? u(WEEK, 1) : f.day ? u("day", 1) : f.date ? u(DATE, 1) : f.dayofyear ? u(DAYOFYEAR, 1) : one$1, v = f.hours ? u(HOURS) : zero$2, S = f.minutes ? u(MINUTES) : zero$2, T = f.seconds ? u(SECONDS) : zero$2, E = f.milliseconds ? u(MILLISECONDS) : zero$2;
	return function(t) {
		d.setTime(+t);
		let n = p(d);
		return o(n, g(d), _(d, n), v(d), S(d), T(d), E(d));
	};
}
function getUnit(t, n, r, i) {
	let o = r <= 1 ? t : i ? (n, o) => i + r * Math.floor((t(n, o) - i) / r) : (n, i) => r * Math.floor(t(n, i) / r);
	return n ? (t, r) => n(o(t, r), r) : o;
}
function weekday(t, n, r) {
	return n + t * 7 - (r + 6) % 7;
}
var localGet = {
	[YEAR]: (t) => t.getFullYear(),
	[QUARTER]: (t) => Math.floor(t.getMonth() / 3),
	[MONTH]: (t) => t.getMonth(),
	[DATE]: (t) => t.getDate(),
	[HOURS]: (t) => t.getHours(),
	[MINUTES]: (t) => t.getMinutes(),
	[SECONDS]: (t) => t.getSeconds(),
	[MILLISECONDS]: (t) => t.getMilliseconds(),
	[DAYOFYEAR]: (t) => localDayOfYear(t),
	[WEEK]: (t) => localWeekNum(t),
	[WEEK + "day"]: (t, n) => weekday(localWeekNum(t), t.getDay(), localFirst(n)),
	day: (t, n) => weekday(1, t.getDay(), localFirst(n))
}, localInv = {
	[QUARTER]: (t) => 3 * t,
	[WEEK]: (t, n) => weekday(t, 0, localFirst(n))
};
function timeFloor(t, n) {
	return floor(t, n || 1, localGet, localInv, localDate);
}
var utcGet = {
	[YEAR]: (t) => t.getUTCFullYear(),
	[QUARTER]: (t) => Math.floor(t.getUTCMonth() / 3),
	[MONTH]: (t) => t.getUTCMonth(),
	[DATE]: (t) => t.getUTCDate(),
	[HOURS]: (t) => t.getUTCHours(),
	[MINUTES]: (t) => t.getUTCMinutes(),
	[SECONDS]: (t) => t.getUTCSeconds(),
	[MILLISECONDS]: (t) => t.getUTCMilliseconds(),
	[DAYOFYEAR]: (t) => utcDayOfYear(t),
	[WEEK]: (t) => utcWeekNum(t),
	day: (t, n) => weekday(1, t.getUTCDay(), utcFirst(n)),
	[WEEK + "day"]: (t, n) => weekday(utcWeekNum(t), t.getUTCDay(), utcFirst(n))
}, utcInv = {
	[QUARTER]: (t) => 3 * t,
	[WEEK]: (t, n) => weekday(t, 0, utcFirst(n))
};
function utcFloor(t, n) {
	return floor(t, n || 1, utcGet, utcInv, utcDate);
}
var timeIntervals = {
	[YEAR]: timeYear,
	[QUARTER]: timeMonth.every(3),
	[MONTH]: timeMonth,
	[WEEK]: timeSunday,
	[DATE]: timeDay,
	day: timeDay,
	[DAYOFYEAR]: timeDay,
	[HOURS]: timeHour,
	[MINUTES]: timeMinute,
	[SECONDS]: second,
	[MILLISECONDS]: millisecond
}, utcIntervals = {
	[YEAR]: utcYear,
	[QUARTER]: utcMonth.every(3),
	[MONTH]: utcMonth,
	[WEEK]: utcSunday,
	[DATE]: utcDay,
	day: utcDay,
	[DAYOFYEAR]: utcDay,
	[HOURS]: utcHour,
	[MINUTES]: utcMinute,
	[SECONDS]: second,
	[MILLISECONDS]: millisecond
};
function timeInterval(t) {
	return timeIntervals[t];
}
function utcInterval(t) {
	return utcIntervals[t];
}
function offset$3(t, n, r) {
	return t ? t.offset(n, r) : void 0;
}
function timeOffset(t, n, r) {
	return offset$3(timeInterval(t), n, r);
}
function utcOffset(t, n, r) {
	return offset$3(utcInterval(t), n, r);
}
function sequence$1(t, n, r, i) {
	return t ? t.range(n, r, i) : void 0;
}
function timeSequence(t, n, r, i) {
	return sequence$1(timeInterval(t), n, r, i);
}
function utcSequence(t, n, r, i) {
	return sequence$1(utcInterval(t), n, r, i);
}
var durationSecond = 1e3, durationMinute = durationSecond * 60, durationHour = durationMinute * 60, durationDay = durationHour * 24, durationWeek = durationDay * 7, durationMonth = durationDay * 30, durationYear = durationDay * 365, Milli = [
	YEAR,
	MONTH,
	DATE,
	HOURS,
	MINUTES,
	SECONDS,
	MILLISECONDS
], Seconds = Milli.slice(0, -1), Minutes = Seconds.slice(0, -1), Hours = Minutes.slice(0, -1), Day = Hours.slice(0, -1), Week = [YEAR, WEEK], Month = [YEAR, MONTH], Year = [YEAR], intervals = [
	[
		Seconds,
		1,
		durationSecond
	],
	[
		Seconds,
		5,
		5 * durationSecond
	],
	[
		Seconds,
		15,
		15 * durationSecond
	],
	[
		Seconds,
		30,
		30 * durationSecond
	],
	[
		Minutes,
		1,
		durationMinute
	],
	[
		Minutes,
		5,
		5 * durationMinute
	],
	[
		Minutes,
		15,
		15 * durationMinute
	],
	[
		Minutes,
		30,
		30 * durationMinute
	],
	[
		Hours,
		1,
		durationHour
	],
	[
		Hours,
		3,
		3 * durationHour
	],
	[
		Hours,
		6,
		6 * durationHour
	],
	[
		Hours,
		12,
		12 * durationHour
	],
	[
		Day,
		1,
		durationDay
	],
	[
		Week,
		1,
		durationWeek
	],
	[
		Month,
		1,
		durationMonth
	],
	[
		Month,
		3,
		3 * durationMonth
	],
	[
		Year,
		1,
		durationYear
	]
];
function bin$1(t) {
	let n = t.extent, r = t.maxbins || 40, i = Math.abs(span(n)) / r, o = bisector((t) => t[2]).right(intervals, i), s, l;
	return o === intervals.length ? (s = Year, l = tickStep(n[0] / durationYear, n[1] / durationYear, r)) : o ? (o = intervals[i / intervals[o - 1][2] < intervals[o][2] / i ? o - 1 : o], s = o[0], l = o[1]) : (s = Milli, l = Math.max(tickStep(n[0], n[1], r), 1)), {
		units: s,
		step: l
	};
}
function memoize(t) {
	let n = {};
	return (r) => n[r] || (n[r] = t(r));
}
function trimZeroes(t, n) {
	return (r) => {
		let i = t(r), o = i.indexOf(n);
		if (o < 0) return i;
		let s = rightmostDigit(i, o), l = s < i.length ? i.slice(s) : "";
		for (; --s > o;) if (i[s] !== "0") {
			++s;
			break;
		}
		return i.slice(0, s) + l;
	};
}
function rightmostDigit(t, n) {
	let r = t.lastIndexOf("e"), i;
	if (r > 0) return r;
	for (r = t.length; --r > n;) if (i = t.charCodeAt(r), i >= 48 && i <= 57) return r + 1;
}
function numberLocale(t) {
	let n = memoize(t.format), r = t.formatPrefix;
	return {
		format: n,
		formatPrefix: r,
		formatFloat(t) {
			let r = formatSpecifier(t || ",");
			if (r.precision == null) {
				switch (r.precision = 12, r.type) {
					case "%":
						r.precision -= 2;
						break;
					case "e":
						--r.precision;
						break;
				}
				return trimZeroes(n(r), n(".1f")(1)[1]);
			} else return n(r);
		},
		formatSpan(t, i, o, s) {
			s = formatSpecifier(s ?? ",f");
			let l = tickStep(t, i, o), u = Math.max(Math.abs(t), Math.abs(i)), d;
			if (s.precision == null) switch (s.type) {
				case "s": return isNaN(d = precisionPrefix_default(l, u)) || (s.precision = d), r(s, u);
				case "":
				case "e":
				case "g":
				case "p":
				case "r":
					isNaN(d = precisionRound_default(l, u)) || (s.precision = d - (s.type === "e"));
					break;
				case "f":
				case "%":
					isNaN(d = precisionFixed_default(l)) || (s.precision = d - (s.type === "%") * 2);
					break;
			}
			return n(s);
		}
	};
}
var defaultNumberLocale;
resetNumberFormatDefaultLocale();
function resetNumberFormatDefaultLocale() {
	return defaultNumberLocale = numberLocale({
		format: format$3,
		formatPrefix
	});
}
function numberFormatLocale(t) {
	return numberLocale(locale_default(t));
}
function numberFormatDefaultLocale(t) {
	return arguments.length ? defaultNumberLocale = numberFormatLocale(t) : defaultNumberLocale;
}
function timeMultiFormat(t, n, r) {
	r ||= {}, isObject(r) || error$1(`Invalid time multi-format specifier: ${r}`);
	let i = n(SECONDS), o = n(MINUTES), s = n(HOURS), l = n(DATE), u = n(WEEK), d = n(MONTH), f = n(QUARTER), p = n(YEAR), g = t(r.milliseconds || ".%L"), _ = t(r.seconds || ":%S"), v = t(r.minutes || "%I:%M"), S = t(r.hours || "%I %p"), T = t(r.date || r.day || "%a %d"), E = t(r.week || "%b %d"), O = t(r.month || "%B"), k = t(r.quarter || "%B"), A = t(r.year || "%Y");
	return (t) => (i(t) < t ? g : o(t) < t ? _ : s(t) < t ? v : l(t) < t ? S : d(t) < t ? u(t) < t ? T : E : p(t) < t ? f(t) < t ? O : k : A)(t);
}
function timeLocale(t) {
	let n = memoize(t.format), r = memoize(t.utcFormat);
	return {
		timeFormat: (t) => isString(t) ? n(t) : timeMultiFormat(n, timeInterval, t),
		utcFormat: (t) => isString(t) ? r(t) : timeMultiFormat(r, utcInterval, t),
		timeParse: memoize(t.parse),
		utcParse: memoize(t.utcParse)
	};
}
var defaultTimeLocale;
resetTimeFormatDefaultLocale();
function resetTimeFormatDefaultLocale() {
	return defaultTimeLocale = timeLocale({
		format: timeFormat$2,
		parse: timeParse$1,
		utcFormat: utcFormat$1,
		utcParse: utcParse$1
	});
}
function timeFormatLocale(t) {
	return timeLocale(formatLocale(t));
}
function timeFormatDefaultLocale(t) {
	return arguments.length ? defaultTimeLocale = timeFormatLocale(t) : defaultTimeLocale;
}
var createLocale = (t, n) => extend({}, t, n);
function locale(t, n) {
	return createLocale(t ? numberFormatLocale(t) : numberFormatDefaultLocale(), n ? timeFormatLocale(n) : timeFormatDefaultLocale());
}
function defaultLocale(t, n) {
	let r = arguments.length;
	return r && r !== 2 && error$1("defaultLocale expects either zero or two arguments."), r ? createLocale(numberFormatDefaultLocale(t), timeFormatDefaultLocale(n)) : createLocale(numberFormatDefaultLocale(), timeFormatDefaultLocale());
}
function resetDefaultLocale() {
	return resetNumberFormatDefaultLocale(), resetTimeFormatDefaultLocale(), defaultLocale();
}
var protocol_re = /^(data:|([A-Za-z]+:)?\/\/)/, allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i, whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, fileProtocol = "file://";
function loaderFactory(t) {
	return (t) => ({
		options: t || {},
		sanitize,
		load: load$1,
		fileAccess: !1,
		file: fileLoader(),
		http: httpLoader
	});
}
async function load$1(t, n) {
	let r = await this.sanitize(t, n), i = r.href;
	return r.localFile ? this.file(i) : this.http(i, n?.http);
}
async function sanitize(t, n) {
	n = extend({}, this.options, n);
	let r = this.fileAccess, i = { href: null }, o, s, l, u = allowed_re.test(t.replace(whitespace_re, ""));
	(t == null || typeof t != "string" || !u) && error$1("Sanitize failure, invalid URI: " + $(t));
	let d = protocol_re.test(t);
	return (l = n.baseURL) && !d && (!t.startsWith("/") && !l.endsWith("/") && (t = "/" + t), t = l + t), s = (o = t.startsWith(fileProtocol)) || n.mode === "file" || n.mode !== "http" && !d && r, o ? t = t.slice(7) : t.startsWith("//") && (n.defaultProtocol === "file" ? (t = t.slice(2), s = !0) : t = (n.defaultProtocol || "http") + ":" + t), Object.defineProperty(i, "localFile", { value: !!s }), i.href = t, n.target && (i.target = n.target + ""), n.rel && (i.rel = n.rel + ""), n.context === "image" && n.crossOrigin && (i.crossOrigin = n.crossOrigin + ""), i;
}
function fileLoader(t) {
	return fileReject;
}
async function fileReject() {
	error$1("No file system access.");
}
async function httpLoader(t, n) {
	let r = extend({}, this.options.http, n), i = n && n.response, o = await fetch(t, r);
	return o.ok ? isFunction(o[i]) ? o[i]() : o.text() : error$1(o.status + "" + o.statusText);
}
var isValid = (t) => t != null && t === t, isBoolean$2 = (t) => t === "true" || t === "false" || t === !0 || t === !1, isDate$1 = (t) => !Number.isNaN(Date.parse(t)), isNumber$1 = (t) => !Number.isNaN(+t) && !(t instanceof Date), isInteger$1 = (t) => isNumber$1(t) && Number.isInteger(+t), typeParsers = {
	boolean: toBoolean,
	integer: toNumber,
	number: toNumber,
	date: toDate,
	string: toString,
	unknown: identity
}, typeTests = [
	isBoolean$2,
	isInteger$1,
	isNumber$1,
	isDate$1
], typeList = [
	"boolean",
	"integer",
	"number",
	"date"
];
function inferType(t, n) {
	if (!t || !t.length) return "unknown";
	let r = t.length, i = typeTests.length, o = typeTests.map((t, n) => n + 1);
	for (let s = 0, l = 0, u, d; s < r; ++s) for (d = n ? t[s][n] : t[s], u = 0; u < i; ++u) if (o[u] && isValid(d) && !typeTests[u](d) && (o[u] = 0, ++l, l === typeTests.length)) return "string";
	return typeList[o.reduce((t, n) => t === 0 ? n : t, 0) - 1];
}
function inferTypes(t, n) {
	return n.reduce((n, r) => (n[r] = inferType(t, r), n), {});
}
function delimitedFormat(t) {
	let n = function(n, r) {
		let i = { delimiter: t };
		return dsv(n, r ? extend(r, i) : i);
	};
	return n.responseType = "text", n;
}
function dsv(t, n) {
	return n.header && (t = n.header.map($).join(n.delimiter) + "\n" + t), dsv_default(n.delimiter).parse(t + "");
}
dsv.responseType = "text";
function isBuffer(t) {
	return typeof Buffer == "function" && isFunction(Buffer.isBuffer) ? Buffer.isBuffer(t) : !1;
}
function json(t, n) {
	let r = n && n.property ? field$1(n.property) : identity;
	return isObject(t) && !isBuffer(t) ? parseJSON(r(t), n) : r(JSON.parse(t));
}
json.responseType = "json";
function parseJSON(t, n) {
	return !isArray(t) && isIterable(t) && (t = [...t]), n && n.copy ? JSON.parse(JSON.stringify(t)) : t;
}
var filters = {
	interior: (t, n) => t !== n,
	exterior: (t, n) => t === n
};
function topojson(t, n) {
	let r, i, o, s;
	return t = json(t, n), n && n.feature ? (r = feature_default, o = n.feature) : n && n.mesh ? (r = mesh_default, o = n.mesh, s = filters[n.filter]) : error$1("Missing TopoJSON feature or mesh parameter."), i = (i = t.objects[o]) ? r(t, i, s) : error$1("Invalid TopoJSON object: " + o), i && i.features || [i];
}
topojson.responseType = "json";
var format$2 = {
	dsv,
	csv: delimitedFormat(","),
	tsv: delimitedFormat("	"),
	json,
	topojson
};
function formats$1(t, n) {
	return arguments.length > 1 ? (format$2[t] = n, this) : has(format$2, t) ? format$2[t] : null;
}
function responseType(t) {
	let n = formats$1(t);
	return n && n.responseType || "text";
}
function read(t, n, r, i) {
	n ||= {};
	let o = formats$1(n.type || "json");
	return o || error$1("Unknown data format type: " + n.type), t = o(t, n), n.parse && parse$6(t, n.parse, r, i), has(t, "columns") && delete t.columns, t;
}
function parse$6(t, n, r, i) {
	if (!t.length) return;
	let o = timeFormatDefaultLocale();
	r ||= o.timeParse, i ||= o.utcParse;
	let s = t.columns || Object.keys(t[0]), l, u, d, f, p, g;
	n === "auto" && (n = inferTypes(t, s)), s = Object.keys(n);
	let _ = s.map((t) => {
		let o = n[t], s, l;
		if (o && (o.startsWith("date:") || o.startsWith("utc:"))) return s = o.split(/:(.+)?/, 2), l = s[1], (l[0] === "'" && l[l.length - 1] === "'" || l[0] === "\"" && l[l.length - 1] === "\"") && (l = l.slice(1, -1)), (s[0] === "utc" ? i : r)(l);
		if (!typeParsers[o]) throw Error("Illegal format pattern: " + t + ":" + o);
		return typeParsers[o];
	});
	for (d = 0, p = t.length, g = s.length; d < p; ++d) for (l = t[d], f = 0; f < g; ++f) u = s[f], l[u] = _[f](l[u]);
}
var loader = loaderFactory();
function UniqueList(t) {
	let n = t || identity, r = [], i = {};
	return r.add = (t) => {
		let o = n(t);
		return i[o] || (i[o] = 1, r.push(t)), r;
	}, r.remove = (t) => {
		let o = n(t);
		if (i[o]) {
			i[o] = 0;
			let n = r.indexOf(t);
			n >= 0 && r.splice(n, 1);
		}
		return r;
	}, r;
}
async function asyncCallback(t, n) {
	try {
		await n(t);
	} catch (n) {
		t.error(n);
	}
}
var TUPLE_ID_KEY = Symbol("vega_id"), TUPLE_ID = 1;
function isTuple(t) {
	return !!(t && tupleid(t));
}
function tupleid(t) {
	return t[TUPLE_ID_KEY];
}
function setid(t, n) {
	return t[TUPLE_ID_KEY] = n, t;
}
function ingest$1(t) {
	let n = t === Object(t) ? t : { data: t };
	return tupleid(n) ? n : setid(n, TUPLE_ID++);
}
function derive(t) {
	return rederive(t, ingest$1({}));
}
function rederive(t, n) {
	for (let r in t) n[r] = t[r];
	return n;
}
function replace$1(t, n) {
	return setid(n, tupleid(t));
}
function stableCompare(t, n) {
	return t ? n ? (r, i) => t(r, i) || tupleid(n(r)) - tupleid(n(i)) : (n, r) => t(n, r) || tupleid(n) - tupleid(r) : null;
}
function isChangeSet(t) {
	return t && t.constructor === changeset;
}
function changeset() {
	let t = [], n = [], r = [], i = [], o = [], s = null, l = !1;
	return {
		constructor: changeset,
		insert(n) {
			let r = array(n), i = r.length;
			for (let n = 0; n < i; ++n) t.push(r[n]);
			return this;
		},
		remove(t) {
			let r = isFunction(t) ? i : n, o = array(t), s = o.length;
			for (let t = 0; t < s; ++t) r.push(o[t]);
			return this;
		},
		modify(t, n, i) {
			let s = {
				field: n,
				value: constant(i)
			};
			return isFunction(t) ? (s.filter = t, o.push(s)) : (s.tuple = t, r.push(s)), this;
		},
		encode(t, n) {
			return isFunction(t) ? o.push({
				filter: t,
				field: n
			}) : r.push({
				tuple: t,
				field: n
			}), this;
		},
		clean(t) {
			return s = t, this;
		},
		reflow() {
			return l = !0, this;
		},
		pulse(u, d) {
			let f = {}, p = {}, g, _, v, S, T, E;
			for (g = 0, _ = d.length; g < _; ++g) f[tupleid(d[g])] = 1;
			for (g = 0, _ = n.length; g < _; ++g) T = n[g], f[tupleid(T)] = -1;
			for (g = 0, _ = i.length; g < _; ++g) S = i[g], d.forEach((t) => {
				S(t) && (f[tupleid(t)] = -1);
			});
			for (g = 0, _ = t.length; g < _; ++g) T = t[g], E = tupleid(T), f[E] ? f[E] = 1 : u.add.push(ingest$1(t[g]));
			for (g = 0, _ = d.length; g < _; ++g) T = d[g], f[tupleid(T)] < 0 && u.rem.push(T);
			function O(t, n, r) {
				r ? t[n] = r(t) : u.encode = n, l || (p[tupleid(t)] = t);
			}
			for (g = 0, _ = r.length; g < _; ++g) v = r[g], T = v.tuple, S = v.field, E = f[tupleid(T)], E > 0 && (O(T, S, v.value), u.modifies(S));
			for (g = 0, _ = o.length; g < _; ++g) v = o[g], S = v.filter, d.forEach((t) => {
				S(t) && f[tupleid(t)] > 0 && O(t, v.field, v.value);
			}), u.modifies(v.field);
			if (l) u.mod = n.length || i.length ? d.filter((t) => f[tupleid(t)] > 0) : d.slice();
			else for (E in p) u.mod.push(p[E]);
			return (s || s == null && (n.length || i.length)) && u.clean(!0), u;
		}
	};
}
var CACHE = "_:mod:_";
function Parameters() {
	Object.defineProperty(this, CACHE, {
		writable: !0,
		value: {}
	});
}
Parameters.prototype = {
	set(t, n, r, i) {
		let o = this, s = o[t], l = o[CACHE];
		return n != null && n >= 0 ? (s[n] !== r || i) && (s[n] = r, l[n + ":" + t] = -1, l[t] = -1) : (s !== r || i) && (o[t] = r, l[t] = isArray(r) ? 1 + r.length : -1), o;
	},
	modified(t, n) {
		let r = this[CACHE];
		if (arguments.length) {
			if (isArray(t)) {
				for (let n = 0; n < t.length; ++n) if (r[t[n]]) return !0;
				return !1;
			}
		} else {
			for (let t in r) if (r[t]) return !0;
			return !1;
		}
		return n != null && n >= 0 ? n + 1 < r[t] || !!r[n + ":" + t] : !!r[t];
	},
	clear() {
		return this[CACHE] = {}, this;
	}
};
var OP_ID = 0, PULSE = "pulse", NO_PARAMS = new Parameters(), SKIP$1$1 = 1, MODIFIED = 2;
function Operator(t, n, r, i) {
	this.id = ++OP_ID, this.value = t, this.stamp = -1, this.rank = -1, this.qrank = -1, this.flags = 0, n && (this._update = n), r && this.parameters(r, i);
}
function flag(t) {
	return function(n) {
		let r = this.flags;
		return arguments.length === 0 ? !!(r & t) : (this.flags = n ? r | t : r & ~t, this);
	};
}
Operator.prototype = {
	targets() {
		return this._targets ||= UniqueList(id);
	},
	set(t) {
		return this.value === t ? 0 : (this.value = t, 1);
	},
	skip: flag(SKIP$1$1),
	modified: flag(MODIFIED),
	parameters(t, n, r) {
		n = n !== !1;
		let i = this._argval = this._argval || new Parameters(), o = this._argops = this._argops || [], s = [], l, u, d, f, p = (t, r, l) => {
			l instanceof Operator ? (l !== this && (n && l.targets().add(this), s.push(l)), o.push({
				op: l,
				name: t,
				index: r
			})) : i.set(t, r, l);
		};
		for (l in t) if (u = t[l], l === PULSE) array(u).forEach((t) => {
			t instanceof Operator ? t !== this && (t.targets().add(this), s.push(t)) : error$1("Pulse parameters must be operator instances.");
		}), this.source = u;
		else if (isArray(u)) for (i.set(l, -1, Array(d = u.length)), f = 0; f < d; ++f) p(l, f, u[f]);
		else p(l, -1, u);
		return this.marshall().clear(), r && (o.initonly = !0), s;
	},
	marshall(t) {
		let n = this._argval || NO_PARAMS, r = this._argops, i, o, s, l;
		if (r) {
			let u = r.length;
			for (o = 0; o < u; ++o) i = r[o], s = i.op, l = s.modified() && s.stamp === t, n.set(i.name, i.index, s.value, l);
			if (r.initonly) {
				for (o = 0; o < u; ++o) i = r[o], i.op.targets().remove(this);
				this._argops = null, this._update = null;
			}
		}
		return n;
	},
	detach() {
		let t = this._argops, n, r, i, o;
		if (t) for (n = 0, r = t.length; n < r; ++n) i = t[n], o = i.op, o._targets && o._targets.remove(this);
		this.pulse = null, this.source = null;
	},
	evaluate(t) {
		let n = this._update;
		if (n) {
			let r = this.marshall(t.stamp), i = n.call(this, r, t);
			if (r.clear(), i !== this.value) this.value = i;
			else if (!this.modified()) return t.StopPropagation;
		}
	},
	run(t) {
		if (t.stamp < this.stamp) return t.StopPropagation;
		let n;
		return this.skip() ? (this.skip(!1), n = 0) : n = this.evaluate(t), this.pulse = n || t;
	}
};
function add$3(t, n, r, i) {
	let o = 1, s;
	return t instanceof Operator ? s = t : t && t.prototype instanceof Operator ? s = new t() : isFunction(t) ? s = new Operator(null, t) : (o = 0, s = new Operator(t, n)), this.rank(s), o && (i = r, r = n), r && this.connect(s, s.parameters(r, i)), this.touch(s), s;
}
function connect(t, n) {
	let r = t.rank, i = n.length;
	for (let o = 0; o < i; ++o) if (r < n[o].rank) {
		this.rerank(t);
		return;
	}
}
var STREAM_ID = 0;
function EventStream(t, n, r) {
	this.id = ++STREAM_ID, this.value = null, r && (this.receive = r), t && (this._filter = t), n && (this._apply = n);
}
function stream(t, n, r) {
	return new EventStream(t, n, r);
}
EventStream.prototype = {
	_filter: truthy,
	_apply: identity,
	targets() {
		return this._targets ||= UniqueList(id);
	},
	consume(t) {
		return arguments.length ? (this._consume = !!t, this) : !!this._consume;
	},
	receive(t) {
		if (this._filter(t)) {
			let n = this.value = this._apply(t), r = this._targets, i = r ? r.length : 0;
			for (let t = 0; t < i; ++t) r[t].receive(n);
			this._consume && (t.preventDefault(), t.stopPropagation());
		}
	},
	filter(t) {
		let n = stream(t);
		return this.targets().add(n), n;
	},
	apply(t) {
		let n = stream(null, t);
		return this.targets().add(n), n;
	},
	merge() {
		let t = stream();
		this.targets().add(t);
		for (let n = 0, r = arguments.length; n < r; ++n) arguments[n].targets().add(t);
		return t;
	},
	throttle(t) {
		let n = -1;
		return this.filter(() => {
			let r = Date.now();
			return r - n > t ? (n = r, 1) : 0;
		});
	},
	debounce(t) {
		let n = stream();
		return this.targets().add(stream(null, null, debounce(t, (t) => {
			let r = t.dataflow;
			n.receive(t), r && r.run && r.run();
		}))), n;
	},
	between(t, n) {
		let r = !1;
		return t.targets().add(stream(null, null, () => r = !0)), n.targets().add(stream(null, null, () => r = !1)), this.filter(() => r);
	},
	detach() {
		this._filter = truthy, this._targets = null;
	}
};
function events$1(t, n, r, i) {
	let o = this, s = stream(r, i), l = function(t) {
		t.dataflow = o;
		try {
			s.receive(t);
		} catch (t) {
			o.error(t);
		} finally {
			o.run();
		}
	}, u;
	u = typeof t == "string" && typeof document < "u" ? document.querySelectorAll(t) : array(t);
	let d = u.length;
	for (let t = 0; t < d; ++t) u[t].addEventListener(n, l);
	return s;
}
function parse$5(t, n) {
	let r = this.locale();
	return read(t, n, r.timeParse, r.utcParse);
}
function ingest(t, n, r) {
	return n = this.parse(n, r), this.pulse(t, this.changeset().insert(n));
}
async function request(t, n) {
	let r = this, i = 0, o;
	try {
		o = await r.loader().load(t, {
			context: "dataflow",
			response: responseType(n && n.type)
		});
		try {
			o = r.parse(o, n);
		} catch (n) {
			i = -2, r.warn("Data ingestion failed", t, n);
		}
	} catch (n) {
		i = -1, r.warn("Loading failed", t, n);
	}
	return {
		data: o,
		status: i
	};
}
async function preload(t, n, r) {
	let i = this, o = i._pending || loadPending(i);
	o.requests += 1;
	let s = await i.request(n, r);
	return i.pulse(t, i.changeset().remove(truthy).insert(s.data || [])), o.done(), s;
}
function loadPending(t) {
	let n, r = new Promise((t) => n = t);
	return r.requests = 0, r.done = () => {
		--r.requests === 0 && (t._pending = null, n(t));
	}, t._pending = r;
}
var SKIP$2 = { skip: !0 };
function on(t, n, r, i, o) {
	return (t instanceof Operator ? onOperator : onStream)(this, t, n, r, i, o), this;
}
function onStream(t, n, r, i, o, s) {
	let l = extend({}, s, SKIP$2), u, d;
	isFunction(r) || (r = constant(r)), i === void 0 ? u = (n) => t.touch(r(n)) : isFunction(i) ? (d = new Operator(null, i, o, !1), u = (n) => {
		d.evaluate(n);
		let i = r(n), o = d.value;
		isChangeSet(o) ? t.pulse(i, o, s) : t.update(i, o, l);
	}) : u = (n) => t.update(r(n), i, l), n.apply(u);
}
function onOperator(t, n, r, i, o, s) {
	if (i === void 0) n.targets().add(r);
	else {
		let l = s || {}, u = new Operator(null, updater(r, i), o, !1);
		u.modified(l.force), u.rank = n.rank, n.targets().add(u), r && (u.skip(!0), u.value = r.value, u.targets().add(r), t.connect(r, [u]));
	}
}
function updater(t, n) {
	return n = isFunction(n) ? n : constant(n), t ? function(r, i) {
		let o = n(r, i);
		return t.skip() || (t.skip(o !== this.value).value = o), o;
	} : n;
}
function rank(t) {
	t.rank = ++this._rank;
}
function rerank(t) {
	let n = [t], r, i, o;
	for (; n.length;) if (this.rank(r = n.pop()), i = r._targets) for (o = i.length; --o >= 0;) n.push(r = i[o]), r === t && error$1("Cycle detected in dataflow graph.");
}
var StopPropagation = {}, ADD = 1, REM = 2, MOD$1 = 4, ADD_REM = ADD | REM, ADD_MOD = ADD | MOD$1, ALL = REM | 5, REFLOW = 8, SOURCE = 16, NO_SOURCE = 32, NO_FIELDS = 64;
function Pulse(t, n, r) {
	this.dataflow = t, this.stamp = n ?? -1, this.add = [], this.rem = [], this.mod = [], this.fields = null, this.encode = r || null;
}
function materialize(t, n) {
	let r = [];
	return visitArray(t, n, (t) => r.push(t)), r;
}
function filter$1(t, n) {
	let r = {};
	return t.visit(n, (t) => {
		r[tupleid(t)] = 1;
	}), (t) => r[tupleid(t)] ? null : t;
}
function addFilter(t, n) {
	return t ? (r, i) => t(r, i) && n(r, i) : n;
}
Pulse.prototype = {
	StopPropagation,
	ADD,
	REM,
	MOD: MOD$1,
	ADD_REM,
	ADD_MOD,
	ALL,
	REFLOW,
	SOURCE,
	NO_SOURCE,
	NO_FIELDS,
	fork(t) {
		return new Pulse(this.dataflow).init(this, t);
	},
	clone() {
		let t = this.fork(ALL);
		return t.add = t.add.slice(), t.rem = t.rem.slice(), t.mod = t.mod.slice(), t.source &&= t.source.slice(), t.materialize(ALL | SOURCE);
	},
	addAll() {
		let t = this;
		return !t.source || t.add === t.rem || !t.rem.length && t.source.length === t.add.length ? t : (t = new Pulse(this.dataflow).init(this), t.add = t.source, t.rem = [], t);
	},
	init(t, n) {
		let r = this;
		return r.stamp = t.stamp, r.encode = t.encode, t.fields && !(n & NO_FIELDS) && (r.fields = t.fields), n & ADD ? (r.addF = t.addF, r.add = t.add) : (r.addF = null, r.add = []), n & REM ? (r.remF = t.remF, r.rem = t.rem) : (r.remF = null, r.rem = []), n & MOD$1 ? (r.modF = t.modF, r.mod = t.mod) : (r.modF = null, r.mod = []), n & NO_SOURCE ? (r.srcF = null, r.source = null) : (r.srcF = t.srcF, r.source = t.source, t.cleans && (r.cleans = t.cleans)), r;
	},
	runAfter(t) {
		this.dataflow.runAfter(t);
	},
	changed(t) {
		let n = t || ALL;
		return n & ADD && this.add.length || n & REM && this.rem.length || n & MOD$1 && this.mod.length;
	},
	reflow(t) {
		if (t) return this.fork(ALL).reflow();
		let n = this.add.length, r = this.source && this.source.length;
		return r && r !== n && (this.mod = this.source, n && this.filter(MOD$1, filter$1(this, ADD))), this;
	},
	clean(t) {
		return arguments.length ? (this.cleans = !!t, this) : this.cleans;
	},
	modifies(t) {
		let n = this.fields ||= {};
		return isArray(t) ? t.forEach((t) => n[t] = !0) : n[t] = !0, this;
	},
	modified(t, n) {
		let r = this.fields;
		return (n || this.mod.length) && r ? arguments.length ? isArray(t) ? t.some((t) => r[t]) : r[t] : !!r : !1;
	},
	filter(t, n) {
		let r = this;
		return t & ADD && (r.addF = addFilter(r.addF, n)), t & REM && (r.remF = addFilter(r.remF, n)), t & MOD$1 && (r.modF = addFilter(r.modF, n)), t & SOURCE && (r.srcF = addFilter(r.srcF, n)), r;
	},
	materialize(t) {
		t ||= ALL;
		let n = this;
		return t & ADD && n.addF && (n.add = materialize(n.add, n.addF), n.addF = null), t & REM && n.remF && (n.rem = materialize(n.rem, n.remF), n.remF = null), t & MOD$1 && n.modF && (n.mod = materialize(n.mod, n.modF), n.modF = null), t & SOURCE && n.srcF && (n.source = n.source.filter(n.srcF), n.srcF = null), n;
	},
	visit(t, n) {
		let r = this, i = n;
		if (t & SOURCE) return visitArray(r.source, r.srcF, i), r;
		t & ADD && visitArray(r.add, r.addF, i), t & REM && visitArray(r.rem, r.remF, i), t & MOD$1 && visitArray(r.mod, r.modF, i);
		let o = r.source;
		if (t & REFLOW && o) {
			let t = r.add.length + r.mod.length;
			t === o.length || (t ? visitArray(o, filter$1(r, ADD_MOD), i) : visitArray(o, r.srcF, i));
		}
		return r;
	}
};
function MultiPulse(t, n, r, i) {
	let o = this, s = 0;
	this.dataflow = t, this.stamp = n, this.fields = null, this.encode = i || null, this.pulses = r;
	for (let t of r) if (t.stamp === n) {
		if (t.fields) {
			let n = o.fields ||= {};
			for (let r in t.fields) n[r] = 1;
		}
		t.changed(o.ADD) && (s |= o.ADD), t.changed(o.REM) && (s |= o.REM), t.changed(o.MOD) && (s |= o.MOD);
	}
	this.changes = s;
}
inherits(MultiPulse, Pulse, {
	fork(t) {
		let n = new Pulse(this.dataflow).init(this, t & this.NO_FIELDS);
		return t !== void 0 && (t & n.ADD && this.visit(n.ADD, (t) => n.add.push(t)), t & n.REM && this.visit(n.REM, (t) => n.rem.push(t)), t & n.MOD && this.visit(n.MOD, (t) => n.mod.push(t))), n;
	},
	changed(t) {
		return this.changes & t;
	},
	modified(t) {
		let n = this, r = n.fields;
		return r && n.changes & n.MOD ? isArray(t) ? t.some((t) => r[t]) : r[t] : 0;
	},
	filter() {
		error$1("MultiPulse does not support filtering.");
	},
	materialize() {
		error$1("MultiPulse does not support materialization.");
	},
	visit(t, n) {
		let r = this, i = r.pulses, o = i.length, s = 0;
		if (t & r.SOURCE) for (; s < o; ++s) i[s].visit(t, n);
		else for (; s < o; ++s) i[s].stamp === r.stamp && i[s].visit(t, n);
		return r;
	}
});
async function evaluate(t, n, r) {
	let i = this, o = [];
	if (i._pulse) return reentrant(i);
	if (i._pending && await i._pending, n && await asyncCallback(i, n), !i._touched.length) return i.debug("Dataflow invoked, but nothing to do."), i;
	let s = ++i._clock;
	i._pulse = new Pulse(i, s, t), i._touched.forEach((t) => i._enqueue(t, !0)), i._touched = UniqueList(id);
	let l = 0, u, d, f;
	try {
		for (; i._heap.size() > 0;) {
			if (u = i._heap.pop(), u.rank !== u.qrank) {
				i._enqueue(u, !0);
				continue;
			}
			d = u.run(i._getPulse(u, t)), d.then ? d = await d : d.async && (o.push(d.async), d = StopPropagation), d !== StopPropagation && u._targets && u._targets.forEach((t) => i._enqueue(t)), ++l;
		}
	} catch (t) {
		i._heap.clear(), f = t;
	}
	if (i._input = {}, i._pulse = null, i.debug(`Pulse ${s}: ${l} operators`), f && (i._postrun = [], i.error(f)), i._postrun.length) {
		let t = i._postrun.sort((t, n) => n.priority - t.priority);
		i._postrun = [];
		for (let n = 0; n < t.length; ++n) await asyncCallback(i, t[n].callback);
	}
	return r && await asyncCallback(i, r), o.length && Promise.all(o).then((t) => i.runAsync(null, () => {
		t.forEach((t) => {
			try {
				t(i);
			} catch (t) {
				i.error(t);
			}
		});
	})), i;
}
async function runAsync(t, n, r) {
	for (; this._running;) await this._running;
	let i = () => this._running = null;
	return (this._running = this.evaluate(t, n, r)).then(i, i), this._running;
}
function run(t, n, r) {
	return this._pulse ? reentrant(this) : (this.evaluate(t, n, r), this);
}
function runAfter(t, n, r) {
	if (this._pulse || n) this._postrun.push({
		priority: r || 0,
		callback: t
	});
	else try {
		t(this);
	} catch (t) {
		this.error(t);
	}
}
function reentrant(t) {
	return t.error("Dataflow already running. Use runAsync() to chain invocations."), t;
}
function enqueue(t, n) {
	let r = t.stamp < this._clock;
	r && (t.stamp = this._clock), (r || n) && (t.qrank = t.rank, this._heap.push(t));
}
function getPulse(t, n) {
	let r = t.source, i = this._clock;
	return r && isArray(r) ? new MultiPulse(this, i, r.map((t) => t.pulse), n) : this._input[t.id] || singlePulse(this._pulse, r && r.pulse);
}
function singlePulse(t, n) {
	return n && n.stamp === t.stamp ? n : (t = t.fork(), n && n !== StopPropagation && (t.source = n.source), t);
}
var NO_OPT = {
	skip: !1,
	force: !1
};
function touch(t, n) {
	let r = n || NO_OPT;
	return this._pulse ? this._enqueue(t) : this._touched.add(t), r.skip && t.skip(!0), this;
}
function update$6(t, n, r) {
	let i = r || NO_OPT;
	return (t.set(n) || i.force) && this.touch(t, i), this;
}
function pulse(t, n, r) {
	this.touch(t, r || NO_OPT);
	let i = new Pulse(this, this._clock + (this._pulse ? 0 : 1)), o = t.pulse && t.pulse.source || [];
	return i.target = t, this._input[t.id] = n.pulse(i, o), this;
}
function Heap(t) {
	let n = [];
	return {
		clear: () => n = [],
		size: () => n.length,
		peek: () => n[0],
		push: (r) => (n.push(r), siftdown(n, 0, n.length - 1, t)),
		pop: () => {
			let r = n.pop(), i;
			return n.length ? (i = n[0], n[0] = r, siftup(n, 0, t)) : i = r, i;
		}
	};
}
function siftdown(t, n, r, i) {
	let o, s, l = t[r];
	for (; r > n;) {
		if (s = r - 1 >> 1, o = t[s], i(l, o) < 0) {
			t[r] = o, r = s;
			continue;
		}
		break;
	}
	return t[r] = l;
}
function siftup(t, n, r) {
	let i = n, o = t.length, s = t[n], l = (n << 1) + 1, u;
	for (; l < o;) u = l + 1, u < o && r(t[l], t[u]) >= 0 && (l = u), t[n] = t[l], n = l, l = (n << 1) + 1;
	return t[n] = s, siftdown(t, i, n, r);
}
function Dataflow() {
	this.logger(logger()), this.logLevel(1), this._clock = 0, this._rank = 0, this._locale = defaultLocale();
	try {
		this._loader = loader();
	} catch {}
	this._touched = UniqueList(id), this._input = {}, this._pulse = null, this._heap = Heap((t, n) => t.qrank - n.qrank), this._postrun = [];
}
function logMethod(t) {
	return function() {
		return this._log[t].apply(this, arguments);
	};
}
Dataflow.prototype = {
	stamp() {
		return this._clock;
	},
	loader(t) {
		return arguments.length ? (this._loader = t, this) : this._loader;
	},
	locale(t) {
		return arguments.length ? (this._locale = t, this) : this._locale;
	},
	logger(t) {
		return arguments.length ? (this._log = t, this) : this._log;
	},
	error: logMethod("error"),
	warn: logMethod("warn"),
	info: logMethod("info"),
	debug: logMethod("debug"),
	logLevel: logMethod("level"),
	cleanThreshold: 1e4,
	add: add$3,
	connect,
	rank,
	rerank,
	pulse,
	touch,
	update: update$6,
	changeset,
	ingest,
	parse: parse$5,
	preload,
	request,
	events: events$1,
	on,
	evaluate,
	run,
	runAsync,
	runAfter,
	_enqueue: enqueue,
	_getPulse: getPulse
};
function Transform(t, n) {
	Operator.call(this, t, null, n);
}
inherits(Transform, Operator, {
	run(t) {
		if (t.stamp < this.stamp) return t.StopPropagation;
		let n;
		return this.skip() ? this.skip(!1) : n = this.evaluate(t), n ||= t, n.then ? n = n.then((t) => this.pulse = t) : n !== t.StopPropagation && (this.pulse = n), n;
	},
	evaluate(t) {
		let n = this.marshall(t.stamp), r = this.transform(n, t);
		return n.clear(), r;
	},
	transform() {}
});
var transforms = {};
function definition(t) {
	let n = transform(t);
	return n && n.Definition || null;
}
function transform(t) {
	return t &&= t.toLowerCase(), has(transforms, t) ? transforms[t] : null;
}
function* numbers$1(t, n) {
	if (n == null) for (let n of t) n != null && n !== "" && (n = +n) >= n && (yield n);
	else {
		let r = -1;
		for (let i of t) i = n(i, ++r, t), i != null && i !== "" && (i = +i) >= i && (yield i);
	}
}
function quantiles(t, n, r) {
	let i = Float64Array.from(numbers$1(t, r));
	return i.sort(ascending$2), n.map((t) => quantileSorted(i, t));
}
function quartiles(t, n) {
	return quantiles(t, [
		.25,
		.5,
		.75
	], n);
}
function estimateBandwidth(t, n) {
	let r = t.length, i = deviation(t, n), o = quartiles(t, n), s = (o[2] - o[0]) / 1.34;
	return 1.06 * (Math.min(i, s) || i || Math.abs(o[0]) || 1) * r ** -.2;
}
function bin(t) {
	let n = t.maxbins || 20, r = t.base || 10, i = Math.log(r), o = t.divide || [5, 2], s = t.extent[0], l = t.extent[1], u, d, f, p, g, _, v = t.span || l - s || Math.abs(s) || 1;
	if (t.step) u = t.step;
	else if (t.steps) {
		for (p = v / n, g = 0, _ = t.steps.length; g < _ && t.steps[g] < p; ++g);
		u = t.steps[Math.max(0, g - 1)];
	} else {
		for (d = Math.ceil(Math.log(n) / i), f = t.minstep || 0, u = Math.max(f, r ** +(Math.round(Math.log(v) / i) - d)); Math.ceil(v / u) > n;) u *= r;
		for (g = 0, _ = o.length; g < _; ++g) p = u / o[g], p >= f && v / p <= n && (u = p);
	}
	p = Math.log(u);
	let S = r ** (-(p >= 0 ? 0 : ~~(-p / i) + 1) - 1);
	return (t.nice || t.nice === void 0) && (p = Math.floor(s / u + S) * u, s = s < p ? p - u : p, l = Math.ceil(l / u) * u), {
		start: s,
		stop: l === s ? s + u : l,
		step: u
	};
}
var random = Math.random;
function setRandom(t) {
	random = t;
}
function bootstrapCI(t, n, r, i) {
	if (!t.length) return [void 0, void 0];
	let o = Float64Array.from(numbers$1(t, i)), s = o.length, l = n, d, f, p, g;
	for (p = 0, g = Array(l); p < l; ++p) {
		for (d = 0, f = 0; f < s; ++f) d += o[~~(random() * s)];
		g[p] = d / s;
	}
	return g.sort(ascending$2), [quantile(g, r / 2), quantile(g, 1 - r / 2)];
}
function dotbin(t, n, r, i) {
	i ||= ((t) => t);
	let o = t.length, s = new Float64Array(o), l = 0, u = 1, d = i(t[0]), f = d, p = d + n, g;
	for (; u < o; ++u) {
		if (g = i(t[u]), g >= p) {
			for (f = (d + f) / 2; l < u; ++l) s[l] = f;
			p = g + n, d = g;
		}
		f = g;
	}
	for (f = (d + f) / 2; l < u; ++l) s[l] = f;
	return r ? smoothing(s, n + n / 4) : s;
}
function smoothing(t, n) {
	let r = t.length, i = 0, o = 1, s, l;
	for (; t[i] === t[o];) ++o;
	for (; o < r;) {
		for (s = o + 1; t[o] === t[s];) ++s;
		if (t[o] - t[o - 1] < n) {
			for (l = o + (i + s - o - o >> 1); l < o;) t[l++] = t[o];
			for (; l > o;) t[l--] = t[i];
		}
		i = o, o = s;
	}
	return t;
}
function lcg(t) {
	return function() {
		return t = (1103515245 * t + 12345) % 2147483647, t / 2147483647;
	};
}
function integer(t, n) {
	n ?? (n = t, t = 0);
	let r, i, o, s = {
		min(t) {
			return arguments.length ? (r = t || 0, o = i - r, s) : r;
		},
		max(t) {
			return arguments.length ? (i = t || 0, o = i - r, s) : i;
		},
		sample() {
			return r + Math.floor(o * random());
		},
		pdf(t) {
			return t === Math.floor(t) && t >= r && t < i ? 1 / o : 0;
		},
		cdf(t) {
			let n = Math.floor(t);
			return n < r ? 0 : n >= i ? 1 : (n - r + 1) / o;
		},
		icdf(t) {
			return t >= 0 && t <= 1 ? r - 1 + Math.floor(t * o) : NaN;
		}
	};
	return s.min(t).max(n);
}
var SQRT2PI = Math.sqrt(2 * Math.PI), SQRT2 = Math.SQRT2, nextSample = NaN;
function sampleNormal(t, n) {
	t ||= 0, n ??= 1;
	let r = 0, i = 0, o, s;
	if (nextSample === nextSample) r = nextSample, nextSample = NaN;
	else {
		do
			r = random() * 2 - 1, i = random() * 2 - 1, o = r * r + i * i;
		while (o === 0 || o > 1);
		s = Math.sqrt(-2 * Math.log(o) / o), r *= s, nextSample = i * s;
	}
	return t + r * n;
}
function densityNormal(t, n, r) {
	r ??= 1;
	let i = (t - (n || 0)) / r;
	return Math.exp(-.5 * i * i) / (r * SQRT2PI);
}
function cumulativeNormal(t, n, r) {
	n ||= 0, r ??= 1;
	let i = (t - n) / r, o = Math.abs(i), s;
	if (o > 37) s = 0;
	else {
		let t = Math.exp(-o * o / 2), n;
		o < 7.07106781186547 ? (n = .0352624965998911 * o + .700383064443688, n = n * o + 6.37396220353165, n = n * o + 33.912866078383, n = n * o + 112.079291497871, n = n * o + 221.213596169931, n = n * o + 220.206867912376, s = t * n, n = .0883883476483184 * o + 1.75566716318264, n = n * o + 16.064177579207, n = n * o + 86.7807322029461, n = n * o + 296.564248779674, n = n * o + 637.333633378831, n = n * o + 793.826512519948, n = n * o + 440.413735824752, s /= n) : (n = o + .65, n = o + 4 / n, n = o + 3 / n, n = o + 2 / n, n = o + 1 / n, s = t / n / 2.506628274631);
	}
	return i > 0 ? 1 - s : s;
}
function quantileNormal(t, n, r) {
	return t < 0 || t > 1 ? NaN : (n || 0) + (r ?? 1) * SQRT2 * erfinv(2 * t - 1);
}
function erfinv(t) {
	let n = -Math.log((1 - t) * (1 + t)), r;
	return n < 6.25 ? (n -= 3.125, r = -364441206401782e-35, r = -16850591381820166e-35 + r * n, r = 128584807152564e-32 + r * n, r = 11157877678025181e-33 + r * n, r = -1333171662854621e-31 + r * n, r = 20972767875968562e-33 + r * n, r = 6637638134358324e-30 + r * n, r = -4054566272975207e-29 + r * n, r = -8151934197605472e-29 + r * n, r = 26335093153082323e-28 + r * n, r = -12975133253453532e-27 + r * n, r = -5415412054294628e-26 + r * n, r = 1.0512122733215323e-9 + r * n, r = -4.112633980346984e-9 + r * n, r = -2.9070369957882005e-8 + r * n, r = 4.2347877827932404e-7 + r * n, r = -13654692000834679e-22 + r * n, r = -13882523362786469e-21 + r * n, r = .00018673420803405714 + r * n, r = -.000740702534166267 + r * n, r = -.006033670871430149 + r * n, r = .24015818242558962 + r * n, r = 1.6536545626831027 + r * n) : n < 16 ? (n = Math.sqrt(n) - 3.25, r = 2.2137376921775787e-9, r = 9.075656193888539e-8 + r * n, r = -2.7517406297064545e-7 + r * n, r = 1.8239629214389228e-8 + r * n, r = 15027403968909828e-22 + r * n, r = -4013867526981546e-21 + r * n, r = 29234449089955446e-22 + r * n, r = 12475304481671779e-21 + r * n, r = -47318229009055734e-21 + r * n, r = 6828485145957318e-20 + r * n, r = 24031110387097894e-21 + r * n, r = -.0003550375203628475 + r * n, r = .0009532893797373805 + r * n, r = -.0016882755560235047 + r * n, r = .002491442096107851 + r * n, r = -.003751208507569241 + r * n, r = .005370914553590064 + r * n, r = 1.0052589676941592 + r * n, r = 3.0838856104922208 + r * n) : Number.isFinite(n) ? (n = Math.sqrt(n) - 5, r = -27109920616438573e-27, r = -2555641816996525e-25 + r * n, r = 1.5076572693500548e-9 + r * n, r = -3.789465440126737e-9 + r * n, r = 7.61570120807834e-9 + r * n, r = -1.496002662714924e-8 + r * n, r = 2.914795345090108e-8 + r * n, r = -6.771199775845234e-8 + r * n, r = 2.2900482228026655e-7 + r * n, r = -9.9298272942317e-7 + r * n, r = 4526062597223154e-21 + r * n, r = -1968177810553167e-20 + r * n, r = 7599527703001776e-20 + r * n, r = -.00021503011930044477 + r * n, r = -.00013871931833623122 + r * n, r = 1.0103004648645344 + r * n, r = 4.849906401408584 + r * n) : r = Infinity, r * t;
}
function gaussian(t, n) {
	let r, i, o = {
		mean(t) {
			return arguments.length ? (r = t || 0, o) : r;
		},
		stdev(t) {
			return arguments.length ? (i = t ?? 1, o) : i;
		},
		sample: () => sampleNormal(r, i),
		pdf: (t) => densityNormal(t, r, i),
		cdf: (t) => cumulativeNormal(t, r, i),
		icdf: (t) => quantileNormal(t, r, i)
	};
	return o.mean(t).stdev(n);
}
function kde(t, n) {
	let r = gaussian(), i = 0, o = {
		data(r) {
			return arguments.length ? (t = r, i = r ? r.length : 0, o.bandwidth(n)) : t;
		},
		bandwidth(r) {
			return arguments.length ? (n = r, !n && t && (n = estimateBandwidth(t)), o) : n;
		},
		sample() {
			return t[~~(random() * i)] + n * r.sample();
		},
		pdf(o) {
			let s = 0, l = 0;
			for (; l < i; ++l) s += r.pdf((o - t[l]) / n);
			return s / n / i;
		},
		cdf(o) {
			let s = 0, l = 0;
			for (; l < i; ++l) s += r.cdf((o - t[l]) / n);
			return s / i;
		},
		icdf() {
			throw Error("KDE icdf not supported.");
		}
	};
	return o.data(t);
}
function sampleLogNormal(t, n) {
	return t ||= 0, n ??= 1, Math.exp(t + sampleNormal() * n);
}
function densityLogNormal(t, n, r) {
	if (t <= 0) return 0;
	n ||= 0, r ??= 1;
	let i = (Math.log(t) - n) / r;
	return Math.exp(-.5 * i * i) / (r * SQRT2PI * t);
}
function cumulativeLogNormal(t, n, r) {
	return cumulativeNormal(Math.log(t), n, r);
}
function quantileLogNormal(t, n, r) {
	return Math.exp(quantileNormal(t, n, r));
}
function lognormal(t, n) {
	let r, i, o = {
		mean(t) {
			return arguments.length ? (r = t || 0, o) : r;
		},
		stdev(t) {
			return arguments.length ? (i = t ?? 1, o) : i;
		},
		sample: () => sampleLogNormal(r, i),
		pdf: (t) => densityLogNormal(t, r, i),
		cdf: (t) => cumulativeLogNormal(t, r, i),
		icdf: (t) => quantileLogNormal(t, r, i)
	};
	return o.mean(t).stdev(n);
}
function mixture(t, n) {
	let r = 0, i;
	function o(t) {
		let n = [], i = 0, o;
		for (o = 0; o < r; ++o) i += n[o] = t[o] == null ? 1 : +t[o];
		for (o = 0; o < r; ++o) n[o] /= i;
		return n;
	}
	let s = {
		weights(t) {
			return arguments.length ? (i = o(n = t || []), s) : n;
		},
		distributions(i) {
			return arguments.length ? (i ? (r = i.length, t = i) : (r = 0, t = []), s.weights(n)) : t;
		},
		sample() {
			let n = random(), o = t[r - 1], s = i[0], l = 0;
			for (; l < r - 1; s += i[++l]) if (n < s) {
				o = t[l];
				break;
			}
			return o.sample();
		},
		pdf(n) {
			let o = 0, s = 0;
			for (; s < r; ++s) o += i[s] * t[s].pdf(n);
			return o;
		},
		cdf(n) {
			let o = 0, s = 0;
			for (; s < r; ++s) o += i[s] * t[s].cdf(n);
			return o;
		},
		icdf() {
			throw Error("Mixture icdf not supported.");
		}
	};
	return s.distributions(t).weights(n);
}
function sampleUniform(t, n) {
	return n ?? (n = t ?? 1, t = 0), t + (n - t) * random();
}
function densityUniform(t, n, r) {
	return r ?? (r = n ?? 1, n = 0), t >= n && t <= r ? 1 / (r - n) : 0;
}
function cumulativeUniform(t, n, r) {
	return r ?? (r = n ?? 1, n = 0), t < n ? 0 : t > r ? 1 : (t - n) / (r - n);
}
function quantileUniform(t, n, r) {
	return r ?? (r = n ?? 1, n = 0), t >= 0 && t <= 1 ? n + t * (r - n) : NaN;
}
function uniform(t, n) {
	let r, i, o = {
		min(t) {
			return arguments.length ? (r = t || 0, o) : r;
		},
		max(t) {
			return arguments.length ? (i = t ?? 1, o) : i;
		},
		sample: () => sampleUniform(r, i),
		pdf: (t) => densityUniform(t, r, i),
		cdf: (t) => cumulativeUniform(t, r, i),
		icdf: (t) => quantileUniform(t, r, i)
	};
	return n ?? (n = t ?? 1, t = 0), o.min(t).max(n);
}
function constant$1(t, n, r) {
	let i = 0, o = 0;
	for (let s of t) {
		let t = r(s);
		n(s) == null || t == null || isNaN(t) || (i += (t - i) / ++o);
	}
	return {
		coef: [i],
		predict: () => i,
		rSquared: 0
	};
}
function ols(t, n, r, i) {
	let o = i - t * t, s = Math.abs(o) < 1e-24 ? 0 : (r - t * n) / o;
	return [n - s * t, s];
}
function points(t, n, r, i) {
	t = t.filter((t) => {
		let i = n(t), o = r(t);
		return i != null && (i = +i) >= i && o != null && (o = +o) >= o;
	}), i && t.sort((t, r) => n(t) - n(r));
	let o = t.length, s = new Float64Array(o), l = new Float64Array(o), u = 0, d = 0, f = 0, p, g, _;
	for (_ of t) s[u] = p = +n(_), l[u] = g = +r(_), ++u, d += (p - d) / u, f += (g - f) / u;
	for (u = 0; u < o; ++u) s[u] -= d, l[u] -= f;
	return [
		s,
		l,
		d,
		f
	];
}
function visitPoints(t, n, r, i) {
	let o = -1, s, l;
	for (let u of t) s = n(u), l = r(u), s != null && (s = +s) >= s && l != null && (l = +l) >= l && i(s, l, ++o);
}
function rSquared(t, n, r, i, o) {
	let s = 0, l = 0;
	return visitPoints(t, n, r, (t, n) => {
		let r = n - o(t), u = n - i;
		s += r * r, l += u * u;
	}), 1 - s / l;
}
function linear(t, n, r) {
	let i = 0, o = 0, s = 0, l = 0, u = 0;
	visitPoints(t, n, r, (t, n) => {
		++u, i += (t - i) / u, o += (n - o) / u, s += (t * n - s) / u, l += (t * t - l) / u;
	});
	let d = ols(i, o, s, l), f = (t) => d[0] + d[1] * t;
	return {
		coef: d,
		predict: f,
		rSquared: rSquared(t, n, r, o, f)
	};
}
function log$1(t, n, r) {
	let i = 0, o = 0, s = 0, l = 0, u = 0;
	visitPoints(t, n, r, (t, n) => {
		++u, t = Math.log(t), i += (t - i) / u, o += (n - o) / u, s += (t * n - s) / u, l += (t * t - l) / u;
	});
	let d = ols(i, o, s, l), f = (t) => d[0] + d[1] * Math.log(t);
	return {
		coef: d,
		predict: f,
		rSquared: rSquared(t, n, r, o, f)
	};
}
function exp(t, n, r) {
	let [i, o, s, l] = points(t, n, r), u = 0, d = 0, f = 0, p = 0, g = 0, _, v, S;
	visitPoints(t, n, r, (t, n) => {
		_ = i[g++], v = Math.log(n), S = _ * n, u += (n * v - u) / g, d += (S - d) / g, f += (S * v - f) / g, p += (_ * S - p) / g;
	});
	let [T, E] = ols(d / l, u / l, f / l, p / l), O = (t) => Math.exp(T + E * (t - s));
	return {
		coef: [Math.exp(T - E * s), E],
		predict: O,
		rSquared: rSquared(t, n, r, l, O)
	};
}
function pow(t, n, r) {
	let i = 0, o = 0, s = 0, l = 0, u = 0, d = 0;
	visitPoints(t, n, r, (t, n) => {
		let r = Math.log(t), f = Math.log(n);
		++d, i += (r - i) / d, o += (f - o) / d, s += (r * f - s) / d, l += (r * r - l) / d, u += (n - u) / d;
	});
	let f = ols(i, o, s, l), p = (t) => f[0] * t ** +f[1];
	return f[0] = Math.exp(f[0]), {
		coef: f,
		predict: p,
		rSquared: rSquared(t, n, r, u, p)
	};
}
function quad(t, n, r) {
	let [i, o, s, l] = points(t, n, r), u = i.length, d = 0, f = 0, p = 0, g = 0, _ = 0, v, S, T, E;
	for (v = 0; v < u;) S = i[v], T = o[v++], E = S * S, d += (E - d) / v, f += (E * S - f) / v, p += (E * E - p) / v, g += (S * T - g) / v, _ += (E * T - _) / v;
	let O = p - d * d, k = d * O - f * f, A = (_ * d - g * f) / k, j = (g * O - _ * f) / k, N = -A * d, P = (t) => (t -= s, A * t * t + j * t + N + l);
	return {
		coef: [
			N - j * s + A * s * s + l,
			j - 2 * A * s,
			A
		],
		predict: P,
		rSquared: rSquared(t, n, r, l, P)
	};
}
function poly(t, n, r, i) {
	if (i === 0) return constant$1(t, n, r);
	if (i === 1) return linear(t, n, r);
	if (i === 2) return quad(t, n, r);
	let [o, s, l, u] = points(t, n, r), d = o.length, f = [], p = [], g = i + 1, _, v, S, T, E;
	for (_ = 0; _ < g; ++_) {
		for (S = 0, T = 0; S < d; ++S) T += o[S] ** +_ * s[S];
		for (f.push(T), E = new Float64Array(g), v = 0; v < g; ++v) {
			for (S = 0, T = 0; S < d; ++S) T += o[S] ** +(_ + v);
			E[v] = T;
		}
		p.push(E);
	}
	p.push(f);
	let O = gaussianElimination(p), k = (t) => {
		t -= l;
		let n = u + O[0] + O[1] * t + O[2] * t * t;
		for (_ = 3; _ < g; ++_) n += O[_] * t ** +_;
		return n;
	};
	return {
		coef: uncenter(g, O, -l, u),
		predict: k,
		rSquared: rSquared(t, n, r, u, k)
	};
}
function uncenter(t, n, r, i) {
	let o = Array(t), s, l, u, d;
	for (s = 0; s < t; ++s) o[s] = 0;
	for (s = t - 1; s >= 0; --s) for (u = n[s], d = 1, o[s] += u, l = 1; l <= s; ++l) d *= (s + 1 - l) / l, o[s - l] += u * r ** +l * d;
	return o[0] += i, o;
}
function gaussianElimination(t) {
	let n = t.length - 1, r = [], i, o, s, l, u;
	for (i = 0; i < n; ++i) {
		for (l = i, o = i + 1; o < n; ++o) Math.abs(t[i][o]) > Math.abs(t[i][l]) && (l = o);
		for (s = i; s < n + 1; ++s) u = t[s][i], t[s][i] = t[s][l], t[s][l] = u;
		for (o = i + 1; o < n; ++o) for (s = n; s >= i; s--) t[s][o] -= t[s][i] * t[i][o] / t[i][i];
	}
	for (o = n - 1; o >= 0; --o) {
		for (u = 0, s = o + 1; s < n; ++s) u += t[s][o] * r[s];
		r[o] = (t[n][o] - u) / t[o][o];
	}
	return r;
}
var maxiters = 2, epsilon$1 = 1e-12;
function loess(t, n, r, i) {
	let [o, s, l, u] = points(t, n, r, !0), d = o.length, f = Math.max(2, ~~(i * d)), p = new Float64Array(d), g = new Float64Array(d), _ = new Float64Array(d).fill(1);
	for (let t = -1; ++t <= maxiters;) {
		let n = [0, f - 1];
		for (let t = 0; t < d; ++t) {
			let r = o[t], i = n[0], l = n[1], u = r - o[i] > o[l] - r ? i : l, d = 0, f = 0, v = 0, S = 0, T = 0, E = 1 / Math.abs(o[u] - r || 1);
			for (let t = i; t <= l; ++t) {
				let n = o[t], i = s[t], l = tricube(Math.abs(r - n) * E) * _[t], u = n * l;
				d += l, f += u, v += i * l, S += i * u, T += n * u;
			}
			let [O, k] = ols(f / d, v / d, S / d, T / d);
			p[t] = O + k * r, g[t] = Math.abs(s[t] - p[t]), updateInterval(o, t + 1, n);
		}
		if (t === maxiters) break;
		let r = median(g);
		if (Math.abs(r) < epsilon$1) break;
		for (let t = 0, n, i; t < d; ++t) n = g[t] / (6 * r), _[t] = n >= 1 ? epsilon$1 : (i = 1 - n * n) * i;
	}
	return output$1(o, p, l, u);
}
function tricube(t) {
	return (t = 1 - t * t * t) * t * t;
}
function updateInterval(t, n, r) {
	let i = t[n], o = r[0], s = r[1] + 1;
	if (!(s >= t.length)) for (; n > o && t[s] - i <= i - t[o];) r[0] = ++o, r[1] = s, ++s;
}
function output$1(t, n, r, i) {
	let o = t.length, s = [], l = 0, u = 0, d = [], f;
	for (; l < o; ++l) f = t[l] + r, d[0] === f ? d[1] += (n[l] - d[1]) / ++u : (u = 0, d[1] += i, d = [f, n[l]], s.push(d));
	return d[1] += i, s;
}
var MIN_RADIANS = .5 * Math.PI / 180;
function sampleCurve(t, n, r, i) {
	r ||= 25, i = Math.max(r, i || 200);
	let o = (n) => [n, t(n)], s = n[0], l = n[1], u = l - s, d = u / i, f = [o(s)], p = [];
	if (r === i) {
		for (let t = 1; t < i; ++t) f.push(o(s + t / r * u));
		return f.push(o(l)), f;
	} else {
		p.push(o(l));
		for (let t = r; --t > 0;) p.push(o(s + t / r * u));
	}
	let g = f[0], _ = p[p.length - 1], v = 1 / u, S = scaleY(g[1], p);
	for (; _;) {
		let t = o((g[0] + _[0]) / 2);
		t[0] - g[0] >= d && angleDelta(g, t, _, v, S) > MIN_RADIANS ? p.push(t) : (g = _, f.push(_), p.pop()), _ = p[p.length - 1];
	}
	return f;
}
function scaleY(t, n) {
	let r = t, i = t, o = n.length;
	for (let t = 0; t < o; ++t) {
		let o = n[t][1];
		o < r && (r = o), o > i && (i = o);
	}
	return 1 / (i - r);
}
function angleDelta(t, n, r, i, o) {
	let s = Math.atan2(o * (r[1] - t[1]), i * (r[0] - t[0])), l = Math.atan2(o * (n[1] - t[1]), i * (n[0] - t[0]));
	return Math.abs(s - l);
}
var vega_transforms_exports = /* @__PURE__ */ __export({
	aggregate: () => Aggregate$1,
	bin: () => Bin,
	collect: () => Collect$1,
	compare: () => Compare$1,
	countpattern: () => CountPattern,
	cross: () => Cross,
	density: () => Density,
	dotbin: () => DotBin,
	expression: () => Expression$1,
	extent: () => Extent,
	facet: () => Facet$1,
	field: () => Field$1,
	filter: () => Filter,
	flatten: () => Flatten,
	fold: () => Fold,
	formula: () => Formula,
	generate: () => Generate,
	impute: () => Impute,
	joinaggregate: () => JoinAggregate,
	kde: () => KDE,
	key: () => Key$1,
	load: () => Load$1,
	lookup: () => Lookup,
	multiextent: () => MultiExtent$1,
	multivalues: () => MultiValues$1,
	params: () => Params$2,
	pivot: () => Pivot,
	prefacet: () => PreFacet$1,
	project: () => Project,
	proxy: () => Proxy$1,
	quantile: () => Quantile$1,
	relay: () => Relay$1,
	sample: () => Sample,
	sequence: () => Sequence,
	sieve: () => Sieve$1,
	subflow: () => Subflow,
	timeunit: () => TimeUnit,
	tupleindex: () => TupleIndex,
	values: () => Values$1,
	window: () => Window
});
function multikey(t) {
	return (n) => {
		let r = t.length, i = 1, o = String(t[0](n));
		for (; i < r; ++i) o += "|" + t[i](n);
		return o;
	};
}
function groupkey(t) {
	return !t || !t.length ? function() {
		return "";
	} : t.length === 1 ? t[0] : multikey(t);
}
function measureName(t, n, r) {
	return r || t + (n ? "_" + n : "");
}
var noop$1 = () => {}, base_op = {
	init: noop$1,
	add: noop$1,
	rem: noop$1,
	idx: 0
}, AggregateOps = {
	values: {
		init: (t) => t.cell.store = !0,
		value: (t) => t.cell.data.values(),
		idx: -1
	},
	count: { value: (t) => t.cell.num },
	__count__: { value: (t) => t.missing + t.valid },
	missing: { value: (t) => t.missing },
	valid: { value: (t) => t.valid },
	sum: {
		init: (t) => t.sum = 0,
		value: (t) => t.valid ? t.sum : void 0,
		add: (t, n) => t.sum += +n,
		rem: (t, n) => t.sum -= n
	},
	product: {
		init: (t) => t.product = 1,
		value: (t) => t.valid ? t.product : void 0,
		add: (t, n) => t.product *= n,
		rem: (t, n) => t.product /= n
	},
	mean: {
		init: (t) => t.mean = 0,
		value: (t) => t.valid ? t.mean : void 0,
		add: (t, n) => (t.mean_d = n - t.mean, t.mean += t.mean_d / t.valid),
		rem: (t, n) => (t.mean_d = n - t.mean, t.mean -= t.valid ? t.mean_d / t.valid : t.mean)
	},
	average: {
		value: (t) => t.valid ? t.mean : void 0,
		req: ["mean"],
		idx: 1
	},
	variance: {
		init: (t) => t.dev = 0,
		value: (t) => t.valid > 1 ? t.dev / (t.valid - 1) : void 0,
		add: (t, n) => t.dev += t.mean_d * (n - t.mean),
		rem: (t, n) => t.dev -= t.mean_d * (n - t.mean),
		req: ["mean"],
		idx: 1
	},
	variancep: {
		value: (t) => t.valid > 1 ? t.dev / t.valid : void 0,
		req: ["variance"],
		idx: 2
	},
	stdev: {
		value: (t) => t.valid > 1 ? Math.sqrt(t.dev / (t.valid - 1)) : void 0,
		req: ["variance"],
		idx: 2
	},
	stdevp: {
		value: (t) => t.valid > 1 ? Math.sqrt(t.dev / t.valid) : void 0,
		req: ["variance"],
		idx: 2
	},
	stderr: {
		value: (t) => t.valid > 1 ? Math.sqrt(t.dev / (t.valid * (t.valid - 1))) : void 0,
		req: ["variance"],
		idx: 2
	},
	distinct: {
		value: (t) => t.cell.data.distinct(t.get),
		req: ["values"],
		idx: 3
	},
	ci0: {
		value: (t) => t.cell.data.ci0(t.get),
		req: ["values"],
		idx: 3
	},
	ci1: {
		value: (t) => t.cell.data.ci1(t.get),
		req: ["values"],
		idx: 3
	},
	median: {
		value: (t) => t.cell.data.q2(t.get),
		req: ["values"],
		idx: 3
	},
	q1: {
		value: (t) => t.cell.data.q1(t.get),
		req: ["values"],
		idx: 3
	},
	q3: {
		value: (t) => t.cell.data.q3(t.get),
		req: ["values"],
		idx: 3
	},
	min: {
		init: (t) => t.min = void 0,
		value: (t) => t.min = Number.isNaN(t.min) ? t.cell.data.min(t.get) : t.min,
		add: (t, n) => {
			(n < t.min || t.min === void 0) && (t.min = n);
		},
		rem: (t, n) => {
			n <= t.min && (t.min = NaN);
		},
		req: ["values"],
		idx: 4
	},
	max: {
		init: (t) => t.max = void 0,
		value: (t) => t.max = Number.isNaN(t.max) ? t.cell.data.max(t.get) : t.max,
		add: (t, n) => {
			(n > t.max || t.max === void 0) && (t.max = n);
		},
		rem: (t, n) => {
			n >= t.max && (t.max = NaN);
		},
		req: ["values"],
		idx: 4
	},
	argmin: {
		init: (t) => t.argmin = void 0,
		value: (t) => t.argmin || t.cell.data.argmin(t.get),
		add: (t, n, r) => {
			n < t.min && (t.argmin = r);
		},
		rem: (t, n) => {
			n <= t.min && (t.argmin = void 0);
		},
		req: ["min", "values"],
		idx: 3
	},
	argmax: {
		init: (t) => t.argmax = void 0,
		value: (t) => t.argmax || t.cell.data.argmax(t.get),
		add: (t, n, r) => {
			n > t.max && (t.argmax = r);
		},
		rem: (t, n) => {
			n >= t.max && (t.argmax = void 0);
		},
		req: ["max", "values"],
		idx: 3
	},
	exponential: {
		init: (t, n) => {
			t.exp = 0, t.exp_r = n;
		},
		value: (t) => t.valid ? t.exp * (1 - t.exp_r) / (1 - t.exp_r ** t.valid) : void 0,
		add: (t, n) => t.exp = t.exp_r * t.exp + n,
		rem: (t, n) => t.exp = (t.exp - n / t.exp_r ** (t.valid - 1)) / t.exp_r
	},
	exponentialb: {
		value: (t) => t.valid ? t.exp * (1 - t.exp_r) : void 0,
		req: ["exponential"],
		idx: 1
	}
}, ValidAggregateOps = Object.keys(AggregateOps).filter((t) => t !== "__count__");
function measure(t, n) {
	return (r, i) => extend({
		name: t,
		aggregate_param: i,
		out: r || t
	}, base_op, n);
}
[...ValidAggregateOps, "__count__"].forEach((t) => {
	AggregateOps[t] = measure(t, AggregateOps[t]);
});
function createMeasure(t, n, r) {
	return AggregateOps[t](r, n);
}
function compareIndex(t, n) {
	return t.idx - n.idx;
}
function resolve(t) {
	let n = {};
	t.forEach((t) => n[t.name] = t);
	let r = (t) => {
		t.req && t.req.forEach((t) => {
			n[t] || r(n[t] = AggregateOps[t]());
		});
	};
	return t.forEach(r), Object.values(n).sort(compareIndex);
}
function init() {
	this.valid = 0, this.missing = 0, this._ops.forEach((t) => t.aggregate_param == null ? t.init(this) : t.init(this, t.aggregate_param));
}
function add$2(t, n) {
	if (t == null || t === "") {
		++this.missing;
		return;
	}
	t === t && (++this.valid, this._ops.forEach((r) => r.add(this, t, n)));
}
function rem(t, n) {
	if (t == null || t === "") {
		--this.missing;
		return;
	}
	t === t && (--this.valid, this._ops.forEach((r) => r.rem(this, t, n)));
}
function set$3(t) {
	return this._out.forEach((n) => t[n.out] = n.value(this)), t;
}
function compileMeasures(t, n) {
	let r = n || identity, i = resolve(t), o = t.slice().sort(compareIndex);
	function s(t) {
		this._ops = i, this._out = o, this.cell = t, this.init();
	}
	return s.prototype.init = init, s.prototype.add = add$2, s.prototype.rem = rem, s.prototype.set = set$3, s.prototype.get = r, s.fields = t.map((t) => t.out), s;
}
function TupleStore(t) {
	this._key = t ? field$1(t) : tupleid, this.reset();
}
var prototype$1 = TupleStore.prototype;
prototype$1.reset = function() {
	this._add = [], this._rem = [], this._ext = null, this._get = null, this._q = null;
}, prototype$1.add = function(t) {
	this._add.push(t);
}, prototype$1.rem = function(t) {
	this._rem.push(t);
}, prototype$1.values = function() {
	if (this._get = null, this._rem.length === 0) return this._add;
	let t = this._add, n = this._rem, r = this._key, i = t.length, o = n.length, s = Array(i - o), l = {}, u, d, f;
	for (u = 0; u < o; ++u) l[r(n[u])] = 1;
	for (u = 0, d = 0; u < i; ++u) l[r(f = t[u])] ? l[r(f)] = 0 : s[d++] = f;
	return this._rem = [], this._add = s;
}, prototype$1.distinct = function(t) {
	let n = this.values(), r = {}, i = n.length, o = 0, s;
	for (; --i >= 0;) s = t(n[i]) + "", has(r, s) || (r[s] = 1, ++o);
	return o;
}, prototype$1.extent = function(t) {
	if (this._get !== t || !this._ext) {
		let n = this.values(), r = extentIndex(n, t);
		this._ext = [n[r[0]], n[r[1]]], this._get = t;
	}
	return this._ext;
}, prototype$1.argmin = function(t) {
	return this.extent(t)[0] || {};
}, prototype$1.argmax = function(t) {
	return this.extent(t)[1] || {};
}, prototype$1.min = function(t) {
	let n = this.extent(t)[0];
	return n == null ? void 0 : t(n);
}, prototype$1.max = function(t) {
	let n = this.extent(t)[1];
	return n == null ? void 0 : t(n);
}, prototype$1.quartile = function(t) {
	return (this._get !== t || !this._q) && (this._q = quartiles(this.values(), t), this._get = t), this._q;
}, prototype$1.q1 = function(t) {
	return this.quartile(t)[0];
}, prototype$1.q2 = function(t) {
	return this.quartile(t)[1];
}, prototype$1.q3 = function(t) {
	return this.quartile(t)[2];
}, prototype$1.ci = function(t) {
	return (this._get !== t || !this._ci) && (this._ci = bootstrapCI(this.values(), 1e3, .05, t), this._get = t), this._ci;
}, prototype$1.ci0 = function(t) {
	return this.ci(t)[0];
}, prototype$1.ci1 = function(t) {
	return this.ci(t)[1];
};
function Aggregate$1(t) {
	Transform.call(this, null, t), this._adds = [], this._mods = [], this._alen = 0, this._mlen = 0, this._drop = !0, this._cross = !1, this._dims = [], this._dnames = [], this._measures = [], this._countOnly = !1, this._counts = null, this._prev = null, this._inputs = null, this._outputs = null;
}
Aggregate$1.Definition = {
	type: "Aggregate",
	metadata: {
		generates: !0,
		changes: !0
	},
	params: [
		{
			name: "groupby",
			type: "field",
			array: !0
		},
		{
			name: "ops",
			type: "enum",
			array: !0,
			values: ValidAggregateOps
		},
		{
			name: "aggregate_params",
			type: "number",
			null: !0,
			array: !0
		},
		{
			name: "fields",
			type: "field",
			null: !0,
			array: !0
		},
		{
			name: "as",
			type: "string",
			null: !0,
			array: !0
		},
		{
			name: "drop",
			type: "boolean",
			default: !0
		},
		{
			name: "cross",
			type: "boolean",
			default: !1
		},
		{
			name: "key",
			type: "field"
		}
	]
}, inherits(Aggregate$1, Transform, {
	transform(t, n) {
		let r = this, i = n.fork(n.NO_SOURCE | n.NO_FIELDS), o = t.modified();
		return r.stamp = i.stamp, r.value && (o || n.modified(r._inputs, !0)) ? (r._prev = r.value, r.value = o ? r.init(t) : Object.create(null), n.visit(n.SOURCE, (t) => r.add(t))) : (r.value = r.value || r.init(t), n.visit(n.REM, (t) => r.rem(t)), n.visit(n.ADD, (t) => r.add(t))), i.modifies(r._outputs), r._drop = t.drop !== !1, t.cross && r._dims.length > 1 && (r._drop = !1, r.cross()), n.clean() && r._drop && i.clean(!0).runAfter(() => this.clean()), r.changes(i);
	},
	cross() {
		let t = this, n = t.value, r = t._dnames, i = r.map(() => ({})), o = r.length;
		function s(t) {
			let n, s, l, u;
			for (n in t) for (l = t[n].tuple, s = 0; s < o; ++s) i[s][u = l[r[s]]] = u;
		}
		s(t._prev), s(n);
		function l(s, u, d) {
			let f = r[d], p = i[d++];
			for (let r in p) {
				let i = s ? s + "|" + r : r;
				u[f] = p[r], d < o ? l(i, u, d) : n[i] || t.cell(i, u);
			}
		}
		l("", {}, 0);
	},
	init(t) {
		let n = this._inputs = [], r = this._outputs = [], i = {};
		function o(t) {
			let r = array(accessorFields(t)), o = r.length, s = 0, l;
			for (; s < o; ++s) i[l = r[s]] || (i[l] = 1, n.push(l));
		}
		this._dims = array(t.groupby), this._dnames = this._dims.map((t) => {
			let n = accessorName(t);
			return o(t), r.push(n), n;
		}), this.cellkey = t.key ? t.key : groupkey(this._dims), this._countOnly = !0, this._counts = [], this._measures = [];
		let s = t.fields || [null], l = t.ops || ["count"], u = t.aggregate_params || [null], d = t.as || [], f = s.length, p = {}, g, _, v, S, T, E, O;
		for (f !== l.length && error$1("Unmatched number of fields and aggregate ops."), O = 0; O < f; ++O) {
			if (g = s[O], _ = l[O], v = u[O] || null, g == null && _ !== "count" && error$1("Null aggregate field specified."), T = accessorName(g), E = measureName(_, T, d[O]), r.push(E), _ === "count") {
				this._counts.push(E);
				continue;
			}
			S = p[T], S || (o(g), S = p[T] = [], S.field = g, this._measures.push(S)), _ !== "count" && (this._countOnly = !1), S.push(createMeasure(_, v, E));
		}
		return this._measures = this._measures.map((t) => compileMeasures(t, t.field)), Object.create(null);
	},
	cellkey: groupkey(),
	cell(t, n) {
		let r = this.value[t];
		return r ? r.num === 0 && this._drop && r.stamp < this.stamp ? (r.stamp = this.stamp, this._adds[this._alen++] = r) : r.stamp < this.stamp && (r.stamp = this.stamp, this._mods[this._mlen++] = r) : (r = this.value[t] = this.newcell(t, n), this._adds[this._alen++] = r), r;
	},
	newcell(t, n) {
		let r = {
			key: t,
			num: 0,
			agg: null,
			tuple: this.newtuple(n, this._prev && this._prev[t]),
			stamp: this.stamp,
			store: !1
		};
		if (!this._countOnly) {
			let t = this._measures, n = t.length;
			r.agg = Array(n);
			for (let i = 0; i < n; ++i) r.agg[i] = new t[i](r);
		}
		return r.store && (r.data = new TupleStore()), r;
	},
	newtuple(t, n) {
		let r = this._dnames, i = this._dims, o = i.length, s = {};
		for (let n = 0; n < o; ++n) s[r[n]] = i[n](t);
		return n ? replace$1(n.tuple, s) : ingest$1(s);
	},
	clean() {
		let t = this.value;
		for (let n in t) t[n].num === 0 && delete t[n];
	},
	add(t) {
		let n = this.cellkey(t), r = this.cell(n, t);
		if (r.num += 1, this._countOnly) return;
		r.store && r.data.add(t);
		let i = r.agg;
		for (let n = 0, r = i.length; n < r; ++n) i[n].add(i[n].get(t), t);
	},
	rem(t) {
		let n = this.cellkey(t), r = this.cell(n, t);
		if (--r.num, this._countOnly) return;
		r.store && r.data.rem(t);
		let i = r.agg;
		for (let n = 0, r = i.length; n < r; ++n) i[n].rem(i[n].get(t), t);
	},
	celltuple(t) {
		let n = t.tuple, r = this._counts;
		t.store && t.data.values();
		for (let i = 0, o = r.length; i < o; ++i) n[r[i]] = t.num;
		if (!this._countOnly) {
			let r = t.agg;
			for (let t = 0, i = r.length; t < i; ++t) r[t].set(n);
		}
		return n;
	},
	changes(t) {
		let n = this._adds, r = this._mods, i = this._prev, o = this._drop, s = t.add, l = t.rem, u = t.mod, d, f, p, g;
		if (i) for (f in i) d = i[f], (!o || d.num) && l.push(d.tuple);
		for (p = 0, g = this._alen; p < g; ++p) s.push(this.celltuple(n[p])), n[p] = null;
		for (p = 0, g = this._mlen; p < g; ++p) d = r[p], (d.num === 0 && o ? l : u).push(this.celltuple(d)), r[p] = null;
		return this._alen = this._mlen = 0, this._prev = null, t;
	}
});
var EPSILON$1 = 1e-14;
function Bin(t) {
	Transform.call(this, null, t);
}
Bin.Definition = {
	type: "Bin",
	metadata: { modifies: !0 },
	params: [
		{
			name: "field",
			type: "field",
			required: !0
		},
		{
			name: "interval",
			type: "boolean",
			default: !0
		},
		{
			name: "anchor",
			type: "number"
		},
		{
			name: "maxbins",
			type: "number",
			default: 20
		},
		{
			name: "base",
			type: "number",
			default: 10
		},
		{
			name: "divide",
			type: "number",
			array: !0,
			default: [5, 2]
		},
		{
			name: "extent",
			type: "number",
			array: !0,
			length: 2,
			required: !0
		},
		{
			name: "span",
			type: "number"
		},
		{
			name: "step",
			type: "number"
		},
		{
			name: "steps",
			type: "number",
			array: !0
		},
		{
			name: "minstep",
			type: "number",
			default: 0
		},
		{
			name: "nice",
			type: "boolean",
			default: !0
		},
		{
			name: "name",
			type: "string"
		},
		{
			name: "as",
			type: "string",
			array: !0,
			length: 2,
			default: ["bin0", "bin1"]
		}
	]
}, inherits(Bin, Transform, {
	transform(t, n) {
		let r = t.interval !== !1, i = this._bins(t), o = i.start, s = i.step, l = t.as || ["bin0", "bin1"], u = l[0], d = l[1], f;
		return t.modified() ? (n = n.reflow(!0), f = n.SOURCE) : f = n.modified(accessorFields(t.field)) ? n.ADD_MOD : n.ADD, n.visit(f, r ? (t) => {
			let n = i(t);
			t[u] = n, t[d] = n == null ? null : o + s * (1 + (n - o) / s);
		} : (t) => t[u] = i(t)), n.modifies(r ? l : u);
	},
	_bins(t) {
		if (this.value && !t.modified()) return this.value;
		let n = t.field, r = bin(t), i = r.step, o = r.start, s = o + Math.ceil((r.stop - o) / i) * i, l, u;
		(l = t.anchor) != null && (u = l - (o + i * Math.floor((l - o) / i)), o += u, s += u);
		let d = function(t) {
			let r = toNumber(n(t));
			return r == null ? null : r < o ? -Infinity : r > s ? Infinity : (r = Math.max(o, Math.min(r, s - i)), o + i * Math.floor(EPSILON$1 + (r - o) / i));
		};
		return d.start = o, d.stop = r.stop, d.step = i, this.value = accessor(d, accessorFields(n), t.name || "bin_" + accessorName(n));
	}
});
function SortedList(t, n, r) {
	let i = t, o = n || [], s = r || [], l = {}, u = 0;
	return {
		add: (t) => s.push(t),
		remove: (t) => l[i(t)] = ++u,
		size: () => o.length,
		data: (t, n) => (u &&= (o = o.filter((t) => !l[i(t)]), l = {}, 0), n && t && o.sort(t), s.length && (o = t ? merge$2(t, o, s.sort(t)) : o.concat(s), s = []), o)
	};
}
function Collect$1(t) {
	Transform.call(this, [], t);
}
Collect$1.Definition = {
	type: "Collect",
	metadata: { source: !0 },
	params: [{
		name: "sort",
		type: "compare"
	}]
}, inherits(Collect$1, Transform, { transform(t, n) {
	let r = n.fork(n.ALL), i = SortedList(tupleid, this.value, r.materialize(r.ADD).add), o = t.sort, s = n.changed() || o && (t.modified("sort") || n.modified(o.fields));
	return r.visit(r.REM, i.remove), this.modified(s), this.value = r.source = i.data(stableCompare(o), s), n.source && n.source.root && (this.value.root = n.source.root), r;
} });
function Compare$1(t) {
	Operator.call(this, null, update$5, t);
}
inherits(Compare$1, Operator);
function update$5(t) {
	return this.value && !t.modified() ? this.value : compare$1(t.fields, t.orders);
}
function CountPattern(t) {
	Transform.call(this, null, t);
}
CountPattern.Definition = {
	type: "CountPattern",
	metadata: {
		generates: !0,
		changes: !0
	},
	params: [
		{
			name: "field",
			type: "field",
			required: !0
		},
		{
			name: "case",
			type: "enum",
			values: [
				"upper",
				"lower",
				"mixed"
			],
			default: "mixed"
		},
		{
			name: "pattern",
			type: "string",
			default: "[\\w\"]+"
		},
		{
			name: "stopwords",
			type: "string",
			default: ""
		},
		{
			name: "as",
			type: "string",
			array: !0,
			length: 2,
			default: ["text", "count"]
		}
	]
};
function tokenize(t, n, r) {
	switch (n) {
		case "upper":
			t = t.toUpperCase();
			break;
		case "lower":
			t = t.toLowerCase();
			break;
	}
	return t.match(r);
}
inherits(CountPattern, Transform, {
	transform(t, n) {
		let r = (n) => (r) => {
			for (var i = tokenize(u(r), t.case, s) || [], o, d = 0, f = i.length; d < f; ++d) l.test(o = i[d]) || n(o);
		}, i = this._parameterCheck(t, n), o = this._counts, s = this._match, l = this._stop, u = t.field, d = t.as || ["text", "count"], f = r((t) => o[t] = 1 + (o[t] || 0)), p = r((t) => --o[t]);
		return i ? n.visit(n.SOURCE, f) : (n.visit(n.ADD, f), n.visit(n.REM, p)), this._finish(n, d);
	},
	_parameterCheck(t, n) {
		let r = !1;
		return (t.modified("stopwords") || !this._stop) && (this._stop = RegExp("^" + (t.stopwords || "") + "$", "i"), r = !0), (t.modified("pattern") || !this._match) && (this._match = new RegExp(t.pattern || "[\\w']+", "g"), r = !0), (t.modified("field") || n.modified(t.field.fields)) && (r = !0), r && (this._counts = {}), r;
	},
	_finish(t, n) {
		let r = this._counts, i = this._tuples ||= {}, o = n[0], s = n[1], l = t.fork(t.NO_SOURCE | t.NO_FIELDS), u, d, f;
		for (u in r) d = i[u], f = r[u] || 0, !d && f ? (i[u] = d = ingest$1({}), d[o] = u, d[s] = f, l.add.push(d)) : f === 0 ? (d && l.rem.push(d), r[u] = null, i[u] = null) : d[s] !== f && (d[s] = f, l.mod.push(d));
		return l.modifies(n);
	}
});
function Cross(t) {
	Transform.call(this, null, t);
}
Cross.Definition = {
	type: "Cross",
	metadata: { generates: !0 },
	params: [{
		name: "filter",
		type: "expr"
	}, {
		name: "as",
		type: "string",
		array: !0,
		length: 2,
		default: ["a", "b"]
	}]
}, inherits(Cross, Transform, { transform(t, n) {
	let r = n.fork(n.NO_SOURCE), i = t.as || ["a", "b"], o = i[0], s = i[1], l = !this.value || n.changed(n.ADD_REM) || t.modified("as") || t.modified("filter"), u = this.value;
	return l ? (u && (r.rem = u), u = n.materialize(n.SOURCE).source, r.add = this.value = cross(u, o, s, t.filter || truthy)) : r.mod = u, r.source = this.value, r.modifies(i);
} });
function cross(t, n, r, i) {
	for (var o = [], s = {}, l = t.length, u = 0, d, f; u < l; ++u) for (s[n] = f = t[u], d = 0; d < l; ++d) s[r] = t[d], i(s) && (o.push(ingest$1(s)), s = {}, s[n] = f);
	return o;
}
var Distributions = {
	kde,
	mixture,
	normal: gaussian,
	lognormal,
	uniform
}, DISTRIBUTIONS = "distributions", FUNCTION = "function", FIELD = "field";
function parse$4(t, n) {
	let r = t[FUNCTION];
	has(Distributions, r) || error$1("Unknown distribution function: " + r);
	let i = Distributions[r]();
	for (let r in t) r === FIELD ? i.data((t.from || n()).map(t[r])) : r === DISTRIBUTIONS ? i[r](t[r].map((t) => parse$4(t, n))) : typeof i[r] === FUNCTION && i[r](t[r]);
	return i;
}
function Density(t) {
	Transform.call(this, null, t);
}
var distributions = [
	{
		key: { function: "normal" },
		params: [{
			name: "mean",
			type: "number",
			default: 0
		}, {
			name: "stdev",
			type: "number",
			default: 1
		}]
	},
	{
		key: { function: "lognormal" },
		params: [{
			name: "mean",
			type: "number",
			default: 0
		}, {
			name: "stdev",
			type: "number",
			default: 1
		}]
	},
	{
		key: { function: "uniform" },
		params: [{
			name: "min",
			type: "number",
			default: 0
		}, {
			name: "max",
			type: "number",
			default: 1
		}]
	},
	{
		key: { function: "kde" },
		params: [
			{
				name: "field",
				type: "field",
				required: !0
			},
			{
				name: "from",
				type: "data"
			},
			{
				name: "bandwidth",
				type: "number",
				default: 0
			}
		]
	}
], mixture$1 = {
	key: { function: "mixture" },
	params: [{
		name: "distributions",
		type: "param",
		array: !0,
		params: distributions
	}, {
		name: "weights",
		type: "number",
		array: !0
	}]
};
Density.Definition = {
	type: "Density",
	metadata: { generates: !0 },
	params: [
		{
			name: "extent",
			type: "number",
			array: !0,
			length: 2
		},
		{
			name: "steps",
			type: "number"
		},
		{
			name: "minsteps",
			type: "number",
			default: 25
		},
		{
			name: "maxsteps",
			type: "number",
			default: 200
		},
		{
			name: "method",
			type: "string",
			default: "pdf",
			values: ["pdf", "cdf"]
		},
		{
			name: "distribution",
			type: "param",
			params: distributions.concat(mixture$1)
		},
		{
			name: "as",
			type: "string",
			array: !0,
			default: ["value", "density"]
		}
	]
}, inherits(Density, Transform, { transform(t, n) {
	let r = n.fork(n.NO_SOURCE | n.NO_FIELDS);
	if (!this.value || n.changed() || t.modified()) {
		let i = parse$4(t.distribution, source$1(n)), o = t.steps || t.minsteps || 25, s = t.steps || t.maxsteps || 200, l = t.method || "pdf";
		l !== "pdf" && l !== "cdf" && error$1("Invalid density method: " + l), !t.extent && !i.data && error$1("Missing density extent parameter."), l = i[l];
		let u = t.as || ["value", "density"], d = t.extent || extent(i.data()), f = sampleCurve(l, d, o, s).map((t) => {
			let n = {};
			return n[u[0]] = t[0], n[u[1]] = t[1], ingest$1(n);
		});
		this.value && (r.rem = this.value), this.value = r.add = r.source = f;
	}
	return r;
} });
function source$1(t) {
	return () => t.materialize(t.SOURCE).source;
}
function fieldNames(t, n) {
	return t ? t.map((t, r) => n[r] || accessorName(t)) : null;
}
function partition$1$1(t, n, r) {
	let i = [], o = (t) => t(d), s, l, u, d, f, p;
	if (n == null) i.push(t.map(r));
	else for (s = {}, l = 0, u = t.length; l < u; ++l) d = t[l], f = n.map(o), p = s[f], p || (s[f] = p = [], p.dims = f, i.push(p)), p.push(r(d));
	return i;
}
var Output$5 = "bin";
function DotBin(t) {
	Transform.call(this, null, t);
}
DotBin.Definition = {
	type: "DotBin",
	metadata: { modifies: !0 },
	params: [
		{
			name: "field",
			type: "field",
			required: !0
		},
		{
			name: "groupby",
			type: "field",
			array: !0
		},
		{
			name: "step",
			type: "number"
		},
		{
			name: "smooth",
			type: "boolean",
			default: !1
		},
		{
			name: "as",
			type: "string",
			default: Output$5
		}
	]
};
var autostep = (t, n) => span(extent(t, n)) / 30;
inherits(DotBin, Transform, { transform(t, n) {
	if (this.value && !(t.modified() || n.changed())) return n;
	let r = n.materialize(n.SOURCE).source, i = partition$1$1(n.source, t.groupby, identity), o = t.smooth || !1, s = t.field, l = t.step || autostep(r, s), u = stableCompare((t, n) => s(t) - s(n)), d = t.as || Output$5, f = i.length, p = Infinity, g = -Infinity, _ = 0, v;
	for (; _ < f; ++_) {
		let t = i[_].sort(u);
		v = -1;
		for (let n of dotbin(t, l, o, s)) n < p && (p = n), n > g && (g = n), t[++v][d] = n;
	}
	return this.value = {
		start: p,
		stop: g,
		step: l
	}, n.reflow(!0).modifies(d);
} });
function Expression$1(t) {
	Operator.call(this, null, update$4, t), this.modified(!0);
}
inherits(Expression$1, Operator);
function update$4(t) {
	let n = t.expr;
	return this.value && !t.modified("expr") ? this.value : accessor((r) => n(r, t), accessorFields(n), accessorName(n));
}
function Extent(t) {
	Transform.call(this, [void 0, void 0], t);
}
Extent.Definition = {
	type: "Extent",
	metadata: {},
	params: [{
		name: "field",
		type: "field",
		required: !0
	}]
}, inherits(Extent, Transform, { transform(t, n) {
	let r = this.value, i = t.field, o = n.changed() || n.modified(i.fields) || t.modified("field"), s = r[0], l = r[1];
	if ((o || s == null) && (s = Infinity, l = -Infinity), n.visit(o ? n.SOURCE : n.ADD, (t) => {
		let n = toNumber(i(t));
		n != null && (n < s && (s = n), n > l && (l = n));
	}), !Number.isFinite(s) || !Number.isFinite(l)) {
		let t = accessorName(i);
		t &&= ` for field "${t}"`, n.dataflow.warn(`Infinite extent${t}: [${s}, ${l}]`), s = l = void 0;
	}
	this.value = [s, l];
} });
function Subflow(t, n) {
	Operator.call(this, t), this.parent = n, this.count = 0;
}
inherits(Subflow, Operator, {
	connect(t) {
		return this.detachSubflow = t.detachSubflow, this.targets().add(t), t.source = this;
	},
	add(t) {
		this.count += 1, this.value.add.push(t);
	},
	rem(t) {
		--this.count, this.value.rem.push(t);
	},
	mod(t) {
		this.value.mod.push(t);
	},
	init(t) {
		this.value.init(t, t.NO_SOURCE);
	},
	evaluate() {
		return this.value;
	}
});
function Facet$1(t) {
	Transform.call(this, {}, t), this._keys = fastmap();
	let n = this._targets = [];
	n.active = 0, n.forEach = (t) => {
		for (let r = 0, i = n.active; r < i; ++r) t(n[r], r, n);
	};
}
inherits(Facet$1, Transform, {
	activate(t) {
		this._targets[this._targets.active++] = t;
	},
	subflow(t, n, r, i) {
		let o = this.value, s = has(o, t) && o[t], l, u;
		return s ? s.value.stamp < r.stamp && (s.init(r), this.activate(s)) : (u = i || (u = this._group[t]) && u.tuple, l = r.dataflow, s = new Subflow(r.fork(r.NO_SOURCE), this), l.add(s).connect(n(l, t, u)), o[t] = s, this.activate(s)), s;
	},
	clean() {
		let t = this.value, n = 0;
		for (let r in t) if (t[r].count === 0) {
			let i = t[r].detachSubflow;
			i && i(), delete t[r], ++n;
		}
		if (n) {
			let t = this._targets.filter((t) => t && t.count > 0);
			this.initTargets(t);
		}
	},
	initTargets(t) {
		let n = this._targets, r = n.length, i = t ? t.length : 0, o = 0;
		for (; o < i; ++o) n[o] = t[o];
		for (; o < r && n[o] != null; ++o) n[o] = null;
		n.active = i;
	},
	transform(t, n) {
		let r = n.dataflow, i = t.key, o = t.subflow, s = this._keys, l = t.modified("key"), u = (t) => this.subflow(t, o, n);
		return this._group = t.group || {}, this.initTargets(), n.visit(n.REM, (t) => {
			let n = tupleid(t), r = s.get(n);
			r !== void 0 && (s.delete(n), u(r).rem(t));
		}), n.visit(n.ADD, (t) => {
			let n = i(t);
			s.set(tupleid(t), n), u(n).add(t);
		}), l || n.modified(i.fields) ? n.visit(n.MOD, (t) => {
			let n = tupleid(t), r = s.get(n), o = i(t);
			r === o ? u(o).mod(t) : (s.set(n, o), u(r).rem(t), u(o).add(t));
		}) : n.changed(n.MOD) && n.visit(n.MOD, (t) => {
			u(s.get(tupleid(t))).mod(t);
		}), l && n.visit(n.REFLOW, (t) => {
			let n = tupleid(t), r = s.get(n), o = i(t);
			r !== o && (s.set(n, o), u(r).rem(t), u(o).add(t));
		}), n.clean() ? r.runAfter(() => {
			this.clean(), s.clean();
		}) : s.empty > r.cleanThreshold && r.runAfter(s.clean), n;
	}
});
function Field$1(t) {
	Operator.call(this, null, update$3, t);
}
inherits(Field$1, Operator);
function update$3(t) {
	return this.value && !t.modified() ? this.value : isArray(t.name) ? array(t.name).map((t) => field$1(t)) : field$1(t.name, t.as);
}
function Filter(t) {
	Transform.call(this, fastmap(), t);
}
Filter.Definition = {
	type: "Filter",
	metadata: { changes: !0 },
	params: [{
		name: "expr",
		type: "expr",
		required: !0
	}]
}, inherits(Filter, Transform, { transform(t, n) {
	let r = n.dataflow, i = this.value, o = n.fork(), s = o.add, l = o.rem, u = o.mod, d = t.expr, f = !0;
	n.visit(n.REM, (t) => {
		let n = tupleid(t);
		i.has(n) ? i.delete(n) : l.push(t);
	}), n.visit(n.ADD, (n) => {
		d(n, t) ? s.push(n) : i.set(tupleid(n), 1);
	});
	function p(n) {
		let r = tupleid(n), o = d(n, t), p = i.get(r);
		o && p ? (i.delete(r), s.push(n)) : !o && !p ? (i.set(r, 1), l.push(n)) : f && o && !p && u.push(n);
	}
	return n.visit(n.MOD, p), t.modified() && (f = !1, n.visit(n.REFLOW, p)), i.empty > r.cleanThreshold && r.runAfter(i.clean), o;
} });
function Flatten(t) {
	Transform.call(this, [], t);
}
Flatten.Definition = {
	type: "Flatten",
	metadata: { generates: !0 },
	params: [
		{
			name: "fields",
			type: "field",
			array: !0,
			required: !0
		},
		{
			name: "index",
			type: "string"
		},
		{
			name: "as",
			type: "string",
			array: !0
		}
	]
}, inherits(Flatten, Transform, { transform(t, n) {
	let r = n.fork(n.NO_SOURCE), i = t.fields, o = fieldNames(i, t.as || []), s = t.index || null, l = o.length;
	return r.rem = this.value, n.visit(n.SOURCE, (t) => {
		let n = i.map((n) => n(t)), u = n.reduce((t, n) => Math.max(t, n.length), 0), d = 0, f, p;
		for (; d < u; ++d) {
			for (p = derive(t), f = 0; f < l; ++f) p[o[f]] = n[f][d] ?? null;
			s && (p[s] = d), r.add.push(p);
		}
	}), this.value = r.source = r.add, s && r.modifies(s), r.modifies(o);
} });
function Fold(t) {
	Transform.call(this, [], t);
}
Fold.Definition = {
	type: "Fold",
	metadata: { generates: !0 },
	params: [{
		name: "fields",
		type: "field",
		array: !0,
		required: !0
	}, {
		name: "as",
		type: "string",
		array: !0,
		length: 2,
		default: ["key", "value"]
	}]
}, inherits(Fold, Transform, { transform(t, n) {
	let r = n.fork(n.NO_SOURCE), i = t.fields, o = i.map(accessorName), s = t.as || ["key", "value"], l = s[0], u = s[1], d = i.length;
	return r.rem = this.value, n.visit(n.SOURCE, (t) => {
		for (let n = 0, s; n < d; ++n) s = derive(t), s[l] = o[n], s[u] = i[n](t), r.add.push(s);
	}), this.value = r.source = r.add, r.modifies(s);
} });
function Formula(t) {
	Transform.call(this, null, t);
}
Formula.Definition = {
	type: "Formula",
	metadata: { modifies: !0 },
	params: [
		{
			name: "expr",
			type: "expr",
			required: !0
		},
		{
			name: "as",
			type: "string",
			required: !0
		},
		{
			name: "initonly",
			type: "boolean"
		}
	]
}, inherits(Formula, Transform, { transform(t, n) {
	let r = t.expr, i = t.as, o = t.modified(), s = t.initonly ? n.ADD : o ? n.SOURCE : n.modified(r.fields) || n.modified(i) ? n.ADD_MOD : n.ADD;
	return o && (n = n.materialize().reflow(!0)), t.initonly || n.modifies(i), n.visit(s, (n) => n[i] = r(n, t));
} });
function Generate(t) {
	Transform.call(this, [], t);
}
inherits(Generate, Transform, { transform(t, n) {
	let r = n.fork(n.ALL), i = t.generator, o = this.value, s = t.size - o.length, l, u, d;
	if (s > 0) {
		for (l = []; --s >= 0;) l.push(d = ingest$1(i(t))), o.push(d);
		r.add = r.add.length ? r.materialize(r.ADD).add.concat(l) : l;
	} else u = o.slice(0, -s), r.rem = r.rem.length ? r.materialize(r.REM).rem.concat(u) : u, o = o.slice(-s);
	return r.source = this.value = o, r;
} });
var Methods$1 = {
	value: "value",
	median,
	mean,
	min: min$1,
	max
}, Empty$1 = [];
function Impute(t) {
	Transform.call(this, [], t);
}
Impute.Definition = {
	type: "Impute",
	metadata: { changes: !0 },
	params: [
		{
			name: "field",
			type: "field",
			required: !0
		},
		{
			name: "key",
			type: "field",
			required: !0
		},
		{
			name: "keyvals",
			array: !0
		},
		{
			name: "groupby",
			type: "field",
			array: !0
		},
		{
			name: "method",
			type: "enum",
			default: "value",
			values: [
				"value",
				"mean",
				"median",
				"max",
				"min"
			]
		},
		{
			name: "value",
			default: 0
		}
	]
};
function getValue(t) {
	var n = t.method || Methods$1.value, r;
	if (Methods$1[n] == null) error$1("Unrecognized imputation method: " + n);
	else if (n === Methods$1.value) return r = t.value === void 0 ? 0 : t.value, () => r;
	else return Methods$1[n];
}
function getField$1(t) {
	let n = t.field;
	return (t) => t ? n(t) : NaN;
}
inherits(Impute, Transform, { transform(t, n) {
	var r = n.fork(n.ALL), i = getValue(t), o = getField$1(t), s = accessorName(t.field), l = accessorName(t.key), u = (t.groupby || []).map(accessorName), d = partition$3(n.source, t.groupby, t.key, t.keyvals), f = [], p = this.value, g = d.domain.length, _, v, S, T, E, O, k, A, j, N;
	for (E = 0, A = d.length; E < A; ++E) for (_ = d[E], S = _.values, v = NaN, k = 0; k < g; ++k) if (_[k] == null) {
		for (T = d.domain[k], N = { _impute: !0 }, O = 0, j = S.length; O < j; ++O) N[u[O]] = S[O];
		N[l] = T, N[s] = Number.isNaN(v) ? v = i(_, o) : v, f.push(ingest$1(N));
	}
	return f.length && (r.add = r.materialize(r.ADD).add.concat(f)), p.length && (r.rem = r.materialize(r.REM).rem.concat(p)), this.value = f, r;
} });
function partition$3(t, n, r, i) {
	var o = (t) => t(E), s = [], l = i ? i.slice() : [], u = {}, d = {}, f, p, g, _, v, S, T, E;
	for (l.forEach((t, n) => u[t] = n + 1), _ = 0, T = t.length; _ < T; ++_) E = t[_], S = r(E), v = u[S] || (u[S] = l.push(S)), p = (f = n ? n.map(o) : Empty$1) + "", (g = d[p]) || (g = d[p] = [], s.push(g), g.values = f), g[v - 1] = E;
	return s.domain = l, s;
}
function JoinAggregate(t) {
	Aggregate$1.call(this, t);
}
JoinAggregate.Definition = {
	type: "JoinAggregate",
	metadata: { modifies: !0 },
	params: [
		{
			name: "groupby",
			type: "field",
			array: !0
		},
		{
			name: "fields",
			type: "field",
			null: !0,
			array: !0
		},
		{
			name: "ops",
			type: "enum",
			array: !0,
			values: ValidAggregateOps
		},
		{
			name: "as",
			type: "string",
			null: !0,
			array: !0
		},
		{
			name: "key",
			type: "field"
		}
	]
}, inherits(JoinAggregate, Aggregate$1, {
	transform(t, n) {
		let r = this, i = t.modified(), o;
		return r.value && (i || n.modified(r._inputs, !0)) ? (o = r.value = i ? r.init(t) : {}, n.visit(n.SOURCE, (t) => r.add(t))) : (o = r.value = r.value || this.init(t), n.visit(n.REM, (t) => r.rem(t)), n.visit(n.ADD, (t) => r.add(t))), r.changes(), n.visit(n.SOURCE, (t) => {
			extend(t, o[r.cellkey(t)].tuple);
		}), n.reflow(i).modifies(this._outputs);
	},
	changes() {
		let t = this._adds, n = this._mods, r, i;
		for (r = 0, i = this._alen; r < i; ++r) this.celltuple(t[r]), t[r] = null;
		for (r = 0, i = this._mlen; r < i; ++r) this.celltuple(n[r]), n[r] = null;
		this._alen = this._mlen = 0;
	}
});
function KDE(t) {
	Transform.call(this, null, t);
}
KDE.Definition = {
	type: "KDE",
	metadata: { generates: !0 },
	params: [
		{
			name: "groupby",
			type: "field",
			array: !0
		},
		{
			name: "field",
			type: "field",
			required: !0
		},
		{
			name: "cumulative",
			type: "boolean",
			default: !1
		},
		{
			name: "counts",
			type: "boolean",
			default: !1
		},
		{
			name: "bandwidth",
			type: "number",
			default: 0
		},
		{
			name: "extent",
			type: "number",
			array: !0,
			length: 2
		},
		{
			name: "resolve",
			type: "enum",
			values: ["shared", "independent"],
			default: "independent"
		},
		{
			name: "steps",
			type: "number"
		},
		{
			name: "minsteps",
			type: "number",
			default: 25
		},
		{
			name: "maxsteps",
			type: "number",
			default: 200
		},
		{
			name: "as",
			type: "string",
			array: !0,
			default: ["value", "density"]
		}
	]
}, inherits(KDE, Transform, { transform(t, n) {
	let r = n.fork(n.NO_SOURCE | n.NO_FIELDS);
	if (!this.value || n.changed() || t.modified()) {
		let i = n.materialize(n.SOURCE).source, o = partition$1$1(i, t.groupby, t.field), s = (t.groupby || []).map(accessorName), l = t.bandwidth, u = t.cumulative ? "cdf" : "pdf", d = t.as || ["value", "density"], f = [], p = t.extent, g = t.steps || t.minsteps || 25, _ = t.steps || t.maxsteps || 200;
		u !== "pdf" && u !== "cdf" && error$1("Invalid density method: " + u), t.resolve === "shared" && (p ||= extent(i, t.field), g = _ = t.steps || _), o.forEach((n) => {
			let r = kde(n, l)[u], i = t.counts ? n.length : 1;
			sampleCurve(r, p || extent(n), g, _).forEach((t) => {
				let r = {};
				for (let t = 0; t < s.length; ++t) r[s[t]] = n.dims[t];
				r[d[0]] = t[0], r[d[1]] = t[1] * i, f.push(ingest$1(r));
			});
		}), this.value && (r.rem = this.value), this.value = r.add = r.source = f;
	}
	return r;
} });
function Key$1(t) {
	Operator.call(this, null, update$2, t);
}
inherits(Key$1, Operator);
function update$2(t) {
	return this.value && !t.modified() ? this.value : key(t.fields, t.flat);
}
function Load$1(t) {
	Transform.call(this, [], t), this._pending = null;
}
inherits(Load$1, Transform, { transform(t, n) {
	let r = n.dataflow;
	return this._pending ? output(this, n, this._pending) : stop(t) ? n.StopPropagation : t.values ? output(this, n, r.parse(t.values, t.format)) : t.async ? { async: r.request(t.url, t.format).then((t) => (this._pending = array(t.data), (t) => t.touch(this))) } : r.request(t.url, t.format).then((t) => output(this, n, array(t.data)));
} });
function stop(t) {
	return t.modified("async") && !(t.modified("values") || t.modified("url") || t.modified("format"));
}
function output(t, n, r) {
	r.forEach(ingest$1);
	let i = n.fork(n.NO_FIELDS & n.NO_SOURCE);
	return i.rem = t.value, t.value = i.source = i.add = r, t._pending = null, i.rem.length && i.clean(!0), i;
}
function Lookup(t) {
	Transform.call(this, {}, t);
}
Lookup.Definition = {
	type: "Lookup",
	metadata: { modifies: !0 },
	params: [
		{
			name: "index",
			type: "index",
			params: [{
				name: "from",
				type: "data",
				required: !0
			}, {
				name: "key",
				type: "field",
				required: !0
			}]
		},
		{
			name: "values",
			type: "field",
			array: !0
		},
		{
			name: "fields",
			type: "field",
			array: !0,
			required: !0
		},
		{
			name: "as",
			type: "string",
			array: !0
		},
		{
			name: "default",
			default: null
		}
	]
}, inherits(Lookup, Transform, { transform(t, n) {
	let r = t.fields, i = t.index, o = t.values, s = t.default == null ? null : t.default, l = t.modified(), u = r.length, d = l ? n.SOURCE : n.ADD, f = n, p = t.as, g, _, v;
	return o ? (_ = o.length, u > 1 && !p && error$1("Multi-field lookup requires explicit \"as\" parameter."), p && p.length !== u * _ && error$1("The \"as\" parameter has too few output field names."), p ||= o.map(accessorName), g = function(t) {
		for (var n = 0, l = 0, d, f; n < u; ++n) if (f = i.get(r[n](t)), f == null) for (d = 0; d < _; ++d, ++l) t[p[l]] = s;
		else for (d = 0; d < _; ++d, ++l) t[p[l]] = o[d](f);
	}) : (p || error$1("Missing output field names."), g = function(t) {
		for (var n = 0, o; n < u; ++n) o = i.get(r[n](t)), t[p[n]] = o ?? s;
	}), l ? f = n.reflow(!0) : (v = r.some((t) => n.modified(t.fields)), d |= v ? n.MOD : 0), n.visit(d, g), f.modifies(p);
} });
function MultiExtent$1(t) {
	Operator.call(this, null, update$1, t);
}
inherits(MultiExtent$1, Operator);
function update$1(t) {
	if (this.value && !t.modified()) return this.value;
	let n = t.extents, r = n.length, i = Infinity, o = -Infinity, s, l;
	for (s = 0; s < r; ++s) l = n[s], l[0] < i && (i = l[0]), l[1] > o && (o = l[1]);
	return [i, o];
}
function MultiValues$1(t) {
	Operator.call(this, null, update, t);
}
inherits(MultiValues$1, Operator);
function update(t) {
	return this.value && !t.modified() ? this.value : t.values.reduce((t, n) => t.concat(n), []);
}
function Params$2(t) {
	Transform.call(this, null, t);
}
inherits(Params$2, Transform, { transform(t, n) {
	return this.modified(t.modified()), this.value = t, n.fork(n.NO_SOURCE | n.NO_FIELDS);
} });
function Pivot(t) {
	Aggregate$1.call(this, t);
}
Pivot.Definition = {
	type: "Pivot",
	metadata: {
		generates: !0,
		changes: !0
	},
	params: [
		{
			name: "groupby",
			type: "field",
			array: !0
		},
		{
			name: "field",
			type: "field",
			required: !0
		},
		{
			name: "value",
			type: "field",
			required: !0
		},
		{
			name: "op",
			type: "enum",
			values: ValidAggregateOps,
			default: "sum"
		},
		{
			name: "limit",
			type: "number",
			default: 0
		},
		{
			name: "key",
			type: "field"
		}
	]
}, inherits(Pivot, Aggregate$1, {
	_transform: Aggregate$1.prototype.transform,
	transform(t, n) {
		return this._transform(aggregateParams(t, n), n);
	}
});
function aggregateParams(t, n) {
	let r = t.field, i = t.value, o = (t.op === "count" ? "__count__" : t.op) || "sum", s = accessorFields(r).concat(accessorFields(i)), l = pivotKeys(r, t.limit || 0, n);
	return n.changed() && t.set("__pivot__", null, null, !0), {
		key: t.key,
		groupby: t.groupby,
		ops: l.map(() => o),
		fields: l.map((t) => get$3(t, r, i, s)),
		as: l.map((t) => t + ""),
		modified: t.modified.bind(t)
	};
}
function get$3(t, n, r, i) {
	return accessor((i) => n(i) === t ? r(i) : NaN, i, t + "");
}
function pivotKeys(t, n, r) {
	let i = {}, o = [];
	return r.visit(r.SOURCE, (n) => {
		let r = t(n);
		i[r] || (i[r] = 1, o.push(r));
	}), o.sort(ascending), n ? o.slice(0, n) : o;
}
function PreFacet$1(t) {
	Facet$1.call(this, t);
}
inherits(PreFacet$1, Facet$1, { transform(t, n) {
	let r = t.subflow, i = t.field, o = (t) => this.subflow(tupleid(t), r, n, t);
	return (t.modified("field") || i && n.modified(accessorFields(i))) && error$1("PreFacet does not support field modification."), this.initTargets(), i ? (n.visit(n.MOD, (t) => {
		let n = o(t);
		i(t).forEach((t) => n.mod(t));
	}), n.visit(n.ADD, (t) => {
		let n = o(t);
		i(t).forEach((t) => n.add(ingest$1(t)));
	}), n.visit(n.REM, (t) => {
		let n = o(t);
		i(t).forEach((t) => n.rem(t));
	})) : (n.visit(n.MOD, (t) => o(t).mod(t)), n.visit(n.ADD, (t) => o(t).add(t)), n.visit(n.REM, (t) => o(t).rem(t))), n.clean() && n.runAfter(() => this.clean()), n;
} });
function Project(t) {
	Transform.call(this, null, t);
}
Project.Definition = {
	type: "Project",
	metadata: {
		generates: !0,
		changes: !0
	},
	params: [{
		name: "fields",
		type: "field",
		array: !0
	}, {
		name: "as",
		type: "string",
		null: !0,
		array: !0
	}]
}, inherits(Project, Transform, { transform(t, n) {
	let r = n.fork(n.NO_SOURCE), i = t.fields, o = fieldNames(t.fields, t.as || []), s = i ? (t, n) => project$1(t, n, i, o) : rederive, l;
	return this.value ? l = this.value : (n = n.addAll(), l = this.value = {}), n.visit(n.REM, (t) => {
		let n = tupleid(t);
		r.rem.push(l[n]), l[n] = null;
	}), n.visit(n.ADD, (t) => {
		let n = s(t, ingest$1({}));
		l[tupleid(t)] = n, r.add.push(n);
	}), n.visit(n.MOD, (t) => {
		r.mod.push(s(t, l[tupleid(t)]));
	}), r;
} });
function project$1(t, n, r, i) {
	for (let o = 0, s = r.length; o < s; ++o) n[i[o]] = r[o](t);
	return n;
}
function Proxy$1(t) {
	Transform.call(this, null, t);
}
inherits(Proxy$1, Transform, { transform(t, n) {
	return this.value = t.value, t.modified("value") ? n.fork(n.NO_SOURCE | n.NO_FIELDS) : n.StopPropagation;
} });
function Quantile$1(t) {
	Transform.call(this, null, t);
}
Quantile$1.Definition = {
	type: "Quantile",
	metadata: {
		generates: !0,
		changes: !0
	},
	params: [
		{
			name: "groupby",
			type: "field",
			array: !0
		},
		{
			name: "field",
			type: "field",
			required: !0
		},
		{
			name: "probs",
			type: "number",
			array: !0
		},
		{
			name: "step",
			type: "number",
			default: .01
		},
		{
			name: "as",
			type: "string",
			array: !0,
			default: ["prob", "value"]
		}
	]
};
var EPSILON = 1e-14;
inherits(Quantile$1, Transform, { transform(t, n) {
	let r = n.fork(n.NO_SOURCE | n.NO_FIELDS), i = t.as || ["prob", "value"];
	if (this.value && !t.modified() && !n.changed()) return r.source = this.value, r;
	let o = n.materialize(n.SOURCE).source, s = partition$1$1(o, t.groupby, t.field), l = (t.groupby || []).map(accessorName), u = [], d = t.step || .01, f = t.probs || range$3(d / 2, 1 - EPSILON, d), p = f.length;
	return s.forEach((t) => {
		let n = quantiles(t, f);
		for (let r = 0; r < p; ++r) {
			let o = {};
			for (let n = 0; n < l.length; ++n) o[l[n]] = t.dims[n];
			o[i[0]] = f[r], o[i[1]] = n[r], u.push(ingest$1(o));
		}
	}), this.value && (r.rem = this.value), this.value = r.add = r.source = u, r;
} });
function Relay$1(t) {
	Transform.call(this, null, t);
}
inherits(Relay$1, Transform, { transform(t, n) {
	let r, i;
	return this.value ? i = this.value : (r = n = n.addAll(), i = this.value = {}), t.derive && (r = n.fork(n.NO_SOURCE), n.visit(n.REM, (t) => {
		let n = tupleid(t);
		r.rem.push(i[n]), i[n] = null;
	}), n.visit(n.ADD, (t) => {
		let n = derive(t);
		i[tupleid(t)] = n, r.add.push(n);
	}), n.visit(n.MOD, (t) => {
		let n = i[tupleid(t)];
		for (let i in t) n[i] = t[i], r.modifies(i);
		r.mod.push(n);
	})), r;
} });
function Sample(t) {
	Transform.call(this, [], t), this.count = 0;
}
Sample.Definition = {
	type: "Sample",
	metadata: {},
	params: [{
		name: "size",
		type: "number",
		default: 1e3
	}]
}, inherits(Sample, Transform, { transform(t, n) {
	let r = n.fork(n.NO_SOURCE), i = t.modified("size"), o = t.size, s = this.value.reduce((t, n) => (t[tupleid(n)] = 1, t), {}), l = this.value, u = this.count, d = 0;
	function f(t) {
		let n, i;
		l.length < o ? l.push(t) : (i = ~~((u + 1) * random()), i < l.length && i >= d && (n = l[i], s[tupleid(n)] && r.rem.push(n), l[i] = t)), ++u;
	}
	if (n.rem.length && (n.visit(n.REM, (t) => {
		let n = tupleid(t);
		s[n] && (s[n] = -1, r.rem.push(t)), --u;
	}), l = l.filter((t) => s[tupleid(t)] !== -1)), (n.rem.length || i) && l.length < o && n.source && (d = u = l.length, n.visit(n.SOURCE, (t) => {
		s[tupleid(t)] || f(t);
	}), d = -1), i && l.length > o) {
		let t = l.length - o;
		for (let n = 0; n < t; ++n) s[tupleid(l[n])] = -1, r.rem.push(l[n]);
		l = l.slice(t);
	}
	return n.mod.length && n.visit(n.MOD, (t) => {
		s[tupleid(t)] && r.mod.push(t);
	}), n.add.length && n.visit(n.ADD, f), (n.add.length || d < 0) && (r.add = l.filter((t) => !s[tupleid(t)])), this.count = u, this.value = r.source = l, r;
} });
function Sequence(t) {
	Transform.call(this, null, t);
}
Sequence.Definition = {
	type: "Sequence",
	metadata: {
		generates: !0,
		changes: !0
	},
	params: [
		{
			name: "start",
			type: "number",
			required: !0
		},
		{
			name: "stop",
			type: "number",
			required: !0
		},
		{
			name: "step",
			type: "number",
			default: 1
		},
		{
			name: "as",
			type: "string",
			default: "data"
		}
	]
}, inherits(Sequence, Transform, { transform(t, n) {
	if (this.value && !t.modified()) return;
	let r = n.materialize().fork(n.MOD), i = t.as || "data";
	return r.rem = this.value ? n.rem.concat(this.value) : n.rem, this.value = range$3(t.start, t.stop, t.step || 1).map((t) => {
		let n = {};
		return n[i] = t, ingest$1(n);
	}), r.add = n.add.concat(this.value), r;
} });
function Sieve$1(t) {
	Transform.call(this, null, t), this.modified(!0);
}
inherits(Sieve$1, Transform, { transform(t, n) {
	return this.value = n.source, n.changed() ? n.fork(n.NO_SOURCE | n.NO_FIELDS) : n.StopPropagation;
} });
function TimeUnit(t) {
	Transform.call(this, null, t);
}
var OUTPUT = ["unit0", "unit1"];
TimeUnit.Definition = {
	type: "TimeUnit",
	metadata: { modifies: !0 },
	params: [
		{
			name: "field",
			type: "field",
			required: !0
		},
		{
			name: "interval",
			type: "boolean",
			default: !0
		},
		{
			name: "units",
			type: "enum",
			values: TIME_UNITS,
			array: !0
		},
		{
			name: "step",
			type: "number",
			default: 1
		},
		{
			name: "maxbins",
			type: "number",
			default: 40
		},
		{
			name: "extent",
			type: "date",
			array: !0
		},
		{
			name: "timezone",
			type: "enum",
			default: "local",
			values: ["local", "utc"]
		},
		{
			name: "as",
			type: "string",
			array: !0,
			length: 2,
			default: OUTPUT
		}
	]
}, inherits(TimeUnit, Transform, {
	transform(t, n) {
		let r = t.field, i = t.interval !== !1, o = t.timezone === "utc", s = this._floor(t, n), l = (o ? utcInterval : timeInterval)(s.unit).offset, u = t.as || OUTPUT, d = u[0], f = u[1], p = s.step, g = s.start || Infinity, _ = s.stop || -Infinity, v = n.ADD;
		return (t.modified() || n.changed(n.REM) || n.modified(accessorFields(r))) && (n = n.reflow(!0), v = n.SOURCE, g = Infinity, _ = -Infinity), n.visit(v, (t) => {
			let n = r(t), o, u;
			n == null ? (t[d] = null, i && (t[f] = null)) : (t[d] = o = u = s(n), i && (t[f] = u = l(o, p)), o < g && (g = o), u > _ && (_ = u));
		}), s.start = g, s.stop = _, n.modifies(i ? u : d);
	},
	_floor(t, n) {
		let r = t.timezone === "utc", { units: i, step: o } = t.units ? {
			units: t.units,
			step: t.step || 1
		} : bin$1({
			extent: t.extent || extent(n.materialize(n.SOURCE).source, t.field),
			maxbins: t.maxbins
		}), s = timeUnits(i), l = this.value || {}, u = (r ? utcFloor : timeFloor)(s, o);
		return u.unit = peek(s), u.units = s, u.step = o, u.start = l.start, u.stop = l.stop, this.value = u;
	}
});
function TupleIndex(t) {
	Transform.call(this, fastmap(), t);
}
inherits(TupleIndex, Transform, { transform(t, n) {
	let r = n.dataflow, i = t.field, o = this.value, s = (t) => o.set(i(t), t), l = !0;
	return t.modified("field") || n.modified(i.fields) ? (o.clear(), n.visit(n.SOURCE, s)) : n.changed() ? (n.visit(n.REM, (t) => o.delete(i(t))), n.visit(n.ADD, s)) : l = !1, this.modified(l), o.empty > r.cleanThreshold && r.runAfter(o.clean), n.fork();
} });
function Values$1(t) {
	Transform.call(this, null, t);
}
inherits(Values$1, Transform, { transform(t, n) {
	(!this.value || t.modified("field") || t.modified("sort") || n.changed() || t.sort && n.modified(t.sort.fields)) && (this.value = (t.sort ? n.source.slice().sort(stableCompare(t.sort)) : n.source).map(t.field));
} });
function WindowOp(t, n, r, i) {
	let o = WindowOps[t](n, r);
	return {
		init: o.init || zero$2,
		update: function(t, n) {
			n[i] = o.next(t);
		}
	};
}
var WindowOps = {
	row_number: function() {
		return { next: (t) => t.index + 1 };
	},
	rank: function() {
		let t;
		return {
			init: () => t = 1,
			next: (n) => {
				let r = n.index, i = n.data;
				return r && n.compare(i[r - 1], i[r]) ? t = r + 1 : t;
			}
		};
	},
	dense_rank: function() {
		let t;
		return {
			init: () => t = 1,
			next: (n) => {
				let r = n.index, i = n.data;
				return r && n.compare(i[r - 1], i[r]) ? ++t : t;
			}
		};
	},
	percent_rank: function() {
		let t = WindowOps.rank(), n = t.next;
		return {
			init: t.init,
			next: (t) => (n(t) - 1) / (t.data.length - 1)
		};
	},
	cume_dist: function() {
		let t;
		return {
			init: () => t = 0,
			next: (n) => {
				let r = n.data, i = n.compare, o = n.index;
				if (t < o) {
					for (; o + 1 < r.length && !i(r[o], r[o + 1]);) ++o;
					t = o;
				}
				return (1 + t) / r.length;
			}
		};
	},
	ntile: function(t, n) {
		n = +n, n > 0 || error$1("ntile num must be greater than zero.");
		let r = WindowOps.cume_dist(), i = r.next;
		return {
			init: r.init,
			next: (t) => Math.ceil(n * i(t))
		};
	},
	lag: function(t, n) {
		return n = +n || 1, { next: (r) => {
			let i = r.index - n;
			return i >= 0 ? t(r.data[i]) : null;
		} };
	},
	lead: function(t, n) {
		return n = +n || 1, { next: (r) => {
			let i = r.index + n, o = r.data;
			return i < o.length ? t(o[i]) : null;
		} };
	},
	first_value: function(t) {
		return { next: (n) => t(n.data[n.i0]) };
	},
	last_value: function(t) {
		return { next: (n) => t(n.data[n.i1 - 1]) };
	},
	nth_value: function(t, n) {
		return n = +n, n > 0 || error$1("nth_value nth must be greater than zero."), { next: (r) => {
			let i = r.i0 + (n - 1);
			return i < r.i1 ? t(r.data[i]) : null;
		} };
	},
	prev_value: function(t) {
		let n;
		return {
			init: () => n = null,
			next: (r) => {
				let i = t(r.data[r.index]);
				return i == null ? n : n = i;
			}
		};
	},
	next_value: function(t) {
		let n, r;
		return {
			init: () => (n = null, r = -1),
			next: (i) => {
				let o = i.data;
				return i.index <= r ? n : (r = find$1(t, o, i.index)) < 0 ? (r = o.length, n = null) : n = t(o[r]);
			}
		};
	}
};
function find$1(t, n, r) {
	for (let i = n.length; r < i; ++r) if (t(n[r]) != null) return r;
	return -1;
}
var ValidWindowOps = Object.keys(WindowOps);
function WindowState(t) {
	let n = array(t.ops), r = array(t.fields), i = array(t.params), o = array(t.aggregate_params), s = array(t.as), l = this.outputs = [], u = this.windows = [], d = {}, f = {}, p = [], g = [], _ = !0;
	function v(t) {
		array(accessorFields(t)).forEach((t) => d[t] = 1);
	}
	v(t.sort), n.forEach((t, n) => {
		let d = r[n], S = i[n], T = o[n] || null, E = accessorName(d), O = measureName(t, E, s[n]);
		if (v(d), l.push(O), has(WindowOps, t)) u.push(WindowOp(t, d, S, O));
		else {
			if (d == null && t !== "count" && error$1("Null aggregate field specified."), t === "count") {
				p.push(O);
				return;
			}
			_ = !1;
			let n = f[E];
			n || (n = f[E] = [], n.field = d, g.push(n)), n.push(createMeasure(t, T, O));
		}
	}), (p.length || g.length) && (this.cell = cell(g, p, _)), this.inputs = Object.keys(d);
}
var prototype = WindowState.prototype;
prototype.init = function() {
	this.windows.forEach((t) => t.init()), this.cell && this.cell.init();
}, prototype.update = function(t, n) {
	let r = this.cell, i = this.windows, o = t.data, s = i && i.length, l;
	if (r) {
		for (l = t.p0; l < t.i0; ++l) r.rem(o[l]);
		for (l = t.p1; l < t.i1; ++l) r.add(o[l]);
		r.set(n);
	}
	for (l = 0; l < s; ++l) i[l].update(t, n);
};
function cell(t, n, r) {
	t = t.map((t) => compileMeasures(t, t.field));
	let i = {
		num: 0,
		agg: null,
		store: !1,
		count: n
	};
	if (!r) for (var o = t.length, s = i.agg = Array(o), l = 0; l < o; ++l) s[l] = new t[l](i);
	if (i.store) var u = i.data = new TupleStore();
	return i.add = function(t) {
		if (i.num += 1, !r) {
			u && u.add(t);
			for (let n = 0; n < o; ++n) s[n].add(s[n].get(t), t);
		}
	}, i.rem = function(t) {
		if (--i.num, !r) {
			u && u.rem(t);
			for (let n = 0; n < o; ++n) s[n].rem(s[n].get(t), t);
		}
	}, i.set = function(t) {
		let o, l;
		for (u && u.values(), o = 0, l = n.length; o < l; ++o) t[n[o]] = i.num;
		if (!r) for (o = 0, l = s.length; o < l; ++o) s[o].set(t);
	}, i.init = function() {
		i.num = 0, u && u.reset();
		for (let t = 0; t < o; ++t) s[t].init();
	}, i;
}
function Window(t) {
	Transform.call(this, {}, t), this._mlen = 0, this._mods = [];
}
Window.Definition = {
	type: "Window",
	metadata: { modifies: !0 },
	params: [
		{
			name: "sort",
			type: "compare"
		},
		{
			name: "groupby",
			type: "field",
			array: !0
		},
		{
			name: "ops",
			type: "enum",
			array: !0,
			values: ValidWindowOps.concat(ValidAggregateOps)
		},
		{
			name: "params",
			type: "number",
			null: !0,
			array: !0
		},
		{
			name: "aggregate_params",
			type: "number",
			null: !0,
			array: !0
		},
		{
			name: "fields",
			type: "field",
			null: !0,
			array: !0
		},
		{
			name: "as",
			type: "string",
			null: !0,
			array: !0
		},
		{
			name: "frame",
			type: "number",
			null: !0,
			array: !0,
			length: 2,
			default: [null, 0]
		},
		{
			name: "ignorePeers",
			type: "boolean",
			default: !1
		}
	]
}, inherits(Window, Transform, {
	transform(t, n) {
		this.stamp = n.stamp;
		let r = t.modified(), i = stableCompare(t.sort), o = groupkey(t.groupby), s = (t) => this.group(o(t)), l = this.state;
		(!l || r) && (l = this.state = new WindowState(t)), r || n.modified(l.inputs) ? (this.value = {}, n.visit(n.SOURCE, (t) => s(t).add(t))) : (n.visit(n.REM, (t) => s(t).remove(t)), n.visit(n.ADD, (t) => s(t).add(t)));
		for (let n = 0, r = this._mlen; n < r; ++n) processPartition(this._mods[n], l, i, t);
		return this._mlen = 0, this._mods = [], n.reflow(r).modifies(l.outputs);
	},
	group(t) {
		let n = this.value[t];
		return n || (n = this.value[t] = SortedList(tupleid), n.stamp = -1), n.stamp < this.stamp && (n.stamp = this.stamp, this._mods[this._mlen++] = n), n;
	}
});
function processPartition(t, n, r, i) {
	let o = i.sort, s = o && !i.ignorePeers, l = i.frame || [null, 0], u = t.data(r), d = u.length, f = s ? bisector(o) : null, p = {
		i0: 0,
		i1: 0,
		p0: 0,
		p1: 0,
		index: 0,
		data: u,
		compare: o || constant(-1)
	};
	n.init();
	for (let t = 0; t < d; ++t) setWindow(p, l, t, d), s && adjustRange(p, f), n.update(p, u[t]);
}
function setWindow(t, n, r, i) {
	t.p0 = t.i0, t.p1 = t.i1, t.i0 = n[0] == null ? 0 : Math.max(0, r - Math.abs(n[0])), t.i1 = n[1] == null ? i : Math.min(i, r + Math.abs(n[1]) + 1), t.index = r;
}
function adjustRange(t, n) {
	let r = t.i0, i = t.i1 - 1, o = t.compare, s = t.data, l = s.length - 1;
	r > 0 && !o(s[r], s[r - 1]) && (t.i0 = n.left(s, s[r])), i < l && !o(s[i], s[i + 1]) && (t.i1 = n.right(s, s[i]));
}
function domCanvas(t, n) {
	if (typeof document < "u" && document.createElement) {
		let r = document.createElement("canvas");
		if (r && r.getContext) return r.width = t, r.height = n, r;
	}
	return null;
}
var domImage = () => typeof Image < "u" ? Image : null;
function bandSpace(t, n, r) {
	let i = t - n + r * 2;
	return t ? i > 0 ? i : 1 : 0;
}
var Identity = "identity", Linear = "linear", Sqrt = "sqrt", Symlog = "symlog", Time = "time", Sequential = "sequential", Diverging = "diverging", Quantile = "quantile", Quantize = "quantize", Threshold = "threshold", Ordinal = "ordinal", Point = "point", Band = "band", BinOrdinal = "bin-ordinal", Continuous = "continuous", Discrete$1 = "discrete", Discretizing = "discretizing", Interpolating = "interpolating", Temporal = "temporal";
function invertRange(t) {
	return function(n) {
		let r = n[0], i = n[1], o;
		return i < r && (o = r, r = i, i = o), [t.invert(r), t.invert(i)];
	};
}
function invertRangeExtent(t) {
	return function(n) {
		let r = t.range(), i = n[0], o = n[1], s = -1, l, u, d, f;
		for (o < i && (u = i, i = o, o = u), d = 0, f = r.length; d < f; ++d) r[d] >= i && r[d] <= o && (s < 0 && (s = d), l = d);
		if (!(s < 0)) return i = t.invertExtent(r[s]), o = t.invertExtent(r[l]), [i[0] === void 0 ? i[1] : i[0], o[1] === void 0 ? o[0] : o[1]];
	};
}
function band() {
	let t = ordinal().unknown(void 0), n = t.domain, r = t.range, i = [0, 1], o, s, l = !1, u = 0, d = 0, f = .5;
	delete t.unknown;
	function p() {
		let t = n().length, p = i[1] < i[0], g = i[1 - p], _ = bandSpace(t, u, d), v = i[p - 0];
		o = (g - v) / (_ || 1), l && (o = Math.floor(o)), v += (g - v - o * (t - u)) * f, s = o * (1 - u), l && (v = Math.round(v), s = Math.round(s));
		let S = range$3(t).map((t) => v + o * t);
		return r(p ? S.reverse() : S);
	}
	return t.domain = function(t) {
		return arguments.length ? (n(t), p()) : n();
	}, t.range = function(t) {
		return arguments.length ? (i = [+t[0], +t[1]], p()) : i.slice();
	}, t.rangeRound = function(t) {
		return i = [+t[0], +t[1]], l = !0, p();
	}, t.bandwidth = function() {
		return s;
	}, t.step = function() {
		return o;
	}, t.round = function(t) {
		return arguments.length ? (l = !!t, p()) : l;
	}, t.padding = function(t) {
		return arguments.length ? (d = Math.max(0, Math.min(1, t)), u = d, p()) : u;
	}, t.paddingInner = function(t) {
		return arguments.length ? (u = Math.max(0, Math.min(1, t)), p()) : u;
	}, t.paddingOuter = function(t) {
		return arguments.length ? (d = Math.max(0, Math.min(1, t)), p()) : d;
	}, t.align = function(t) {
		return arguments.length ? (f = Math.max(0, Math.min(1, t)), p()) : f;
	}, t.invertRange = function(t) {
		if (t[0] == null || t[1] == null) return;
		let o = i[1] < i[0], l = o ? r().reverse() : r(), u = l.length - 1, d = +t[0], f = +t[1], p, g, v;
		if (!(d !== d || f !== f) && (f < d && (v = d, d = f, f = v), !(f < l[0] || d > i[1 - o]))) return p = Math.max(0, bisectRight$1(l, d) - 1), g = d === f ? p : bisectRight$1(l, f) - 1, d - l[p] > s + 1e-10 && ++p, o && (v = p, p = u - g, g = u - v), p > g ? void 0 : n().slice(p, g + 1);
	}, t.invert = function(n) {
		let r = t.invertRange([n, n]);
		return r && r[0];
	}, t.copy = function() {
		return band().domain(n()).range(i).round(l).paddingInner(u).paddingOuter(d).align(f);
	}, p();
}
function pointish(t) {
	let n = t.copy;
	return t.padding = t.paddingOuter, delete t.paddingInner, t.copy = function() {
		return pointish(n());
	}, t;
}
function point$3() {
	return pointish(band().paddingInner(1));
}
var map = Array.prototype.map;
function numbers(t) {
	return map.call(t, toNumber);
}
var slice$2 = Array.prototype.slice;
function scaleBinOrdinal() {
	let t = [], n = [];
	function r(r) {
		return r == null || r !== r ? void 0 : n[(bisect_default(t, r) - 1) % n.length];
	}
	return r.domain = function(n) {
		return arguments.length ? (t = numbers(n), r) : t.slice();
	}, r.range = function(t) {
		return arguments.length ? (n = slice$2.call(t), r) : n.slice();
	}, r.tickFormat = function(n, r) {
		return tickFormat$1(t[0], peek(t), n ?? 10, r);
	}, r.copy = function() {
		return scaleBinOrdinal().domain(r.domain()).range(r.range());
	}, r;
}
var scales = /* @__PURE__ */ new Map(), VEGA_SCALE = Symbol("vega_scale");
function registerScale(t) {
	return t[VEGA_SCALE] = !0, t;
}
function isRegisteredScale(t) {
	return t && t[VEGA_SCALE] === !0;
}
function create$2(t, n, r) {
	let i = function() {
		let r = n();
		return r.invertRange ||= r.invert ? invertRange(r) : r.invertExtent ? invertRangeExtent(r) : void 0, r.type = t, registerScale(r);
	};
	return i.metadata = toSet(array(r)), i;
}
function scale(t, n, r) {
	return arguments.length > 1 ? (scales.set(t, create$2(t, n, r)), this) : isValidScaleType(t) ? scales.get(t) : void 0;
}
scale(Identity, identity$2), scale(Linear, linear$1, Continuous), scale("log", log$3, [Continuous, "log"]), scale("pow", pow$2, Continuous), scale(Sqrt, sqrt$2, Continuous), scale(Symlog, symlog$1, Continuous), scale(Time, time$1, [Continuous, Temporal]), scale("utc", utcTime, [Continuous, Temporal]), scale(Sequential, sequential, [Continuous, Interpolating]), scale(`${Sequential}-${Linear}`, sequential, [Continuous, Interpolating]), scale(`${Sequential}-log`, sequentialLog, [
	Continuous,
	Interpolating,
	"log"
]), scale(`${Sequential}-pow`, sequentialPow, [Continuous, Interpolating]), scale(`${Sequential}-${Sqrt}`, sequentialSqrt, [Continuous, Interpolating]), scale(`${Sequential}-${Symlog}`, sequentialSymlog, [Continuous, Interpolating]), scale(`${Diverging}-${Linear}`, diverging, [Continuous, Interpolating]), scale(`${Diverging}-log`, divergingLog, [
	Continuous,
	Interpolating,
	"log"
]), scale(`${Diverging}-pow`, divergingPow, [Continuous, Interpolating]), scale(`${Diverging}-${Sqrt}`, divergingSqrt, [Continuous, Interpolating]), scale(`${Diverging}-${Symlog}`, divergingSymlog, [Continuous, Interpolating]), scale(Quantile, quantile$1, [Discretizing, Quantile]), scale(Quantize, quantize$1, Discretizing), scale(Threshold, threshold, Discretizing), scale(BinOrdinal, scaleBinOrdinal, [Discrete$1, Discretizing]), scale(Ordinal, ordinal, Discrete$1), scale(Band, band, Discrete$1), scale(Point, point$3, Discrete$1);
function isValidScaleType(t) {
	return scales.has(t);
}
function hasType(t, n) {
	let r = scales.get(t);
	return r && r.metadata[n];
}
function isContinuous$1(t) {
	return hasType(t, Continuous);
}
function isDiscrete$2(t) {
	return hasType(t, Discrete$1);
}
function isDiscretizing$1(t) {
	return hasType(t, Discretizing);
}
function isLogarithmic(t) {
	return hasType(t, "log");
}
function isTemporal(t) {
	return hasType(t, Temporal);
}
function isInterpolating(t) {
	return hasType(t, Interpolating);
}
function isQuantile$1(t) {
	return hasType(t, Quantile);
}
var scaleProps = [
	"clamp",
	"base",
	"constant",
	"exponent"
];
function interpolateRange$1(t, n) {
	let r = n[0], i = peek(n) - r;
	return function(n) {
		return t(r + n * i);
	};
}
function interpolateColors(t, n, r) {
	return piecewise(interpolate$1(n || "rgb", r), t);
}
function quantizeInterpolator(t, n) {
	let r = Array(n), i = n + 1;
	for (let o = 0; o < n;) r[o] = t(++o / i);
	return r;
}
function scaleFraction(t, n, r) {
	let i = r - n, o, s, l;
	return !i || !Number.isFinite(i) ? constant(.5) : (o = (s = t.type).indexOf("-"), s = o < 0 ? s : s.slice(o + 1), l = scale(s)().domain([n, r]).range([0, 1]), scaleProps.forEach((n) => t[n] ? l[n](t[n]()) : 0), l);
}
function interpolate$1(t, n) {
	let r = src_exports$1[method(t)];
	return n != null && r && r.gamma ? r.gamma(n) : r;
}
function method(t) {
	return "interpolate" + t.toLowerCase().split("-").map((t) => t[0].toUpperCase() + t.slice(1)).join("");
}
var continuous = {
	blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
	greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
	greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
	oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
	purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
	reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
	blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
	bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
	greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
	orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
	purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
	purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
	purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
	redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
	yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
	yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
	yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
	blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
	brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
	purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
	purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
	redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
	redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
	yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
	redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
	redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
	pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
	spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
	viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
	magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
	inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
	plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
	cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
	rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
	sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
	turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
	browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
	tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
	teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
	warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
	goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
	goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
	goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
	lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
	lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
	lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
	lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
	lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
	darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
	darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
	darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
	darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
	darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
}, discrete = {
	accent: Accent_default,
	category10: category10_default,
	category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
	category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
	category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
	dark2: Dark2_default,
	observable10: observable10_default,
	paired: Paired_default,
	pastel1: Pastel1_default,
	pastel2: Pastel2_default,
	set1: Set1_default,
	set2: Set2_default,
	set3: Set3_default,
	tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
	tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
};
function colors(t) {
	if (isArray(t)) return t;
	let n = t.length / 6 | 0, r = Array(n);
	for (let i = 0; i < n;) r[i] = "#" + t.slice(i * 6, ++i * 6);
	return r;
}
function apply$1(t, n) {
	for (let r in t) scheme$1(r, n(t[r]));
}
var schemes = {};
apply$1(discrete, colors), apply$1(continuous, (t) => interpolateColors(colors(t)));
function scheme$1(t, n) {
	return t &&= t.toLowerCase(), arguments.length > 1 ? (schemes[t] = n, this) : schemes[t];
}
var defaultFormatter = (t) => isArray(t) ? t.map((t) => String(t)) : String(t), ascending$1 = (t, n) => t[1] - n[1], descending = (t, n) => n[1] - t[1];
function tickCount(t, n, r) {
	let i;
	return isNumber(n) && (t.bins && (n = Math.max(n, t.bins.length)), r != null && (n = Math.min(n, Math.floor(span(t.domain()) / r || 1) + 1))), isObject(n) && (i = n.step, n = n.interval), isString(n) && (n = t.type === "time" ? timeInterval(n) : t.type == "utc" ? utcInterval(n) : error$1("Only time and utc scales accept interval strings."), i && (n = n.every(i))), n;
}
function validTicks(t, n, r) {
	let i = t.range(), o = i[0], s = peek(i), l = ascending$1;
	if (o > s && (i = s, s = o, o = i, l = descending), o = Math.floor(o), s = Math.ceil(s), n = n.map((n) => [n, t(n)]).filter((t) => o <= t[1] && t[1] <= s).sort(l).map((t) => t[0]), r > 0 && n.length > 1) {
		let t = [n[0], peek(n)];
		for (; n.length > r && n.length >= 3;) n = n.filter((t, n) => !(n % 2));
		n.length < 3 && (n = t);
	}
	return n;
}
function tickValues(t, n) {
	return t.bins ? validTicks(t, t.bins, n) : t.ticks ? t.ticks(n) : t.domain();
}
function tickFormat(t, n, r, i, o, s) {
	let l = n.type, u = defaultFormatter;
	if (l === "time" || o === "time") u = t.timeFormat(i);
	else if (l === "utc" || o === "utc") u = t.utcFormat(i);
	else if (isLogarithmic(l)) {
		let o = t.formatFloat(i);
		if (s || n.bins) u = o;
		else {
			let t = tickLog(n, r, !1);
			u = (n) => t(n) ? o(n) : "";
		}
	} else if (n.tickFormat) {
		let o = n.domain();
		u = t.formatSpan(o[0], o[o.length - 1], r, i);
	} else i && (u = t.format(i));
	return u;
}
function tickLog(t, n, r) {
	let i = tickValues(t, n), o = t.base(), s = Math.log(o), l = Math.max(1, o * n / i.length), u = (t) => {
		let n = t / o ** +Math.round(Math.log(t) / s);
		return n * o < o - .5 && (n *= o), n <= l;
	};
	return r ? i.filter(u) : u;
}
var symbols$2 = {
	[Quantile]: "quantiles",
	[Quantize]: "thresholds",
	[Threshold]: "domain"
}, formats = {
	[Quantile]: "quantiles",
	[Quantize]: "domain"
};
function labelValues(t, n) {
	return t.bins ? binValues(t.bins) : t.type === "log" ? tickLog(t, n, !0) : symbols$2[t.type] ? thresholdValues(t[symbols$2[t.type]]()) : tickValues(t, n);
}
function thresholdFormat(t, n, r) {
	let i = n[formats[n.type]](), o = i.length, s = o > 1 ? i[1] - i[0] : i[0], l;
	for (l = 1; l < o; ++l) s = Math.min(s, i[l] - i[l - 1]);
	return t.formatSpan(0, s, 30, r);
}
function thresholdValues(t) {
	let n = [-Infinity].concat(t);
	return n.max = Infinity, n;
}
function binValues(t) {
	let n = t.slice(0, -1);
	return n.max = peek(t), n;
}
var isDiscreteRange = (t) => symbols$2[t.type] || t.bins;
function labelFormat(t, n, r, i, o, s, l) {
	let u = formats[n.type] && s !== "time" && s !== "utc" ? thresholdFormat(t, n, o) : tickFormat(t, n, r, o, s, l);
	return i === "symbol" && isDiscreteRange(n) ? formatRange(u) : i === "discrete" ? formatDiscrete(u) : formatPoint(u);
}
var formatRange = (t) => (n, r, i) => {
	let o = get$2(i[r + 1], get$2(i.max, Infinity)), s = formatValue$2(n, t), l = formatValue$2(o, t);
	return s && l ? s + " – " + l : l ? "< " + l : "≥ " + s;
}, get$2 = (t, n) => t ?? n, formatDiscrete = (t) => (n, r) => r ? t(n) : null, formatPoint = (t) => (n) => t(n), formatValue$2 = (t, n) => Number.isFinite(t) ? n(t) : null;
function labelFraction(t) {
	let n = t.domain(), r = n.length - 1, i = +n[0], o = +peek(n), s = o - i;
	if (t.type === "threshold") {
		let t = r ? s / r : .1;
		i -= t, o += t, s = o - i;
	}
	return (t) => (t - i) / s;
}
function format$1(t, n, r, i) {
	let o = i || n.type;
	return isString(r) && isTemporal(o) && (r = r.replace(/%a/g, "%A").replace(/%b/g, "%B")), !r && o === "time" ? t.timeFormat("%A, %d %B %Y, %X") : !r && o === "utc" ? t.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat(t, n, 5, null, r, i, !0);
}
function domainCaption(t, n, r) {
	r ||= {};
	let i = Math.max(3, r.maxlen || 7), o = format$1(t, n, r.format, r.formatType);
	if (isDiscretizing$1(n.type)) {
		let t = labelValues(n).slice(1).map(o), r = t.length;
		return `${r} boundar${r === 1 ? "y" : "ies"}: ${t.join(", ")}`;
	} else if (isDiscrete$2(n.type)) {
		let t = n.domain(), r = t.length, s = r > i ? t.slice(0, i - 2).map(o).join(", ") + ", ending with " + t.slice(-1).map(o) : t.map(o).join(", ");
		return `${r} value${r === 1 ? "" : "s"}: ${s}`;
	} else {
		let t = n.domain();
		return `values from ${o(t[0])} to ${o(peek(t))}`;
	}
}
var gradient_id = 0;
function resetSVGGradientId() {
	gradient_id = 0;
}
var patternPrefix = "p_";
function isGradient(t) {
	return t && t.gradient;
}
function gradientRef(t, n, r) {
	let i = t.gradient, o = t.id, s = i === "radial" ? patternPrefix : "";
	return o || (o = t.id = "gradient_" + gradient_id++, i === "radial" ? (t.x1 = get$1(t.x1, .5), t.y1 = get$1(t.y1, .5), t.r1 = get$1(t.r1, 0), t.x2 = get$1(t.x2, .5), t.y2 = get$1(t.y2, .5), t.r2 = get$1(t.r2, .5), s = patternPrefix) : (t.x1 = get$1(t.x1, 0), t.y1 = get$1(t.y1, 0), t.x2 = get$1(t.x2, 1), t.y2 = get$1(t.y2, 0))), n[o] = t, "url(" + (r || "") + "#" + s + o + ")";
}
function get$1(t, n) {
	return t ?? n;
}
function Gradient$1(t, n) {
	var r = [], i;
	return i = {
		gradient: "linear",
		x1: t ? t[0] : 0,
		y1: t ? t[1] : 0,
		x2: n ? n[0] : 1,
		y2: n ? n[1] : 0,
		stops: r,
		stop: function(t, n) {
			return r.push({
				offset: t,
				color: n
			}), i;
		}
	};
}
var lookup$4 = {
	basis: { curve: basis_default },
	"basis-closed": { curve: basisClosed_default },
	"basis-open": { curve: basisOpen_default },
	bundle: {
		curve: bundle_default,
		tension: "beta",
		value: .85
	},
	cardinal: {
		curve: cardinal_default,
		tension: "tension",
		value: 0
	},
	"cardinal-open": {
		curve: cardinalOpen_default,
		tension: "tension",
		value: 0
	},
	"cardinal-closed": {
		curve: cardinalClosed_default,
		tension: "tension",
		value: 0
	},
	"catmull-rom": {
		curve: catmullRom_default,
		tension: "alpha",
		value: .5
	},
	"catmull-rom-closed": {
		curve: catmullRomClosed_default,
		tension: "alpha",
		value: .5
	},
	"catmull-rom-open": {
		curve: catmullRomOpen_default,
		tension: "alpha",
		value: .5
	},
	linear: { curve: linear_default },
	"linear-closed": { curve: linearClosed_default },
	monotone: {
		horizontal: monotoneY,
		vertical: monotoneX
	},
	natural: { curve: natural_default },
	step: { curve: step_default },
	"step-after": { curve: stepAfter },
	"step-before": { curve: stepBefore }
};
function curves(t, n, r) {
	var i = has(lookup$4, t) && lookup$4[t], o = null;
	return i && (o = i.curve || i[n || "vertical"], i.tension && r != null && (o = o[i.tension](r))), o;
}
var paramCounts = {
	m: 2,
	l: 2,
	h: 1,
	v: 1,
	z: 0,
	c: 6,
	s: 4,
	q: 4,
	t: 2,
	a: 7
}, commandPattern = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi, numberPattern = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/, spacePattern = /^((\s+,?\s*)|(,\s*))/, flagPattern = /^[01]/;
function parse$3(t) {
	let n = [];
	return (t.match(commandPattern) || []).forEach((t) => {
		let r = t[0], i = r.toLowerCase(), o = paramCounts[i], s = parseParams(i, o, t.slice(1).trim()), l = s.length;
		if (l < o || l && l % o !== 0) throw Error("Invalid SVG path, incorrect parameter count");
		if (n.push([r, ...s.slice(0, o)]), l !== o) {
			i === "m" && (r = r === "M" ? "L" : "l");
			for (let t = o; t < l; t += o) n.push([r, ...s.slice(t, t + o)]);
		}
	}), n;
}
function parseParams(t, n, r) {
	let i = [];
	for (let o = 0; n && o < r.length;) for (let s = 0; s < n; ++s) {
		let n = t === "a" && (s === 3 || s === 4) ? flagPattern : numberPattern, l = r.slice(o).match(n);
		if (l === null) throw Error("Invalid SVG path, incorrect parameter type");
		o += l[0].length, i.push(+l[0]);
		let u = r.slice(o).match(spacePattern);
		u !== null && (o += u[0].length);
	}
	return i;
}
var DegToRad = Math.PI / 180, Epsilon = 1e-14, HalfPi = Math.PI / 2, Tau = Math.PI * 2, HalfSqrt3 = Math.sqrt(3) / 2, segmentCache = {}, bezierCache = {}, join$1 = [].join;
function segments(t, n, r, i, o, s, l, u, d) {
	let f = join$1.call(arguments);
	if (segmentCache[f]) return segmentCache[f];
	let p = l * DegToRad, g = Math.sin(p), _ = Math.cos(p);
	r = Math.abs(r), i = Math.abs(i);
	let v = _ * (u - t) * .5 + g * (d - n) * .5, S = _ * (d - n) * .5 - g * (u - t) * .5, T = v * v / (r * r) + S * S / (i * i);
	T > 1 && (T = Math.sqrt(T), r *= T, i *= T);
	let E = _ / r, O = g / r, k = -g / i, A = _ / i, j = E * u + O * d, N = k * u + A * d, P = E * t + O * n, F = k * t + A * n, I = 1 / ((P - j) * (P - j) + (F - N) * (F - N)) - .25;
	I < 0 && (I = 0);
	let L = Math.sqrt(I);
	s == o && (L = -L);
	let R = .5 * (j + P) - L * (F - N), z = .5 * (N + F) + L * (P - j), V = Math.atan2(N - z, j - R), H = Math.atan2(F - z, P - R) - V;
	H < 0 && s === 1 ? H += Tau : H > 0 && s === 0 && (H -= Tau);
	let U = Math.ceil(Math.abs(H / (HalfPi + .001))), W = [];
	for (let t = 0; t < U; ++t) W[t] = [
		R,
		z,
		V + t * H / U,
		V + (t + 1) * H / U,
		r,
		i,
		g,
		_
	];
	return segmentCache[f] = W;
}
function bezier(t) {
	let n = join$1.call(t);
	if (bezierCache[n]) return bezierCache[n];
	var r = t[0], i = t[1], o = t[2], s = t[3], l = t[4], u = t[5], d = t[6], f = t[7];
	let p = f * l, g = -d * u, _ = d * l, v = f * u, S = Math.cos(o), T = Math.sin(o), E = Math.cos(s), O = Math.sin(s), k = .5 * (s - o), A = Math.sin(k * .5), j = 8 / 3 * A * A / Math.sin(k), N = r + S - j * T, P = i + T + j * S, F = r + E, I = i + O, L = F + j * O, R = I - j * E;
	return bezierCache[n] = [
		p * N + g * P,
		_ * N + v * P,
		p * L + g * R,
		_ * L + v * R,
		p * F + g * I,
		_ * F + v * I
	];
}
var temp = [
	"l",
	0,
	0,
	0,
	0,
	0,
	0,
	0
];
function scale$1$1(t, n, r) {
	let i = temp[0] = t[0];
	if (i === "a" || i === "A") temp[1] = n * t[1], temp[2] = r * t[2], temp[3] = t[3], temp[4] = t[4], temp[5] = t[5], temp[6] = n * t[6], temp[7] = r * t[7];
	else if (i === "h" || i === "H") temp[1] = n * t[1];
	else if (i === "v" || i === "V") temp[1] = r * t[1];
	else for (var o = 1, s = t.length; o < s; ++o) temp[o] = (o % 2 == 1 ? n : r) * t[o];
	return temp;
}
function pathRender(t, n, r, i, o, s) {
	var l, u = null, d = 0, f = 0, p = 0, g = 0, _, v, S, T, E = 0, O = 0;
	r ??= 0, i ??= 0, o ??= 1, s ??= o, t.beginPath && t.beginPath();
	for (var k = 0, A = n.length; k < A; ++k) {
		switch (l = n[k], (o !== 1 || s !== 1) && (l = scale$1$1(l, o, s)), l[0]) {
			case "l":
				d += l[1], f += l[2], t.lineTo(d + r, f + i);
				break;
			case "L":
				d = l[1], f = l[2], t.lineTo(d + r, f + i);
				break;
			case "h":
				d += l[1], t.lineTo(d + r, f + i);
				break;
			case "H":
				d = l[1], t.lineTo(d + r, f + i);
				break;
			case "v":
				f += l[1], t.lineTo(d + r, f + i);
				break;
			case "V":
				f = l[1], t.lineTo(d + r, f + i);
				break;
			case "m":
				d += l[1], f += l[2], E = d, O = f, t.moveTo(d + r, f + i);
				break;
			case "M":
				d = l[1], f = l[2], E = d, O = f, t.moveTo(d + r, f + i);
				break;
			case "c":
				_ = d + l[5], v = f + l[6], p = d + l[3], g = f + l[4], t.bezierCurveTo(d + l[1] + r, f + l[2] + i, p + r, g + i, _ + r, v + i), d = _, f = v;
				break;
			case "C":
				d = l[5], f = l[6], p = l[3], g = l[4], t.bezierCurveTo(l[1] + r, l[2] + i, p + r, g + i, d + r, f + i);
				break;
			case "s":
				_ = d + l[3], v = f + l[4], p = 2 * d - p, g = 2 * f - g, t.bezierCurveTo(p + r, g + i, d + l[1] + r, f + l[2] + i, _ + r, v + i), p = d + l[1], g = f + l[2], d = _, f = v;
				break;
			case "S":
				_ = l[3], v = l[4], p = 2 * d - p, g = 2 * f - g, t.bezierCurveTo(p + r, g + i, l[1] + r, l[2] + i, _ + r, v + i), d = _, f = v, p = l[1], g = l[2];
				break;
			case "q":
				_ = d + l[3], v = f + l[4], p = d + l[1], g = f + l[2], t.quadraticCurveTo(p + r, g + i, _ + r, v + i), d = _, f = v;
				break;
			case "Q":
				_ = l[3], v = l[4], t.quadraticCurveTo(l[1] + r, l[2] + i, _ + r, v + i), d = _, f = v, p = l[1], g = l[2];
				break;
			case "t":
				_ = d + l[1], v = f + l[2], u[0].match(/[QqTt]/) === null ? (p = d, g = f) : u[0] === "t" ? (p = 2 * d - S, g = 2 * f - T) : u[0] === "q" && (p = 2 * d - p, g = 2 * f - g), S = p, T = g, t.quadraticCurveTo(p + r, g + i, _ + r, v + i), d = _, f = v, p = d + l[1], g = f + l[2];
				break;
			case "T":
				_ = l[1], v = l[2], p = 2 * d - p, g = 2 * f - g, t.quadraticCurveTo(p + r, g + i, _ + r, v + i), d = _, f = v;
				break;
			case "a":
				drawArc(t, d + r, f + i, [
					l[1],
					l[2],
					l[3],
					l[4],
					l[5],
					l[6] + d + r,
					l[7] + f + i
				]), d += l[6], f += l[7];
				break;
			case "A":
				drawArc(t, d + r, f + i, [
					l[1],
					l[2],
					l[3],
					l[4],
					l[5],
					l[6] + r,
					l[7] + i
				]), d = l[6], f = l[7];
				break;
			case "z":
			case "Z":
				d = E, f = O, t.closePath();
				break;
		}
		u = l;
	}
}
function drawArc(t, n, r, i) {
	let o = segments(i[5], i[6], i[0], i[1], i[3], i[4], i[2], n, r);
	for (let n = 0; n < o.length; ++n) {
		let r = bezier(o[n]);
		t.bezierCurveTo(r[0], r[1], r[2], r[3], r[4], r[5]);
	}
}
var Tan30 = .5773502691896257, builtins = {
	circle: { draw: function(t, n) {
		let r = Math.sqrt(n) / 2;
		t.moveTo(r, 0), t.arc(0, 0, r, 0, Tau);
	} },
	cross: { draw: function(t, n) {
		var r = Math.sqrt(n) / 2, i = r / 2.5;
		t.moveTo(-r, -i), t.lineTo(-r, i), t.lineTo(-i, i), t.lineTo(-i, r), t.lineTo(i, r), t.lineTo(i, i), t.lineTo(r, i), t.lineTo(r, -i), t.lineTo(i, -i), t.lineTo(i, -r), t.lineTo(-i, -r), t.lineTo(-i, -i), t.closePath();
	} },
	diamond: { draw: function(t, n) {
		let r = Math.sqrt(n) / 2;
		t.moveTo(-r, 0), t.lineTo(0, -r), t.lineTo(r, 0), t.lineTo(0, r), t.closePath();
	} },
	square: { draw: function(t, n) {
		var r = Math.sqrt(n), i = -r / 2;
		t.rect(i, i, r, r);
	} },
	arrow: { draw: function(t, n) {
		var r = Math.sqrt(n) / 2, i = r / 7, o = r / 2.5, s = r / 8;
		t.moveTo(-i, r), t.lineTo(i, r), t.lineTo(i, -s), t.lineTo(o, -s), t.lineTo(0, -r), t.lineTo(-o, -s), t.lineTo(-i, -s), t.closePath();
	} },
	wedge: { draw: function(t, n) {
		var r = Math.sqrt(n) / 2, i = HalfSqrt3 * r, o = i - r * Tan30, s = r / 4;
		t.moveTo(0, -i - o), t.lineTo(-s, i - o), t.lineTo(s, i - o), t.closePath();
	} },
	triangle: { draw: function(t, n) {
		var r = Math.sqrt(n) / 2, i = HalfSqrt3 * r, o = i - r * Tan30;
		t.moveTo(0, -i - o), t.lineTo(-r, i - o), t.lineTo(r, i - o), t.closePath();
	} },
	"triangle-up": { draw: function(t, n) {
		var r = Math.sqrt(n) / 2, i = HalfSqrt3 * r;
		t.moveTo(0, -i), t.lineTo(-r, i), t.lineTo(r, i), t.closePath();
	} },
	"triangle-down": { draw: function(t, n) {
		var r = Math.sqrt(n) / 2, i = HalfSqrt3 * r;
		t.moveTo(0, i), t.lineTo(-r, -i), t.lineTo(r, -i), t.closePath();
	} },
	"triangle-right": { draw: function(t, n) {
		var r = Math.sqrt(n) / 2, i = HalfSqrt3 * r;
		t.moveTo(i, 0), t.lineTo(-i, -r), t.lineTo(-i, r), t.closePath();
	} },
	"triangle-left": { draw: function(t, n) {
		var r = Math.sqrt(n) / 2, i = HalfSqrt3 * r;
		t.moveTo(-i, 0), t.lineTo(i, -r), t.lineTo(i, r), t.closePath();
	} },
	stroke: { draw: function(t, n) {
		let r = Math.sqrt(n) / 2;
		t.moveTo(-r, 0), t.lineTo(r, 0);
	} }
};
function symbols$1(t) {
	return has(builtins, t) ? builtins[t] : customSymbol(t);
}
var custom = {};
function customSymbol(t) {
	if (!has(custom, t)) {
		let n = parse$3(t);
		custom[t] = { draw: function(t, r) {
			pathRender(t, n, 0, 0, Math.sqrt(r) / 2);
		} };
	}
	return custom[t];
}
var C = .448084975506;
function rectangleX(t) {
	return t.x;
}
function rectangleY(t) {
	return t.y;
}
function rectangleWidth(t) {
	return t.width;
}
function rectangleHeight(t) {
	return t.height;
}
function number$3(t) {
	return typeof t == "function" ? t : () => +t;
}
function clamp(t, n, r) {
	return Math.max(n, Math.min(t, r));
}
function vg_rect() {
	var t = rectangleX, n = rectangleY, r = rectangleWidth, i = rectangleHeight, o = number$3(0), s = o, l = o, u = o, d = null;
	function f(f, p, g) {
		var _, v = p ?? +t.call(this, f), S = g ?? +n.call(this, f), T = +r.call(this, f), E = +i.call(this, f), O = Math.min(T, E) / 2, k = clamp(+o.call(this, f), 0, O), A = clamp(+s.call(this, f), 0, O), j = clamp(+l.call(this, f), 0, O), N = clamp(+u.call(this, f), 0, O);
		if (d ||= _ = path(), k <= 0 && A <= 0 && j <= 0 && N <= 0) d.rect(v, S, T, E);
		else {
			var P = v + T, F = S + E;
			d.moveTo(v + k, S), d.lineTo(P - A, S), d.bezierCurveTo(P - C * A, S, P, S + C * A, P, S + A), d.lineTo(P, F - N), d.bezierCurveTo(P, F - C * N, P - C * N, F, P - N, F), d.lineTo(v + j, F), d.bezierCurveTo(v + C * j, F, v, F - C * j, v, F - j), d.lineTo(v, S + k), d.bezierCurveTo(v, S + C * k, v + C * k, S, v + k, S), d.closePath();
		}
		if (_) return d = null, _ + "" || null;
	}
	return f.x = function(n) {
		return arguments.length ? (t = number$3(n), f) : t;
	}, f.y = function(t) {
		return arguments.length ? (n = number$3(t), f) : n;
	}, f.width = function(t) {
		return arguments.length ? (r = number$3(t), f) : r;
	}, f.height = function(t) {
		return arguments.length ? (i = number$3(t), f) : i;
	}, f.cornerRadius = function(t, n, r, i) {
		return arguments.length ? (o = number$3(t), s = n == null ? o : number$3(n), u = r == null ? o : number$3(r), l = i == null ? s : number$3(i), f) : o;
	}, f.context = function(t) {
		return arguments.length ? (d = t ?? null, f) : d;
	}, f;
}
function vg_trail() {
	var t, n, r, i, o = null, s, l, u, d;
	function f(t, n, r) {
		let i = r / 2;
		if (s) {
			var f = u - n, p = t - l;
			if (f || p) {
				var g = Math.hypot(f, p), _ = (f /= g) * d, v = (p /= g) * d, S = Math.atan2(p, f);
				o.moveTo(l - _, u - v), o.lineTo(t - f * i, n - p * i), o.arc(t, n, i, S - Math.PI, S), o.lineTo(l + _, u + v), o.arc(l, u, d, S, S + Math.PI);
			} else o.arc(t, n, i, 0, Tau);
			o.closePath();
		} else s = 1;
		l = t, u = n, d = i;
	}
	function p(l) {
		var u, d = l.length, p, g = !1, _;
		for (o ??= _ = path(), u = 0; u <= d; ++u) !(u < d && i(p = l[u], u, l)) === g && (g = !g) && (s = 0), g && f(+t(p, u, l), +n(p, u, l), +r(p, u, l));
		if (_) return o = null, _ + "" || null;
	}
	return p.x = function(n) {
		return arguments.length ? (t = n, p) : t;
	}, p.y = function(t) {
		return arguments.length ? (n = t, p) : n;
	}, p.size = function(t) {
		return arguments.length ? (r = t, p) : r;
	}, p.defined = function(t) {
		return arguments.length ? (i = t, p) : i;
	}, p.context = function(t) {
		return arguments.length ? (o = t ?? null, p) : o;
	}, p;
}
function value$1(t, n) {
	return t ?? n;
}
var x = (t) => t.x || 0, y = (t) => t.y || 0, w$1 = (t) => t.width || 0, h = (t) => t.height || 0, xw = (t) => (t.x || 0) + (t.width || 0), yh = (t) => (t.y || 0) + (t.height || 0), sa = (t) => t.startAngle || 0, ea = (t) => t.endAngle || 0, pa = (t) => t.padAngle || 0, ir = (t) => t.innerRadius || 0, or = (t) => t.outerRadius || 0, cr = (t) => t.cornerRadius || 0, tl = (t) => value$1(t.cornerRadiusTopLeft, t.cornerRadius) || 0, tr = (t) => value$1(t.cornerRadiusTopRight, t.cornerRadius) || 0, br = (t) => value$1(t.cornerRadiusBottomRight, t.cornerRadius) || 0, bl = (t) => value$1(t.cornerRadiusBottomLeft, t.cornerRadius) || 0, sz = (t) => value$1(t.size, 64), ts = (t) => t.size || 1, def = (t) => t.defined !== !1, type$1 = (t) => symbols$1(t.shape || "circle"), arcShape = arc_default().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr), areavShape = area_default$1().x(x).y1(y).y0(yh).defined(def), areahShape = area_default$1().y(y).x1(x).x0(xw).defined(def), lineShape = line_default().x(x).y(y).defined(def), rectShape = vg_rect().x(x).y(y).width(w$1).height(h).cornerRadius(tl, tr, br, bl), symbolShape = Symbol$1().type(type$1).size(sz), trailShape = vg_trail().x(x).y(y).defined(def).size(ts);
function hasCornerRadius(t) {
	return t.cornerRadius || t.cornerRadiusTopLeft || t.cornerRadiusTopRight || t.cornerRadiusBottomRight || t.cornerRadiusBottomLeft;
}
function arc$1$1(t, n) {
	return arcShape.context(t)(n);
}
function area$1$1(t, n) {
	let r = n[0], i = r.interpolate || "linear";
	return (r.orient === "horizontal" ? areahShape : areavShape).curve(curves(i, r.orient, r.tension)).context(t)(n);
}
function line$1$1(t, n) {
	let r = n[0], i = r.interpolate || "linear";
	return lineShape.curve(curves(i, r.orient, r.tension)).context(t)(n);
}
function rectangle(t, n, r, i) {
	return rectShape.context(t)(n, r, i);
}
function shape$1(t, n) {
	return (n.mark.shape || n.shape).context(t)(n);
}
function symbol$1(t, n) {
	return symbolShape.context(t)(n);
}
function trail$1(t, n) {
	return trailShape.context(t)(n);
}
var clip_id = 1;
function resetSVGClipId() {
	clip_id = 1;
}
function clip$1(t, n, r) {
	var i = n.clip, o = t._defs, s = n.clip_id ||= "clip" + clip_id++, l = o.clipping[s] || (o.clipping[s] = { id: s });
	return isFunction(i) ? l.path = i(null) : hasCornerRadius(r) ? l.path = rectangle(null, r, 0, 0) : (l.width = r.width || 0, l.height = r.height || 0), "url(#" + s + ")";
}
function Bounds(t) {
	this.clear(), t && this.union(t);
}
Bounds.prototype = {
	clone() {
		return new Bounds(this);
	},
	clear() {
		return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
	},
	empty() {
		return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
	},
	equals(t) {
		return this.x1 === t.x1 && this.y1 === t.y1 && this.x2 === t.x2 && this.y2 === t.y2;
	},
	set(t, n, r, i) {
		return r < t ? (this.x2 = t, this.x1 = r) : (this.x1 = t, this.x2 = r), i < n ? (this.y2 = n, this.y1 = i) : (this.y1 = n, this.y2 = i), this;
	},
	add(t, n) {
		return t < this.x1 && (this.x1 = t), n < this.y1 && (this.y1 = n), t > this.x2 && (this.x2 = t), n > this.y2 && (this.y2 = n), this;
	},
	expand(t) {
		return this.x1 -= t, this.y1 -= t, this.x2 += t, this.y2 += t, this;
	},
	round() {
		return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
	},
	scale(t) {
		return this.x1 *= t, this.y1 *= t, this.x2 *= t, this.y2 *= t, this;
	},
	translate(t, n) {
		return this.x1 += t, this.x2 += t, this.y1 += n, this.y2 += n, this;
	},
	rotate(t, n, r) {
		let i = this.rotatedPoints(t, n, r);
		return this.clear().add(i[0], i[1]).add(i[2], i[3]).add(i[4], i[5]).add(i[6], i[7]);
	},
	rotatedPoints(t, n, r) {
		var { x1: i, y1: o, x2: s, y2: l } = this, u = Math.cos(t), d = Math.sin(t), f = n - n * u + r * d, p = r - n * d - r * u;
		return [
			u * i - d * o + f,
			d * i + u * o + p,
			u * i - d * l + f,
			d * i + u * l + p,
			u * s - d * o + f,
			d * s + u * o + p,
			u * s - d * l + f,
			d * s + u * l + p
		];
	},
	union(t) {
		return t.x1 < this.x1 && (this.x1 = t.x1), t.y1 < this.y1 && (this.y1 = t.y1), t.x2 > this.x2 && (this.x2 = t.x2), t.y2 > this.y2 && (this.y2 = t.y2), this;
	},
	intersect(t) {
		return t.x1 > this.x1 && (this.x1 = t.x1), t.y1 > this.y1 && (this.y1 = t.y1), t.x2 < this.x2 && (this.x2 = t.x2), t.y2 < this.y2 && (this.y2 = t.y2), this;
	},
	encloses(t) {
		return t && this.x1 <= t.x1 && this.x2 >= t.x2 && this.y1 <= t.y1 && this.y2 >= t.y2;
	},
	alignsWith(t) {
		return t && (this.x1 == t.x1 || this.x2 == t.x2 || this.y1 == t.y1 || this.y2 == t.y2);
	},
	intersects(t) {
		return t && !(this.x2 < t.x1 || this.x1 > t.x2 || this.y2 < t.y1 || this.y1 > t.y2);
	},
	contains(t, n) {
		return !(t < this.x1 || t > this.x2 || n < this.y1 || n > this.y2);
	},
	width() {
		return this.x2 - this.x1;
	},
	height() {
		return this.y2 - this.y1;
	}
};
function Item(t) {
	this.mark = t, this.bounds = this.bounds || new Bounds();
}
function GroupItem(t) {
	Item.call(this, t), this.items = this.items || [];
}
inherits(GroupItem, Item);
var ResourceLoader = class {
	constructor(t) {
		this._pending = 0, this._loader = t || loader();
	}
	pending() {
		return this._pending;
	}
	sanitizeURL(t) {
		let n = this;
		return increment(n), n._loader.sanitize(t, { context: "href" }).then((t) => (decrement(n), t)).catch(() => (decrement(n), null));
	}
	loadImage(t) {
		let n = this, r = domImage();
		return increment(n), n._loader.sanitize(t, { context: "image" }).then((t) => {
			let i = t.href;
			if (!i || !r) throw { url: i };
			let o = new r(), s = has(t, "crossOrigin") ? t.crossOrigin : "anonymous";
			return s != null && (o.crossOrigin = s), o.onload = () => decrement(n), o.onerror = () => decrement(n), o.src = i, o;
		}).catch((t) => (decrement(n), {
			complete: !1,
			width: 0,
			height: 0,
			src: t && t.url || ""
		}));
	}
	ready() {
		let t = this;
		return new Promise((n) => {
			function r(i) {
				t.pending() ? setTimeout(() => {
					r(!0);
				}, 10) : n(i);
			}
			r(!1);
		});
	}
};
function increment(t) {
	t._pending += 1;
}
function decrement(t) {
	--t._pending;
}
function boundStroke(t, n, r) {
	if (n.stroke && n.opacity !== 0 && n.strokeOpacity !== 0) {
		let i = n.strokeWidth == null ? 1 : +n.strokeWidth;
		t.expand(i + (r ? miterAdjustment(n, i) : 0));
	}
	return t;
}
function miterAdjustment(t, n) {
	return t.strokeJoin && t.strokeJoin !== "miter" ? 0 : n;
}
var circleThreshold = Tau - 1e-8, bounds, lx, ly, rot, ma, mb, mc, md, add$1 = (t, n) => bounds.add(t, n), addL = (t, n) => add$1(lx = t, ly = n), addX = (t) => add$1(t, bounds.y1), addY = (t) => add$1(bounds.x1, t), px = (t, n) => ma * t + mc * n, py = (t, n) => mb * t + md * n, addp = (t, n) => add$1(px(t, n), py(t, n)), addpL = (t, n) => addL(px(t, n), py(t, n));
function boundContext(t, n) {
	return bounds = t, n ? (rot = n * DegToRad, ma = md = Math.cos(rot), mb = Math.sin(rot), mc = -mb) : (ma = md = 1, rot = mb = mc = 0), context$1;
}
var context$1 = {
	beginPath() {},
	closePath() {},
	moveTo: addpL,
	lineTo: addpL,
	rect(t, n, r, i) {
		rot ? (addp(t + r, n), addp(t + r, n + i), addp(t, n + i), addpL(t, n)) : (add$1(t + r, n + i), addL(t, n));
	},
	quadraticCurveTo(t, n, r, i) {
		let o = px(t, n), s = py(t, n), l = px(r, i), u = py(r, i);
		quadExtrema(lx, o, l, addX), quadExtrema(ly, s, u, addY), addL(l, u);
	},
	bezierCurveTo(t, n, r, i, o, s) {
		let l = px(t, n), u = py(t, n), d = px(r, i), f = py(r, i), p = px(o, s), g = py(o, s);
		cubicExtrema(lx, l, d, p, addX), cubicExtrema(ly, u, f, g, addY), addL(p, g);
	},
	arc(t, n, r, i, o, s) {
		if (i += rot, o += rot, lx = r * Math.cos(o) + t, ly = r * Math.sin(o) + n, Math.abs(o - i) > circleThreshold) add$1(t - r, n - r), add$1(t + r, n + r);
		else {
			let l = (i) => add$1(r * Math.cos(i) + t, r * Math.sin(i) + n), u, d;
			if (l(i), l(o), o !== i) if (i %= Tau, i < 0 && (i += Tau), o %= Tau, o < 0 && (o += Tau), o < i && (s = !s, u = i, i = o, o = u), s) for (o -= Tau, u = i - i % HalfPi, d = 0; d < 4 && u > o; ++d, u -= HalfPi) l(u);
			else for (u = i - i % HalfPi + HalfPi, d = 0; d < 4 && u < o; ++d, u += HalfPi) l(u);
		}
	}
};
function quadExtrema(t, n, r, i) {
	let o = (t - n) / (t + r - 2 * n);
	0 < o && o < 1 && i(t + (n - t) * o);
}
function cubicExtrema(t, n, r, i, o) {
	let s = i - t + 3 * n - 3 * r, l = t + r - 2 * n, u = t - n, d = 0, f = 0, p;
	Math.abs(s) > Epsilon ? (p = l * l + u * s, p >= 0 && (p = Math.sqrt(p), d = (-l + p) / s, f = (-l - p) / s)) : d = .5 * u / l, 0 < d && d < 1 && o(cubic(d, t, n, r, i)), 0 < f && f < 1 && o(cubic(f, t, n, r, i));
}
function cubic(t, n, r, i, o) {
	let s = 1 - t, l = s * s, u = t * t;
	return l * s * n + 3 * l * t * r + 3 * s * u * i + u * t * o;
}
var context$2 = (context$2 = domCanvas(1, 1)) ? context$2.getContext("2d") : null, b = new Bounds();
function intersectPath(t) {
	return function(n, r) {
		if (!context$2) return !0;
		t(context$2, n), b.clear().union(n.bounds).intersect(r).round();
		let { x1: i, y1: o, x2: s, y2: l } = b;
		for (let t = o; t <= l; ++t) for (let n = i; n <= s; ++n) if (context$2.isPointInPath(n, t)) return !0;
		return !1;
	};
}
function intersectPoint(t, n) {
	return n.contains(t.x || 0, t.y || 0);
}
function intersectRect(t, n) {
	let r = t.x || 0, i = t.y || 0, o = t.width || 0, s = t.height || 0;
	return n.intersects(b.set(r, i, r + o, i + s));
}
function intersectRule(t, n) {
	let r = t.x || 0, i = t.y || 0;
	return intersectBoxLine(n, r, i, t.x2 == null ? r : t.x2, t.y2 == null ? i : t.y2);
}
function intersectBoxLine(t, n, r, i, o) {
	let { x1: s, y1: l, x2: u, y2: d } = t, f = i - n, p = o - r, g = 0, _ = 1, v, S, T, E;
	for (E = 0; E < 4; ++E) {
		if (E === 0 && (v = -f, S = -(s - n)), E === 1 && (v = f, S = u - n), E === 2 && (v = -p, S = -(l - r)), E === 3 && (v = p, S = d - r), Math.abs(v) < 1e-10 && S < 0) return !1;
		if (T = S / v, v < 0) {
			if (T > _) return !1;
			T > g && (g = T);
		} else if (v > 0) {
			if (T < g) return !1;
			T < _ && (_ = T);
		}
	}
	return !0;
}
function blend(t, n) {
	t.globalCompositeOperation = n.blend || "source-over";
}
function value$2(t, n) {
	return t ?? n;
}
function addStops(t, n) {
	let r = n.length;
	for (let i = 0; i < r; ++i) t.addColorStop(n[i].offset, n[i].color);
	return t;
}
function gradient$2(t, n, r) {
	let i = r.width(), o = r.height(), s;
	if (n.gradient === "radial") s = t.createRadialGradient(r.x1 + value$2(n.x1, .5) * i, r.y1 + value$2(n.y1, .5) * o, Math.max(i, o) * value$2(n.r1, 0), r.x1 + value$2(n.x2, .5) * i, r.y1 + value$2(n.y2, .5) * o, Math.max(i, o) * value$2(n.r2, .5));
	else {
		let l = value$2(n.x1, 0), u = value$2(n.y1, 0), d = value$2(n.x2, 1), f = value$2(n.y2, 0);
		if (l === d || u === f || i === o) s = t.createLinearGradient(r.x1 + l * i, r.y1 + u * o, r.x1 + d * i, r.y1 + f * o);
		else {
			let r = domCanvas(Math.ceil(i), Math.ceil(o)), s = r.getContext("2d");
			return s.scale(i, o), s.fillStyle = addStops(s.createLinearGradient(l, u, d, f), n.stops), s.fillRect(0, 0, i, o), t.createPattern(r, "no-repeat");
		}
	}
	return addStops(s, n.stops);
}
function color$2(t, n, r) {
	return isGradient(r) ? gradient$2(t, r, n.bounds) : r;
}
function fill(t, n, r) {
	return r *= n.fillOpacity == null ? 1 : n.fillOpacity, r > 0 ? (t.globalAlpha = r, t.fillStyle = color$2(t, n, n.fill), !0) : !1;
}
var Empty = [];
function stroke(t, n, r) {
	var i = (i = n.strokeWidth) ?? 1;
	return i <= 0 ? !1 : (r *= n.strokeOpacity == null ? 1 : n.strokeOpacity, r > 0 ? (t.globalAlpha = r, t.strokeStyle = color$2(t, n, n.stroke), t.lineWidth = i, t.lineCap = n.strokeCap || "butt", t.lineJoin = n.strokeJoin || "miter", t.miterLimit = n.strokeMiterLimit || 10, t.setLineDash && (t.setLineDash(n.strokeDash || Empty), t.lineDashOffset = n.strokeDashOffset || 0), !0) : !1);
}
function compare$2(t, n) {
	return t.zindex - n.zindex || t.index - n.index;
}
function zorder(t) {
	if (!t.zdirty) return t.zitems;
	var n = t.items, r = [], i, o, s;
	for (o = 0, s = n.length; o < s; ++o) i = n[o], i.index = o, i.zindex && r.push(i);
	return t.zdirty = !1, t.zitems = r.sort(compare$2);
}
function visit(t, n) {
	var r = t.items, i, o;
	if (!r || !r.length) return;
	let s = zorder(t);
	if (s && s.length) {
		for (i = 0, o = r.length; i < o; ++i) r[i].zindex || n(r[i]);
		r = s;
	}
	for (i = 0, o = r.length; i < o; ++i) n(r[i]);
}
function pickVisit(t, n) {
	var r = t.items, i, o;
	if (!r || !r.length) return null;
	let s = zorder(t);
	for (s && s.length && (r = s), o = r.length; --o >= 0;) if (i = n(r[o])) return i;
	if (r === s) {
		for (r = t.items, o = r.length; --o >= 0;) if (!r[o].zindex && (i = n(r[o]))) return i;
	}
	return null;
}
function drawAll(t) {
	return function(n, r, i) {
		visit(r, (r) => {
			(!i || i.intersects(r.bounds)) && drawPath(t, n, r, r);
		});
	};
}
function drawOne(t) {
	return function(n, r, i) {
		r.items.length && (!i || i.intersects(r.bounds)) && drawPath(t, n, r.items[0], r.items);
	};
}
function drawPath(t, n, r, i) {
	var o = r.opacity == null ? 1 : r.opacity;
	o !== 0 && (t(n, i) || (blend(n, r), r.fill && fill(n, r, o) && n.fill(), r.stroke && stroke(n, r, o) && n.stroke()));
}
function pick$1(t) {
	return t ||= truthy, function(n, r, i, o, s, l) {
		return i *= n.pixelRatio, o *= n.pixelRatio, pickVisit(r, (r) => {
			let u = r.bounds;
			if (!(u && !u.contains(s, l) || !u) && t(n, r, i, o, s, l)) return r;
		});
	};
}
function hitPath(t, n) {
	return function(r, i, o, s) {
		var l = Array.isArray(i) ? i[0] : i, u = n ?? l.fill, d = l.stroke && r.isPointInStroke, f, p;
		return d && (f = l.strokeWidth, p = l.strokeCap, r.lineWidth = f ?? 1, r.lineCap = p ?? "butt"), t(r, i) ? !1 : u && r.isPointInPath(o, s) || d && r.isPointInStroke(o, s);
	};
}
function pickPath(t) {
	return pick$1(hitPath(t));
}
function translate$2(t, n) {
	return "translate(" + t + "," + n + ")";
}
function rotate(t) {
	return "rotate(" + t + ")";
}
function scale$4(t, n) {
	return "scale(" + t + "," + n + ")";
}
function translateItem(t) {
	return translate$2(t.x || 0, t.y || 0);
}
function rotateItem(t) {
	return translate$2(t.x || 0, t.y || 0) + (t.angle ? " " + rotate(t.angle) : "");
}
function transformItem(t) {
	return translate$2(t.x || 0, t.y || 0) + (t.angle ? " " + rotate(t.angle) : "") + (t.scaleX || t.scaleY ? " " + scale$4(t.scaleX || 1, t.scaleY || 1) : "");
}
function markItemPath(t, n, r) {
	function i(t, r) {
		t("transform", rotateItem(r)), t("d", n(null, r));
	}
	function o(t, r) {
		return n(boundContext(t, r.angle), r), boundStroke(t, r).translate(r.x || 0, r.y || 0);
	}
	function s(t, r) {
		var i = r.x || 0, o = r.y || 0, s = r.angle || 0;
		t.translate(i, o), s && t.rotate(s *= DegToRad), t.beginPath(), n(t, r), s && t.rotate(-s), t.translate(-i, -o);
	}
	return {
		type: t,
		tag: "path",
		nested: !1,
		attr: i,
		bound: o,
		draw: drawAll(s),
		pick: pickPath(s),
		isect: r || intersectPath(s)
	};
}
var arc$2 = markItemPath("arc", arc$1$1);
function pickArea(t, n) {
	for (var r = t[0].orient === "horizontal" ? n[1] : n[0], i = t[0].orient === "horizontal" ? "y" : "x", o = t.length, s = Infinity, l, u; --o >= 0;) t[o].defined !== !1 && (u = Math.abs(t[o][i] - r), u < s && (s = u, l = t[o]));
	return l;
}
function pickLine(t, n) {
	for (var r = (t[0].strokeWidth || 1) ** 2, i = t.length, o, s, l; --i >= 0;) if (t[i].defined !== !1 && (o = t[i].x - n[0], s = t[i].y - n[1], l = o * o + s * s, l < r)) return t[i];
	return null;
}
function pickTrail(t, n) {
	for (var r = t.length, i, o, s; --r >= 0;) if (t[r].defined !== !1 && (i = t[r].x - n[0], o = t[r].y - n[1], s = i * i + o * o, i = t[r].size || 1, s < i * i)) return t[r];
	return null;
}
function markMultiItemPath(t, n, r) {
	function i(t, r) {
		var i = r.mark.items;
		i.length && t("d", n(null, i));
	}
	function o(t, r) {
		var i = r.items;
		return i.length === 0 ? t : (n(boundContext(t), i), boundStroke(t, i[0]));
	}
	function s(t, r) {
		t.beginPath(), n(t, r);
	}
	let l = hitPath(s);
	function u(t, n, r, i, o, s) {
		var u = n.items, d = n.bounds;
		return !u || !u.length || d && !d.contains(o, s) ? null : (r *= t.pixelRatio, i *= t.pixelRatio, l(t, u, r, i) ? u[0] : null);
	}
	return {
		type: t,
		tag: "path",
		nested: !0,
		attr: i,
		bound: o,
		draw: drawOne(s),
		pick: u,
		isect: intersectPoint,
		tip: r
	};
}
var area$2 = markMultiItemPath("area", area$1$1, pickArea);
function clip$2(t, n) {
	var r = n.clip;
	t.save(), isFunction(r) ? (t.beginPath(), r(t), t.clip()) : clipGroup(t, n.group);
}
function clipGroup(t, n) {
	t.beginPath(), hasCornerRadius(n) ? rectangle(t, n, 0, 0) : t.rect(0, 0, n.width || 0, n.height || 0), t.clip();
}
function offset$1(t) {
	let n = value$2(t.strokeWidth, 1);
	return t.strokeOffset == null ? t.stroke && n > .5 && n < 1.5 ? .5 - Math.abs(n - 1) : 0 : t.strokeOffset;
}
function attr$5(t, n) {
	t("transform", translateItem(n));
}
function emitRectangle(t, n) {
	let r = offset$1(n);
	t("d", rectangle(null, n, r, r));
}
function background$1(t, n) {
	t("class", "background"), t("aria-hidden", !0), emitRectangle(t, n);
}
function foreground(t, n) {
	t("class", "foreground"), t("aria-hidden", !0), n.strokeForeground ? emitRectangle(t, n) : t("d", "");
}
function content(t, n, r) {
	t("clip-path", n.clip ? clip$1(r, n, n) : null);
}
function bound$5(t, n) {
	if (!n.clip && n.items) {
		let r = n.items, i = r.length;
		for (let n = 0; n < i; ++n) t.union(r[n].bounds);
	}
	return (n.clip || n.width || n.height) && !n.noBound && t.add(0, 0).add(n.width || 0, n.height || 0), boundStroke(t, n), t.translate(n.x || 0, n.y || 0);
}
function rectanglePath(t, n, r, i) {
	let o = offset$1(n);
	t.beginPath(), rectangle(t, n, (r || 0) + o, (i || 0) + o);
}
var hitBackground = hitPath(rectanglePath), hitForeground = hitPath(rectanglePath, !1), hitCorner = hitPath(rectanglePath, !0);
function draw$4(t, n, r, i) {
	visit(n, (n) => {
		let o = n.x || 0, s = n.y || 0, l = n.strokeForeground, u = n.opacity == null ? 1 : n.opacity;
		(n.stroke || n.fill) && u && (rectanglePath(t, n, o, s), blend(t, n), n.fill && fill(t, n, u) && t.fill(), n.stroke && !l && stroke(t, n, u) && t.stroke()), t.save(), t.translate(o, s), n.clip && clipGroup(t, n), r && r.translate(-o, -s), visit(n, (n) => {
			(n.marktype === "group" || i == null || i.includes(n.marktype)) && this.draw(t, n, r, i);
		}), r && r.translate(o, s), t.restore(), l && n.stroke && u && (rectanglePath(t, n, o, s), blend(t, n), stroke(t, n, u) && t.stroke());
	});
}
function pick$2(t, n, r, i, o, s) {
	if (n.bounds && !n.bounds.contains(o, s) || !n.items) return null;
	let l = r * t.pixelRatio, u = i * t.pixelRatio;
	return pickVisit(n, (d) => {
		let f, p, g, _ = d.bounds;
		if (_ && !_.contains(o, s)) return;
		p = d.x || 0, g = d.y || 0;
		let v = p + (d.width || 0), S = g + (d.height || 0), T = d.clip;
		if (T && (o < p || o > v || s < g || s > S)) return;
		if (t.save(), t.translate(p, g), p = o - p, g = s - g, T && hasCornerRadius(d) && !hitCorner(t, d, l, u)) return t.restore(), null;
		let E = d.strokeForeground, O = n.interactive !== !1;
		return O && E && d.stroke && hitForeground(t, d, l, u) ? (t.restore(), d) : (f = pickVisit(d, (t) => pickMark(t, p, g) ? this.pick(t, r, i, p, g) : null), !f && O && (d.fill || !E && d.stroke) && hitBackground(t, d, l, u) && (f = d), t.restore(), f || null);
	});
}
function pickMark(t, n, r) {
	return (t.interactive !== !1 || t.marktype === "group") && t.bounds && t.bounds.contains(n, r);
}
var group = {
	type: "group",
	tag: "g",
	nested: !1,
	attr: attr$5,
	bound: bound$5,
	draw: draw$4,
	pick: pick$2,
	isect: intersectRect,
	content,
	background: background$1,
	foreground
}, metadata = {
	xmlns: "http://www.w3.org/2000/svg",
	"xmlns:xlink": "http://www.w3.org/1999/xlink",
	version: "1.1"
};
function getImage(t, n) {
	var r = t.image;
	return (!r || t.url && t.url !== r.url) && (r = {
		complete: !1,
		width: 0,
		height: 0
	}, n.loadImage(t.url).then((n) => {
		t.image = n, t.image.url = t.url;
	})), r;
}
function imageWidth(t, n) {
	return t.width == null ? !n || !n.width ? 0 : t.aspect !== !1 && t.height ? t.height * n.width / n.height : n.width : t.width;
}
function imageHeight(t, n) {
	return t.height == null ? !n || !n.height ? 0 : t.aspect !== !1 && t.width ? t.width * n.height / n.width : n.height : t.height;
}
function imageXOffset(t, n) {
	return t === "center" ? n / 2 : t === "right" ? n : 0;
}
function imageYOffset(t, n) {
	return t === "middle" ? n / 2 : t === "bottom" ? n : 0;
}
function attr$4(t, n, r) {
	let i = getImage(n, r), o = imageWidth(n, i), s = imageHeight(n, i), l = (n.x || 0) - imageXOffset(n.align, o), u = (n.y || 0) - imageYOffset(n.baseline, s);
	t("href", !i.src && i.toDataURL ? i.toDataURL() : i.src || "", metadata["xmlns:xlink"], "xlink:href"), t("transform", translate$2(l, u)), t("width", o), t("height", s), t("preserveAspectRatio", n.aspect === !1 ? "none" : "xMidYMid");
}
function bound$4(t, n) {
	let r = n.image, i = imageWidth(n, r), o = imageHeight(n, r), s = (n.x || 0) - imageXOffset(n.align, i), l = (n.y || 0) - imageYOffset(n.baseline, o);
	return t.set(s, l, s + i, l + o);
}
function draw$3(t, n, r) {
	visit(n, (n) => {
		if (r && !r.intersects(n.bounds)) return;
		let i = getImage(n, this), o = imageWidth(n, i), s = imageHeight(n, i);
		if (o === 0 || s === 0) return;
		let l = (n.x || 0) - imageXOffset(n.align, o), u = (n.y || 0) - imageYOffset(n.baseline, s), d, f, p;
		n.aspect !== !1 && (d = i.width / i.height, f = n.width / n.height, d === d && f === f && d !== f && (f < d ? (p = o / d, u += (s - p) / 2, s = p) : (p = s * d, l += (o - p) / 2, o = p))), (i.complete || i.toDataURL) && (blend(t, n), t.globalAlpha = n.opacity ?? 1, t.imageSmoothingEnabled = n.smooth !== !1, t.drawImage(i, l, u, o, s));
	});
}
var image$1 = {
	type: "image",
	tag: "image",
	nested: !1,
	attr: attr$4,
	bound: bound$4,
	draw: draw$3,
	pick: pick$1(),
	isect: truthy,
	get: getImage,
	xOffset: imageXOffset,
	yOffset: imageYOffset
}, line$2 = markMultiItemPath("line", line$1$1, pickLine);
function attr$3(t, n) {
	var r = n.scaleX || 1, i = n.scaleY || 1;
	(r !== 1 || i !== 1) && t("vector-effect", "non-scaling-stroke"), t("transform", transformItem(n)), t("d", n.path);
}
function path$1(t, n) {
	var r = n.path;
	if (r == null) return !0;
	var i = n.x || 0, o = n.y || 0, s = n.scaleX || 1, l = n.scaleY || 1, u = (n.angle || 0) * DegToRad, d = n.pathCache;
	(!d || d.path !== r) && ((n.pathCache = d = parse$3(r)).path = r), u && t.rotate && t.translate ? (t.translate(i, o), t.rotate(u), pathRender(t, d, 0, 0, s, l), t.rotate(-u), t.translate(-i, -o)) : pathRender(t, d, i, o, s, l);
}
function bound$3(t, n) {
	return path$1(boundContext(t, n.angle), n) ? t.set(0, 0, 0, 0) : boundStroke(t, n, !0);
}
var path$2 = {
	type: "path",
	tag: "path",
	nested: !1,
	attr: attr$3,
	bound: bound$3,
	draw: drawAll(path$1),
	pick: pickPath(path$1),
	isect: intersectPath(path$1)
};
function attr$2(t, n) {
	t("d", rectangle(null, n));
}
function bound$2(t, n) {
	var r, i;
	return boundStroke(t.set(r = n.x || 0, i = n.y || 0, r + n.width || 0, i + n.height || 0), n);
}
function draw$2(t, n) {
	t.beginPath(), rectangle(t, n);
}
var rect$1 = {
	type: "rect",
	tag: "path",
	nested: !1,
	attr: attr$2,
	bound: bound$2,
	draw: drawAll(draw$2),
	pick: pickPath(draw$2),
	isect: intersectRect
};
function attr$1(t, n) {
	t("transform", translateItem(n)), t("x2", n.x2 == null ? 0 : n.x2 - (n.x || 0)), t("y2", n.y2 == null ? 0 : n.y2 - (n.y || 0));
}
function bound$1(t, n) {
	var r, i;
	return boundStroke(t.set(r = n.x || 0, i = n.y || 0, n.x2 == null ? r : n.x2, n.y2 == null ? i : n.y2), n);
}
function path$3(t, n, r) {
	var i, o, s, l;
	return n.stroke && stroke(t, n, r) ? (i = n.x || 0, o = n.y || 0, s = n.x2 == null ? i : n.x2, l = n.y2 == null ? o : n.y2, t.beginPath(), t.moveTo(i, o), t.lineTo(s, l), !0) : !1;
}
function draw$1(t, n, r) {
	visit(n, (n) => {
		if (!(r && !r.intersects(n.bounds))) {
			var i = n.opacity == null ? 1 : n.opacity;
			i && path$3(t, n, i) && (blend(t, n), t.stroke());
		}
	});
}
function hit$1(t, n, r, i) {
	return t.isPointInStroke ? path$3(t, n, 1) && t.isPointInStroke(r, i) : !1;
}
var rule$2 = {
	type: "rule",
	tag: "line",
	nested: !1,
	attr: attr$1,
	bound: bound$1,
	draw: draw$1,
	pick: pick$1(hit$1),
	isect: intersectRule
}, shape = markItemPath("shape", shape$1), symbol = markItemPath("symbol", symbol$1, intersectPoint), widthCache = lruCache(), textMetrics = {
	height: fontSize,
	measureWidth,
	estimateWidth,
	width: estimateWidth,
	canvas: useCanvas
};
useCanvas(!0);
function useCanvas(t) {
	textMetrics.width = t && context$2 ? measureWidth : estimateWidth;
}
function estimateWidth(t, n) {
	return _estimateWidth(textValue(t, n), fontSize(t));
}
function _estimateWidth(t, n) {
	return ~~(.8 * t.length * n);
}
function measureWidth(t, n) {
	return fontSize(t) <= 0 || !(n = textValue(t, n)) ? 0 : _measureWidth(n, font$1(t));
}
function _measureWidth(t, n) {
	let r = `(${n}) ${t}`, i = widthCache.get(r);
	return i === void 0 && (context$2.font = n, i = context$2.measureText(t).width, widthCache.set(r, i)), i;
}
function fontSize(t) {
	return t.fontSize == null ? 11 : +t.fontSize || 0;
}
function lineHeight(t) {
	return t.lineHeight == null ? fontSize(t) + 2 : t.lineHeight;
}
function lineArray(t) {
	return isArray(t) ? t.length > 1 ? t : t[0] : t;
}
function textLines(t) {
	return lineArray(t.lineBreak && t.text && !isArray(t.text) ? t.text.split(t.lineBreak) : t.text);
}
function multiLineOffset(t) {
	let n = textLines(t);
	return (isArray(n) ? n.length - 1 : 0) * lineHeight(t);
}
function textValue(t, n) {
	let r = n == null ? "" : (n + "").trim();
	return t.limit > 0 && r.length ? truncate$1(t, r) : r;
}
function widthGetter(t) {
	if (textMetrics.width === measureWidth) {
		let n = font$1(t);
		return (t) => _measureWidth(t, n);
	} else if (textMetrics.width === estimateWidth) {
		let n = fontSize(t);
		return (t) => _estimateWidth(t, n);
	} else return (n) => textMetrics.width(t, n);
}
function truncate$1(t, n) {
	var r = +t.limit, i = widthGetter(t);
	if (i(n) < r) return n;
	var o = t.ellipsis || "…", s = t.dir === "rtl", l = 0, u = n.length, d;
	if (r -= i(o), s) {
		for (; l < u;) d = l + u >>> 1, i(n.slice(d)) > r ? l = d + 1 : u = d;
		return o + n.slice(l);
	} else {
		for (; l < u;) d = 1 + (l + u >>> 1), i(n.slice(0, d)) < r ? l = d : u = d - 1;
		return n.slice(0, l) + o;
	}
}
function fontFamily(t, n) {
	var r = t.font;
	return (n && r ? String(r).replace(/"/g, "'") : r) || "sans-serif";
}
function font$1(t, n) {
	return (t.fontStyle ? t.fontStyle + " " : "") + (t.fontVariant ? t.fontVariant + " " : "") + (t.fontWeight ? t.fontWeight + " " : "") + fontSize(t) + "px " + fontFamily(t, n);
}
function offset$2(t) {
	var n = t.baseline, r = fontSize(t);
	return Math.round(n === "top" ? .79 * r : n === "middle" ? .3 * r : n === "bottom" ? -.21 * r : n === "line-top" ? .29 * r + .5 * lineHeight(t) : n === "line-bottom" ? .29 * r - .5 * lineHeight(t) : 0);
}
var textAlign = {
	left: "start",
	center: "middle",
	right: "end"
}, tempBounds$1 = new Bounds();
function anchorPoint(t) {
	var n = t.x || 0, r = t.y || 0, i = t.radius || 0, o;
	return i && (o = (t.theta || 0) - HalfPi, n += i * Math.cos(o), r += i * Math.sin(o)), tempBounds$1.x1 = n, tempBounds$1.y1 = r, tempBounds$1;
}
function attr(t, n) {
	var r = n.dx || 0, i = (n.dy || 0) + offset$2(n), o = anchorPoint(n), s = o.x1, l = o.y1, u = n.angle || 0, d;
	t("text-anchor", textAlign[n.align] || "start"), u ? (d = translate$2(s, l) + " " + rotate(u), (r || i) && (d += " " + translate$2(r, i))) : d = translate$2(s + r, l + i), t("transform", d);
}
function bound(t, n, r) {
	var i = textMetrics.height(n), o = n.align, s = anchorPoint(n), l = s.x1, u = s.y1, d = n.dx || 0, f = (n.dy || 0) + offset$2(n) - Math.round(.8 * i), p = textLines(n), g;
	if (isArray(p) ? (i += lineHeight(n) * (p.length - 1), g = p.reduce((t, r) => Math.max(t, textMetrics.width(n, r)), 0)) : g = textMetrics.width(n, p), o === "center" ? d -= g / 2 : o === "right" && (d -= g), t.set(d += l, f += u, d + g, f + i), n.angle && !r) t.rotate(n.angle * DegToRad, l, u);
	else if (r === 2) return t.rotatedPoints(n.angle * DegToRad, l, u);
	return t;
}
function draw$5(t, n, r) {
	visit(n, (n) => {
		var i = n.opacity == null ? 1 : n.opacity, o, s, l, u, d, f, p;
		if (!(r && !r.intersects(n.bounds) || i === 0 || n.fontSize <= 0 || n.text == null || n.text.length === 0)) {
			if (t.font = font$1(n), t.textAlign = n.align || "left", o = anchorPoint(n), s = o.x1, l = o.y1, n.angle && (t.save(), t.translate(s, l), t.rotate(n.angle * DegToRad), s = l = 0), s += n.dx || 0, l += (n.dy || 0) + offset$2(n), f = textLines(n), blend(t, n), isArray(f)) for (d = lineHeight(n), u = 0; u < f.length; ++u) p = textValue(n, f[u]), n.fill && fill(t, n, i) && t.fillText(p, s, l), n.stroke && stroke(t, n, i) && t.strokeText(p, s, l), l += d;
			else p = textValue(n, f), n.fill && fill(t, n, i) && t.fillText(p, s, l), n.stroke && stroke(t, n, i) && t.strokeText(p, s, l);
			n.angle && t.restore();
		}
	});
}
function hit(t, n, r, i, o, s) {
	if (n.fontSize <= 0) return !1;
	if (!n.angle) return !0;
	var l = anchorPoint(n), u = l.x1, d = l.y1, f = bound(tempBounds$1, n, 1), p = -n.angle * DegToRad, g = Math.cos(p), _ = Math.sin(p), v = g * o - _ * s + (u - g * u + _ * d), S = _ * o + g * s + (d - _ * u - g * d);
	return f.contains(v, S);
}
function intersectText(t, n) {
	let r = bound(tempBounds$1, t, 2);
	return intersectBoxLine(n, r[0], r[1], r[2], r[3]) || intersectBoxLine(n, r[0], r[1], r[4], r[5]) || intersectBoxLine(n, r[4], r[5], r[6], r[7]) || intersectBoxLine(n, r[2], r[3], r[6], r[7]);
}
var Marks = {
	arc: arc$2,
	area: area$2,
	group,
	image: image$1,
	line: line$2,
	path: path$2,
	rect: rect$1,
	rule: rule$2,
	shape,
	symbol,
	text: {
		type: "text",
		tag: "text",
		nested: !1,
		attr,
		bound,
		draw: draw$5,
		pick: pick$1(hit),
		isect: intersectText
	},
	trail: markMultiItemPath("trail", trail$1, pickTrail)
};
function boundItem$1(t, n, r) {
	var i = Marks[t.mark.marktype], o = n || i.bound;
	return i.nested && (t = t.mark), o(t.bounds ||= new Bounds(), t, r);
}
var DUMMY = { mark: null };
function boundMark(t, n, r) {
	var i = Marks[t.marktype], o = i.bound, s = t.items, l = s && s.length, u, d, f, p;
	if (i.nested) return l ? f = s[0] : (DUMMY.mark = t, f = DUMMY), p = boundItem$1(f, o, r), n = n && n.union(p) || p, n;
	if (n = n || t.bounds && t.bounds.clear() || new Bounds(), l) for (u = 0, d = s.length; u < d; ++u) n.union(boundItem$1(s[u], o, r));
	return t.bounds = n;
}
var keys$2 = /* @__PURE__ */ "marktype.name.role.interactive.clip.items.zindex.x.y.width.height.align.baseline.fill.fillOpacity.opacity.blend.stroke.strokeOpacity.strokeWidth.strokeCap.strokeDash.strokeDashOffset.strokeForeground.strokeOffset.startAngle.endAngle.innerRadius.outerRadius.cornerRadius.padAngle.cornerRadiusTopLeft.cornerRadiusTopRight.cornerRadiusBottomLeft.cornerRadiusBottomRight.interpolate.tension.orient.defined.url.aspect.smooth.path.scaleX.scaleY.x2.y2.size.shape.text.angle.theta.radius.dir.dx.dy.ellipsis.limit.lineBreak.lineHeight.font.fontSize.fontWeight.fontStyle.fontVariant.description.aria.ariaRole.ariaRoleDescription".split(".");
function sceneToJSON(t, n) {
	return JSON.stringify(t, keys$2, n);
}
function sceneFromJSON(t) {
	return initialize$1(typeof t == "string" ? JSON.parse(t) : t);
}
function initialize$1(t) {
	var n = t.marktype, r = t.items, i, o, s;
	if (r) for (o = 0, s = r.length; o < s; ++o) i = n ? "mark" : "group", r[o][i] = t, r[o].zindex && (r[o][i].zdirty = !0), (n || i) === "group" && initialize$1(r[o]);
	return n && boundMark(t), t;
}
var Scenegraph = class {
	constructor(t) {
		arguments.length ? this.root = sceneFromJSON(t) : (this.root = createMark({
			marktype: "group",
			name: "root",
			role: "frame"
		}), this.root.items = [new GroupItem(this.root)]);
	}
	toJSON(t) {
		return sceneToJSON(this.root, t || 0);
	}
	mark(t, n, r) {
		n ||= this.root.items[0];
		let i = createMark(t, n);
		return n.items[r] = i, i.zindex && (i.group.zdirty = !0), i;
	}
};
function createMark(t, n) {
	let r = {
		bounds: new Bounds(),
		clip: !!t.clip,
		group: n,
		interactive: t.interactive !== !1,
		items: [],
		marktype: t.marktype,
		name: t.name || void 0,
		role: t.role || void 0,
		zindex: t.zindex || 0
	};
	return t.aria != null && (r.aria = t.aria), t.description && (r.description = t.description), r;
}
function domCreate(t, n, r) {
	return !t && typeof document < "u" && document.createElement && (t = document), t ? r ? t.createElementNS(r, n) : t.createElement(n) : null;
}
function domFind(t, n) {
	n = n.toLowerCase();
	for (var r = t.childNodes, i = 0, o = r.length; i < o; ++i) if (r[i].tagName.toLowerCase() === n) return r[i];
}
function domChild(t, n, r, i) {
	var o = t.childNodes[n], s;
	return (!o || o.tagName.toLowerCase() !== r.toLowerCase()) && (s = o || null, o = domCreate(t.ownerDocument, r, i), t.insertBefore(o, s)), o;
}
function domClear(t, n) {
	for (var r = t.childNodes, i = r.length; i > n;) t.removeChild(r[--i]);
	return t;
}
function cssClass(t) {
	return "mark-" + t.marktype + (t.role ? " role-" + t.role : "") + (t.name ? " " + t.name : "");
}
function point$2(t, n) {
	let r = n.getBoundingClientRect();
	return [t.clientX - r.left - (n.clientLeft || 0), t.clientY - r.top - (n.clientTop || 0)];
}
function resolveItem(t, n, r, i) {
	var o = t && t.mark, s, l;
	if (o && (s = Marks[o.marktype]).tip) {
		for (l = point$2(n, r), l[0] -= i[0], l[1] -= i[1]; t = t.mark.group;) l[0] -= t.x || 0, l[1] -= t.y || 0;
		t = s.tip(o.items, l);
	}
	return t;
}
var Handler$1 = class {
	constructor(t, n) {
		this._active = null, this._handlers = {}, this._loader = t || loader(), this._tooltip = n || defaultTooltip$1;
	}
	initialize(t, n, r) {
		return this._el = t, this._obj = r || null, this.origin(n);
	}
	element() {
		return this._el;
	}
	canvas() {
		return this._el && this._el.firstChild;
	}
	origin(t) {
		return arguments.length ? (this._origin = t || [0, 0], this) : this._origin.slice();
	}
	scene(t) {
		return arguments.length ? (this._scene = t, this) : this._scene;
	}
	on() {}
	off() {}
	_handlerIndex(t, n, r) {
		for (let i = t ? t.length : 0; --i >= 0;) if (t[i].type === n && (!r || t[i].handler === r)) return i;
		return -1;
	}
	handlers(t) {
		let n = this._handlers, r = [];
		if (t) r.push(...n[this.eventName(t)]);
		else for (let t in n) r.push(...n[t]);
		return r;
	}
	eventName(t) {
		let n = t.indexOf(".");
		return n < 0 ? t : t.slice(0, n);
	}
	handleHref(t, n, r) {
		this._loader.sanitize(r, { context: "href" }).then((n) => {
			let r = new MouseEvent(t.type, t), i = domCreate(null, "a");
			for (let t in n) i.setAttribute(t, n[t]);
			i.dispatchEvent(r);
		}).catch(() => {});
	}
	handleTooltip(t, n, r) {
		if (n && n.tooltip != null) {
			n = resolveItem(n, t, this.canvas(), this._origin);
			let i = r && n && n.tooltip || null;
			this._tooltip.call(this._obj, this, t, n, i);
		}
	}
	getItemBoundingClientRect(t) {
		let n = this.canvas();
		if (!n) return;
		let r = n.getBoundingClientRect(), i = this._origin, o = t.bounds, s = o.width(), l = o.height(), u = o.x1 + i[0] + r.left, d = o.y1 + i[1] + r.top;
		for (; t.mark && (t = t.mark.group);) u += t.x || 0, d += t.y || 0;
		return {
			x: u,
			y: d,
			width: s,
			height: l,
			left: u,
			top: d,
			right: u + s,
			bottom: d + l
		};
	}
};
function defaultTooltip$1(t, n, r, i) {
	t.element().setAttribute("title", i || "");
}
var Renderer = class {
	constructor(t) {
		this._el = null, this._bgcolor = null, this._loader = new ResourceLoader(t);
	}
	initialize(t, n, r, i, o) {
		return this._el = t, this.resize(n, r, i, o);
	}
	element() {
		return this._el;
	}
	canvas() {
		return this._el && this._el.firstChild;
	}
	background(t) {
		return arguments.length === 0 ? this._bgcolor : (this._bgcolor = t, this);
	}
	resize(t, n, r, i) {
		return this._width = t, this._height = n, this._origin = r || [0, 0], this._scale = i || 1, this;
	}
	dirty() {}
	render(t, n) {
		let r = this;
		return r._call = function() {
			r._render(t, n);
		}, r._call(), r._call = null, r;
	}
	_render() {}
	renderAsync(t, n) {
		let r = this.render(t, n);
		return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
	}
	_load(t, n) {
		var r = this, i = r._loader[t](n);
		if (!r._ready) {
			let t = r._call;
			r._ready = r._loader.ready().then((n) => {
				n && t(), r._ready = null;
			});
		}
		return i;
	}
	sanitizeURL(t) {
		return this._load("sanitizeURL", t);
	}
	loadImage(t) {
		return this._load("loadImage", t);
	}
}, KeyDownEvent = "keydown", KeyPressEvent = "keypress", KeyUpEvent = "keyup", DragEnterEvent = "dragenter", DragLeaveEvent = "dragleave", DragOverEvent = "dragover", PointerDownEvent = "pointerdown", PointerUpEvent = "pointerup", PointerMoveEvent = "pointermove", PointerOutEvent = "pointerout", PointerOverEvent = "pointerover", MouseDownEvent = "mousedown", MouseUpEvent = "mouseup", MouseMoveEvent = "mousemove", MouseOutEvent = "mouseout", MouseOverEvent = "mouseover", ClickEvent = "click", DoubleClickEvent = "dblclick", WheelEvent = "wheel", MouseWheelEvent = "mousewheel", TouchStartEvent = "touchstart", TouchMoveEvent = "touchmove", TouchEndEvent = "touchend", Events = [
	KeyDownEvent,
	KeyPressEvent,
	KeyUpEvent,
	DragEnterEvent,
	DragLeaveEvent,
	DragOverEvent,
	PointerDownEvent,
	PointerUpEvent,
	PointerMoveEvent,
	PointerOutEvent,
	PointerOverEvent,
	MouseDownEvent,
	MouseUpEvent,
	MouseMoveEvent,
	MouseOutEvent,
	MouseOverEvent,
	ClickEvent,
	DoubleClickEvent,
	WheelEvent,
	MouseWheelEvent,
	TouchStartEvent,
	TouchMoveEvent,
	TouchEndEvent
], TooltipShowEvent = PointerMoveEvent, TooltipHideEvent = MouseOutEvent, HrefEvent = ClickEvent, CanvasHandler = class extends Handler$1 {
	constructor(t, n) {
		super(t, n), this._down = null, this._touch = null, this._first = !0, this._events = {}, this.events = Events, this.pointermove = move([PointerMoveEvent, MouseMoveEvent], [PointerOverEvent, MouseOverEvent], [PointerOutEvent, MouseOutEvent]), this.dragover = move([DragOverEvent], [DragEnterEvent], [DragLeaveEvent]), this.pointerout = inactive([PointerOutEvent, MouseOutEvent]), this.dragleave = inactive([DragLeaveEvent]);
	}
	initialize(t, n, r) {
		return this._canvas = t && domFind(t, "canvas"), [
			ClickEvent,
			MouseDownEvent,
			PointerDownEvent,
			PointerMoveEvent,
			PointerOutEvent,
			DragLeaveEvent
		].forEach((t) => eventListenerCheck(this, t)), super.initialize(t, n, r);
	}
	canvas() {
		return this._canvas;
	}
	context() {
		return this._canvas.getContext("2d");
	}
	DOMMouseScroll(t) {
		this.fire(MouseWheelEvent, t);
	}
	pointerdown(t) {
		this._down = this._active, this.fire(PointerDownEvent, t);
	}
	mousedown(t) {
		this._down = this._active, this.fire(MouseDownEvent, t);
	}
	click(t) {
		this._down === this._active && (this.fire(ClickEvent, t), this._down = null);
	}
	touchstart(t) {
		this._touch = this.pickEvent(t.changedTouches[0]), this._first &&= (this._active = this._touch, !1), this.fire(TouchStartEvent, t, !0);
	}
	touchmove(t) {
		this.fire(TouchMoveEvent, t, !0);
	}
	touchend(t) {
		this.fire(TouchEndEvent, t, !0), this._touch = null;
	}
	fire(t, n, r) {
		let i = r ? this._touch : this._active, o = this._handlers[t];
		if (n.vegaType = t, t === HrefEvent && i && i.href ? this.handleHref(n, i, i.href) : (t === TooltipShowEvent || t === TooltipHideEvent) && this.handleTooltip(n, i, t !== TooltipHideEvent), o) for (let t = 0, r = o.length; t < r; ++t) o[t].handler.call(this._obj, n, i);
	}
	on(t, n) {
		let r = this.eventName(t), i = this._handlers;
		return this._handlerIndex(i[r], t, n) < 0 && (eventListenerCheck(this, t), (i[r] || (i[r] = [])).push({
			type: t,
			handler: n
		})), this;
	}
	off(t, n) {
		let r = this.eventName(t), i = this._handlers[r], o = this._handlerIndex(i, t, n);
		return o >= 0 && i.splice(o, 1), this;
	}
	pickEvent(t) {
		let n = point$2(t, this._canvas), r = this._origin;
		return this.pick(this._scene, n[0], n[1], n[0] - r[0], n[1] - r[1]);
	}
	pick(t, n, r, i, o) {
		let s = this.context();
		return Marks[t.marktype].pick.call(this, s, t, n, r, i, o);
	}
}, eventBundle = (t) => t === TouchStartEvent || t === TouchMoveEvent || t === TouchEndEvent ? [
	TouchStartEvent,
	TouchMoveEvent,
	TouchEndEvent
] : [t];
function eventListenerCheck(t, n) {
	eventBundle(n).forEach((n) => addEventListener(t, n));
}
function addEventListener(t, n) {
	let r = t.canvas();
	r && !t._events[n] && (t._events[n] = 1, r.addEventListener(n, t[n] ? (r) => t[n](r) : (r) => t.fire(n, r)));
}
function fireAll(t, n, r) {
	n.forEach((n) => t.fire(n, r));
}
function move(t, n, r) {
	return function(i) {
		let o = this._active, s = this.pickEvent(i);
		s === o ? fireAll(this, t, i) : ((!o || !o.exit) && fireAll(this, r, i), this._active = s, fireAll(this, n, i), fireAll(this, t, i));
	};
}
function inactive(t) {
	return function(n) {
		fireAll(this, t, n), this._active = null;
	};
}
function devicePixelRatio() {
	return typeof window < "u" && window.devicePixelRatio || 1;
}
function resize(t, n, r, i, o, s) {
	let l = typeof HTMLElement < "u" && t instanceof HTMLElement && t.parentNode != null, u = t.getContext("2d"), d = l ? devicePixelRatio() : o;
	for (let i in t.width = n * d, t.height = r * d, s) u[i] = s[i];
	return l && d !== 1 && (t.style.width = n + "px", t.style.height = r + "px"), u.pixelRatio = d, u.setTransform(d, 0, 0, d, d * i[0], d * i[1]), t;
}
var CanvasRenderer = class extends Renderer {
	constructor(t) {
		super(t), this._options = {}, this._redraw = !1, this._dirty = new Bounds(), this._tempb = new Bounds();
	}
	initialize(t, n, r, i, o, s) {
		return this._options = s || {}, this._canvas = this._options.externalContext ? null : domCanvas(1, 1, this._options.type), t && this._canvas && (domClear(t, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), super.initialize(t, n, r, i, o);
	}
	resize(t, n, r, i) {
		if (super.resize(t, n, r, i), this._canvas) resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
		else {
			let t = this._options.externalContext;
			t || error$1("CanvasRenderer is missing a valid canvas or context"), t.scale(this._scale, this._scale), t.translate(this._origin[0], this._origin[1]);
		}
		return this._redraw = !0, this;
	}
	canvas() {
		return this._canvas;
	}
	context() {
		return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
	}
	dirty(t) {
		let n = this._tempb.clear().union(t.bounds), r = t.mark.group;
		for (; r;) n.translate(r.x || 0, r.y || 0), r = r.mark.group;
		this._dirty.union(n);
	}
	_render(t, n) {
		let r = this.context(), i = this._origin, o = this._width, s = this._height, l = this._dirty, u = viewBounds(i, o, s);
		r.save();
		let d = this._redraw || l.empty() ? (this._redraw = !1, u.expand(1)) : clipToBounds(r, u.intersect(l), i);
		return this.clear(-i[0], -i[1], o, s), this.draw(r, t, d, n), r.restore(), l.clear(), this;
	}
	draw(t, n, r, i) {
		if (n.marktype !== "group" && i != null && !i.includes(n.marktype)) return;
		let o = Marks[n.marktype];
		n.clip && clip$2(t, n), o.draw.call(this, t, n, r, i), n.clip && t.restore();
	}
	clear(t, n, r, i) {
		let o = this._options, s = this.context();
		o.type !== "pdf" && !o.externalContext && s.clearRect(t, n, r, i), this._bgcolor != null && (s.fillStyle = this._bgcolor, s.fillRect(t, n, r, i));
	}
}, viewBounds = (t, n, r) => new Bounds().set(0, 0, n, r).translate(-t[0], -t[1]);
function clipToBounds(t, n, r) {
	return n.expand(1).round(), t.pixelRatio % 1 && n.scale(t.pixelRatio).round().scale(1 / t.pixelRatio), n.translate(-(r[0] % 1), -(r[1] % 1)), t.beginPath(), t.rect(n.x1, n.y1, n.width(), n.height()), t.clip(), n;
}
var SVGHandler = class extends Handler$1 {
	constructor(t, n) {
		super(t, n);
		let r = this;
		r._hrefHandler = listener(r, (t, n) => {
			n && n.href && r.handleHref(t, n, n.href);
		}), r._tooltipHandler = listener(r, (t, n) => {
			r.handleTooltip(t, n, t.type !== TooltipHideEvent);
		});
	}
	initialize(t, n, r) {
		let i = this._svg;
		return i && (i.removeEventListener(HrefEvent, this._hrefHandler), i.removeEventListener(TooltipShowEvent, this._tooltipHandler), i.removeEventListener(TooltipHideEvent, this._tooltipHandler)), this._svg = i = t && domFind(t, "svg"), i && (i.addEventListener(HrefEvent, this._hrefHandler), i.addEventListener(TooltipShowEvent, this._tooltipHandler), i.addEventListener(TooltipHideEvent, this._tooltipHandler)), super.initialize(t, n, r);
	}
	canvas() {
		return this._svg;
	}
	on(t, n) {
		let r = this.eventName(t), i = this._handlers;
		if (this._handlerIndex(i[r], t, n) < 0) {
			let o = {
				type: t,
				handler: n,
				listener: listener(this, n)
			};
			(i[r] || (i[r] = [])).push(o), this._svg && this._svg.addEventListener(r, o.listener);
		}
		return this;
	}
	off(t, n) {
		let r = this.eventName(t), i = this._handlers[r], o = this._handlerIndex(i, t, n);
		return o >= 0 && (this._svg && this._svg.removeEventListener(r, i[o].listener), i.splice(o, 1)), this;
	}
}, listener = (t, n) => (r) => {
	let i = r.target.__data__;
	i = Array.isArray(i) ? i[0] : i, r.vegaType = r.type, n.call(t._obj, r, i);
}, ARIA_HIDDEN = "aria-hidden", ARIA_LABEL = "aria-label", ARIA_ROLE = "role", ARIA_ROLEDESCRIPTION = "aria-roledescription", GRAPHICS_OBJECT = "graphics-object", GRAPHICS_SYMBOL = "graphics-symbol", bundle = (t, n, r) => ({
	[ARIA_ROLE]: t,
	[ARIA_ROLEDESCRIPTION]: n,
	[ARIA_LABEL]: r || void 0
}), AriaIgnore = toSet([
	"axis-domain",
	"axis-grid",
	"axis-label",
	"axis-tick",
	"axis-title",
	"legend-band",
	"legend-entry",
	"legend-gradient",
	"legend-label",
	"legend-title",
	"legend-symbol",
	"title"
]), AriaGuides = {
	axis: {
		desc: "axis",
		caption: axisCaption
	},
	legend: {
		desc: "legend",
		caption: legendCaption
	},
	"title-text": {
		desc: "title",
		caption: (t) => `Title text '${titleCaption(t)}'`
	},
	"title-subtitle": {
		desc: "subtitle",
		caption: (t) => `Subtitle text '${titleCaption(t)}'`
	}
}, AriaEncode = {
	ariaRole: ARIA_ROLE,
	ariaRoleDescription: ARIA_ROLEDESCRIPTION,
	description: ARIA_LABEL
};
function ariaItemAttributes(t, n) {
	let r = n.aria === !1;
	if (t(ARIA_HIDDEN, r || void 0), r || n.description == null) for (let n in AriaEncode) t(AriaEncode[n], void 0);
	else {
		let r = n.mark.marktype;
		t(ARIA_LABEL, n.description), t(ARIA_ROLE, n.ariaRole || (r === "group" ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL)), t(ARIA_ROLEDESCRIPTION, n.ariaRoleDescription || `${r} mark`);
	}
}
function ariaMarkAttributes(t) {
	return t.aria === !1 ? { [ARIA_HIDDEN]: !0 } : AriaIgnore[t.role] ? null : AriaGuides[t.role] ? ariaGuide(t, AriaGuides[t.role]) : ariaMark(t);
}
function ariaMark(t) {
	let n = t.marktype;
	return bundle(n === "group" || n === "text" || t.items.some((t) => t.description != null && t.aria !== !1) ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${n} mark container`, t.description);
}
function ariaGuide(t, n) {
	try {
		let r = t.items[0], i = n.caption || (() => "");
		return bundle(n.role || GRAPHICS_SYMBOL, n.desc, r.description || i(r));
	} catch {
		return null;
	}
}
function titleCaption(t) {
	return array(t.text).join(" ");
}
function axisCaption(t) {
	let n = t.datum, r = t.orient, i = n.title ? extractTitle(t) : null, o = t.context, s = o.scales[n.scale].value, l = o.dataflow.locale(), u = s.type;
	return `${r === "left" || r === "right" ? "Y" : "X"}-axis` + (i ? ` titled '${i}'` : "") + ` for a ${isDiscrete$2(u) ? "discrete" : u} scale with ${domainCaption(l, s, t)}`;
}
function legendCaption(t) {
	let n = t.datum, r = n.title ? extractTitle(t) : null, i = `${n.type || ""} legend`.trim(), o = n.scales, s = Object.keys(o), l = t.context, u = l.scales[o[s[0]]].value, d = l.dataflow.locale();
	return capitalize(i) + (r ? ` titled '${r}'` : "") + ` for ${channelCaption(s)} with ${domainCaption(d, u, t)}`;
}
function extractTitle(t) {
	try {
		return array(peek(t.items).items[0].text).join(" ");
	} catch {
		return null;
	}
}
function channelCaption(t) {
	return t = t.map((t) => t + (t === "fill" || t === "stroke" ? " color" : "")), t.length < 2 ? t[0] : t.slice(0, -1).join(", ") + " and " + peek(t);
}
function capitalize(t) {
	return t.length ? t[0].toUpperCase() + t.slice(1) : t;
}
var innerText = (t) => (t + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), attrText = (t) => innerText(t).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function markup() {
	let t = "", n = "", r = "", i = [], o = () => n = r = "", s = (s) => {
		n && (t += `${n}>${r}`, o()), i.push(s);
	}, l = (t, r) => (r != null && (n += ` ${t}="${attrText(r)}"`), u), u = {
		open(t, ...r) {
			s(t), n = "<" + t;
			for (let t of r) for (let n in t) l(n, t[n]);
			return u;
		},
		close() {
			let s = i.pop();
			return n ? t += n + (r ? `>${r}</${s}>` : "/>") : t += `</${s}>`, o(), u;
		},
		attr: l,
		text: (t) => (r += innerText(t), u),
		toString: () => t
	};
	return u;
}
var serializeXML = (t) => _serialize(markup(), t) + "";
function _serialize(t, n) {
	if (t.open(n.tagName), n.hasAttributes()) {
		let r = n.attributes, i = r.length;
		for (let n = 0; n < i; ++n) t.attr(r[n].name, r[n].value);
	}
	if (n.hasChildNodes()) {
		let r = n.childNodes;
		for (let n of r) n.nodeType === 3 ? t.text(n.nodeValue) : _serialize(t, n);
	}
	return t.close();
}
var stylesAttr = {
	fill: "fill",
	fillOpacity: "fill-opacity",
	stroke: "stroke",
	strokeOpacity: "stroke-opacity",
	strokeWidth: "stroke-width",
	strokeCap: "stroke-linecap",
	strokeJoin: "stroke-linejoin",
	strokeDash: "stroke-dasharray",
	strokeDashOffset: "stroke-dashoffset",
	strokeMiterLimit: "stroke-miterlimit",
	opacity: "opacity"
}, stylesCss = { blend: "mix-blend-mode" }, rootAttributes = {
	fill: "none",
	"stroke-miterlimit": 10
}, RootIndex = 0, xmlns = "http://www.w3.org/2000/xmlns/", svgns = metadata.xmlns, SVGRenderer = class extends Renderer {
	constructor(t) {
		super(t), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null;
	}
	initialize(t, n, r, i, o) {
		return this._defs = {}, this._clearDefs(), t && (this._svg = domChild(t, 0, "svg", svgns), this._svg.setAttributeNS(xmlns, "xmlns", svgns), this._svg.setAttributeNS(xmlns, "xmlns:xlink", metadata["xmlns:xlink"]), this._svg.setAttribute("version", metadata.version), this._svg.setAttribute("class", "marks"), domClear(t, 1), this._root = domChild(this._svg, RootIndex, "g", svgns), setAttributes(this._root, rootAttributes), domClear(this._svg, RootIndex + 1)), this.background(this._bgcolor), super.initialize(t, n, r, i, o);
	}
	background(t) {
		return arguments.length && this._svg && this._svg.style.setProperty("background-color", t), super.background(...arguments);
	}
	resize(t, n, r, i) {
		return super.resize(t, n, r, i), this._svg && (setAttributes(this._svg, {
			width: this._width * this._scale,
			height: this._height * this._scale,
			viewBox: `0 0 ${this._width} ${this._height}`
		}), this._root.setAttribute("transform", `translate(${this._origin})`)), this._dirty = [], this;
	}
	canvas() {
		return this._svg;
	}
	svg() {
		let t = this._svg, n = this._bgcolor;
		if (!t) return null;
		let r;
		n && (t.removeAttribute("style"), r = domChild(t, RootIndex, "rect", svgns), setAttributes(r, {
			width: this._width,
			height: this._height,
			fill: n
		}));
		let i = serializeXML(t);
		return n && (t.removeChild(r), this._svg.style.setProperty("background-color", n)), i;
	}
	_render(t, n) {
		return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, t, void 0, n), domClear(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this;
	}
	dirty(t) {
		t.dirty !== this._dirtyID && (t.dirty = this._dirtyID, this._dirty.push(t));
	}
	isDirty(t) {
		return this._dirtyAll || !t._svg || !t._svg.ownerSVGElement || t.dirty === this._dirtyID;
	}
	_dirtyCheck() {
		this._dirtyAll = !0;
		let t = this._dirty;
		if (!t.length || !this._dirtyID) return !0;
		let n = ++this._dirtyID, r, i, o, s, l, u, d;
		for (l = 0, u = t.length; l < u; ++l) if (r = t[l], i = r.mark, i.marktype !== o && (o = i.marktype, s = Marks[o]), i.zdirty && i.dirty !== n && (this._dirtyAll = !1, dirtyParents(r, n), i.items.forEach((t) => {
			t.dirty = n;
		})), !i.zdirty) {
			if (r.exit) {
				s.nested && i.items.length ? (d = i.items[0], d._svg && this._update(s, d._svg, d)) : r._svg && (d = r._svg.parentNode, d && d.removeChild(r._svg)), r._svg = null;
				continue;
			}
			r = s.nested ? i.items[0] : r, r._update !== n && (!r._svg || !r._svg.ownerSVGElement ? (this._dirtyAll = !1, dirtyParents(r, n)) : this._update(s, r._svg, r), r._update = n);
		}
		return !this._dirtyAll;
	}
	mark(t, n, r, i) {
		if (!this.isDirty(n)) return n._svg;
		let o = this._svg, s = n.marktype, l = Marks[s], u = n.interactive === !1 ? "none" : null, d = l.tag === "g", f = bind$1(n, t, r, "g", o);
		if (s !== "group" && i != null && !i.includes(s)) return domClear(f, 0), n._svg;
		f.setAttribute("class", cssClass(n));
		let p = ariaMarkAttributes(n);
		for (let t in p) setAttribute(f, t, p[t]);
		d || setAttribute(f, "pointer-events", u), setAttribute(f, "clip-path", n.clip ? clip$1(this, n, n.group) : null);
		let g = null, _ = 0, v = (t) => {
			let n = this.isDirty(t), r = bind$1(t, f, g, l.tag, o);
			n && (this._update(l, r, t), d && recurse(this, r, t, i)), g = r, ++_;
		};
		return l.nested ? n.items.length && v(n.items[0]) : visit(n, v), domClear(f, _), f;
	}
	_update(t, n, r) {
		element$1 = n, values$2 = n.__values__, ariaItemAttributes(emit, r), t.attr(emit, r, this);
		let i = mark_extras[t.type];
		i && i.call(this, t, n, r), element$1 && this.style(element$1, r);
	}
	style(t, n) {
		if (n != null) {
			for (let r in stylesAttr) {
				let i = r === "font" ? fontFamily(n) : n[r];
				if (i === values$2[r]) continue;
				let o = stylesAttr[r];
				i == null ? t.removeAttribute(o) : (isGradient(i) && (i = gradientRef(i, this._defs.gradient, href())), t.setAttribute(o, i + "")), values$2[r] = i;
			}
			for (let r in stylesCss) setStyle(t, stylesCss[r], n[r]);
		}
	}
	defs() {
		let t = this._svg, n = this._defs, r = n.el, i = 0;
		for (let o in n.gradient) r || (n.el = r = domChild(t, RootIndex + 1, "defs", svgns)), i = updateGradient(r, n.gradient[o], i);
		for (let o in n.clipping) r || (n.el = r = domChild(t, RootIndex + 1, "defs", svgns)), i = updateClipping(r, n.clipping[o], i);
		r && (i === 0 ? (t.removeChild(r), n.el = null) : domClear(r, i));
	}
	_clearDefs() {
		let t = this._defs;
		t.gradient = {}, t.clipping = {};
	}
};
function dirtyParents(t, n) {
	for (; t && t.dirty !== n; t = t.mark.group) if (t.dirty = n, t.mark && t.mark.dirty !== n) t.mark.dirty = n;
	else return;
}
function updateGradient(t, n, r) {
	let i, o, s;
	if (n.gradient === "radial") {
		let i = domChild(t, r++, "pattern", svgns);
		setAttributes(i, {
			id: patternPrefix + n.id,
			viewBox: "0,0,1,1",
			width: "100%",
			height: "100%",
			preserveAspectRatio: "xMidYMid slice"
		}), i = domChild(i, 0, "rect", svgns), setAttributes(i, {
			width: 1,
			height: 1,
			fill: `url(${href()}#${n.id})`
		}), t = domChild(t, r++, "radialGradient", svgns), setAttributes(t, {
			id: n.id,
			fx: n.x1,
			fy: n.y1,
			fr: n.r1,
			cx: n.x2,
			cy: n.y2,
			r: n.r2
		});
	} else t = domChild(t, r++, "linearGradient", svgns), setAttributes(t, {
		id: n.id,
		x1: n.x1,
		x2: n.x2,
		y1: n.y1,
		y2: n.y2
	});
	for (i = 0, o = n.stops.length; i < o; ++i) s = domChild(t, i, "stop", svgns), s.setAttribute("offset", n.stops[i].offset), s.setAttribute("stop-color", n.stops[i].color);
	return domClear(t, i), r;
}
function updateClipping(t, n, r) {
	let i;
	return t = domChild(t, r, "clipPath", svgns), t.setAttribute("id", n.id), n.path ? (i = domChild(t, 0, "path", svgns), i.setAttribute("d", n.path)) : (i = domChild(t, 0, "rect", svgns), setAttributes(i, {
		x: 0,
		y: 0,
		width: n.width,
		height: n.height
	})), domClear(t, 1), r + 1;
}
function recurse(t, n, r, i) {
	n = n.lastChild.previousSibling;
	let o, s = 0;
	visit(r, (r) => {
		o = t.mark(n, r, o, i), ++s;
	}), domClear(n, 1 + s);
}
function bind$1(t, n, r, i, o) {
	let s = t._svg, l;
	if (!s && (l = n.ownerDocument, s = domCreate(l, i, svgns), t._svg = s, t.mark && (s.__data__ = t, s.__values__ = { fill: "default" }, i === "g"))) {
		let n = domCreate(l, "path", svgns);
		s.appendChild(n), n.__data__ = t;
		let r = domCreate(l, "g", svgns);
		s.appendChild(r), r.__data__ = t;
		let i = domCreate(l, "path", svgns);
		s.appendChild(i), i.__data__ = t, i.__values__ = { fill: "default" };
	}
	return (s.ownerSVGElement !== o || siblingCheck(s, r)) && n.insertBefore(s, r ? r.nextSibling : n.firstChild), s;
}
function siblingCheck(t, n) {
	return t.parentNode && t.parentNode.childNodes.length > 1 && t.previousSibling != n;
}
var element$1 = null, values$2 = null, mark_extras = {
	group(t, n, r) {
		let i = element$1 = n.childNodes[2];
		values$2 = i.__values__, t.foreground(emit, r, this), values$2 = n.__values__, element$1 = n.childNodes[1], t.content(emit, r, this);
		let o = element$1 = n.childNodes[0];
		t.background(emit, r, this);
		let s = r.mark.interactive === !1 ? "none" : null;
		if (s !== values$2.events && (setAttribute(i, "pointer-events", s), setAttribute(o, "pointer-events", s), values$2.events = s), r.strokeForeground && r.stroke) {
			let t = r.fill;
			setAttribute(i, "display", null), this.style(o, r), setAttribute(o, "stroke", null), t && (r.fill = null), values$2 = i.__values__, this.style(i, r), t && (r.fill = t), element$1 = null;
		} else setAttribute(i, "display", "none");
	},
	image(t, n, r) {
		r.smooth === !1 ? (setStyle(n, "image-rendering", "optimizeSpeed"), setStyle(n, "image-rendering", "pixelated")) : setStyle(n, "image-rendering", null);
	},
	text(t, n, r) {
		let i = textLines(r), o, s, l, u;
		isArray(i) ? (s = i.map((t) => textValue(r, t)), o = s.join("\n"), o !== values$2.text && (domClear(n, 0), l = n.ownerDocument, u = lineHeight(r), s.forEach((t, i) => {
			let o = domCreate(l, "tspan", svgns);
			o.__data__ = r, o.textContent = t, i && (o.setAttribute("x", 0), o.setAttribute("dy", u)), n.appendChild(o);
		}), values$2.text = o)) : (s = textValue(r, i), s !== values$2.text && (n.textContent = s, values$2.text = s)), setAttribute(n, "font-family", fontFamily(r)), setAttribute(n, "font-size", fontSize(r) + "px"), setAttribute(n, "font-style", r.fontStyle), setAttribute(n, "font-variant", r.fontVariant), setAttribute(n, "font-weight", r.fontWeight);
	}
};
function emit(t, n, r) {
	n !== values$2[t] && (r ? setAttributeNS(element$1, t, n, r) : setAttribute(element$1, t, n), values$2[t] = n);
}
function setStyle(t, n, r) {
	r !== values$2[n] && (r == null ? t.style.removeProperty(n) : t.style.setProperty(n, r + ""), values$2[n] = r);
}
function setAttributes(t, n) {
	for (let r in n) setAttribute(t, r, n[r]);
}
function setAttribute(t, n, r) {
	r == null ? t.removeAttribute(n) : t.setAttribute(n, r);
}
function setAttributeNS(t, n, r, i) {
	r == null ? t.removeAttributeNS(i, n) : t.setAttributeNS(i, n, r);
}
function href() {
	let t;
	return typeof window > "u" ? "" : (t = window.location).hash ? t.href.slice(0, -t.hash.length) : t.href;
}
var SVGStringRenderer = class extends Renderer {
	constructor(t) {
		super(t), this._text = null, this._defs = {
			gradient: {},
			clipping: {}
		};
	}
	svg() {
		return this._text;
	}
	_render(t) {
		let n = markup();
		n.open("svg", extend({}, metadata, {
			class: "marks",
			width: this._width * this._scale,
			height: this._height * this._scale,
			viewBox: `0 0 ${this._width} ${this._height}`
		}));
		let r = this._bgcolor;
		return r && r !== "transparent" && r !== "none" && n.open("rect", {
			width: this._width,
			height: this._height,
			fill: r
		}).close(), n.open("g", rootAttributes, { transform: "translate(" + this._origin + ")" }), this.mark(n, t), n.close(), this.defs(n), this._text = n.close() + "", this;
	}
	mark(t, n) {
		let r = Marks[n.marktype], i = r.tag, o = [ariaItemAttributes, r.attr];
		t.open("g", {
			class: cssClass(n),
			"clip-path": n.clip ? clip$1(this, n, n.group) : null
		}, ariaMarkAttributes(n), { "pointer-events": i !== "g" && n.interactive === !1 ? "none" : null });
		let s = (s) => {
			let l = this.href(s);
			if (l && t.open("a", l), t.open(i, this.attr(n, s, o, i === "g" ? null : i)), i === "text") {
				let n = textLines(s);
				if (isArray(n)) {
					let r = {
						x: 0,
						dy: lineHeight(s)
					};
					for (let i = 0; i < n.length; ++i) t.open("tspan", i ? r : null).text(textValue(s, n[i])).close();
				} else t.text(textValue(s, n));
			} else if (i === "g") {
				let i = s.strokeForeground, o = s.fill, l = s.stroke;
				i && l && (s.stroke = null), t.open("path", this.attr(n, s, r.background, "bgrect")).close(), t.open("g", this.attr(n, s, r.content)), visit(s, (n) => this.mark(t, n)), t.close(), i && l ? (o && (s.fill = null), s.stroke = l, t.open("path", this.attr(n, s, r.foreground, "bgrect")).close(), o && (s.fill = o)) : t.open("path", this.attr(n, s, r.foreground, "bgfore")).close();
			}
			t.close(), l && t.close();
		};
		return r.nested ? n.items && n.items.length && s(n.items[0]) : visit(n, s), t.close();
	}
	href(t) {
		let n = t.href, r;
		if (n) {
			if (r = this._hrefs && this._hrefs[n]) return r;
			this.sanitizeURL(n).then((t) => {
				t["xlink:href"] = t.href, t.href = null, (this._hrefs ||= {})[n] = t;
			});
		}
		return null;
	}
	attr(t, n, r, i) {
		let o = {}, s = (t, n, r, i) => {
			o[i || t] = n;
		};
		return Array.isArray(r) ? r.forEach((t) => t(s, n, this)) : r(s, n, this), i && style(o, n, t, i, this._defs), o;
	}
	defs(t) {
		let n = this._defs.gradient, r = this._defs.clipping;
		if (Object.keys(n).length + Object.keys(r).length !== 0) {
			for (let r in t.open("defs"), n) {
				let i = n[r], o = i.stops;
				i.gradient === "radial" ? (t.open("pattern", {
					id: patternPrefix + r,
					viewBox: "0,0,1,1",
					width: "100%",
					height: "100%",
					preserveAspectRatio: "xMidYMid slice"
				}), t.open("rect", {
					width: "1",
					height: "1",
					fill: "url(#" + r + ")"
				}).close(), t.close(), t.open("radialGradient", {
					id: r,
					fx: i.x1,
					fy: i.y1,
					fr: i.r1,
					cx: i.x2,
					cy: i.y2,
					r: i.r2
				})) : t.open("linearGradient", {
					id: r,
					x1: i.x1,
					x2: i.x2,
					y1: i.y1,
					y2: i.y2
				});
				for (let n = 0; n < o.length; ++n) t.open("stop", {
					offset: o[n].offset,
					"stop-color": o[n].color
				}).close();
				t.close();
			}
			for (let n in r) {
				let i = r[n];
				t.open("clipPath", { id: n }), i.path ? t.open("path", { d: i.path }).close() : t.open("rect", {
					x: 0,
					y: 0,
					width: i.width,
					height: i.height
				}).close(), t.close();
			}
			t.close();
		}
	}
};
function style(t, n, r, i, o) {
	let s;
	if (n == null || (i === "bgrect" && r.interactive === !1 && (t["pointer-events"] = "none"), i === "bgfore" && (r.interactive === !1 && (t["pointer-events"] = "none"), t.display = "none", n.fill !== null))) return t;
	for (let r in i === "image" && n.smooth === !1 && (s = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]), i === "text" && (t["font-family"] = fontFamily(n), t["font-size"] = fontSize(n) + "px", t["font-style"] = n.fontStyle, t["font-variant"] = n.fontVariant, t["font-weight"] = n.fontWeight), stylesAttr) {
		let i = n[r], s = stylesAttr[r];
		i === "transparent" && (s === "fill" || s === "stroke") || i != null && (isGradient(i) && (i = gradientRef(i, o.gradient, "")), t[s] = i);
	}
	for (let t in stylesCss) {
		let r = n[t];
		r != null && (s ||= [], s.push(`${stylesCss[t]}: ${r};`));
	}
	return s && (t.style = s.join(" ")), t;
}
var OPTS = {
	svgMarkTypes: ["text"],
	svgOnTop: !0,
	debug: !1
};
function setHybridRendererOptions(t) {
	OPTS.svgMarkTypes = t.svgMarkTypes ?? ["text"], OPTS.svgOnTop = t.svgOnTop ?? !0, OPTS.debug = t.debug ?? !1;
}
var HybridRenderer = class extends Renderer {
	constructor(t) {
		super(t), this._svgRenderer = new SVGRenderer(t), this._canvasRenderer = new CanvasRenderer(t);
	}
	initialize(t, n, r, i, o) {
		this._root_el = domChild(t, 0, "div");
		let s = domChild(this._root_el, 0, "div"), l = domChild(this._root_el, 1, "div");
		return this._root_el.style.position = "relative", OPTS.debug || (s.style.height = "100%", l.style.position = "absolute", l.style.top = "0", l.style.left = "0", l.style.height = "100%", l.style.width = "100%"), this._svgEl = OPTS.svgOnTop ? l : s, this._canvasEl = OPTS.svgOnTop ? s : l, this._svgEl.style.pointerEvents = "none", this._canvasRenderer.initialize(this._canvasEl, n, r, i, o), this._svgRenderer.initialize(this._svgEl, n, r, i, o), super.initialize(t, n, r, i, o);
	}
	dirty(t) {
		return OPTS.svgMarkTypes.includes(t.mark.marktype) ? this._svgRenderer.dirty(t) : this._canvasRenderer.dirty(t), this;
	}
	_render(t, n) {
		let r = (n ?? [
			"arc",
			"area",
			"image",
			"line",
			"path",
			"rect",
			"rule",
			"shape",
			"symbol",
			"text",
			"trail"
		]).filter((t) => !OPTS.svgMarkTypes.includes(t));
		this._svgRenderer.render(t, OPTS.svgMarkTypes), this._canvasRenderer.render(t, r);
	}
	resize(t, n, r, i) {
		return super.resize(t, n, r, i), this._svgRenderer.resize(t, n, r, i), this._canvasRenderer.resize(t, n, r, i), this;
	}
	background(t) {
		return OPTS.svgOnTop ? this._canvasRenderer.background(t) : this._svgRenderer.background(t), this;
	}
}, HybridHandler = class extends CanvasHandler {
	constructor(t, n) {
		super(t, n);
	}
	initialize(t, n, r) {
		let i = domChild(domChild(t, 0, "div"), OPTS.svgOnTop ? 0 : 1, "div");
		return super.initialize(i, n, r);
	}
}, Canvas = "canvas", Hybrid = "hybrid", PNG = "png", SVG = "svg", None$1 = "none", RenderType = {
	Canvas,
	PNG,
	SVG,
	Hybrid,
	None: None$1
}, modules = {};
modules[Canvas] = modules[PNG] = {
	renderer: CanvasRenderer,
	headless: CanvasRenderer,
	handler: CanvasHandler
}, modules[SVG] = {
	renderer: SVGRenderer,
	headless: SVGStringRenderer,
	handler: SVGHandler
}, modules[Hybrid] = {
	renderer: HybridRenderer,
	headless: HybridRenderer,
	handler: HybridHandler
}, modules[None$1] = {};
function renderModule(t, n) {
	return t = String(t || "").toLowerCase(), arguments.length > 1 ? (modules[t] = n, this) : modules[t];
}
function intersect(t, n, r) {
	let i = [], o = new Bounds().union(n), s = t.marktype;
	return s ? intersectMark(t, o, r, i) : s === "group" ? intersectGroup(t, o, r, i) : error$1("Intersect scene must be mark node or group item.");
}
function intersectMark(t, n, r, i) {
	if (visitMark(t, n, r)) {
		let o = t.items, s = t.marktype, l = o.length, u = 0;
		if (s === "group") for (; u < l; ++u) intersectGroup(o[u], n, r, i);
		else for (let t = Marks[s].isect; u < l; ++u) {
			let r = o[u];
			intersectItem(r, n, t) && i.push(r);
		}
	}
	return i;
}
function visitMark(t, n, r) {
	return t.bounds && n.intersects(t.bounds) && (t.marktype === "group" || t.interactive !== !1 && (!r || r(t)));
}
function intersectGroup(t, n, r, i) {
	r && r(t.mark) && intersectItem(t, n, Marks.group.isect) && i.push(t);
	let o = t.items, s = o && o.length;
	if (s) {
		let l = t.x || 0, u = t.y || 0;
		n.translate(-l, -u);
		for (let t = 0; t < s; ++t) intersectMark(o[t], n, r, i);
		n.translate(l, u);
	}
	return i;
}
function intersectItem(t, n, r) {
	let i = t.bounds;
	return n.encloses(i) || n.intersects(i) && r(t, n);
}
var clipBounds = new Bounds();
function boundClip(t) {
	let n = t.clip;
	if (isFunction(n)) n(boundContext(clipBounds.clear()));
	else if (n) clipBounds.set(0, 0, t.group.width, t.group.height);
	else return;
	t.bounds.intersect(clipBounds);
}
var TOLERANCE = 1e-9;
function sceneEqual(t, n, r) {
	return t === n ? !0 : r === "path" ? pathEqual(t, n) : t instanceof Date && n instanceof Date ? +t == +n : isNumber(t) && isNumber(n) ? Math.abs(t - n) <= TOLERANCE : !t || !n || !isObject(t) && !isObject(n) ? t == n : objectEqual(t, n);
}
function pathEqual(t, n) {
	return sceneEqual(parse$3(t), parse$3(n));
}
function objectEqual(t, n) {
	var r = Object.keys(t), i = Object.keys(n), o, s;
	if (r.length !== i.length) return !1;
	for (r.sort(), i.sort(), s = r.length - 1; s >= 0; s--) if (r[s] != i[s]) return !1;
	for (s = r.length - 1; s >= 0; s--) if (o = r[s], !sceneEqual(t[o], n[o], o)) return !1;
	return typeof t == typeof n;
}
function resetSVGDefIds() {
	resetSVGClipId(), resetSVGGradientId();
}
var vega_view_transforms_exports = /* @__PURE__ */ __export({
	bound: () => Bound$1,
	identifier: () => Identifier$1,
	mark: () => Mark$2,
	overlap: () => Overlap$1,
	render: () => Render$1,
	viewlayout: () => ViewLayout$1
}), Top$1 = "top", Left$1 = "left", Right$1 = "right", Bottom$1 = "bottom", TopLeft = "top-left", TopRight = "top-right", BottomLeft = "bottom-left", BottomRight = "bottom-right", Start$1 = "start", Middle$1 = "middle", End$1 = "end", X$1 = "x", Y$1 = "y", Group = "group", AxisRole$1 = "axis", TitleRole$1 = "title", FrameRole$1 = "frame", ScopeRole$1 = "scope", LegendRole$1 = "legend", RowHeader = "row-header", RowFooter = "row-footer", RowTitle = "row-title", ColHeader = "column-header", ColFooter = "column-footer", ColTitle = "column-title", Padding$1 = "padding", Symbols$1 = "symbol", Fit = "fit", FitX = "fit-x", FitY = "fit-y", Pad = "pad", None = "none", All = "all", Each = "each", Flush = "flush", Column = "column", Row = "row";
function Bound$1(t) {
	Transform.call(this, null, t);
}
inherits(Bound$1, Transform, { transform(t, n) {
	let r = n.dataflow, i = t.mark, o = i.marktype, s = Marks[o], l = s.bound, u = i.bounds, d;
	if (s.nested) i.items.length && r.dirty(i.items[0]), u = boundItem(i, l), i.items.forEach((t) => {
		t.bounds.clear().union(u);
	});
	else if (o === Group || t.modified()) switch (n.visit(n.MOD, (t) => r.dirty(t)), u.clear(), i.items.forEach((t) => u.union(boundItem(t, l))), i.role) {
		case AxisRole$1:
		case LegendRole$1:
		case TitleRole$1: n.reflow();
	}
	else d = n.changed(n.REM), n.visit(n.ADD, (t) => {
		u.union(boundItem(t, l));
	}), n.visit(n.MOD, (t) => {
		d ||= u.alignsWith(t.bounds), r.dirty(t), u.union(boundItem(t, l));
	}), d && (u.clear(), i.items.forEach((t) => u.union(t.bounds)));
	return boundClip(i), n.modifies("bounds");
} });
function boundItem(t, n, r) {
	return n(t.bounds.clear(), t, r);
}
var COUNTER_NAME = ":vega_identifier:";
function Identifier$1(t) {
	Transform.call(this, 0, t);
}
Identifier$1.Definition = {
	type: "Identifier",
	metadata: { modifies: !0 },
	params: [{
		name: "as",
		type: "string",
		required: !0
	}]
}, inherits(Identifier$1, Transform, { transform(t, n) {
	let r = getCounter(n.dataflow), i = t.as, o = r.value;
	return n.visit(n.ADD, (t) => t[i] = t[i] || ++o), r.set(this.value = o), n;
} });
function getCounter(t) {
	return t._signals[COUNTER_NAME] || (t._signals[COUNTER_NAME] = t.add(0));
}
function Mark$2(t) {
	Transform.call(this, null, t);
}
inherits(Mark$2, Transform, { transform(t, n) {
	let r = this.value;
	r || (r = n.dataflow.scenegraph().mark(t.markdef, lookup$1$1(t), t.index), r.group.context = t.context, t.context.group || (t.context.group = r.group), r.source = this.source, r.clip = t.clip, r.interactive = t.interactive, this.value = r);
	let i = r.marktype === Group ? GroupItem : Item;
	return n.visit(n.ADD, (t) => i.call(t, r)), (t.modified("clip") || t.modified("interactive")) && (r.clip = t.clip, r.interactive = !!t.interactive, r.zdirty = !0, n.reflow()), r.items = n.source, n;
} });
function lookup$1$1(t) {
	let n = t.groups, r = t.parent;
	return n && n.size === 1 ? n.get(Object.keys(n.object)[0]) : n && r ? n.lookup(r) : null;
}
function Overlap$1(t) {
	Transform.call(this, null, t);
}
var methods = {
	parity: (t) => t.filter((t, n) => n % 2 ? t.opacity = 0 : 1),
	greedy: (t, n) => {
		let r;
		return t.filter((t, i) => !i || !intersect$2(r.bounds, t.bounds, n) ? (r = t, 1) : t.opacity = 0);
	}
}, intersect$2 = (t, n, r) => r > Math.max(n.x1 - t.x2, t.x1 - n.x2, n.y1 - t.y2, t.y1 - n.y2), hasOverlap = (t, n) => {
	for (var r = 1, i = t.length, o = t[0].bounds, s; r < i; o = s, ++r) if (intersect$2(o, s = t[r].bounds, n)) return !0;
}, hasBounds = (t) => {
	let n = t.bounds;
	return n.width() > 1 && n.height() > 1;
}, boundTest = (t, n, r) => {
	var i = t.range(), o = new Bounds();
	return n === Top$1 || n === Bottom$1 ? o.set(i[0], -Infinity, i[1], Infinity) : o.set(-Infinity, i[0], Infinity, i[1]), o.expand(r || 1), (t) => o.encloses(t.bounds);
}, reset$1 = (t) => (t.forEach((t) => t.opacity = 1), t), reflow = (t, n) => t.reflow(n.modified()).modifies("opacity");
inherits(Overlap$1, Transform, { transform(t, n) {
	let r = methods[t.method] || methods.parity, i = t.separation || 0, o = n.materialize(n.SOURCE).source, s, l;
	if (!o || !o.length) return;
	if (!t.method) return t.modified("method") && (reset$1(o), n = reflow(n, t)), n;
	if (o = o.filter(hasBounds), !o.length) return;
	if (t.sort && (o = o.slice().sort(t.sort)), s = reset$1(o), n = reflow(n, t), s.length >= 3 && hasOverlap(s, i)) {
		do
			s = r(s, i);
		while (s.length >= 3 && hasOverlap(s, i));
		s.length < 3 && !peek(o).opacity && (s.length > 1 && (peek(s).opacity = 0), peek(o).opacity = 1);
	}
	t.boundScale && t.boundTolerance >= 0 && (l = boundTest(t.boundScale, t.boundOrient, +t.boundTolerance), o.forEach((t) => {
		l(t) || (t.opacity = 0);
	}));
	let u = s[0].mark.bounds.clear();
	return o.forEach((t) => {
		t.opacity && u.union(t.bounds);
	}), n;
} });
function Render$1(t) {
	Transform.call(this, null, t);
}
inherits(Render$1, Transform, { transform(t, n) {
	let r = n.dataflow;
	if (n.visit(n.ALL, (t) => r.dirty(t)), n.fields && n.fields.zindex) {
		let t = n.source && n.source[0];
		t && (t.mark.zdirty = !0);
	}
} });
var tempBounds = new Bounds();
function set$2(t, n, r) {
	return t[n] === r ? 0 : (t[n] = r, 1);
}
function isYAxis(t) {
	var n = t.items[0].orient;
	return n === Left$1 || n === Right$1;
}
function axisIndices(t) {
	let n = +t.grid;
	return [
		t.ticks ? n++ : -1,
		t.labels ? n++ : -1,
		n + +t.domain
	];
}
function axisLayout(t, n, r, i) {
	var o = n.items[0], s = o.datum, l = o.translate == null ? .5 : o.translate, u = o.orient, d = axisIndices(s), f = o.range, p = o.offset, g = o.position, _ = o.minExtent, v = o.maxExtent, S = s.title && o.items[d[2]].items[0], T = o.titlePadding, E = o.bounds, O = S && multiLineOffset(S), k = 0, A = 0, j, N;
	switch (tempBounds.clear().union(E), E.clear(), (j = d[0]) > -1 && E.union(o.items[j].bounds), (j = d[1]) > -1 && E.union(o.items[j].bounds), u) {
		case Top$1:
			k = g || 0, A = -p, N = Math.max(_, Math.min(v, -E.y1)), E.add(0, -N).add(f, 0), S && axisTitleLayout(t, S, N, T, O, 0, -1, E);
			break;
		case Left$1:
			k = -p, A = g || 0, N = Math.max(_, Math.min(v, -E.x1)), E.add(-N, 0).add(0, f), S && axisTitleLayout(t, S, N, T, O, 1, -1, E);
			break;
		case Right$1:
			k = r + p, A = g || 0, N = Math.max(_, Math.min(v, E.x2)), E.add(0, 0).add(N, f), S && axisTitleLayout(t, S, N, T, O, 1, 1, E);
			break;
		case Bottom$1:
			k = g || 0, A = i + p, N = Math.max(_, Math.min(v, E.y2)), E.add(0, 0).add(f, N), S && axisTitleLayout(t, S, N, T, 0, 0, 1, E);
			break;
		default: k = o.x, A = o.y;
	}
	return boundStroke(E.translate(k, A), o), set$2(o, "x", k + l) | set$2(o, "y", A + l) && (o.bounds = tempBounds, t.dirty(o), o.bounds = E, t.dirty(o)), o.mark.bounds.clear().union(E);
}
function axisTitleLayout(t, n, r, i, o, s, l, u) {
	let d = n.bounds;
	if (n.auto) {
		let u = l * (r + o + i), f = 0, p = 0;
		t.dirty(n), s ? f = (n.x || 0) - (n.x = u) : p = (n.y || 0) - (n.y = u), n.mark.bounds.clear().union(d.translate(-f, -p)), t.dirty(n);
	}
	u.union(d);
}
var min = (t, n) => Math.floor(Math.min(t, n)), max$1 = (t, n) => Math.ceil(Math.max(t, n));
function gridLayoutGroups(t) {
	var n = t.items, r = n.length, i = 0, o, s;
	let l = {
		marks: [],
		rowheaders: [],
		rowfooters: [],
		colheaders: [],
		colfooters: [],
		rowtitle: null,
		coltitle: null
	};
	for (; i < r; ++i) if (o = n[i], s = o.items, o.marktype === Group) switch (o.role) {
		case AxisRole$1:
		case LegendRole$1:
		case TitleRole$1: break;
		case RowHeader:
			l.rowheaders.push(...s);
			break;
		case RowFooter:
			l.rowfooters.push(...s);
			break;
		case ColHeader:
			l.colheaders.push(...s);
			break;
		case ColFooter:
			l.colfooters.push(...s);
			break;
		case RowTitle:
			l.rowtitle = s[0];
			break;
		case ColTitle:
			l.coltitle = s[0];
			break;
		default: l.marks.push(...s);
	}
	return l;
}
function bboxFlush(t) {
	return new Bounds().set(0, 0, t.width || 0, t.height || 0);
}
function bboxFull(t) {
	let n = t.bounds.clone();
	return n.empty() ? n.set(0, 0, 0, 0) : n.translate(-(t.x || 0), -(t.y || 0));
}
function get(t, n, r) {
	return (isObject(t) ? t[n] : t) ?? (r === void 0 ? 0 : r);
}
function offsetValue$1(t) {
	return t < 0 ? Math.ceil(-t) : 0;
}
function gridLayout(t, n, r) {
	var i = !r.nodirty, o = r.bounds === Flush ? bboxFlush : bboxFull, s = tempBounds.set(0, 0, 0, 0), l = get(r.align, Column), u = get(r.align, Row), d = get(r.padding, Column), f = get(r.padding, Row), p = r.columns || n.length, g = p <= 0 ? 1 : Math.ceil(n.length / p), _ = n.length, v = Array(_), S = Array(p), T = 0, E = Array(_), O = Array(g), k = 0, A = Array(_), j = Array(_), N = Array(_), P, F, I, L, R, z, V, H, U, W, G;
	for (F = 0; F < p; ++F) S[F] = 0;
	for (F = 0; F < g; ++F) O[F] = 0;
	for (F = 0; F < _; ++F) z = n[F], R = N[F] = o(z), z.x = z.x || 0, A[F] = 0, z.y = z.y || 0, j[F] = 0, I = F % p, L = ~~(F / p), T = Math.max(T, V = Math.ceil(R.x2)), k = Math.max(k, H = Math.ceil(R.y2)), S[I] = Math.max(S[I], V), O[L] = Math.max(O[L], H), v[F] = d + offsetValue$1(R.x1), E[F] = f + offsetValue$1(R.y1), i && t.dirty(n[F]);
	for (F = 0; F < _; ++F) F % p === 0 && (v[F] = 0), F < p && (E[F] = 0);
	if (l === Each) for (I = 1; I < p; ++I) {
		for (G = 0, F = I; F < _; F += p) G < v[F] && (G = v[F]);
		for (F = I; F < _; F += p) v[F] = G + S[I - 1];
	}
	else if (l === All) {
		for (G = 0, F = 0; F < _; ++F) F % p && G < v[F] && (G = v[F]);
		for (F = 0; F < _; ++F) F % p && (v[F] = G + T);
	} else for (l = !1, I = 1; I < p; ++I) for (F = I; F < _; F += p) v[F] += S[I - 1];
	if (u === Each) for (L = 1; L < g; ++L) {
		for (G = 0, F = L * p, P = F + p; F < P; ++F) G < E[F] && (G = E[F]);
		for (F = L * p; F < P; ++F) E[F] = G + O[L - 1];
	}
	else if (u === All) {
		for (G = 0, F = p; F < _; ++F) G < E[F] && (G = E[F]);
		for (F = p; F < _; ++F) E[F] = G + k;
	} else for (u = !1, L = 1; L < g; ++L) for (F = L * p, P = F + p; F < P; ++F) E[F] += O[L - 1];
	for (U = 0, F = 0; F < _; ++F) U = v[F] + (F % p ? U : 0), A[F] += U - n[F].x;
	for (I = 0; I < p; ++I) for (W = 0, F = I; F < _; F += p) W += E[F], j[F] += W - n[F].y;
	if (l && get(r.center, Column) && g > 1) for (F = 0; F < _; ++F) R = l === All ? T : S[F % p], U = R - N[F].x2 - n[F].x - A[F], U > 0 && (A[F] += U / 2);
	if (u && get(r.center, Row) && p !== 1) for (F = 0; F < _; ++F) R = u === All ? k : O[~~(F / p)], W = R - N[F].y2 - n[F].y - j[F], W > 0 && (j[F] += W / 2);
	for (F = 0; F < _; ++F) s.union(N[F].translate(A[F], j[F]));
	switch (U = get(r.anchor, X$1), W = get(r.anchor, Y$1), get(r.anchor, Column)) {
		case End$1:
			U -= s.width();
			break;
		case Middle$1: U -= s.width() / 2;
	}
	switch (get(r.anchor, Row)) {
		case End$1:
			W -= s.height();
			break;
		case Middle$1: W -= s.height() / 2;
	}
	for (U = Math.round(U), W = Math.round(W), s.clear(), F = 0; F < _; ++F) n[F].mark.bounds.clear();
	for (F = 0; F < _; ++F) z = n[F], z.x += A[F] += U, z.y += j[F] += W, s.union(z.mark.bounds.union(z.bounds.translate(A[F], j[F]))), i && t.dirty(z);
	return s;
}
function trellisLayout(t, n, r) {
	var i = gridLayoutGroups(n), o = i.marks, s = r.bounds === Flush ? boundFlush : boundFull, l = r.offset, u = r.columns || o.length, d = u <= 0 ? 1 : Math.ceil(o.length / u), f = d * u, p, g, _, v, S, T, E;
	let O = gridLayout(t, o, r);
	O.empty() && O.set(0, 0, 0, 0), i.rowheaders && (T = get(r.headerBand, Row, null), p = layoutHeaders(t, i.rowheaders, o, u, d, -get(l, "rowHeader"), min, 0, s, "x1", 0, u, 1, T)), i.colheaders && (T = get(r.headerBand, Column, null), g = layoutHeaders(t, i.colheaders, o, u, u, -get(l, "columnHeader"), min, 1, s, "y1", 0, 1, u, T)), i.rowfooters && (T = get(r.footerBand, Row, null), _ = layoutHeaders(t, i.rowfooters, o, u, d, get(l, "rowFooter"), max$1, 0, s, "x2", u - 1, u, 1, T)), i.colfooters && (T = get(r.footerBand, Column, null), v = layoutHeaders(t, i.colfooters, o, u, u, get(l, "columnFooter"), max$1, 1, s, "y2", f - u, 1, u, T)), i.rowtitle && (S = get(r.titleAnchor, Row), E = get(l, "rowTitle"), E = S === End$1 ? _ + E : p - E, T = get(r.titleBand, Row, .5), layoutTitle(t, i.rowtitle, E, 0, O, T)), i.coltitle && (S = get(r.titleAnchor, Column), E = get(l, "columnTitle"), E = S === End$1 ? v + E : g - E, T = get(r.titleBand, Column, .5), layoutTitle(t, i.coltitle, E, 1, O, T));
}
function boundFlush(t, n) {
	return n === "x1" ? t.x || 0 : n === "y1" ? t.y || 0 : n === "x2" ? (t.x || 0) + (t.width || 0) : n === "y2" ? (t.y || 0) + (t.height || 0) : void 0;
}
function boundFull(t, n) {
	return t.bounds[n];
}
function layoutHeaders(t, n, r, i, o, s, l, u, d, f, p, g, _, v) {
	var S = r.length, T = 0, E = 0, O, k, A, j, N, P, F, I, L;
	if (!S) return T;
	for (O = p; O < S; O += g) r[O] && (T = l(T, d(r[O], f)));
	if (!n.length) return T;
	for (n.length > o && (t.warn("Grid headers exceed limit: " + o), n = n.slice(0, o)), T += s, k = 0, j = n.length; k < j; ++k) t.dirty(n[k]), n[k].mark.bounds.clear();
	for (O = p, k = 0, j = n.length; k < j; ++k, O += g) {
		for (P = n[k], N = P.mark.bounds, A = O; A >= 0 && (F = r[A]) == null; A -= _);
		u ? (I = v == null ? F.x : Math.round(F.bounds.x1 + v * F.bounds.width()), L = T) : (I = T, L = v == null ? F.y : Math.round(F.bounds.y1 + v * F.bounds.height())), N.union(P.bounds.translate(I - (P.x || 0), L - (P.y || 0))), P.x = I, P.y = L, t.dirty(P), E = l(E, N[f]);
	}
	return E;
}
function layoutTitle(t, n, r, i, o, s) {
	if (n) {
		t.dirty(n);
		var l = r, u = r;
		i ? l = Math.round(o.x1 + s * o.width()) : u = Math.round(o.y1 + s * o.height()), n.bounds.translate(l - (n.x || 0), u - (n.y || 0)), n.mark.bounds.clear().union(n.bounds), n.x = l, n.y = u, t.dirty(n);
	}
}
function lookup$3(t, n) {
	let r = t[n] || {};
	return (n, i) => r[n] == null ? t[n] == null ? i : t[n] : r[n];
}
function offsets(t, n) {
	let r = -Infinity;
	return t.forEach((t) => {
		t.offset != null && (r = Math.max(r, t.offset));
	}), r > -Infinity ? r : n;
}
function legendParams(t, n, r, i, o, s, l) {
	let u = lookup$3(r, n), d = offsets(t, u("offset", 0)), f = u("anchor", Start$1), p = f === End$1 ? 1 : f === Middle$1 ? .5 : 0, g = {
		align: Each,
		bounds: u("bounds", Flush),
		columns: u("direction") === "vertical" ? 1 : t.length,
		padding: u("margin", 8),
		center: u("center"),
		nodirty: !0
	};
	switch (n) {
		case Left$1:
			g.anchor = {
				x: Math.floor(i.x1) - d,
				column: End$1,
				y: p * (l || i.height() + 2 * i.y1),
				row: f
			};
			break;
		case Right$1:
			g.anchor = {
				x: Math.ceil(i.x2) + d,
				y: p * (l || i.height() + 2 * i.y1),
				row: f
			};
			break;
		case Top$1:
			g.anchor = {
				y: Math.floor(o.y1) - d,
				row: End$1,
				x: p * (s || o.width() + 2 * o.x1),
				column: f
			};
			break;
		case Bottom$1:
			g.anchor = {
				y: Math.ceil(o.y2) + d,
				x: p * (s || o.width() + 2 * o.x1),
				column: f
			};
			break;
		case TopLeft:
			g.anchor = {
				x: d,
				y: d
			};
			break;
		case TopRight:
			g.anchor = {
				x: s - d,
				y: d,
				column: End$1
			};
			break;
		case BottomLeft:
			g.anchor = {
				x: d,
				y: l - d,
				row: End$1
			};
			break;
		case BottomRight:
			g.anchor = {
				x: s - d,
				y: l - d,
				column: End$1,
				row: End$1
			};
			break;
	}
	return g;
}
function legendLayout(t, n) {
	var r = n.items[0], i = r.datum, o = r.orient, s = r.bounds, l = r.x, u = r.y, d, f;
	return r._bounds ? r._bounds.clear().union(s) : r._bounds = s.clone(), s.clear(), legendGroupLayout(t, r, r.items[0].items[0]), s = legendBounds(r, s), d = 2 * r.padding, f = 2 * r.padding, s.empty() || (d = Math.ceil(s.width() + d), f = Math.ceil(s.height() + f)), i.type === Symbols$1 && legendEntryLayout(r.items[0].items[0].items[0].items), o !== None && (r.x = l = 0, r.y = u = 0), r.width = d, r.height = f, boundStroke(s.set(l, u, l + d, u + f), r), r.mark.bounds.clear().union(s), r;
}
function legendBounds(t, n) {
	return t.items.forEach((t) => n.union(t.bounds)), n.x1 = t.padding, n.y1 = t.padding, n;
}
function legendGroupLayout(t, n, r) {
	var i = n.padding, o = i - r.x, s = i - r.y;
	if (!n.datum.title) (o || s) && translate$1(t, r, o, s);
	else {
		var l = n.items[1].items[0], u = l.anchor, d = n.titlePadding || 0, f = i - l.x, p = i - l.y;
		switch (l.orient) {
			case Left$1:
				o += Math.ceil(l.bounds.width()) + d;
				break;
			case Right$1:
			case Bottom$1: break;
			default: s += l.bounds.height() + d;
		}
		switch ((o || s) && translate$1(t, r, o, s), l.orient) {
			case Left$1:
				p += legendTitleOffset(n, r, l, u, 1, 1);
				break;
			case Right$1:
				f += legendTitleOffset(n, r, l, End$1, 0, 0) + d, p += legendTitleOffset(n, r, l, u, 1, 1);
				break;
			case Bottom$1:
				f += legendTitleOffset(n, r, l, u, 0, 0), p += legendTitleOffset(n, r, l, End$1, -1, 0, 1) + d;
				break;
			default: f += legendTitleOffset(n, r, l, u, 0, 0);
		}
		(f || p) && translate$1(t, l, f, p), (f = Math.round(l.bounds.x1 - i)) < 0 && (translate$1(t, r, -f, 0), translate$1(t, l, -f, 0));
	}
}
function legendTitleOffset(t, n, r, i, o, s, l) {
	let u = t.datum.type !== "symbol", d = r.datum.vgrad, f = (u && (s || !d) && !l ? n.items[0] : n).bounds[o ? "y2" : "x2"] - t.padding, p = d && s ? f : 0, g = d && s ? 0 : f, _ = o <= 0 ? 0 : multiLineOffset(r);
	return Math.round(i === Start$1 ? p : i === End$1 ? g - _ : .5 * (f - _));
}
function translate$1(t, n, r, i) {
	n.x += r, n.y += i, n.bounds.translate(r, i), n.mark.bounds.translate(r, i), t.dirty(n);
}
function legendEntryLayout(t) {
	let n = t.reduce((t, n) => (t[n.column] = Math.max(n.bounds.x2 - n.x, t[n.column] || 0), t), {});
	t.forEach((t) => {
		t.width = n[t.column], t.height = t.bounds.y2 - t.y;
	});
}
function titleLayout(t, n, r, i, o) {
	var s = n.items[0], l = s.frame, u = s.orient, d = s.anchor, f = s.offset, p = s.padding, g = s.items[0].items[0], _ = s.items[1] && s.items[1].items[0], v = u === Left$1 || u === Right$1 ? i : r, S = 0, T = 0, E = 0, O = 0, k = 0, A;
	if (l === Group ? u === Left$1 && (S = i, v = 0) : u === Left$1 ? (S = o.y2, v = o.y1) : u === Right$1 ? (S = o.y1, v = o.y2) : (S = o.x1, v = o.x2), A = d === Start$1 ? S : d === End$1 ? v : (S + v) / 2, _ && _.text) {
		switch (u) {
			case Top$1:
			case Bottom$1:
				k = g.bounds.height() + p;
				break;
			case Left$1:
				O = g.bounds.width() + p;
				break;
			case Right$1:
				O = -g.bounds.width() - p;
				break;
		}
		tempBounds.clear().union(_.bounds), tempBounds.translate(O - (_.x || 0), k - (_.y || 0)), set$2(_, "x", O) | set$2(_, "y", k) && (t.dirty(_), _.bounds.clear().union(tempBounds), _.mark.bounds.clear().union(tempBounds), t.dirty(_)), tempBounds.clear().union(_.bounds);
	} else tempBounds.clear();
	switch (tempBounds.union(g.bounds), u) {
		case Top$1:
			T = A, E = o.y1 - tempBounds.height() - f;
			break;
		case Left$1:
			T = o.x1 - tempBounds.width() - f, E = A;
			break;
		case Right$1:
			T = o.x2 + tempBounds.width() + f, E = A;
			break;
		case Bottom$1:
			T = A, E = o.y2 + f;
			break;
		default: T = s.x, E = s.y;
	}
	return set$2(s, "x", T) | set$2(s, "y", E) && (tempBounds.translate(T, E), t.dirty(s), s.bounds.clear().union(tempBounds), n.bounds.clear().union(tempBounds), t.dirty(s)), s.bounds;
}
function ViewLayout$1(t) {
	Transform.call(this, null, t);
}
inherits(ViewLayout$1, Transform, { transform(t, n) {
	let r = n.dataflow;
	return t.mark.items.forEach((n) => {
		t.layout && trellisLayout(r, n, t.layout), layoutGroup(r, n, t);
	}), shouldReflow(t.mark.group) ? n.reflow() : n;
} });
function shouldReflow(t) {
	return t && t.mark.role !== "legend-entry";
}
function layoutGroup(t, n, r) {
	var i = n.items, o = Math.max(0, n.width || 0), s = Math.max(0, n.height || 0), l = new Bounds().set(0, 0, o, s), u = l.clone(), d = l.clone(), f = [], p, g, _, v, S, T;
	for (S = 0, T = i.length; S < T; ++S) switch (g = i[S], g.role) {
		case AxisRole$1:
			v = isYAxis(g) ? u : d, v.union(axisLayout(t, g, o, s));
			break;
		case TitleRole$1:
			p = g;
			break;
		case LegendRole$1:
			f.push(legendLayout(t, g));
			break;
		case FrameRole$1:
		case ScopeRole$1:
		case RowHeader:
		case RowFooter:
		case RowTitle:
		case ColHeader:
		case ColFooter:
		case ColTitle:
			u.union(g.bounds), d.union(g.bounds);
			break;
		default: l.union(g.bounds);
	}
	if (f.length) {
		let n = {};
		for (let i in f.forEach((t) => {
			_ = t.orient || Right$1, _ !== None && (n[_] || (n[_] = [])).push(t);
		}), n) {
			let l = n[i];
			gridLayout(t, l, legendParams(l, i, r.legends, u, d, o, s));
		}
		f.forEach((n) => {
			let i = n.bounds;
			if (i.equals(n._bounds) || (n.bounds = n._bounds, t.dirty(n), n.bounds = i, t.dirty(n)), r.autosize && (r.autosize.type === Fit || r.autosize.type === FitX || r.autosize.type === FitY)) switch (n.orient) {
				case Left$1:
				case Right$1:
					l.add(i.x1, 0).add(i.x2, 0);
					break;
				case Top$1:
				case Bottom$1: l.add(0, i.y1).add(0, i.y2);
			}
			else l.union(i);
		});
	}
	l.union(u).union(d), p && l.union(titleLayout(t, p, o, s, l)), n.clip && l.set(0, 0, n.width || 0, n.height || 0), viewSizeLayout(t, n, l, r);
}
function viewSizeLayout(t, n, r, i) {
	let o = i.autosize || {}, s = o.type;
	if (t._autosize < 1 || !s) return;
	let l = t._width, u = t._height, d = Math.max(0, n.width || 0), f = Math.max(0, Math.ceil(-r.x1)), p = Math.max(0, n.height || 0), g = Math.max(0, Math.ceil(-r.y1)), _ = Math.max(0, Math.ceil(r.x2 - d)), v = Math.max(0, Math.ceil(r.y2 - p));
	if (o.contains === Padding$1) {
		let n = t.padding();
		l -= n.left + n.right, u -= n.top + n.bottom;
	}
	s === None ? (f = 0, g = 0, d = l, p = u) : s === Fit ? (d = Math.max(0, l - f - _), p = Math.max(0, u - g - v)) : s === FitX ? (d = Math.max(0, l - f - _), u = p + g + v) : s === FitY ? (l = d + f + _, p = Math.max(0, u - g - v)) : s === Pad && (l = d + f + _, u = p + g + v), t._resizeView(l, u, d, p, [f, g], o.resize);
}
var vega_encode_exports = /* @__PURE__ */ __export({
	axisticks: () => AxisTicks$1,
	datajoin: () => DataJoin$1,
	encode: () => Encode$1,
	legendentries: () => LegendEntries$1,
	linkpath: () => LinkPath,
	pie: () => Pie,
	scale: () => Scale$1,
	sortitems: () => SortItems$1,
	stack: () => Stack
});
function AxisTicks$1(t) {
	Transform.call(this, null, t);
}
inherits(AxisTicks$1, Transform, { transform(t, n) {
	if (this.value && !t.modified()) return n.StopPropagation;
	var r = n.dataflow.locale(), i = n.fork(n.NO_SOURCE | n.NO_FIELDS), o = this.value, s = t.scale, l = tickCount(s, t.count == null ? t.values ? t.values.length : 10 : t.count, t.minstep), u = t.format || tickFormat(r, s, l, t.formatSpecifier, t.formatType, !!t.values), d = t.values ? validTicks(s, t.values, l) : tickValues(s, l);
	return o && (i.rem = o), o = d.map((t, n) => ingest$1({
		index: n / (d.length - 1 || 1),
		value: t,
		label: u(t)
	})), t.extra && o.length && o.push(ingest$1({
		index: -1,
		extra: { value: o[0].value },
		label: ""
	})), i.source = o, i.add = o, this.value = o, i;
} });
function DataJoin$1(t) {
	Transform.call(this, null, t);
}
function defaultItemCreate() {
	return ingest$1({});
}
function newMap(t) {
	let n = fastmap().test((t) => t.exit);
	return n.lookup = (r) => n.get(t(r)), n;
}
inherits(DataJoin$1, Transform, { transform(t, n) {
	var r = n.dataflow, i = n.fork(n.NO_SOURCE | n.NO_FIELDS), o = t.item || defaultItemCreate, s = t.key || tupleid, l = this.value;
	return isArray(i.encode) && (i.encode = null), l && (t.modified("key") || n.modified(s)) && error$1("DataJoin does not support modified key function or fields."), l || (n = n.addAll(), this.value = l = newMap(s)), n.visit(n.ADD, (t) => {
		let n = s(t), r = l.get(n);
		r ? r.exit ? (l.empty--, i.add.push(r)) : i.mod.push(r) : (r = o(t), l.set(n, r), i.add.push(r)), r.datum = t, r.exit = !1;
	}), n.visit(n.MOD, (t) => {
		let n = s(t), r = l.get(n);
		r && (r.datum = t, i.mod.push(r));
	}), n.visit(n.REM, (t) => {
		let n = s(t), r = l.get(n);
		t === r.datum && !r.exit && (i.rem.push(r), r.exit = !0, ++l.empty);
	}), n.changed(n.ADD_MOD) && i.modifies("datum"), (n.clean() || t.clean && l.empty > r.cleanThreshold) && r.runAfter(l.clean), i;
} });
function Encode$1(t) {
	Transform.call(this, null, t);
}
inherits(Encode$1, Transform, { transform(t, n) {
	var r = n.fork(n.ADD_REM), i = t.mod || !1, o = t.encoders, s = n.encode;
	if (isArray(s)) if (r.changed() || s.every((t) => o[t])) s = s[0], r.encode = null;
	else return n.StopPropagation;
	var l = s === "enter", u = o.update || falsy, d = o.enter || falsy, f = o.exit || falsy, p = (s && !l ? o[s] : u) || falsy;
	if (n.changed(n.ADD) && (n.visit(n.ADD, (n) => {
		d(n, t), u(n, t);
	}), r.modifies(d.output), r.modifies(u.output), p !== falsy && p !== u && (n.visit(n.ADD, (n) => {
		p(n, t);
	}), r.modifies(p.output))), n.changed(n.REM) && f !== falsy && (n.visit(n.REM, (n) => {
		f(n, t);
	}), r.modifies(f.output)), l || p !== falsy) {
		let o = n.MOD | (t.modified() ? n.REFLOW : 0);
		l ? (n.visit(o, (n) => {
			let o = d(n, t) || i;
			(p(n, t) || o) && r.mod.push(n);
		}), r.mod.length && r.modifies(d.output)) : n.visit(o, (n) => {
			(p(n, t) || i) && r.mod.push(n);
		}), r.mod.length && r.modifies(p.output);
	}
	return r.changed() ? r : n.StopPropagation;
} });
function LegendEntries$1(t) {
	Transform.call(this, [], t);
}
inherits(LegendEntries$1, Transform, { transform(t, n) {
	if (this.value != null && !t.modified()) return n.StopPropagation;
	var r = n.dataflow.locale(), i = n.fork(n.NO_SOURCE | n.NO_FIELDS), o = this.value, s = t.type || "symbol", l = t.scale, u = +t.limit, d = tickCount(l, t.count == null ? 5 : t.count, t.minstep), f = !!t.values || s === "symbol", p = t.format || labelFormat(r, l, d, s, t.formatSpecifier, t.formatType, f), g = t.values || labelValues(l, d), _, v, S, T, E;
	return o && (i.rem = o), s === "symbol" ? (u && g.length > u ? (n.dataflow.warn("Symbol legend count exceeds limit, filtering items."), o = g.slice(0, u - 1), E = !0) : o = g, isFunction(S = t.size) ? (!t.values && l(o[0]) === 0 && (o = o.slice(1)), T = o.reduce((n, r) => Math.max(n, S(r, t)), 0)) : S = constant(T = S || 8), o = o.map((n, r) => ingest$1({
		index: r,
		label: p(n, r, o),
		value: n,
		offset: T,
		size: S(n, t)
	})), E && (E = g[o.length], o.push(ingest$1({
		index: o.length,
		label: `\u2026${g.length - o.length} entries`,
		value: E,
		offset: T,
		size: S(E, t)
	})))) : s === "gradient" ? (_ = l.domain(), v = scaleFraction(l, _[0], peek(_)), g.length < 3 && !t.values && _[0] !== peek(_) && (g = [_[0], peek(_)]), o = g.map((t, n) => ingest$1({
		index: n,
		label: p(t, n, g),
		value: t,
		perc: v(t)
	}))) : (S = g.length - 1, v = labelFraction(l), o = g.map((t, n) => ingest$1({
		index: n,
		label: p(t, n, g),
		value: t,
		perc: n ? v(t) : 0,
		perc2: n === S ? 1 : v(g[n + 1])
	}))), i.source = o, i.add = o, this.value = o, i;
} });
var sourceX = (t) => t.source.x, sourceY = (t) => t.source.y, targetX = (t) => t.target.x, targetY = (t) => t.target.y;
function LinkPath(t) {
	Transform.call(this, {}, t);
}
LinkPath.Definition = {
	type: "LinkPath",
	metadata: { modifies: !0 },
	params: [
		{
			name: "sourceX",
			type: "field",
			default: "source.x"
		},
		{
			name: "sourceY",
			type: "field",
			default: "source.y"
		},
		{
			name: "targetX",
			type: "field",
			default: "target.x"
		},
		{
			name: "targetY",
			type: "field",
			default: "target.y"
		},
		{
			name: "orient",
			type: "enum",
			default: "vertical",
			values: [
				"horizontal",
				"vertical",
				"radial"
			]
		},
		{
			name: "shape",
			type: "enum",
			default: "line",
			values: [
				"line",
				"arc",
				"curve",
				"diagonal",
				"orthogonal"
			]
		},
		{
			name: "require",
			type: "signal"
		},
		{
			name: "as",
			type: "string",
			default: "path"
		}
	]
}, inherits(LinkPath, Transform, { transform(t, n) {
	var r = t.sourceX || sourceX, i = t.sourceY || sourceY, o = t.targetX || targetX, s = t.targetY || targetY, l = t.as || "path", u = t.orient || "vertical", d = t.shape || "line", f = Paths.get(d + "-" + u) || Paths.get(d);
	return f || error$1("LinkPath unsupported type: " + t.shape + (t.orient ? "-" + t.orient : "")), n.visit(n.SOURCE, (t) => {
		t[l] = f(r(t), i(t), o(t), s(t));
	}), n.reflow(t.modified()).modifies(l);
} });
var line$1 = (t, n, r, i) => "M" + t + "," + n + "L" + r + "," + i, lineR = (t, n, r, i) => line$1(n * Math.cos(t), n * Math.sin(t), i * Math.cos(r), i * Math.sin(r)), arc$1 = (t, n, r, i) => {
	var o = r - t, s = i - n, l = Math.hypot(o, s) / 2, u = 180 * Math.atan2(s, o) / Math.PI;
	return "M" + t + "," + n + "A" + l + "," + l + " " + u + " 0 1 " + r + "," + i;
}, arcR = (t, n, r, i) => arc$1(n * Math.cos(t), n * Math.sin(t), i * Math.cos(r), i * Math.sin(r)), curve = (t, n, r, i) => {
	let o = r - t, s = i - n, l = .2 * (o + s), u = .2 * (s - o);
	return "M" + t + "," + n + "C" + (t + l) + "," + (n + u) + " " + (r + u) + "," + (i - l) + " " + r + "," + i;
}, curveR = (t, n, r, i) => curve(n * Math.cos(t), n * Math.sin(t), i * Math.cos(r), i * Math.sin(r)), orthoX = (t, n, r, i) => "M" + t + "," + n + "V" + i + "H" + r, orthoY = (t, n, r, i) => "M" + t + "," + n + "H" + r + "V" + i, orthoR = (t, n, r, i) => {
	let o = Math.cos(t), s = Math.sin(t), l = Math.cos(r), u = Math.sin(r), d = Math.abs(r - t) > Math.PI ? r <= t : r > t;
	return "M" + n * o + "," + n * s + "A" + n + "," + n + " 0 0," + (d ? 1 : 0) + " " + n * l + "," + n * u + "L" + i * l + "," + i * u;
}, diagonalX = (t, n, r, i) => {
	let o = (t + r) / 2;
	return "M" + t + "," + n + "C" + o + "," + n + " " + o + "," + i + " " + r + "," + i;
}, diagonalY = (t, n, r, i) => {
	let o = (n + i) / 2;
	return "M" + t + "," + n + "C" + t + "," + o + " " + r + "," + o + " " + r + "," + i;
}, diagonalR = (t, n, r, i) => {
	let o = Math.cos(t), s = Math.sin(t), l = Math.cos(r), u = Math.sin(r), d = (n + i) / 2;
	return "M" + n * o + "," + n * s + "C" + d * o + "," + d * s + " " + d * l + "," + d * u + " " + i * l + "," + i * u;
}, Paths = fastmap({
	line: line$1,
	"line-radial": lineR,
	arc: arc$1,
	"arc-radial": arcR,
	curve,
	"curve-radial": curveR,
	"orthogonal-horizontal": orthoX,
	"orthogonal-vertical": orthoY,
	"orthogonal-radial": orthoR,
	"diagonal-horizontal": diagonalX,
	"diagonal-vertical": diagonalY,
	"diagonal-radial": diagonalR
});
function Pie(t) {
	Transform.call(this, null, t);
}
Pie.Definition = {
	type: "Pie",
	metadata: { modifies: !0 },
	params: [
		{
			name: "field",
			type: "field"
		},
		{
			name: "startAngle",
			type: "number",
			default: 0
		},
		{
			name: "endAngle",
			type: "number",
			default: 6.283185307179586
		},
		{
			name: "sort",
			type: "boolean",
			default: !1
		},
		{
			name: "as",
			type: "string",
			array: !0,
			length: 2,
			default: ["startAngle", "endAngle"]
		}
	]
}, inherits(Pie, Transform, { transform(t, n) {
	var r = t.as || ["startAngle", "endAngle"], i = r[0], o = r[1], s = t.field || one$1, l = t.startAngle || 0, u = t.endAngle == null ? 2 * Math.PI : t.endAngle, d = n.source, f = d.map(s), p = f.length, g = l, _ = (u - l) / sum(f), v = range$3(p), S, T, E;
	for (t.sort && v.sort((t, n) => f[t] - f[n]), S = 0; S < p; ++S) E = f[v[S]], T = d[v[S]], T[i] = g, T[o] = g += E * _;
	return this.value = f, n.reflow(t.modified()).modifies(r);
} });
var DEFAULT_COUNT = 5;
function includeZero(t) {
	let n = t.type;
	return !t.bins && (n === "linear" || n === "pow" || n === "sqrt");
}
function includePad(t) {
	return isContinuous$1(t) && t !== "sequential";
}
var SKIP$1 = toSet([
	"set",
	"modified",
	"clear",
	"type",
	"scheme",
	"schemeExtent",
	"schemeCount",
	"domain",
	"domainMin",
	"domainMid",
	"domainMax",
	"domainRaw",
	"domainImplicit",
	"nice",
	"zero",
	"bins",
	"range",
	"rangeStep",
	"round",
	"reverse",
	"interpolate",
	"interpolateGamma"
]);
function Scale$1(t) {
	Transform.call(this, null, t), this.modified(!0);
}
inherits(Scale$1, Transform, { transform(t, n) {
	var r = n.dataflow, i = this.value, o = scaleKey(t);
	for (o in (!i || o !== i.type) && (this.value = i = scale(o)()), t) if (!SKIP$1[o]) {
		if (o === "padding" && includePad(i.type)) continue;
		isFunction(i[o]) ? i[o](t[o]) : r.warn("Unsupported scale property: " + o);
	}
	return configureRange(i, t, configureBins(i, t, configureDomain(i, t, r))), n.fork(n.NO_SOURCE | n.NO_FIELDS);
} });
function scaleKey(t) {
	var n = t.type, r = "", i;
	return n === "sequential" ? Sequential + "-" + Linear : (isContinuousColor(t) && (i = t.rawDomain ? t.rawDomain.length : t.domain ? t.domain.length + +(t.domainMid != null) : 0, r = i === 2 ? Sequential + "-" : i === 3 ? Diverging + "-" : ""), (r + n || "linear").toLowerCase());
}
function isContinuousColor(t) {
	let n = t.type;
	return isContinuous$1(n) && n !== "time" && n !== "utc" && (t.scheme || t.range && t.range.length && t.range.every(isString));
}
function configureDomain(t, n, r) {
	let i = rawDomain(t, n.domainRaw, r);
	if (i > -1) return i;
	var o = n.domain, s = t.type, l = n.zero || n.zero === void 0 && includeZero(t), u, d;
	if (!o) return 0;
	if ((l || n.domainMin != null || n.domainMax != null || n.domainMid != null) && (u = (o = o.slice()).length - 1 || 1, l && (o[0] > 0 && (o[0] = 0), o[u] < 0 && (o[u] = 0)), n.domainMin != null && (o[0] = n.domainMin), n.domainMax != null && (o[u] = n.domainMax), n.domainMid != null)) {
		d = n.domainMid;
		let t = d > o[u] ? u + 1 : d < o[0] ? 0 : u;
		t !== u && r.warn("Scale domainMid exceeds domain min or max.", d), o.splice(t, 0, d);
	}
	return includePad(s) && n.padding && o[0] !== peek(o) && (o = padDomain(s, o, n.range, n.padding, n.exponent, n.constant)), t.domain(domainCheck(s, o, r)), s === "ordinal" && t.unknown(n.domainImplicit ? implicit : void 0), n.nice && t.nice && t.nice(n.nice !== !0 && tickCount(t, n.nice) || null), o.length;
}
function rawDomain(t, n, r) {
	return n ? (t.domain(domainCheck(t.type, n, r)), n.length) : -1;
}
function padDomain(t, n, r, i, o, s) {
	var l = Math.abs(peek(r) - r[0]), u = l / (l - 2 * i), d = t === "log" ? zoomLog(n, null, u) : t === "sqrt" ? zoomPow(n, null, u, .5) : t === "pow" ? zoomPow(n, null, u, o || 1) : t === "symlog" ? zoomSymlog(n, null, u, s || 1) : zoomLinear(n, null, u);
	return n = n.slice(), n[0] = d[0], n[n.length - 1] = d[1], n;
}
function domainCheck(t, n, r) {
	return isLogarithmic(t) && Math.abs(n.reduce((t, n) => t + (n < 0 ? -1 : n > 0 ? 1 : 0), 0)) !== n.length && r.warn("Log scale domain includes zero: " + $(n)), n;
}
function configureBins(t, n, r) {
	let i = n.bins;
	if (i && !isArray(i)) {
		let n = t.domain(), r = n[0], o = peek(n), s = i.step, l = i.start == null ? r : i.start, u = i.stop == null ? o : i.stop;
		s || error$1("Scale bins parameter missing step property."), l < r && (l = s * Math.ceil(r / s)), u > o && (u = s * Math.floor(o / s)), i = range$3(l, u + s / 2, s);
	}
	return i ? t.bins = i : t.bins && delete t.bins, t.type === "bin-ordinal" && (i ? !n.domain && !n.domainRaw && (t.domain(i), r = i.length) : t.bins = t.domain()), r;
}
function configureRange(t, n, r) {
	var i = t.type, o = n.round || !1, s = n.range;
	if (n.rangeStep != null) s = configureRangeStep(i, n, r);
	else if (n.scheme && (s = configureScheme(i, n, r), isFunction(s))) {
		if (t.interpolator) return t.interpolator(s);
		error$1(`Scale type ${i} does not support interpolating color schemes.`);
	}
	if (s && isInterpolating(i)) return t.interpolator(interpolateColors(flip(s, n.reverse), n.interpolate, n.interpolateGamma));
	s && n.interpolate && t.interpolate ? t.interpolate(interpolate$1(n.interpolate, n.interpolateGamma)) : isFunction(t.round) ? t.round(o) : isFunction(t.rangeRound) && t.interpolate(o ? round_default : value_default), s && t.range(flip(s, n.reverse));
}
function configureRangeStep(t, n, r) {
	t !== "band" && t !== "point" && error$1("Only band and point scales support rangeStep.");
	var i = (n.paddingOuter == null ? n.padding : n.paddingOuter) || 0, o = t === "point" ? 1 : (n.paddingInner == null ? n.padding : n.paddingInner) || 0;
	return [0, n.rangeStep * bandSpace(r, o, i)];
}
function configureScheme(t, n, r) {
	var i = n.schemeExtent, o, s;
	return isArray(n.scheme) ? s = interpolateColors(n.scheme, n.interpolate, n.interpolateGamma) : (o = n.scheme.toLowerCase(), s = scheme$1(o), s || error$1(`Unrecognized scheme name: ${n.scheme}`)), r = t === "threshold" ? r + 1 : t === "bin-ordinal" ? r - 1 : t === "quantile" || t === "quantize" ? +n.schemeCount || DEFAULT_COUNT : r, isInterpolating(t) ? adjustScheme(s, i, n.reverse) : isFunction(s) ? quantizeInterpolator(adjustScheme(s, i), r) : t === "ordinal" ? s : s.slice(0, r);
}
function adjustScheme(t, n, r) {
	return isFunction(t) && (n || r) ? interpolateRange$1(t, flip(n || [0, 1], r)) : t;
}
function flip(t, n) {
	return n ? t.slice().reverse() : t;
}
function SortItems$1(t) {
	Transform.call(this, null, t);
}
inherits(SortItems$1, Transform, { transform(t, n) {
	let r = t.modified("sort") || n.changed(n.ADD) || n.modified(t.sort.fields) || n.modified("datum");
	return r && n.source.sort(stableCompare(t.sort)), this.modified(r), n;
} });
var Zero = "zero", Center$1 = "center", Normalize = "normalize", DefOutput = ["y0", "y1"];
function Stack(t) {
	Transform.call(this, null, t);
}
Stack.Definition = {
	type: "Stack",
	metadata: { modifies: !0 },
	params: [
		{
			name: "field",
			type: "field"
		},
		{
			name: "groupby",
			type: "field",
			array: !0
		},
		{
			name: "sort",
			type: "compare"
		},
		{
			name: "offset",
			type: "enum",
			default: Zero,
			values: [
				Zero,
				Center$1,
				Normalize
			]
		},
		{
			name: "as",
			type: "string",
			array: !0,
			length: 2,
			default: DefOutput
		}
	]
}, inherits(Stack, Transform, { transform(t, n) {
	var r = t.as || DefOutput, i = r[0], o = r[1], s = stableCompare(t.sort), l = t.field || one$1, u = t.offset === Center$1 ? stackCenter : t.offset === Normalize ? stackNormalize : stackZero, d = partition$2(n.source, t.groupby, s, l), f, p, g;
	for (f = 0, p = d.length, g = d.max; f < p; ++f) u(d[f], g, l, i, o);
	return n.reflow(t.modified()).modifies(r);
} });
function stackCenter(t, n, r, i, o) {
	for (var s = (n - t.sum) / 2, l = t.length, u = 0, d; u < l; ++u) d = t[u], d[i] = s, d[o] = s += Math.abs(r(d));
}
function stackNormalize(t, n, r, i, o) {
	for (var s = 1 / t.sum, l = 0, u = t.length, d = 0, f = 0, p; d < u; ++d) p = t[d], p[i] = l, p[o] = l = s * (f += Math.abs(r(p)));
}
function stackZero(t, n, r, i, o) {
	for (var s = 0, l = 0, u = t.length, d = 0, f, p; d < u; ++d) p = t[d], f = +r(p), f < 0 ? (p[i] = l, p[o] = l += f) : (p[i] = s, p[o] = s += f);
}
function partition$2(t, n, r, i) {
	var o = [], s = (t) => t(p), l, u, d, f, p, g, _, v, S;
	if (n == null) o.push(t.slice());
	else for (l = {}, u = 0, d = t.length; u < d; ++u) p = t[u], g = n.map(s), _ = l[g], _ || (l[g] = _ = [], o.push(_)), _.push(p);
	for (g = 0, S = 0, f = o.length; g < f; ++g) {
		for (_ = o[g], u = 0, v = 0, d = _.length; u < d; ++u) v += Math.abs(i(_[u]));
		_.sum = v, v > S && (S = v), r && _.sort(r);
	}
	return o.max = S, o;
}
var abs = Math.abs, cos = Math.cos, sin = Math.sin, pi = Math.PI, halfPi = pi / 2;
pi / 4;
var sqrt2 = sqrt(2);
pi * 2, 180 / pi, pi / 180;
function asin(t) {
	return t > 1 ? halfPi : t < -1 ? -halfPi : Math.asin(t);
}
function sqrt(t) {
	return t > 0 ? Math.sqrt(t) : 0;
}
function mollweideBromleyTheta(t, n) {
	var r = t * sin(n), i = 30, o;
	do
		n -= o = (n + sin(n) - r) / (1 + cos(n));
	while (abs(o) > 1e-6 && --i > 0);
	return n / 2;
}
function mollweideBromleyRaw(t, n, r) {
	function i(i, o) {
		return [t * i * cos(o = mollweideBromleyTheta(r, o)), n * sin(o)];
	}
	return i.invert = function(i, o) {
		return o = asin(o / n), [i / (t * cos(o)), asin((2 * o + sin(2 * o)) / r)];
	}, i;
}
var mollweideRaw = mollweideBromleyRaw(sqrt2 / halfPi, sqrt2, pi);
function mollweide_default() {
	return projection$1(mollweideRaw).scale(169.529);
}
var defaultPath = path_default(), projectionProperties = [
	"clipAngle",
	"clipExtent",
	"scale",
	"translate",
	"center",
	"rotate",
	"parallels",
	"precision",
	"reflectX",
	"reflectY",
	"coefficient",
	"distance",
	"fraction",
	"lobes",
	"parallel",
	"radius",
	"ratio",
	"spacing",
	"tilt"
];
function create$1(t, n) {
	return function r() {
		let i = n();
		return i.type = t, i.path = path_default().projection(i), i.copy = i.copy || function() {
			let t = r();
			return projectionProperties.forEach((n) => {
				i[n] && t[n](i[n]());
			}), t.path.pointRadius(i.path.pointRadius()), t;
		}, registerScale(i);
	};
}
function projection(t, n) {
	if (!t || typeof t != "string") throw Error("Projection type must be a name string.");
	return t = t.toLowerCase(), arguments.length > 1 ? (projections[t] = create$1(t, n), this) : projections[t] || null;
}
function getProjectionPath(t) {
	return t && t.path || defaultPath;
}
var projections = {
	albers: albers_default,
	albersusa: albersUsa_default,
	azimuthalequalarea: azimuthalEqualArea_default,
	azimuthalequidistant: azimuthalEquidistant_default,
	conicconformal: conicConformal_default,
	conicequalarea: conicEqualArea_default,
	conicequidistant: conicEquidistant_default,
	equalEarth: equalEarth_default,
	equirectangular: equirectangular_default,
	gnomonic: gnomonic_default,
	identity: identity_default,
	mercator: mercator_default,
	mollweide: mollweide_default,
	naturalEarth1: naturalEarth1_default,
	orthographic: orthographic_default,
	stereographic: stereographic_default,
	transversemercator: transverseMercator_default
};
for (let t in projections) projection(t, projections[t]);
var vega_geo_exports = /* @__PURE__ */ __export({
	contour: () => Contour,
	geojson: () => GeoJSON,
	geopath: () => GeoPath,
	geopoint: () => GeoPoint,
	geoshape: () => GeoShape,
	graticule: () => Graticule,
	heatmap: () => Heatmap,
	isocontour: () => Isocontour,
	kde2d: () => KDE2D,
	projection: () => Projection$1
});
function noop() {}
var cases = [
	[],
	[[[1, 1.5], [.5, 1]]],
	[[[1.5, 1], [1, 1.5]]],
	[[[1.5, 1], [.5, 1]]],
	[[[1, .5], [1.5, 1]]],
	[[[1, 1.5], [.5, 1]], [[1, .5], [1.5, 1]]],
	[[[1, .5], [1, 1.5]]],
	[[[1, .5], [.5, 1]]],
	[[[.5, 1], [1, .5]]],
	[[[1, 1.5], [1, .5]]],
	[[[.5, 1], [1, .5]], [[1.5, 1], [1, 1.5]]],
	[[[1.5, 1], [1, .5]]],
	[[[.5, 1], [1.5, 1]]],
	[[[1, 1.5], [1.5, 1]]],
	[[[.5, 1], [1, 1.5]]],
	[]
];
function contours() {
	var t = 1, n = 1, r = u;
	function i(t, n) {
		return n.map((n) => o(t, n));
	}
	function o(t, n) {
		var i = [], o = [];
		return s(t, n, (s) => {
			r(s, t, n), area$1(s) > 0 ? i.push([s]) : o.push(s);
		}), o.forEach((t) => {
			for (var n = 0, r = i.length, o; n < r; ++n) if (contains$1((o = i[n])[0], t) !== -1) {
				o.push(t);
				return;
			}
		}), {
			type: "MultiPolygon",
			value: n,
			coordinates: i
		};
	}
	function s(r, i, o) {
		var s = [], u = [], d = f = -1, f, p, g = r[0] >= i, _, v;
		for (cases[g << 1].forEach(S); ++d < t - 1;) p = g, g = r[d + 1] >= i, cases[p | g << 1].forEach(S);
		for (cases[g << 0].forEach(S); ++f < n - 1;) {
			for (d = -1, g = r[f * t + t] >= i, _ = r[f * t] >= i, cases[g << 1 | _ << 2].forEach(S); ++d < t - 1;) p = g, g = r[f * t + t + d + 1] >= i, v = _, _ = r[f * t + d + 1] >= i, cases[p | g << 1 | _ << 2 | v << 3].forEach(S);
			cases[g | _ << 3].forEach(S);
		}
		for (d = -1, _ = r[f * t] >= i, cases[_ << 2].forEach(S); ++d < t - 1;) v = _, _ = r[f * t + d + 1] >= i, cases[_ << 2 | v << 3].forEach(S);
		cases[_ << 3].forEach(S);
		function S(t) {
			var n = [t[0][0] + d, t[0][1] + f], r = [t[1][0] + d, t[1][1] + f], i = l(n), p = l(r), g, _;
			(g = u[i]) ? (_ = s[p]) ? (delete u[g.end], delete s[_.start], g === _ ? (g.ring.push(r), o(g.ring)) : s[g.start] = u[_.end] = {
				start: g.start,
				end: _.end,
				ring: g.ring.concat(_.ring)
			}) : (delete u[g.end], g.ring.push(r), u[g.end = p] = g) : (g = s[p]) ? (_ = u[i]) ? (delete s[g.start], delete u[_.end], g === _ ? (g.ring.push(r), o(g.ring)) : s[_.start] = u[g.end] = {
				start: _.start,
				end: g.end,
				ring: _.ring.concat(g.ring)
			}) : (delete s[g.start], g.ring.unshift(n), s[g.start = i] = g) : s[i] = u[p] = {
				start: i,
				end: p,
				ring: [n, r]
			};
		}
	}
	function l(n) {
		return n[0] * 2 + n[1] * (t + 1) * 4;
	}
	function u(r, i, o) {
		r.forEach((r) => {
			var s = r[0], l = r[1], u = s | 0, d = l | 0, f, p = i[d * t + u];
			s > 0 && s < t && u === s && (f = i[d * t + u - 1], r[0] = s + (o - f) / (p - f) - .5), l > 0 && l < n && d === l && (f = i[(d - 1) * t + u], r[1] = l + (o - f) / (p - f) - .5);
		});
	}
	return i.contour = o, i.size = function(r) {
		if (!arguments.length) return [t, n];
		var o = Math.floor(r[0]), s = Math.floor(r[1]);
		return o >= 0 && s >= 0 || error$1("invalid size"), t = o, n = s, i;
	}, i.smooth = function(t) {
		return arguments.length ? (r = t ? u : noop, i) : r === u;
	}, i;
}
function area$1(t) {
	for (var n = 0, r = t.length, i = t[r - 1][1] * t[0][0] - t[r - 1][0] * t[0][1]; ++n < r;) i += t[n - 1][1] * t[n][0] - t[n - 1][0] * t[n][1];
	return i;
}
function contains$1(t, n) {
	for (var r = -1, i = n.length, o; ++r < i;) if (o = ringContains(t, n[r])) return o;
	return 0;
}
function ringContains(t, n) {
	for (var r = n[0], i = n[1], o = -1, s = 0, l = t.length, u = l - 1; s < l; u = s++) {
		var d = t[s], f = d[0], p = d[1], g = t[u], _ = g[0], v = g[1];
		if (segmentContains(d, g, n)) return 0;
		p > i != v > i && r < (_ - f) * (i - p) / (v - p) + f && (o = -o);
	}
	return o;
}
function segmentContains(t, n, r) {
	var i;
	return collinear(t, n, r) && within(t[i = +(t[0] === n[0])], r[i], n[i]);
}
function collinear(t, n, r) {
	return (n[0] - t[0]) * (r[1] - t[1]) === (r[0] - t[0]) * (n[1] - t[1]);
}
function within(t, n, r) {
	return t <= n && n <= r || r <= n && n <= t;
}
function quantize(t, n, r) {
	return function(i) {
		var o = extent(i), s = r ? Math.min(o[0], 0) : o[0], l = o[1], u = l - s, d = n ? tickStep(s, l, t) : u / (t + 1);
		return range$3(s + d, l, d);
	};
}
function Isocontour(t) {
	Transform.call(this, null, t);
}
Isocontour.Definition = {
	type: "Isocontour",
	metadata: { generates: !0 },
	params: [
		{
			name: "field",
			type: "field"
		},
		{
			name: "thresholds",
			type: "number",
			array: !0
		},
		{
			name: "levels",
			type: "number"
		},
		{
			name: "nice",
			type: "boolean",
			default: !1
		},
		{
			name: "resolve",
			type: "enum",
			values: ["shared", "independent"],
			default: "independent"
		},
		{
			name: "zero",
			type: "boolean",
			default: !0
		},
		{
			name: "smooth",
			type: "boolean",
			default: !0
		},
		{
			name: "scale",
			type: "number",
			expr: !0
		},
		{
			name: "translate",
			type: "number",
			array: !0,
			expr: !0
		},
		{
			name: "as",
			type: "string",
			null: !0,
			default: "contour"
		}
	]
}, inherits(Isocontour, Transform, { transform(t, n) {
	if (this.value && !n.changed() && !t.modified()) return n.StopPropagation;
	var r = n.fork(n.NO_SOURCE | n.NO_FIELDS), i = n.materialize(n.SOURCE).source, o = t.field || identity, s = contours().smooth(t.smooth !== !1), l = t.thresholds || levels(i, o, t), u = t.as === null ? null : t.as || "contour", d = [];
	return i.forEach((n) => {
		let r = o(n), i = s.size([r.width, r.height])(r.values, isArray(l) ? l : l(r.values));
		transformPaths(i, r, n, t), i.forEach((t) => {
			d.push(rederive(n, ingest$1(u == null ? t : { [u]: t })));
		});
	}), this.value && (r.rem = this.value), this.value = r.source = r.add = d, r;
} });
function levels(t, n, r) {
	let i = quantize(r.levels || 10, r.nice, r.zero !== !1);
	return r.resolve === "shared" ? i(t.map((t) => max(n(t).values))) : i;
}
function transformPaths(t, n, r, i) {
	let o = i.scale || n.scale, s = i.translate || n.translate;
	if (isFunction(o) && (o = o(r, i)), isFunction(s) && (s = s(r, i)), (o === 1 || o == null) && !s) return;
	let l = (isNumber(o) ? o : o[0]) || 1, u = (isNumber(o) ? o : o[1]) || 1, d = s && s[0] || 0, f = s && s[1] || 0;
	t.forEach(transform$2(n, l, u, d, f));
}
function transform$2(t, n, r, i, o) {
	let s = t.x1 || 0, l = t.y1 || 0, u = n * r < 0;
	function d(t) {
		t.forEach(f);
	}
	function f(t) {
		u && t.reverse(), t.forEach(p);
	}
	function p(t) {
		t[0] = (t[0] - s) * n + i, t[1] = (t[1] - l) * r + o;
	}
	return function(t) {
		return t.coordinates.forEach(d), t;
	};
}
function radius(t, n, r) {
	let i = t >= 0 ? t : estimateBandwidth(n, r);
	return Math.round((Math.sqrt(4 * i * i + 1) - 1) / 2);
}
function number$2(t) {
	return isFunction(t) ? t : constant(+t);
}
function density2D() {
	var t = (t) => t[0], n = (t) => t[1], r = one$1, i = [-1, -1], o = 960, s = 500, l = 2;
	function u(u, d) {
		let f = radius(i[0], u, t) >> l, p = radius(i[1], u, n) >> l, g = f ? f + 2 : 0, _ = p ? p + 2 : 0, v = 2 * g + (o >> l), S = 2 * _ + (s >> l), T = new Float32Array(v * S), E = new Float32Array(v * S), O = T;
		u.forEach((i) => {
			let o = g + (+t(i) >> l), s = _ + (+n(i) >> l);
			o >= 0 && o < v && s >= 0 && s < S && (T[o + s * v] += +r(i));
		}), f > 0 && p > 0 ? (blurX(v, S, T, E, f), blurY(v, S, E, T, p), blurX(v, S, T, E, f), blurY(v, S, E, T, p), blurX(v, S, T, E, f), blurY(v, S, E, T, p)) : f > 0 ? (blurX(v, S, T, E, f), blurX(v, S, E, T, f), blurX(v, S, T, E, f), O = E) : p > 0 && (blurY(v, S, T, E, p), blurY(v, S, E, T, p), blurY(v, S, T, E, p), O = E);
		let k = d ? 2 ** (-2 * l) : 1 / sum(O);
		for (let t = 0, n = v * S; t < n; ++t) O[t] *= k;
		return {
			values: O,
			scale: 1 << l,
			width: v,
			height: S,
			x1: g,
			y1: _,
			x2: g + (o >> l),
			y2: _ + (s >> l)
		};
	}
	return u.x = function(n) {
		return arguments.length ? (t = number$2(n), u) : t;
	}, u.y = function(t) {
		return arguments.length ? (n = number$2(t), u) : n;
	}, u.weight = function(t) {
		return arguments.length ? (r = number$2(t), u) : r;
	}, u.size = function(t) {
		if (!arguments.length) return [o, s];
		var n = +t[0], r = +t[1];
		return n >= 0 && r >= 0 || error$1("invalid size"), o = n, s = r, u;
	}, u.cellSize = function(t) {
		return arguments.length ? ((t = +t) >= 1 || error$1("invalid cell size"), l = Math.floor(Math.log(t) / Math.LN2), u) : 1 << l;
	}, u.bandwidth = function(t) {
		return arguments.length ? (t = array(t), t.length === 1 && (t = [+t[0], +t[0]]), t.length !== 2 && error$1("invalid bandwidth"), i = t, u) : i;
	}, u;
}
function blurX(t, n, r, i, o) {
	let s = (o << 1) + 1;
	for (let l = 0; l < n; ++l) for (let n = 0, u = 0; n < t + o; ++n) n < t && (u += r[n + l * t]), n >= o && (n >= s && (u -= r[n - s + l * t]), i[n - o + l * t] = u / Math.min(n + 1, t - 1 + s - n, s));
}
function blurY(t, n, r, i, o) {
	let s = (o << 1) + 1;
	for (let l = 0; l < t; ++l) for (let u = 0, d = 0; u < n + o; ++u) u < n && (d += r[l + u * t]), u >= o && (u >= s && (d -= r[l + (u - s) * t]), i[l + (u - o) * t] = d / Math.min(u + 1, n - 1 + s - u, s));
}
function KDE2D(t) {
	Transform.call(this, null, t);
}
KDE2D.Definition = {
	type: "KDE2D",
	metadata: { generates: !0 },
	params: [
		{
			name: "size",
			type: "number",
			array: !0,
			length: 2,
			required: !0
		},
		{
			name: "x",
			type: "field",
			required: !0
		},
		{
			name: "y",
			type: "field",
			required: !0
		},
		{
			name: "weight",
			type: "field"
		},
		{
			name: "groupby",
			type: "field",
			array: !0
		},
		{
			name: "cellSize",
			type: "number"
		},
		{
			name: "bandwidth",
			type: "number",
			array: !0,
			length: 2
		},
		{
			name: "counts",
			type: "boolean",
			default: !1
		},
		{
			name: "as",
			type: "string",
			default: "grid"
		}
	]
};
var PARAMS = [
	"x",
	"y",
	"weight",
	"size",
	"cellSize",
	"bandwidth"
];
function params(t, n) {
	return PARAMS.forEach((r) => n[r] == null ? 0 : t[r](n[r])), t;
}
inherits(KDE2D, Transform, { transform(t, n) {
	if (this.value && !n.changed() && !t.modified()) return n.StopPropagation;
	var r = n.fork(n.NO_SOURCE | n.NO_FIELDS), i = n.materialize(n.SOURCE).source, o = partition$1(i, t.groupby), s = (t.groupby || []).map(accessorName), l = params(density2D(), t), u = t.as || "grid", d = [];
	function f(t, n) {
		for (let r = 0; r < s.length; ++r) t[s[r]] = n[r];
		return t;
	}
	return d = o.map((n) => ingest$1(f({ [u]: l(n, t.counts) }, n.dims))), this.value && (r.rem = this.value), this.value = r.source = r.add = d, r;
} });
function partition$1(t, n) {
	var r = [], i = (t) => t(u), o, s, l, u, d, f;
	if (n == null) r.push(t);
	else for (o = {}, s = 0, l = t.length; s < l; ++s) u = t[s], d = n.map(i), f = o[d], f || (o[d] = f = [], f.dims = d, r.push(f)), f.push(u);
	return r;
}
function Contour(t) {
	Transform.call(this, null, t);
}
Contour.Definition = {
	type: "Contour",
	metadata: { generates: !0 },
	params: [
		{
			name: "size",
			type: "number",
			array: !0,
			length: 2,
			required: !0
		},
		{
			name: "values",
			type: "number",
			array: !0
		},
		{
			name: "x",
			type: "field"
		},
		{
			name: "y",
			type: "field"
		},
		{
			name: "weight",
			type: "field"
		},
		{
			name: "cellSize",
			type: "number"
		},
		{
			name: "bandwidth",
			type: "number"
		},
		{
			name: "count",
			type: "number"
		},
		{
			name: "nice",
			type: "boolean",
			default: !1
		},
		{
			name: "thresholds",
			type: "number",
			array: !0
		},
		{
			name: "smooth",
			type: "boolean",
			default: !0
		}
	]
}, inherits(Contour, Transform, { transform(t, n) {
	if (this.value && !n.changed() && !t.modified()) return n.StopPropagation;
	var r = n.fork(n.NO_SOURCE | n.NO_FIELDS), i = contours().smooth(t.smooth !== !1), o = t.values, s = t.thresholds || quantize(t.count || 10, t.nice, !!o), l = t.size, u, d;
	return o ||= (o = n.materialize(n.SOURCE).source, u = params(density2D(), t)(o, !0), d = transform$2(u, u.scale || 1, u.scale || 1, 0, 0), l = [u.width, u.height], u.values), s = isArray(s) ? s : s(o), o = i.size(l)(o, s), d && o.forEach(d), this.value && (r.rem = this.value), this.value = r.source = r.add = (o || []).map(ingest$1), r;
} });
var Feature = "Feature", FeatureCollection = "FeatureCollection", MultiPoint = "MultiPoint";
function GeoJSON(t) {
	Transform.call(this, null, t);
}
GeoJSON.Definition = {
	type: "GeoJSON",
	metadata: {},
	params: [{
		name: "fields",
		type: "field",
		array: !0,
		length: 2
	}, {
		name: "geojson",
		type: "field"
	}]
}, inherits(GeoJSON, Transform, { transform(t, n) {
	var r = this._features, i = this._points, o = t.fields, s = o && o[0], l = o && o[1], u = t.geojson || !o && identity, d = n.ADD, f = t.modified() || n.changed(n.REM) || n.modified(accessorFields(u)) || s && n.modified(accessorFields(s)) || l && n.modified(accessorFields(l));
	(!this.value || f) && (d = n.SOURCE, this._features = r = [], this._points = i = []), u && n.visit(d, (t) => r.push(u(t))), s && l && (n.visit(d, (t) => {
		var n = s(t), r = l(t);
		n != null && r != null && (n = +n) === n && (r = +r) === r && i.push([n, r]);
	}), r = r.concat({
		type: Feature,
		geometry: {
			type: MultiPoint,
			coordinates: i
		}
	})), this.value = {
		type: FeatureCollection,
		features: r
	};
} });
function GeoPath(t) {
	Transform.call(this, null, t);
}
GeoPath.Definition = {
	type: "GeoPath",
	metadata: { modifies: !0 },
	params: [
		{
			name: "projection",
			type: "projection"
		},
		{
			name: "field",
			type: "field"
		},
		{
			name: "pointRadius",
			type: "number",
			expr: !0
		},
		{
			name: "as",
			type: "string",
			default: "path"
		}
	]
}, inherits(GeoPath, Transform, { transform(t, n) {
	var r = n.fork(n.ALL), i = this.value, o = t.field || identity, s = t.as || "path", l = r.SOURCE;
	!i || t.modified() ? (this.value = i = getProjectionPath(t.projection), r.materialize().reflow()) : l = o === identity || n.modified(o.fields) ? r.ADD_MOD : r.ADD;
	let u = initPath(i, t.pointRadius);
	return r.visit(l, (t) => t[s] = i(o(t))), i.pointRadius(u), r.modifies(s);
} });
function initPath(t, n) {
	let r = t.pointRadius();
	return t.context(null), n != null && t.pointRadius(n), r;
}
function GeoPoint(t) {
	Transform.call(this, null, t);
}
GeoPoint.Definition = {
	type: "GeoPoint",
	metadata: { modifies: !0 },
	params: [
		{
			name: "projection",
			type: "projection",
			required: !0
		},
		{
			name: "fields",
			type: "field",
			array: !0,
			required: !0,
			length: 2
		},
		{
			name: "as",
			type: "string",
			array: !0,
			length: 2,
			default: ["x", "y"]
		}
	]
}, inherits(GeoPoint, Transform, { transform(t, n) {
	var r = t.projection, i = t.fields[0], o = t.fields[1], s = t.as || ["x", "y"], l = s[0], u = s[1], d;
	function f(t) {
		let n = r([i(t), o(t)]);
		n ? (t[l] = n[0], t[u] = n[1]) : (t[l] = void 0, t[u] = void 0);
	}
	return t.modified() ? n = n.materialize().reflow(!0).visit(n.SOURCE, f) : (d = n.modified(i.fields) || n.modified(o.fields), n.visit(d ? n.ADD_MOD : n.ADD, f)), n.modifies(s);
} });
function GeoShape(t) {
	Transform.call(this, null, t);
}
GeoShape.Definition = {
	type: "GeoShape",
	metadata: {
		modifies: !0,
		nomod: !0
	},
	params: [
		{
			name: "projection",
			type: "projection"
		},
		{
			name: "field",
			type: "field",
			default: "datum"
		},
		{
			name: "pointRadius",
			type: "number",
			expr: !0
		},
		{
			name: "as",
			type: "string",
			default: "shape"
		}
	]
}, inherits(GeoShape, Transform, { transform(t, n) {
	var r = n.fork(n.ALL), i = this.value, o = t.as || "shape", s = r.ADD;
	return (!i || t.modified()) && (this.value = i = shapeGenerator(getProjectionPath(t.projection), t.field || field$1("datum"), t.pointRadius), r.materialize().reflow(), s = r.SOURCE), r.visit(s, (t) => t[o] = i), r.modifies(o);
} });
function shapeGenerator(t, n, r) {
	let i = r == null ? (r) => t(n(r)) : (i) => {
		var o = t.pointRadius(), s = t.pointRadius(r)(n(i));
		return t.pointRadius(o), s;
	};
	return i.context = (n) => (t.context(n), i), i;
}
function Graticule(t) {
	Transform.call(this, [], t), this.generator = graticule();
}
Graticule.Definition = {
	type: "Graticule",
	metadata: {
		changes: !0,
		generates: !0
	},
	params: [
		{
			name: "extent",
			type: "array",
			array: !0,
			length: 2,
			content: {
				type: "number",
				array: !0,
				length: 2
			}
		},
		{
			name: "extentMajor",
			type: "array",
			array: !0,
			length: 2,
			content: {
				type: "number",
				array: !0,
				length: 2
			}
		},
		{
			name: "extentMinor",
			type: "array",
			array: !0,
			length: 2,
			content: {
				type: "number",
				array: !0,
				length: 2
			}
		},
		{
			name: "step",
			type: "number",
			array: !0,
			length: 2
		},
		{
			name: "stepMajor",
			type: "number",
			array: !0,
			length: 2,
			default: [90, 360]
		},
		{
			name: "stepMinor",
			type: "number",
			array: !0,
			length: 2,
			default: [10, 10]
		},
		{
			name: "precision",
			type: "number",
			default: 2.5
		}
	]
}, inherits(Graticule, Transform, { transform(t, n) {
	var r = this.value, i = this.generator, o;
	if (!r.length || t.modified()) for (let n in t) isFunction(i[n]) && i[n](t[n]);
	return o = i(), r.length ? n.mod.push(replace$1(r[0], o)) : n.add.push(ingest$1(o)), r[0] = o, n;
} });
function Heatmap(t) {
	Transform.call(this, null, t);
}
Heatmap.Definition = {
	type: "heatmap",
	metadata: { modifies: !0 },
	params: [
		{
			name: "field",
			type: "field"
		},
		{
			name: "color",
			type: "string",
			expr: !0
		},
		{
			name: "opacity",
			type: "number",
			expr: !0
		},
		{
			name: "resolve",
			type: "enum",
			values: ["shared", "independent"],
			default: "independent"
		},
		{
			name: "as",
			type: "string",
			default: "image"
		}
	]
}, inherits(Heatmap, Transform, { transform(t, n) {
	if (!n.changed() && !t.modified()) return n.StopPropagation;
	var r = n.materialize(n.SOURCE).source, i = t.resolve === "shared", o = t.field || identity, s = opacity_(t.opacity, t), l = color_(t.color, t), u = t.as || "image", d = {
		$x: 0,
		$y: 0,
		$value: 0,
		$max: i ? max(r.map((t) => max(o(t).values))) : 0
	};
	return r.forEach((t) => {
		let n = o(t), r = extend({}, t, d);
		i || (r.$max = max(n.values || [])), t[u] = toCanvas(n, r, l.dep ? l : constant(l(r)), s.dep ? s : constant(s(r)));
	}), n.reflow(!0).modifies(u);
} });
function color_(t, n) {
	let r;
	return isFunction(t) ? (r = (r) => rgb(t(r, n)), r.dep = dependency(t)) : r = constant(rgb(t || "#888")), r;
}
function opacity_(t, n) {
	let r;
	return isFunction(t) ? (r = (r) => t(r, n), r.dep = dependency(t)) : t ? r = constant(t) : (r = (t) => t.$value / t.$max || 0, r.dep = !0), r;
}
function dependency(t) {
	if (!isFunction(t)) return !1;
	let n = toSet(accessorFields(t));
	return n.$x || n.$y || n.$value || n.$max;
}
function toCanvas(t, n, r, i) {
	let o = t.width, s = t.height, l = t.x1 || 0, u = t.y1 || 0, d = t.x2 || o, f = t.y2 || s, p = t.values, g = p ? (t) => p[t] : zero$2, _ = domCanvas(d - l, f - u), v = _.getContext("2d"), S = v.getImageData(0, 0, d - l, f - u), T = S.data;
	for (let t = u, s = 0; t < f; ++t) {
		n.$y = t - u;
		for (let u = l, f = t * o; u < d; ++u, s += 4) {
			n.$x = u - l, n.$value = g(u + f);
			let t = r(n);
			T[s + 0] = t.r, T[s + 1] = t.g, T[s + 2] = t.b, T[s + 3] = ~~(255 * i(n));
		}
	}
	return v.putImageData(S, 0, 0), _;
}
function Projection$1(t) {
	Transform.call(this, null, t), this.modified(!0);
}
inherits(Projection$1, Transform, { transform(t, n) {
	let r = this.value;
	return !r || t.modified("type") ? (this.value = r = create(t.type), projectionProperties.forEach((n) => {
		t[n] != null && set$1(r, n, t[n]);
	})) : projectionProperties.forEach((n) => {
		t.modified(n) && set$1(r, n, t[n]);
	}), t.pointRadius != null && r.path.pointRadius(t.pointRadius), t.fit && fit(r, t), n.fork(n.NO_SOURCE | n.NO_FIELDS);
} });
function fit(t, n) {
	let r = collectGeoJSON(n.fit);
	n.extent ? t.fitExtent(n.extent, r) : n.size && t.fitSize(n.size, r);
}
function create(t) {
	let n = projection((t || "mercator").toLowerCase());
	return n || error$1("Unrecognized projection type: " + t), n();
}
function set$1(t, n, r) {
	isFunction(t[n]) && t[n](r);
}
function collectGeoJSON(t) {
	return t = array(t), t.length === 1 ? t[0] : {
		type: FeatureCollection,
		features: t.reduce((t, n) => t.concat(featurize(n)), [])
	};
}
function featurize(t) {
	return t.type === FeatureCollection ? t.features : array(t).filter((t) => t != null).map((t) => t.type === Feature ? t : {
		type: Feature,
		geometry: t
	});
}
var vega_force_exports = /* @__PURE__ */ __export({ force: () => Force }), ForceMap = {
	center: center_default,
	collide: collide_default,
	nbody: manyBody_default,
	link: link_default,
	x: x_default,
	y: y_default
}, Forces = "forces", ForceParams = [
	"alpha",
	"alphaMin",
	"alphaTarget",
	"velocityDecay",
	"forces"
], ForceConfig = ["static", "iterations"], ForceOutput = [
	"x",
	"y",
	"vx",
	"vy"
];
function Force(t) {
	Transform.call(this, null, t);
}
Force.Definition = {
	type: "Force",
	metadata: { modifies: !0 },
	params: [
		{
			name: "static",
			type: "boolean",
			default: !1
		},
		{
			name: "restart",
			type: "boolean",
			default: !1
		},
		{
			name: "iterations",
			type: "number",
			default: 300
		},
		{
			name: "alpha",
			type: "number",
			default: 1
		},
		{
			name: "alphaMin",
			type: "number",
			default: .001
		},
		{
			name: "alphaTarget",
			type: "number",
			default: 0
		},
		{
			name: "velocityDecay",
			type: "number",
			default: .4
		},
		{
			name: "forces",
			type: "param",
			array: !0,
			params: [
				{
					key: { force: "center" },
					params: [{
						name: "x",
						type: "number",
						default: 0
					}, {
						name: "y",
						type: "number",
						default: 0
					}]
				},
				{
					key: { force: "collide" },
					params: [
						{
							name: "radius",
							type: "number",
							expr: !0
						},
						{
							name: "strength",
							type: "number",
							default: .7
						},
						{
							name: "iterations",
							type: "number",
							default: 1
						}
					]
				},
				{
					key: { force: "nbody" },
					params: [
						{
							name: "strength",
							type: "number",
							default: -30,
							expr: !0
						},
						{
							name: "theta",
							type: "number",
							default: .9
						},
						{
							name: "distanceMin",
							type: "number",
							default: 1
						},
						{
							name: "distanceMax",
							type: "number"
						}
					]
				},
				{
					key: { force: "link" },
					params: [
						{
							name: "links",
							type: "data"
						},
						{
							name: "id",
							type: "field"
						},
						{
							name: "distance",
							type: "number",
							default: 30,
							expr: !0
						},
						{
							name: "strength",
							type: "number",
							expr: !0
						},
						{
							name: "iterations",
							type: "number",
							default: 1
						}
					]
				},
				{
					key: { force: "x" },
					params: [{
						name: "strength",
						type: "number",
						default: .1
					}, {
						name: "x",
						type: "field"
					}]
				},
				{
					key: { force: "y" },
					params: [{
						name: "strength",
						type: "number",
						default: .1
					}, {
						name: "y",
						type: "field"
					}]
				}
			]
		},
		{
			name: "as",
			type: "string",
			array: !0,
			modify: !1,
			default: ForceOutput
		}
	]
}, inherits(Force, Transform, {
	transform(t, n) {
		var r = this.value, i = n.changed(n.ADD_REM), o = t.modified(ForceParams), s = t.iterations || 300;
		if (r ? (i && (n.modifies("index"), r.nodes(n.source)), (o || n.changed(n.MOD)) && setup(r, t, 0, n)) : (this.value = r = simulation(n.source, t), r.on("tick", rerun(n.dataflow, this)), t.static || (i = !0, r.tick()), n.modifies("index")), o || i || t.modified(ForceConfig) || n.changed() && t.restart) {
			if (r.alpha(Math.max(r.alpha(), t.alpha || 1)).alphaDecay(1 - r.alphaMin() ** (1 / s)), t.static) for (r.stop(); --s >= 0;) r.tick();
			else if (r.stopped() && r.restart(), !i) return n.StopPropagation;
		}
		return this.finish(t, n);
	},
	finish(t, n) {
		let r = n.dataflow;
		for (let t = this._argops, n = 0, u = t.length, d; n < u; ++n) if (d = t[n], !(d.name !== Forces || d.op._argval.force !== "link")) {
			for (var i = d.op._argops, o = 0, s = i.length, l; o < s; ++o) if (i[o].name === "links" && (l = i[o].op.source)) {
				r.pulse(l, r.changeset().reflow());
				break;
			}
		}
		return n.reflow(t.modified()).modifies(ForceOutput);
	}
});
function rerun(t, n) {
	return () => t.touch(n).run();
}
function simulation(t, n) {
	let r = simulation_default(t), i = r.stop, o = r.restart, s = !1;
	return r.stopped = () => s, r.restart = () => (s = !1, o()), r.stop = () => (s = !0, i()), setup(r, n, !0).on("end", () => s = !0);
}
function setup(t, n, r, i) {
	var o = array(n.forces), s, l, u, d;
	for (s = 0, l = ForceParams.length; s < l; ++s) u = ForceParams[s], u !== Forces && n.modified(u) && t[u](n[u]);
	for (s = 0, l = o.length; s < l; ++s) d = Forces + s, u = r || n.modified(Forces, s) ? getForce(o[s]) : i && modified(o[s], i) ? t.force(d) : null, u && t.force(d, u);
	for (l = t.numForces || 0; s < l; ++s) t.force(Forces + s, null);
	return t.numForces = o.length, t;
}
function modified(t, n) {
	var r, i;
	for (r in t) if (isFunction(i = t[r]) && n.modified(accessorFields(i))) return 1;
	return 0;
}
function getForce(t) {
	var n, r;
	for (r in has(ForceMap, t.force) || error$1("Unrecognized force: " + t.force), n = ForceMap[t.force](), t) isFunction(n[r]) && setForceParam(n[r], t[r], t);
	return n;
}
function setForceParam(t, n, r) {
	t(isFunction(n) ? (t) => n(t, r) : n);
}
var vega_hierarchy_exports = /* @__PURE__ */ __export({
	nest: () => Nest,
	pack: () => Pack,
	partition: () => Partition,
	stratify: () => Stratify,
	tree: () => Tree,
	treelinks: () => TreeLinks,
	treemap: () => Treemap
});
function lookup$2(t, n, r) {
	let i = {};
	return t.each((t) => {
		let o = t.data;
		r(o) && (i[n(o)] = t);
	}), t.lookup = i, t;
}
function Nest(t) {
	Transform.call(this, null, t);
}
Nest.Definition = {
	type: "Nest",
	metadata: {
		treesource: !0,
		changes: !0
	},
	params: [{
		name: "keys",
		type: "field",
		array: !0
	}, {
		name: "generate",
		type: "boolean"
	}]
};
var children$1 = (t) => t.values;
inherits(Nest, Transform, { transform(t, n) {
	n.source || error$1("Nest transform requires an upstream data source.");
	var r = t.generate, i = t.modified(), o = n.clone(), s = this.value;
	return (!s || i || n.changed()) && (s && s.each((t) => {
		t.children && isTuple(t.data) && o.rem.push(t.data);
	}), this.value = s = hierarchy({ values: array(t.keys).reduce((t, n) => (t.key(n), t), nest()).entries(o.source) }, children$1), r && s.each((t) => {
		t.children && (t = ingest$1(t.data), o.add.push(t), o.source.push(t));
	}), lookup$2(s, tupleid, tupleid)), o.source.root = s, o;
} });
function nest() {
	let t = [], n = {
		entries: (t) => i(r(t, 0), 0),
		key: (r) => (t.push(r), n)
	};
	function r(n, i) {
		if (i >= t.length) return n;
		let o = n.length, s = t[i++], l = {}, u = {}, d = -1, f, p, g;
		for (; ++d < o;) f = s(p = n[d]) + "", (g = l[f]) ? g.push(p) : l[f] = [p];
		for (f in l) u[f] = r(l[f], i);
		return u;
	}
	function i(n, r) {
		if (++r > t.length) return n;
		let o = [];
		for (let t in n) o.push({
			key: t,
			values: i(n[t], r)
		});
		return o;
	}
	return n;
}
function HierarchyLayout(t) {
	Transform.call(this, null, t);
}
var defaultSeparation = (t, n) => t.parent === n.parent ? 1 : 2;
inherits(HierarchyLayout, Transform, { transform(t, n) {
	(!n.source || !n.source.root) && error$1(this.constructor.name + " transform requires a backing tree data source.");
	let r = this.layout(t.method), i = this.fields, o = n.source.root, s = t.as || i;
	t.field ? o.sum(t.field) : o.count(), t.sort && o.sort(stableCompare(t.sort, (t) => t.data)), setParams(r, this.params, t), r.separation && r.separation(t.separation === !1 ? one$1 : defaultSeparation);
	try {
		this.value = r(o);
	} catch (t) {
		error$1(t);
	}
	return o.each((t) => setFields(t, i, s)), n.reflow(t.modified()).modifies(s).modifies("leaf");
} });
function setParams(t, n, r) {
	for (let i, o = 0, s = n.length; o < s; ++o) i = n[o], i in r && t[i](r[i]);
}
function setFields(t, n, r) {
	let i = t.data, o = n.length - 1;
	for (let s = 0; s < o; ++s) i[r[s]] = t[n[s]];
	i[r[o]] = t.children ? t.children.length : 0;
}
var Output$3 = [
	"x",
	"y",
	"r",
	"depth",
	"children"
];
function Pack(t) {
	HierarchyLayout.call(this, t);
}
Pack.Definition = {
	type: "Pack",
	metadata: {
		tree: !0,
		modifies: !0
	},
	params: [
		{
			name: "field",
			type: "field"
		},
		{
			name: "sort",
			type: "compare"
		},
		{
			name: "padding",
			type: "number",
			default: 0
		},
		{
			name: "radius",
			type: "field",
			default: null
		},
		{
			name: "size",
			type: "number",
			array: !0,
			length: 2
		},
		{
			name: "as",
			type: "string",
			array: !0,
			length: Output$3.length,
			default: Output$3
		}
	]
}, inherits(Pack, HierarchyLayout, {
	layout: pack_default,
	params: [
		"radius",
		"size",
		"padding"
	],
	fields: Output$3
});
var Output$2 = [
	"x0",
	"y0",
	"x1",
	"y1",
	"depth",
	"children"
];
function Partition(t) {
	HierarchyLayout.call(this, t);
}
Partition.Definition = {
	type: "Partition",
	metadata: {
		tree: !0,
		modifies: !0
	},
	params: [
		{
			name: "field",
			type: "field"
		},
		{
			name: "sort",
			type: "compare"
		},
		{
			name: "padding",
			type: "number",
			default: 0
		},
		{
			name: "round",
			type: "boolean",
			default: !1
		},
		{
			name: "size",
			type: "number",
			array: !0,
			length: 2
		},
		{
			name: "as",
			type: "string",
			array: !0,
			length: Output$2.length,
			default: Output$2
		}
	]
}, inherits(Partition, HierarchyLayout, {
	layout: partition_default,
	params: [
		"size",
		"round",
		"padding"
	],
	fields: Output$2
});
function Stratify(t) {
	Transform.call(this, null, t);
}
Stratify.Definition = {
	type: "Stratify",
	metadata: { treesource: !0 },
	params: [{
		name: "key",
		type: "field",
		required: !0
	}, {
		name: "parentKey",
		type: "field",
		required: !0
	}]
}, inherits(Stratify, Transform, { transform(t, n) {
	n.source || error$1("Stratify transform requires an upstream data source.");
	let r = this.value, i = t.modified(), o = n.fork(n.ALL).materialize(n.SOURCE), s = !r || i || n.changed(n.ADD_REM) || n.modified(t.key.fields) || n.modified(t.parentKey.fields);
	return o.source = o.source.slice(), s && (r = o.source.length ? lookup$2(stratify_default().id(t.key).parentId(t.parentKey)(o.source), t.key, truthy) : lookup$2(stratify_default()([{}]), t.key, t.key)), o.source.root = this.value = r, o;
} });
var Layouts = {
	tidy: tree_default,
	cluster: cluster_default
}, Output$1$1 = [
	"x",
	"y",
	"depth",
	"children"
];
function Tree(t) {
	HierarchyLayout.call(this, t);
}
Tree.Definition = {
	type: "Tree",
	metadata: {
		tree: !0,
		modifies: !0
	},
	params: [
		{
			name: "field",
			type: "field"
		},
		{
			name: "sort",
			type: "compare"
		},
		{
			name: "method",
			type: "enum",
			default: "tidy",
			values: ["tidy", "cluster"]
		},
		{
			name: "size",
			type: "number",
			array: !0,
			length: 2
		},
		{
			name: "nodeSize",
			type: "number",
			array: !0,
			length: 2
		},
		{
			name: "separation",
			type: "boolean",
			default: !0
		},
		{
			name: "as",
			type: "string",
			array: !0,
			length: Output$1$1.length,
			default: Output$1$1
		}
	]
}, inherits(Tree, HierarchyLayout, {
	layout(t) {
		let n = t || "tidy";
		if (has(Layouts, n)) return Layouts[n]();
		error$1("Unrecognized Tree layout method: " + n);
	},
	params: ["size", "nodeSize"],
	fields: Output$1$1
});
function TreeLinks(t) {
	Transform.call(this, [], t);
}
TreeLinks.Definition = {
	type: "TreeLinks",
	metadata: {
		tree: !0,
		generates: !0,
		changes: !0
	},
	params: []
}, inherits(TreeLinks, Transform, { transform(t, n) {
	let r = this.value, i = n.source && n.source.root, o = n.fork(n.NO_SOURCE), s = {};
	return i || error$1("TreeLinks transform requires a tree data source."), n.changed(n.ADD_REM) ? (o.rem = r, n.visit(n.SOURCE, (t) => s[tupleid(t)] = 1), i.each((t) => {
		let n = t.data, r = t.parent && t.parent.data;
		r && s[tupleid(n)] && s[tupleid(r)] && o.add.push(ingest$1({
			source: r,
			target: n
		}));
	}), this.value = o.add) : n.changed(n.MOD) && (n.visit(n.MOD, (t) => s[tupleid(t)] = 1), r.forEach((t) => {
		(s[tupleid(t.source)] || s[tupleid(t.target)]) && o.mod.push(t);
	})), o;
} });
var Tiles = {
	binary: binary_default,
	dice: dice_default,
	slice: slice_default,
	slicedice: sliceDice_default,
	squarify: squarify_default,
	resquarify: resquarify_default
}, Output$4 = [
	"x0",
	"y0",
	"x1",
	"y1",
	"depth",
	"children"
];
function Treemap(t) {
	HierarchyLayout.call(this, t);
}
Treemap.Definition = {
	type: "Treemap",
	metadata: {
		tree: !0,
		modifies: !0
	},
	params: [
		{
			name: "field",
			type: "field"
		},
		{
			name: "sort",
			type: "compare"
		},
		{
			name: "method",
			type: "enum",
			default: "squarify",
			values: [
				"squarify",
				"resquarify",
				"binary",
				"dice",
				"slice",
				"slicedice"
			]
		},
		{
			name: "padding",
			type: "number",
			default: 0
		},
		{
			name: "paddingInner",
			type: "number",
			default: 0
		},
		{
			name: "paddingOuter",
			type: "number",
			default: 0
		},
		{
			name: "paddingTop",
			type: "number",
			default: 0
		},
		{
			name: "paddingRight",
			type: "number",
			default: 0
		},
		{
			name: "paddingBottom",
			type: "number",
			default: 0
		},
		{
			name: "paddingLeft",
			type: "number",
			default: 0
		},
		{
			name: "ratio",
			type: "number",
			default: 1.618033988749895
		},
		{
			name: "round",
			type: "boolean",
			default: !1
		},
		{
			name: "size",
			type: "number",
			array: !0,
			length: 2
		},
		{
			name: "as",
			type: "string",
			array: !0,
			length: Output$4.length,
			default: Output$4
		}
	]
}, inherits(Treemap, HierarchyLayout, {
	layout() {
		let t = treemap_default();
		return t.ratio = (n) => {
			let r = t.tile();
			r.ratio && t.tile(r.ratio(n));
		}, t.method = (n) => {
			has(Tiles, n) ? t.tile(Tiles[n]) : error$1("Unrecognized Treemap layout method: " + n);
		}, t;
	},
	params: [
		"method",
		"ratio",
		"size",
		"round",
		"padding",
		"paddingInner",
		"paddingOuter",
		"paddingTop",
		"paddingRight",
		"paddingBottom",
		"paddingLeft"
	],
	fields: Output$4
});
var vega_label_exports = /* @__PURE__ */ __export({ label: () => Label$1 }), ALPHA_MASK = 4278190080;
function baseBitmaps(t, n) {
	let r = t.bitmap();
	return (n || []).forEach((n) => r.set(t(n.boundary[0]), t(n.boundary[3]))), [r, void 0];
}
function markBitmaps(t, n, r, i, o) {
	let s = t.width, l = t.height, u = i || o, d = domCanvas(s, l).getContext("2d"), f = domCanvas(s, l).getContext("2d"), p = u && domCanvas(s, l).getContext("2d");
	r.forEach((t) => draw(d, t, !1)), draw(f, n, !1), u && draw(p, n, !0);
	let g = getBuffer(d, s, l), _ = getBuffer(f, s, l), v = u && getBuffer(p, s, l), S = t.bitmap(), T = u && t.bitmap(), E, O, k, A, j, N, P, F;
	for (O = 0; O < l; ++O) for (E = 0; E < s; ++E) j = O * s + E, N = g[j] & ALPHA_MASK, F = _[j] & ALPHA_MASK, P = u && v[j] & ALPHA_MASK, (N || P || F) && (k = t(E), A = t(O), !o && (N || F) && S.set(k, A), u && (N || P) && T.set(k, A));
	return [S, T];
}
function getBuffer(t, n, r) {
	return new Uint32Array(t.getImageData(0, 0, n, r).data.buffer);
}
function draw(t, n, r) {
	if (!n.length) return;
	let i = n[0].mark.marktype;
	i === "group" ? n.forEach((n) => {
		n.items.forEach((n) => draw(t, n.items, r));
	}) : Marks[i].draw(t, { items: r ? n.map(prepare) : n });
}
function prepare(t) {
	let n = rederive(t, {});
	return n.stroke && n.strokeOpacity !== 0 || n.fill && n.fillOpacity !== 0 ? {
		...n,
		strokeOpacity: 1,
		stroke: "#000",
		fillOpacity: 0
	} : n;
}
var DIV = 5, MOD = 31, SIZE$1 = 32, RIGHT0 = new Uint32Array(SIZE$1 + 1), RIGHT1 = new Uint32Array(SIZE$1 + 1);
RIGHT1[0] = 0, RIGHT0[0] = ~RIGHT1[0];
for (let t = 1; t <= SIZE$1; ++t) RIGHT1[t] = RIGHT1[t - 1] << 1 | 1, RIGHT0[t] = ~RIGHT1[t];
function Bitmap(t, n) {
	let r = new Uint32Array(~~((t * n + SIZE$1) / SIZE$1));
	function i(t, n) {
		r[t] |= n;
	}
	function o(t, n) {
		r[t] &= n;
	}
	return {
		array: r,
		get: (n, i) => {
			let o = i * t + n;
			return r[o >>> DIV] & 1 << (o & MOD);
		},
		set: (n, r) => {
			let o = r * t + n;
			i(o >>> DIV, 1 << (o & MOD));
		},
		clear: (n, r) => {
			let i = r * t + n;
			o(i >>> DIV, ~(1 << (i & MOD)));
		},
		getRange: (n, i, o, s) => {
			let l = s, u, d, f, p;
			for (; l >= i; --l) if (u = l * t + n, d = l * t + o, f = u >>> DIV, p = d >>> DIV, f === p) {
				if (r[f] & RIGHT0[u & MOD] & RIGHT1[(d & MOD) + 1]) return !0;
			} else {
				if (r[f] & RIGHT0[u & MOD] || r[p] & RIGHT1[(d & MOD) + 1]) return !0;
				for (let t = f + 1; t < p; ++t) if (r[t]) return !0;
			}
			return !1;
		},
		setRange: (n, r, o, s) => {
			let l, u, d, f, p;
			for (; r <= s; ++r) if (l = r * t + n, u = r * t + o, d = l >>> DIV, f = u >>> DIV, d === f) i(d, RIGHT0[l & MOD] & RIGHT1[(u & MOD) + 1]);
			else for (i(d, RIGHT0[l & MOD]), i(f, RIGHT1[(u & MOD) + 1]), p = d + 1; p < f; ++p) i(p, 4294967295);
		},
		clearRange: (n, r, i, s) => {
			let l, u, d, f, p;
			for (; r <= s; ++r) if (l = r * t + n, u = r * t + i, d = l >>> DIV, f = u >>> DIV, d === f) o(d, RIGHT1[l & MOD] | RIGHT0[(u & MOD) + 1]);
			else for (o(d, RIGHT1[l & MOD]), o(f, RIGHT0[(u & MOD) + 1]), p = d + 1; p < f; ++p) o(p, 0);
		},
		outOfBounds: (r, i, o, s) => r < 0 || i < 0 || s >= n || o >= t
	};
}
function scaler(t, n, r) {
	let i = Math.max(1, Math.sqrt(t * n / 1e6)), o = ~~((t + 2 * r + i) / i), s = ~~((n + 2 * r + i) / i), l = (t) => ~~((t + r) / i);
	return l.invert = (t) => t * i - r, l.bitmap = () => Bitmap(o, s), l.ratio = i, l.padding = r, l.width = t, l.height = n, l;
}
function placeAreaLabelNaive(t, n, r, i) {
	let o = t.width, s = t.height;
	return function(t) {
		let n = t.datum.datum.items[i].items, r = n.length, l = t.datum.fontSize, u = textMetrics.width(t.datum, t.datum.text), d = 0, f, p, g, _, v, S, T;
		for (let i = 0; i < r; ++i) f = n[i].x, g = n[i].y, p = n[i].x2 === void 0 ? f : n[i].x2, _ = n[i].y2 === void 0 ? g : n[i].y2, v = (f + p) / 2, S = (g + _) / 2, T = Math.abs(p - f + _ - g), T >= d && (d = T, t.x = v, t.y = S);
		return v = u / 2, S = l / 2, f = t.x - v, p = t.x + v, g = t.y - S, _ = t.y + S, t.align = "center", f < 0 && p <= o ? t.align = "left" : 0 <= f && o < p && (t.align = "right"), t.baseline = "middle", g < 0 && _ <= s ? t.baseline = "top" : 0 <= g && s < _ && (t.baseline = "bottom"), !0;
	};
}
function outOfBounds(t, n, r, i, o, s) {
	let l = r / 2;
	return t - l < 0 || t + l > o || n - (l = i / 2) < 0 || n + l > s;
}
function collision(t, n, r, i, o, s, l, u) {
	let d = o * s / (i * 2), f = t(n - d), p = t(n + d), g = t(r - (s /= 2)), _ = t(r + s);
	return l.outOfBounds(f, g, p, _) || l.getRange(f, g, p, _) || u && u.getRange(f, g, p, _);
}
function placeAreaLabelReducedSearch(t, n, r, i) {
	let o = t.width, s = t.height, l = n[0], u = n[1];
	function d(n, r, i, d, f) {
		let p = t.invert(n), g = t.invert(r), _ = i, v = s, S;
		if (!outOfBounds(p, g, d, f, o, s) && !collision(t, p, g, f, d, _, l, u) && !collision(t, p, g, f, d, f, l, null)) {
			for (; v - _ >= 1;) S = (_ + v) / 2, collision(t, p, g, f, d, S, l, u) ? v = S : _ = S;
			if (_ > i) return [
				p,
				g,
				_,
				!0
			];
		}
	}
	return function(n) {
		let u = n.datum.datum.items[i].items, f = u.length, p = n.datum.fontSize, g = textMetrics.width(n.datum, n.datum.text), _ = r ? p : 0, v = !1, S = !1, T = 0, E, O, k, A, j, N, P, F, I, L, R, z, V, H, U, W, G;
		for (let i = 0; i < f; ++i) {
			for (E = u[i].x, k = u[i].y, O = u[i].x2 === void 0 ? E : u[i].x2, A = u[i].y2 === void 0 ? k : u[i].y2, E > O && (G = E, E = O, O = G), k > A && (G = k, k = A, A = G), I = t(E), R = t(O), L = ~~((I + R) / 2), z = t(k), H = t(A), V = ~~((z + H) / 2), P = L; P >= I; --P) for (F = V; F >= z; --F) W = d(P, F, _, g, p), W && ([n.x, n.y, _, v] = W);
			for (P = L; P <= R; ++P) for (F = V; F <= H; ++F) W = d(P, F, _, g, p), W && ([n.x, n.y, _, v] = W);
			!v && !r && (U = Math.abs(O - E + A - k), j = (E + O) / 2, N = (k + A) / 2, U >= T && !outOfBounds(j, N, g, p, o, s) && !collision(t, j, N, p, g, p, l, null) && (T = U, n.x = j, n.y = N, S = !0));
		}
		return v || S ? (j = g / 2, N = p / 2, l.setRange(t(n.x - j), t(n.y - N), t(n.x + j), t(n.y + N)), n.align = "center", n.baseline = "middle", !0) : !1;
	};
}
var X_DIR = [
	-1,
	-1,
	1,
	1
], Y_DIR = [
	-1,
	1,
	-1,
	1
];
function placeAreaLabelFloodFill(t, n, r, i) {
	let o = t.width, s = t.height, l = n[0], u = n[1], d = t.bitmap();
	return function(n) {
		let f = n.datum.datum.items[i].items, p = f.length, g = n.datum.fontSize, _ = textMetrics.width(n.datum, n.datum.text), v = [], S = r ? g : 0, T = !1, E = !1, O = 0, k, A, j, N, P, F, I, L, R, z, V, H;
		for (let i = 0; i < p; ++i) {
			for (k = f[i].x, j = f[i].y, A = f[i].x2 === void 0 ? k : f[i].x2, N = f[i].y2 === void 0 ? j : f[i].y2, v.push([t((k + A) / 2), t((j + N) / 2)]); v.length;) if ([I, L] = v.pop(), !(l.get(I, L) || u.get(I, L) || d.get(I, L))) {
				d.set(I, L);
				for (let t = 0; t < 4; ++t) P = I + X_DIR[t], F = L + Y_DIR[t], d.outOfBounds(P, F, P, F) || v.push([P, F]);
				if (P = t.invert(I), F = t.invert(L), R = S, z = s, !outOfBounds(P, F, _, g, o, s) && !collision(t, P, F, g, _, R, l, u) && !collision(t, P, F, g, _, g, l, null)) {
					for (; z - R >= 1;) V = (R + z) / 2, collision(t, P, F, g, _, V, l, u) ? z = V : R = V;
					R > S && (n.x = P, n.y = F, S = R, T = !0);
				}
			}
			!T && !r && (H = Math.abs(A - k + N - j), P = (k + A) / 2, F = (j + N) / 2, H >= O && !outOfBounds(P, F, _, g, o, s) && !collision(t, P, F, g, _, g, l, null) && (O = H, n.x = P, n.y = F, E = !0));
		}
		return T || E ? (P = _ / 2, F = g / 2, l.setRange(t(n.x - P), t(n.y - F), t(n.x + P), t(n.y + F)), n.align = "center", n.baseline = "middle", !0) : !1;
	};
}
var Aligns = [
	"right",
	"center",
	"left"
], Baselines = [
	"bottom",
	"middle",
	"top"
];
function placeMarkLabel(t, n, r, i) {
	let o = t.width, s = t.height, l = n[0], u = n[1], d = i.length;
	return function(n) {
		let f = n.boundary, p = n.datum.fontSize;
		if (f[2] < 0 || f[5] < 0 || f[0] > o || f[3] > s) return !1;
		let g = n.textWidth ?? 0, _, v, S, T, E, O, k, A, j, N, P, F, I, L, R;
		for (let o = 0; o < d; ++o) {
			if (_ = (r[o] & 3) - 1, v = (r[o] >>> 2 & 3) - 1, S = _ === 0 && v === 0 || i[o] < 0, T = _ && v ? Math.SQRT1_2 : 1, E = i[o] < 0 ? -1 : 1, O = f[1 + _] + i[o] * _ * T, P = f[4 + v] + E * p * v / 2 + i[o] * v * T, A = P - p / 2, j = P + p / 2, F = t(O), L = t(A), R = t(j), !g) if (test(F, F, L, R, l, u, O, O, A, j, f, S)) g = textMetrics.width(n.datum, n.datum.text);
			else continue;
			if (N = O + E * g * _ / 2, O = N - g / 2, k = N + g / 2, F = t(O), I = t(k), test(F, I, L, R, l, u, O, k, A, j, f, S)) return n.x = _ ? _ * E < 0 ? k : O : N, n.y = v ? v * E < 0 ? j : A : P, n.align = Aligns[_ * E + 1], n.baseline = Baselines[v * E + 1], l.setRange(F, L, I, R), !0;
		}
		return !1;
	};
}
function test(t, n, r, i, o, s, l, u, d, f, p, g) {
	return !(o.outOfBounds(t, r, n, i) || (g && s || o).getRange(t, r, n, i));
}
var TOP = 0, MIDDLE = 4, BOTTOM = 8, LEFT = 0, CENTER$1 = 1, RIGHT = 2, anchorCode = {
	"top-left": TOP + LEFT,
	top: TOP + CENTER$1,
	"top-right": TOP + RIGHT,
	left: MIDDLE + LEFT,
	middle: MIDDLE + CENTER$1,
	right: MIDDLE + RIGHT,
	"bottom-left": BOTTOM + LEFT,
	bottom: BOTTOM + CENTER$1,
	"bottom-right": BOTTOM + RIGHT
}, placeAreaLabel = {
	naive: placeAreaLabelNaive,
	"reduced-search": placeAreaLabelReducedSearch,
	floodfill: placeAreaLabelFloodFill
};
function labelLayout(t, n, r, i, o, s, l, u, d, f, p) {
	if (!t.length) return t;
	let g = Math.max(i.length, o.length), _ = getOffsets(i, g), v = getAnchors(o, g), S = markType(t[0].datum), T = S === "group" && t[0].datum.items[d].marktype, E = T === "area", O = markBoundary(S, T, u, d), k = f === null || f === Infinity, A = E && p === "naive", j = -1, N = -1, P = t.map((t) => {
		let n = k ? textMetrics.width(t, t.text) : void 0;
		return j = Math.max(j, n), N = Math.max(N, t.fontSize), {
			datum: t,
			opacity: 0,
			x: void 0,
			y: void 0,
			align: void 0,
			baseline: void 0,
			boundary: O(t),
			textWidth: n
		};
	});
	f = f === null || f === Infinity ? Math.max(j, N) + Math.max(...i) : f;
	let F = scaler(n[0], n[1], f), I;
	if (!A) {
		r && P.sort((t, n) => r(t.datum, n.datum));
		let n = !1;
		for (let t = 0; t < v.length && !n; ++t) n = v[t] === 5 || _[t] < 0;
		let i = (S && l || E) && t.map((t) => t.datum);
		I = s.length || i ? markBitmaps(F, i || [], s, n, E) : baseBitmaps(F, l && P);
	}
	let L = E ? placeAreaLabel[p](F, I, l, d) : placeMarkLabel(F, I, v, _);
	return P.forEach((t) => t.opacity = +L(t)), P;
}
function getOffsets(t, n) {
	let r = new Float64Array(n), i = t.length;
	for (let n = 0; n < i; ++n) r[n] = t[n] || 0;
	for (let t = i; t < n; ++t) r[t] = r[i - 1];
	return r;
}
function getAnchors(t, n) {
	let r = new Int8Array(n), i = t.length;
	for (let n = 0; n < i; ++n) r[n] |= anchorCode[t[n]];
	for (let t = i; t < n; ++t) r[t] = r[i - 1];
	return r;
}
function markType(t) {
	return t && t.mark && t.mark.marktype;
}
function markBoundary(t, n, r, i) {
	let o = (t) => [
		t.x,
		t.x,
		t.x,
		t.y,
		t.y,
		t.y
	];
	return t ? t === "line" || t === "area" ? (t) => o(t.datum) : n === "line" ? (t) => {
		let n = t.datum.items[i].items;
		return o(n.length ? n[r === "start" ? 0 : n.length - 1] : {
			x: NaN,
			y: NaN
		});
	} : (t) => {
		let n = t.datum.bounds;
		return [
			n.x1,
			(n.x1 + n.x2) / 2,
			n.x2,
			n.y1,
			(n.y1 + n.y2) / 2,
			n.y2
		];
	} : o;
}
var Output$1 = [
	"x",
	"y",
	"opacity",
	"align",
	"baseline"
], Anchors = [
	"top-left",
	"left",
	"bottom-left",
	"top",
	"bottom",
	"top-right",
	"right",
	"bottom-right"
];
function Label$1(t) {
	Transform.call(this, null, t);
}
Label$1.Definition = {
	type: "Label",
	metadata: { modifies: !0 },
	params: [
		{
			name: "size",
			type: "number",
			array: !0,
			length: 2,
			required: !0
		},
		{
			name: "sort",
			type: "compare"
		},
		{
			name: "anchor",
			type: "string",
			array: !0,
			default: Anchors
		},
		{
			name: "offset",
			type: "number",
			array: !0,
			default: [1]
		},
		{
			name: "padding",
			type: "number",
			default: 0,
			null: !0
		},
		{
			name: "lineAnchor",
			type: "string",
			values: ["start", "end"],
			default: "end"
		},
		{
			name: "markIndex",
			type: "number",
			default: 0
		},
		{
			name: "avoidBaseMark",
			type: "boolean",
			default: !0
		},
		{
			name: "avoidMarks",
			type: "data",
			array: !0
		},
		{
			name: "method",
			type: "string",
			default: "naive"
		},
		{
			name: "as",
			type: "string",
			array: !0,
			length: Output$1.length,
			default: Output$1
		}
	]
}, inherits(Label$1, Transform, { transform(t, n) {
	function r(r) {
		let i = t[r];
		return isFunction(i) && n.modified(i.fields);
	}
	let i = t.modified();
	if (!(i || n.changed(n.ADD_REM) || r("sort"))) return;
	(!t.size || t.size.length !== 2) && error$1("Size parameter should be specified as a [width, height] array.");
	let o = t.as || Output$1;
	return labelLayout(n.materialize(n.SOURCE).source || [], t.size, t.sort, array(t.offset == null ? 1 : t.offset), array(t.anchor || Anchors), t.avoidMarks || [], t.avoidBaseMark !== !1, t.lineAnchor || "end", t.markIndex || 0, t.padding === void 0 ? 0 : t.padding, t.method || "naive").forEach((t) => {
		let n = t.datum;
		n[o[0]] = t.x, n[o[1]] = t.y, n[o[2]] = t.opacity, n[o[3]] = t.align, n[o[4]] = t.baseline;
	}), n.reflow(i).modifies(o);
} });
var vega_regression_exports = /* @__PURE__ */ __export({
	loess: () => Loess,
	regression: () => Regression
});
function partition(t, n) {
	var r = [], i = function(t) {
		return t(u);
	}, o, s, l, u, d, f;
	if (n == null) r.push(t);
	else for (o = {}, s = 0, l = t.length; s < l; ++s) u = t[s], d = n.map(i), f = o[d], f || (o[d] = f = [], f.dims = d, r.push(f)), f.push(u);
	return r;
}
function Loess(t) {
	Transform.call(this, null, t);
}
Loess.Definition = {
	type: "Loess",
	metadata: { generates: !0 },
	params: [
		{
			name: "x",
			type: "field",
			required: !0
		},
		{
			name: "y",
			type: "field",
			required: !0
		},
		{
			name: "groupby",
			type: "field",
			array: !0
		},
		{
			name: "bandwidth",
			type: "number",
			default: .3
		},
		{
			name: "as",
			type: "string",
			array: !0
		}
	]
}, inherits(Loess, Transform, { transform(t, n) {
	let r = n.fork(n.NO_SOURCE | n.NO_FIELDS);
	if (!this.value || n.changed() || t.modified()) {
		let i = n.materialize(n.SOURCE).source, o = partition(i, t.groupby), s = (t.groupby || []).map(accessorName), l = s.length, u = t.as || [accessorName(t.x), accessorName(t.y)], d = [];
		o.forEach((n) => {
			loess(n, t.x, t.y, t.bandwidth || .3).forEach((t) => {
				let r = {};
				for (let t = 0; t < l; ++t) r[s[t]] = n.dims[t];
				r[u[0]] = t[0], r[u[1]] = t[1], d.push(ingest$1(r));
			});
		}), this.value && (r.rem = this.value), this.value = r.add = r.source = d;
	}
	return r;
} });
var Methods = {
	constant: constant$1,
	linear,
	log: log$1,
	exp,
	pow,
	quad,
	poly
}, degreesOfFreedom = (t, n) => t === "poly" ? n : t === "quad" ? 2 : 1;
function Regression(t) {
	Transform.call(this, null, t);
}
Regression.Definition = {
	type: "Regression",
	metadata: { generates: !0 },
	params: [
		{
			name: "x",
			type: "field",
			required: !0
		},
		{
			name: "y",
			type: "field",
			required: !0
		},
		{
			name: "groupby",
			type: "field",
			array: !0
		},
		{
			name: "method",
			type: "string",
			default: "linear",
			values: Object.keys(Methods)
		},
		{
			name: "order",
			type: "number",
			default: 3
		},
		{
			name: "extent",
			type: "number",
			array: !0,
			length: 2
		},
		{
			name: "params",
			type: "boolean",
			default: !1
		},
		{
			name: "as",
			type: "string",
			array: !0
		}
	]
}, inherits(Regression, Transform, { transform(t, n) {
	let r = n.fork(n.NO_SOURCE | n.NO_FIELDS);
	if (!this.value || n.changed() || t.modified()) {
		let i = n.materialize(n.SOURCE).source, o = partition(i, t.groupby), s = (t.groupby || []).map(accessorName), l = t.method || "linear", u = t.order == null ? 3 : t.order, d = degreesOfFreedom(l, u), f = t.as || [accessorName(t.x), accessorName(t.y)], p = Methods[l], g = [], _ = t.extent;
		has(Methods, l) || error$1("Invalid regression method: " + l), _ != null && l === "log" && _[0] <= 0 && (n.dataflow.warn("Ignoring extent with values <= 0 for log regression."), _ = null), o.forEach((r) => {
			if (r.length <= d) {
				n.dataflow.warn("Skipping regression with more parameters than data points.");
				return;
			}
			let i = p(r, t.x, t.y, u);
			if (t.params) {
				g.push(ingest$1({
					keys: r.dims,
					coef: i.coef,
					rSquared: i.rSquared
				}));
				return;
			}
			let o = _ || extent(r, t.x), v = (t) => {
				let n = {};
				for (let t = 0; t < s.length; ++t) n[s[t]] = r.dims[t];
				n[f[0]] = t[0], n[f[1]] = t[1], g.push(ingest$1(n));
			};
			l === "linear" || l === "constant" ? o.forEach((t) => v([t, i.predict(t)])) : sampleCurve(i.predict, o, 25, 200).forEach(v);
		}), this.value && (r.rem = this.value), this.value = r.add = r.source = g;
	}
	return r;
} });
var vega_voronoi_exports = /* @__PURE__ */ __export({ voronoi: () => Voronoi });
function Voronoi(t) {
	Transform.call(this, null, t);
}
Voronoi.Definition = {
	type: "Voronoi",
	metadata: { modifies: !0 },
	params: [
		{
			name: "x",
			type: "field",
			required: !0
		},
		{
			name: "y",
			type: "field",
			required: !0
		},
		{
			name: "size",
			type: "number",
			array: !0,
			length: 2
		},
		{
			name: "extent",
			type: "array",
			array: !0,
			length: 2,
			default: [[-1e5, -1e5], [1e5, 1e5]],
			content: {
				type: "number",
				array: !0,
				length: 2
			}
		},
		{
			name: "as",
			type: "string",
			default: "path"
		}
	]
};
var defaultExtent = [
	-1e5,
	-1e5,
	1e5,
	1e5
];
inherits(Voronoi, Transform, { transform(t, n) {
	let r = t.as || "path", i = n.source;
	if (!i || !i.length) return n;
	let o = t.size;
	o = o ? [
		0,
		0,
		o[0],
		o[1]
	] : (o = t.extent) ? [
		o[0][0],
		o[0][1],
		o[1][0],
		o[1][1]
	] : defaultExtent;
	let s = this.value = Delaunay.from(i, t.x, t.y).voronoi(o);
	for (let t = 0, n = i.length; t < n; ++t) {
		let n = s.cellPolygon(t);
		i[t][r] = n && !isPoint(n) ? toPathString(n) : null;
	}
	return n.reflow(t.modified()).modifies(r);
} });
function toPathString(t) {
	let n = t[0][0], r = t[0][1], i = t.length - 1;
	for (; t[i][0] === n && t[i][1] === r; --i);
	return "M" + t.slice(0, i + 1).join("L") + "Z";
}
function isPoint(t) {
	return t.length === 2 && t[0][0] === t[1][0] && t[0][1] === t[1][1];
}
var vega_wordcloud_exports = /* @__PURE__ */ __export({ wordcloud: () => Wordcloud }), cloudRadians = Math.PI / 180, cw = 64, ch = 2048;
function cloud() {
	var t = [256, 256], n, r, i, o, s, l, u, d = archimedeanSpiral, f = [], p = Math.random, g = {};
	g.layout = function() {
		for (var d = _(domCanvas()), g = zeroArray((t[0] >> 5) * t[1]), S = null, T = f.length, E = -1, O = [], k = f.map((t) => ({
			text: n(t),
			font: r(t),
			style: o(t),
			weight: s(t),
			rotate: l(t),
			size: ~~(i(t) + 1e-14),
			padding: u(t),
			xoff: 0,
			yoff: 0,
			x1: 0,
			y1: 0,
			x0: 0,
			y0: 0,
			hasText: !1,
			sprite: null,
			datum: t
		})).sort((t, n) => n.size - t.size); ++E < T;) {
			var A = k[E];
			A.x = t[0] * (p() + .5) >> 1, A.y = t[1] * (p() + .5) >> 1, cloudSprite(d, A, k, E), A.hasText && v(g, A, S) && (O.push(A), S ? cloudBounds(S, A) : S = [{
				x: A.x + A.x0,
				y: A.y + A.y0
			}, {
				x: A.x + A.x1,
				y: A.y + A.y1
			}], A.x -= t[0] >> 1, A.y -= t[1] >> 1);
		}
		return O;
	};
	function _(t) {
		t.width = t.height = 1;
		var n = Math.sqrt(t.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
		t.width = (cw << 5) / n, t.height = ch / n;
		var r = t.getContext("2d");
		return r.fillStyle = r.strokeStyle = "red", r.textAlign = "center", {
			context: r,
			ratio: n
		};
	}
	function v(n, r, i) {
		for (var o = r.x, s = r.y, l = Math.hypot(t[0], t[1]), u = d(t), f = p() < .5 ? 1 : -1, g = -f, _, v, S; (_ = u(g += f)) && (v = ~~_[0], S = ~~_[1], !(Math.min(Math.abs(v), Math.abs(S)) >= l));) if (r.x = o + v, r.y = s + S, !(r.x + r.x0 < 0 || r.y + r.y0 < 0 || r.x + r.x1 > t[0] || r.y + r.y1 > t[1]) && (!i || !cloudCollide(r, n, t[0])) && (!i || collideRects(r, i))) {
			for (var T = r.sprite, E = r.width >> 5, O = t[0] >> 5, k = r.x - (E << 4), A = k & 127, j = 32 - A, N = r.y1 - r.y0, P = (r.y + r.y0) * O + (k >> 5), F, I = 0; I < N; I++) {
				F = 0;
				for (var L = 0; L <= E; L++) n[P + L] |= F << j | (L < E ? (F = T[I * E + L]) >>> A : 0);
				P += O;
			}
			return r.sprite = null, !0;
		}
		return !1;
	}
	return g.words = function(t) {
		return arguments.length ? (f = t, g) : f;
	}, g.size = function(n) {
		return arguments.length ? (t = [+n[0], +n[1]], g) : t;
	}, g.font = function(t) {
		return arguments.length ? (r = functor(t), g) : r;
	}, g.fontStyle = function(t) {
		return arguments.length ? (o = functor(t), g) : o;
	}, g.fontWeight = function(t) {
		return arguments.length ? (s = functor(t), g) : s;
	}, g.rotate = function(t) {
		return arguments.length ? (l = functor(t), g) : l;
	}, g.text = function(t) {
		return arguments.length ? (n = functor(t), g) : n;
	}, g.spiral = function(t) {
		return arguments.length ? (d = spirals[t] || t, g) : d;
	}, g.fontSize = function(t) {
		return arguments.length ? (i = functor(t), g) : i;
	}, g.padding = function(t) {
		return arguments.length ? (u = functor(t), g) : u;
	}, g.random = function(t) {
		return arguments.length ? (p = t, g) : p;
	}, g;
}
function cloudSprite(t, n, r, i) {
	if (!n.sprite) {
		var o = t.context, s = t.ratio;
		o.clearRect(0, 0, (cw << 5) / s, ch / s);
		var l = 0, u = 0, d = 0, f = r.length, p, g, _, v, S;
		for (--i; ++i < f;) {
			if (n = r[i], o.save(), o.font = n.style + " " + n.weight + " " + ~~((n.size + 1) / s) + "px " + n.font, p = o.measureText(n.text + "m").width * s, _ = n.size << 1, n.rotate) {
				var T = Math.sin(n.rotate * cloudRadians), E = Math.cos(n.rotate * cloudRadians), O = p * E, k = p * T, A = _ * E, j = _ * T;
				p = Math.max(Math.abs(O + j), Math.abs(O - j)) + 31 >> 5 << 5, _ = ~~Math.max(Math.abs(k + A), Math.abs(k - A));
			} else p = p + 31 >> 5 << 5;
			if (_ > d && (d = _), l + p >= cw << 5 && (l = 0, u += d, d = 0), u + _ >= ch) break;
			o.translate((l + (p >> 1)) / s, (u + (_ >> 1)) / s), n.rotate && o.rotate(n.rotate * cloudRadians), o.fillText(n.text, 0, 0), n.padding && (o.lineWidth = 2 * n.padding, o.strokeText(n.text, 0, 0)), o.restore(), n.width = p, n.height = _, n.xoff = l, n.yoff = u, n.x1 = p >> 1, n.y1 = _ >> 1, n.x0 = -n.x1, n.y0 = -n.y1, n.hasText = !0, l += p;
		}
		for (var N = o.getImageData(0, 0, (cw << 5) / s, ch / s).data, P = []; --i >= 0;) if (n = r[i], n.hasText) {
			for (p = n.width, g = p >> 5, _ = n.y1 - n.y0, v = 0; v < _ * g; v++) P[v] = 0;
			if (l = n.xoff, l == null) return;
			u = n.yoff;
			var F = 0, I = -1;
			for (S = 0; S < _; S++) {
				for (v = 0; v < p; v++) {
					var L = g * S + (v >> 5), R = N[(u + S) * (cw << 5) + (l + v) << 2] ? 1 << 31 - v % 32 : 0;
					P[L] |= R, F |= R;
				}
				F ? I = S : (n.y0++, _--, S--, u++);
			}
			n.y1 = n.y0 + I, n.sprite = P.slice(0, (n.y1 - n.y0) * g);
		}
	}
}
function cloudCollide(t, n, r) {
	r >>= 5;
	for (var i = t.sprite, o = t.width >> 5, s = t.x - (o << 4), l = s & 127, u = 32 - l, d = t.y1 - t.y0, f = (t.y + t.y0) * r + (s >> 5), p, g = 0; g < d; g++) {
		p = 0;
		for (var _ = 0; _ <= o; _++) if ((p << u | (_ < o ? (p = i[g * o + _]) >>> l : 0)) & n[f + _]) return !0;
		f += r;
	}
	return !1;
}
function cloudBounds(t, n) {
	var r = t[0], i = t[1];
	n.x + n.x0 < r.x && (r.x = n.x + n.x0), n.y + n.y0 < r.y && (r.y = n.y + n.y0), n.x + n.x1 > i.x && (i.x = n.x + n.x1), n.y + n.y1 > i.y && (i.y = n.y + n.y1);
}
function collideRects(t, n) {
	return t.x + t.x1 > n[0].x && t.x + t.x0 < n[1].x && t.y + t.y1 > n[0].y && t.y + t.y0 < n[1].y;
}
function archimedeanSpiral(t) {
	var n = t[0] / t[1];
	return function(t) {
		return [n * (t *= .1) * Math.cos(t), t * Math.sin(t)];
	};
}
function rectangularSpiral(t) {
	var n = 4, r = n * t[0] / t[1], i = 0, o = 0;
	return function(t) {
		var s = t < 0 ? -1 : 1;
		switch (Math.sqrt(1 + 4 * s * t) - s & 3) {
			case 0:
				i += r;
				break;
			case 1:
				o += n;
				break;
			case 2:
				i -= r;
				break;
			default:
				o -= n;
				break;
		}
		return [i, o];
	};
}
function zeroArray(t) {
	for (var n = [], r = -1; ++r < t;) n[r] = 0;
	return n;
}
function functor(t) {
	return typeof t == "function" ? t : function() {
		return t;
	};
}
var spirals = {
	archimedean: archimedeanSpiral,
	rectangular: rectangularSpiral
}, Output = [
	"x",
	"y",
	"font",
	"fontSize",
	"fontStyle",
	"fontWeight",
	"angle"
], Params$1 = [
	"text",
	"font",
	"rotate",
	"fontSize",
	"fontStyle",
	"fontWeight"
];
function Wordcloud(t) {
	Transform.call(this, cloud(), t);
}
Wordcloud.Definition = {
	type: "Wordcloud",
	metadata: { modifies: !0 },
	params: [
		{
			name: "size",
			type: "number",
			array: !0,
			length: 2
		},
		{
			name: "font",
			type: "string",
			expr: !0,
			default: "sans-serif"
		},
		{
			name: "fontStyle",
			type: "string",
			expr: !0,
			default: "normal"
		},
		{
			name: "fontWeight",
			type: "string",
			expr: !0,
			default: "normal"
		},
		{
			name: "fontSize",
			type: "number",
			expr: !0,
			default: 14
		},
		{
			name: "fontSizeRange",
			type: "number",
			array: "nullable",
			default: [10, 50]
		},
		{
			name: "rotate",
			type: "number",
			expr: !0,
			default: 0
		},
		{
			name: "text",
			type: "field"
		},
		{
			name: "spiral",
			type: "string",
			values: ["archimedean", "rectangular"]
		},
		{
			name: "padding",
			type: "number",
			expr: !0
		},
		{
			name: "as",
			type: "string",
			array: !0,
			length: 7,
			default: Output
		}
	]
}, inherits(Wordcloud, Transform, { transform(t, n) {
	t.size && !(t.size[0] && t.size[1]) && error$1("Wordcloud size dimensions must be non-zero.");
	function r(r) {
		let i = t[r];
		return isFunction(i) && n.modified(i.fields);
	}
	let i = t.modified();
	if (!(i || n.changed(n.ADD_REM) || Params$1.some(r))) return;
	let o = n.materialize(n.SOURCE).source, s = this.value, l = t.as || Output, u = t.fontSize || 14, d;
	if (isFunction(u) ? d = t.fontSizeRange : u = constant(u), d) {
		let t = u, n = scale("sqrt")().domain(extent(o, t)).range(d);
		u = (r) => n(t(r));
	}
	o.forEach((t) => {
		t[l[0]] = NaN, t[l[1]] = NaN, t[l[3]] = 0;
	});
	let f = s.words(o).text(t.text).size(t.size || [500, 500]).padding(t.padding || 1).spiral(t.spiral || "archimedean").rotate(t.rotate || 0).font(t.font || "sans-serif").fontStyle(t.fontStyle || "normal").fontWeight(t.fontWeight || "normal").fontSize(u).random(random).layout(), p = s.size(), g = p[0] >> 1, _ = p[1] >> 1, v = f.length;
	for (let t = 0, n, r; t < v; ++t) n = f[t], r = n.datum, r[l[0]] = n.x + g, r[l[1]] = n.y + _, r[l[2]] = n.font, r[l[3]] = n.size, r[l[4]] = n.style, r[l[5]] = n.weight, r[l[6]] = n.rotate;
	return n.reflow(i).modifies(l);
} });
var vega_crossfilter_exports = /* @__PURE__ */ __export({
	crossfilter: () => CrossFilter,
	resolvefilter: () => ResolveFilter
}), array8 = (t) => new Uint8Array(t), array16 = (t) => new Uint16Array(t), array32 = (t) => new Uint32Array(t);
function Bitmaps() {
	let t = 8, n = [], r = array32(0), i = array$2(0, t), o = array$2(0, t);
	return {
		data: () => n,
		seen: () => r = lengthen(r, n.length),
		add(t) {
			for (let r = 0, i = n.length, o = t.length, s; r < o; ++r) s = t[r], s._index = i++, n.push(s);
		},
		remove(t, r) {
			let s = n.length, l = Array(s - t), u = n, d, f, p;
			for (f = 0; !r[f] && f < s; ++f) l[f] = n[f], u[f] = f;
			for (p = f; f < s; ++f) d = n[f], r[f] ? u[f] = -1 : (u[f] = p, i[p] = i[f], o[p] = o[f], l[p] = d, d._index = p++), i[f] = 0;
			return n = l, u;
		},
		size: () => n.length,
		curr: () => i,
		prev: () => o,
		reset: (t) => o[t] = i[t],
		all: () => t < 257 ? 255 : t < 65537 ? 65535 : 4294967295,
		set(t, n) {
			i[t] |= n;
		},
		clear(t, n) {
			i[t] &= ~n;
		},
		resize(n, r) {
			(n > i.length || r > t) && (t = Math.max(r, t), i = array$2(n, t, i), o = array$2(n, t));
		}
	};
}
function lengthen(t, n, r) {
	return t.length >= n ? t : (r ||= new t.constructor(n), r.set(t), r);
}
function array$2(t, n, r) {
	let i = (n < 257 ? array8 : n < 65537 ? array16 : array32)(t);
	return r && i.set(r), i;
}
function Dimension(t, n, r) {
	let i = 1 << n;
	return {
		one: i,
		zero: ~i,
		range: r.slice(),
		bisect: t.bisect,
		index: t.index,
		size: t.size,
		onAdd(t, n) {
			let r = this, o = r.bisect(r.range, t.value), s = t.index, l = o[0], u = o[1], d = s.length, f;
			for (f = 0; f < l; ++f) n[s[f]] |= i;
			for (f = u; f < d; ++f) n[s[f]] |= i;
			return r;
		}
	};
}
function SortedIndex() {
	let t = array32(0), n = [], r = 0;
	function i(i, o, s) {
		if (!o.length) return [];
		let l = r, u = o.length, d = array32(u), f = Array(u), p, g, _;
		for (_ = 0; _ < u; ++_) f[_] = i(o[_]), d[_] = _;
		if (f = sort$1(f, d), l) p = n, g = t, n = Array(l + u), t = array32(l + u), merge$1(s, p, g, l, f, d, u, n, t);
		else {
			if (s > 0) for (_ = 0; _ < u; ++_) d[_] += s;
			n = f, t = d;
		}
		return r = l + u, {
			index: d,
			value: f
		};
	}
	function o(i, o) {
		let s = r, l, u, d;
		for (u = 0; !o[t[u]] && u < s; ++u);
		for (d = u; u < s; ++u) o[l = t[u]] || (t[d] = l, n[d] = n[u], ++d);
		r = s - i;
	}
	function s(n) {
		for (let i = 0, o = r; i < o; ++i) t[i] = n[t[i]];
	}
	function l(t, i) {
		let o;
		return i ? o = i.length : (i = n, o = r), [bisectLeft$1(i, t[0], 0, o), bisectRight$1(i, t[1], 0, o)];
	}
	return {
		insert: i,
		remove: o,
		bisect: l,
		reindex: s,
		index: () => t,
		size: () => r
	};
}
function sort$1(t, n) {
	return t.sort.call(n, (n, r) => {
		let i = t[n], o = t[r];
		return i < o ? -1 : i > o ? 1 : 0;
	}), permute(t, n);
}
function merge$1(t, n, r, i, o, s, l, u, d) {
	let f = 0, p = 0, g;
	for (g = 0; f < i && p < l; ++g) n[f] < o[p] ? (u[g] = n[f], d[g] = r[f++]) : (u[g] = o[p], d[g] = s[p++] + t);
	for (; f < i; ++f, ++g) u[g] = n[f], d[g] = r[f];
	for (; p < l; ++p, ++g) u[g] = o[p], d[g] = s[p] + t;
}
function CrossFilter(t) {
	Transform.call(this, Bitmaps(), t), this._indices = null, this._dims = null;
}
CrossFilter.Definition = {
	type: "CrossFilter",
	metadata: {},
	params: [{
		name: "fields",
		type: "field",
		array: !0,
		required: !0
	}, {
		name: "query",
		type: "array",
		array: !0,
		required: !0,
		content: {
			type: "number",
			array: !0,
			length: 2
		}
	}]
}, inherits(CrossFilter, Transform, {
	transform(t, n) {
		return this._dims ? t.modified("fields") || t.fields.some((t) => n.modified(t.fields)) ? this.reinit(t, n) : this.eval(t, n) : this.init(t, n);
	},
	init(t, n) {
		let r = t.fields, i = t.query, o = this._indices = {}, s = this._dims = [], l = i.length, u = 0, d, f;
		for (; u < l; ++u) d = r[u].fname, f = o[d] || (o[d] = SortedIndex()), s.push(Dimension(f, u, i[u]));
		return this.eval(t, n);
	},
	reinit(t, n) {
		let r = n.materialize().fork(), i = t.fields, o = t.query, s = this._indices, l = this._dims, u = this.value, d = u.curr(), f = u.prev(), p = u.all(), g = r.rem = r.add, _ = r.mod, v = o.length, S = {}, T, E, O, k, A, j, N, P, F;
		if (f.set(d), n.rem.length && (A = this.remove(t, n, r)), n.add.length && u.add(n.add), n.mod.length) for (j = {}, k = n.mod, N = 0, P = k.length; N < P; ++N) j[k[N]._index] = 1;
		for (N = 0; N < v; ++N) F = i[N], (!l[N] || t.modified("fields", N) || n.modified(F.fields)) && (O = F.fname, (T = S[O]) || (s[O] = E = SortedIndex(), S[O] = T = E.insert(F, n.source, 0)), l[N] = Dimension(E, N, o[N]).onAdd(T, d));
		for (N = 0, P = u.data().length; N < P; ++N) if (A[N]) continue;
		else f[N] === d[N] ? j[N] && d[N] !== p && _.push(N) : g.push(N);
		return u.mask = (1 << v) - 1, r;
	},
	eval(t, n) {
		let r = n.materialize().fork(), i = this._dims.length, o = 0;
		return n.rem.length && (this.remove(t, n, r), o |= (1 << i) - 1), t.modified("query") && !t.modified("fields") && (o |= this.update(t, n, r)), n.add.length && (this.insert(t, n, r), o |= (1 << i) - 1), n.mod.length && (this.modify(n, r), o |= (1 << i) - 1), this.value.mask = o, r;
	},
	insert(t, n, r) {
		let i = n.add, o = this.value, s = this._dims, l = this._indices, u = t.fields, d = {}, f = r.add, p = o.size() + i.length, g = s.length, _ = o.size(), v, S, T;
		o.resize(p, g), o.add(i);
		let E = o.curr(), O = o.prev(), k = o.all();
		for (v = 0; v < g; ++v) S = u[v].fname, T = d[S] || (d[S] = l[S].insert(u[v], i, _)), s[v].onAdd(T, E);
		for (; _ < p; ++_) O[_] = k, E[_] !== k && f.push(_);
	},
	modify(t, n) {
		let r = n.mod, i = this.value, o = i.curr(), s = i.all(), l = t.mod, u, d, f;
		for (u = 0, d = l.length; u < d; ++u) f = l[u]._index, o[f] !== s && r.push(f);
	},
	remove(t, n, r) {
		let i = this._indices, o = this.value, s = o.curr(), l = o.prev(), u = o.all(), d = {}, f = r.rem, p = n.rem, g, _, v, S;
		for (g = 0, _ = p.length; g < _; ++g) v = p[g]._index, d[v] = 1, l[v] = S = s[v], s[v] = u, S !== u && f.push(v);
		for (v in i) i[v].remove(_, d);
		return this.reindex(n, _, d), d;
	},
	reindex(t, n, r) {
		let i = this._indices, o = this.value;
		t.runAfter(() => {
			let t = o.remove(n, r);
			for (let n in i) i[n].reindex(t);
		});
	},
	update(t, n, r) {
		let i = this._dims, o = t.query, s = n.stamp, l = i.length, u = 0, d, f;
		for (r.filters = 0, f = 0; f < l; ++f) t.modified("query", f) && (d = f, ++u);
		if (u === 1) u = i[d].one, this.incrementOne(i[d], o[d], r.add, r.rem);
		else for (f = 0, u = 0; f < l; ++f) t.modified("query", f) && (u |= i[f].one, this.incrementAll(i[f], o[f], s, r.add), r.rem = r.add);
		return u;
	},
	incrementAll(t, n, r, i) {
		let o = this.value, s = o.seen(), l = o.curr(), u = o.prev(), d = t.index(), f = t.bisect(t.range), p = t.bisect(n), g = p[0], _ = p[1], v = f[0], S = f[1], T = t.one, E, O, k;
		if (g < v) for (E = g, O = Math.min(v, _); E < O; ++E) k = d[E], s[k] !== r && (u[k] = l[k], s[k] = r, i.push(k)), l[k] ^= T;
		else if (g > v) for (E = v, O = Math.min(g, S); E < O; ++E) k = d[E], s[k] !== r && (u[k] = l[k], s[k] = r, i.push(k)), l[k] ^= T;
		if (_ > S) for (E = Math.max(g, S), O = _; E < O; ++E) k = d[E], s[k] !== r && (u[k] = l[k], s[k] = r, i.push(k)), l[k] ^= T;
		else if (_ < S) for (E = Math.max(v, _), O = S; E < O; ++E) k = d[E], s[k] !== r && (u[k] = l[k], s[k] = r, i.push(k)), l[k] ^= T;
		t.range = n.slice();
	},
	incrementOne(t, n, r, i) {
		let o = this.value.curr(), s = t.index(), l = t.bisect(t.range), u = t.bisect(n), d = u[0], f = u[1], p = l[0], g = l[1], _ = t.one, v, S, T;
		if (d < p) for (v = d, S = Math.min(p, f); v < S; ++v) T = s[v], o[T] ^= _, r.push(T);
		else if (d > p) for (v = p, S = Math.min(d, g); v < S; ++v) T = s[v], o[T] ^= _, i.push(T);
		if (f > g) for (v = Math.max(d, g), S = f; v < S; ++v) T = s[v], o[T] ^= _, r.push(T);
		else if (f < g) for (v = Math.max(p, f), S = g; v < S; ++v) T = s[v], o[T] ^= _, i.push(T);
		t.range = n.slice();
	}
});
function ResolveFilter(t) {
	Transform.call(this, null, t);
}
ResolveFilter.Definition = {
	type: "ResolveFilter",
	metadata: {},
	params: [{
		name: "ignore",
		type: "number",
		required: !0,
		description: "A bit mask indicating which filters to ignore."
	}, {
		name: "filter",
		type: "object",
		required: !0,
		description: "Per-tuple filter bitmaps from a CrossFilter transform."
	}]
}, inherits(ResolveFilter, Transform, { transform(t, n) {
	let r = ~(t.ignore || 0), i = t.filter, o = i.mask;
	if ((o & r) === 0) return n.StopPropagation;
	let s = n.fork(n.ALL), l = i.data(), u = i.curr(), d = i.prev(), f = (t) => u[t] & r ? null : l[t];
	return s.filter(s.MOD, f), o & o - 1 ? (s.filter(s.ADD, (t) => {
		let n = u[t] & r;
		return !n && n ^ d[t] & r ? l[t] : null;
	}), s.filter(s.REM, (t) => {
		let n = u[t] & r;
		return n && !(n ^ (n ^ d[t] & r)) ? l[t] : null;
	})) : (s.filter(s.ADD, f), s.filter(s.REM, (t) => (u[t] & r) === o ? l[t] : null)), s.filter(s.SOURCE, (t) => f(t._index));
} });
var RawCode = "RawCode", Literal = "Literal", Property = "Property", Identifier = "Identifier", ArrayExpression = "ArrayExpression", BinaryExpression = "BinaryExpression", CallExpression = "CallExpression", ConditionalExpression = "ConditionalExpression", LogicalExpression = "LogicalExpression", MemberExpression = "MemberExpression", ObjectExpression = "ObjectExpression", UnaryExpression = "UnaryExpression";
function ASTNode(t) {
	this.type = t;
}
ASTNode.prototype.visit = function(t) {
	let n, r, i;
	if (t(this)) return 1;
	for (n = children(this), r = 0, i = n.length; r < i; ++r) if (n[r].visit(t)) return 1;
};
function children(t) {
	switch (t.type) {
		case ArrayExpression: return t.elements;
		case BinaryExpression:
		case LogicalExpression: return [t.left, t.right];
		case CallExpression: return [t.callee].concat(t.arguments);
		case ConditionalExpression: return [
			t.test,
			t.consequent,
			t.alternate
		];
		case MemberExpression: return [t.object, t.property];
		case ObjectExpression: return t.properties;
		case Property: return [t.key, t.value];
		case UnaryExpression: return [t.argument];
		case Identifier:
		case Literal:
		case RawCode:
		default: return [];
	}
}
var TokenName, source, index, length, lookahead, TokenBooleanLiteral = 1, TokenEOF = 2, TokenIdentifier = 3, TokenKeyword = 4, TokenNullLiteral = 5, TokenNumericLiteral = 6, TokenPunctuator = 7, TokenStringLiteral = 8, TokenRegularExpression = 9;
TokenName = {}, TokenName[TokenBooleanLiteral] = "Boolean", TokenName[TokenEOF] = "<end>", TokenName[TokenIdentifier] = "Identifier", TokenName[TokenKeyword] = "Keyword", TokenName[TokenNullLiteral] = "Null", TokenName[TokenNumericLiteral] = "Numeric", TokenName[TokenPunctuator] = "Punctuator", TokenName[TokenStringLiteral] = "String", TokenName[TokenRegularExpression] = "RegularExpression";
var SyntaxArrayExpression = "ArrayExpression", SyntaxBinaryExpression = "BinaryExpression", SyntaxCallExpression = "CallExpression", SyntaxConditionalExpression = "ConditionalExpression", SyntaxIdentifier = "Identifier", SyntaxLiteral = "Literal", SyntaxLogicalExpression = "LogicalExpression", SyntaxMemberExpression = "MemberExpression", SyntaxObjectExpression = "ObjectExpression", SyntaxProperty = "Property", SyntaxUnaryExpression = "UnaryExpression", MessageUnexpectedToken = "Unexpected token %0", MessageUnexpectedNumber = "Unexpected number", MessageUnexpectedString = "Unexpected string", MessageUnexpectedIdentifier = "Unexpected identifier", MessageUnexpectedReserved = "Unexpected reserved word", MessageUnexpectedEOS = "Unexpected end of input", MessageInvalidRegExp = "Invalid regular expression", MessageUnterminatedRegExp = "Invalid regular expression: missing /", MessageStrictOctalLiteral = "Octal literals are not allowed in strict mode.", MessageStrictDuplicateProperty = "Duplicate data property in object literal not allowed in strict mode", ILLEGAL$1 = "ILLEGAL", DISABLED = "Disabled.", RegexNonAsciiIdentifierStart = /* @__PURE__ */ RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"), RegexNonAsciiIdentifierPart = /* @__PURE__ */ RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function assert(t, n) {
	/* istanbul ignore next */
	if (!t) throw Error("ASSERT: " + n);
}
function isDecimalDigit(t) {
	return t >= 48 && t <= 57;
}
function isHexDigit(t) {
	return "0123456789abcdefABCDEF".includes(t);
}
function isOctalDigit(t) {
	return "01234567".includes(t);
}
function isWhiteSpace(t) {
	return t === 32 || t === 9 || t === 11 || t === 12 || t === 160 || t >= 5760 && [
		5760,
		6158,
		8192,
		8193,
		8194,
		8195,
		8196,
		8197,
		8198,
		8199,
		8200,
		8201,
		8202,
		8239,
		8287,
		12288,
		65279
	].includes(t);
}
function isLineTerminator(t) {
	return t === 10 || t === 13 || t === 8232 || t === 8233;
}
function isIdentifierStart(t) {
	return t === 36 || t === 95 || t >= 65 && t <= 90 || t >= 97 && t <= 122 || t === 92 || t >= 128 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(t));
}
function isIdentifierPart(t) {
	return t === 36 || t === 95 || t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 48 && t <= 57 || t === 92 || t >= 128 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(t));
}
var keywords = {
	if: 1,
	in: 1,
	do: 1,
	var: 1,
	for: 1,
	new: 1,
	try: 1,
	let: 1,
	this: 1,
	else: 1,
	case: 1,
	void: 1,
	with: 1,
	enum: 1,
	while: 1,
	break: 1,
	catch: 1,
	throw: 1,
	const: 1,
	yield: 1,
	class: 1,
	super: 1,
	return: 1,
	typeof: 1,
	delete: 1,
	switch: 1,
	export: 1,
	import: 1,
	public: 1,
	static: 1,
	default: 1,
	finally: 1,
	extends: 1,
	package: 1,
	private: 1,
	function: 1,
	continue: 1,
	debugger: 1,
	interface: 1,
	protected: 1,
	instanceof: 1,
	implements: 1
};
function skipComment() {
	for (; index < length;) {
		let t = source.charCodeAt(index);
		if (isWhiteSpace(t) || isLineTerminator(t)) ++index;
		else break;
	}
}
function scanHexEscape(t) {
	var n, r, i, o = 0;
	for (r = t === "u" ? 4 : 2, n = 0; n < r; ++n) index < length && isHexDigit(source[index]) ? (i = source[index++], o = o * 16 + "0123456789abcdef".indexOf(i.toLowerCase())) : throwError({}, MessageUnexpectedToken, ILLEGAL$1);
	return String.fromCharCode(o);
}
function scanUnicodeCodePointEscape() {
	var t = source[index], n = 0, r, i;
	for (t === "}" && throwError({}, MessageUnexpectedToken, ILLEGAL$1); index < length && (t = source[index++], isHexDigit(t));) n = n * 16 + "0123456789abcdef".indexOf(t.toLowerCase());
	return (n > 1114111 || t !== "}") && throwError({}, MessageUnexpectedToken, ILLEGAL$1), n <= 65535 ? String.fromCharCode(n) : (r = (n - 65536 >> 10) + 55296, i = (n - 65536 & 1023) + 56320, String.fromCharCode(r, i));
}
function getEscapedIdentifier() {
	var t = source.charCodeAt(index++), n = String.fromCharCode(t);
	for (t === 92 && (source.charCodeAt(index) !== 117 && throwError({}, MessageUnexpectedToken, ILLEGAL$1), ++index, t = scanHexEscape("u"), (!t || t === "\\" || !isIdentifierStart(t.charCodeAt(0))) && throwError({}, MessageUnexpectedToken, ILLEGAL$1), n = t); index < length && (t = source.charCodeAt(index), isIdentifierPart(t));) ++index, n += String.fromCharCode(t), t === 92 && (n = n.substr(0, n.length - 1), source.charCodeAt(index) !== 117 && throwError({}, MessageUnexpectedToken, ILLEGAL$1), ++index, t = scanHexEscape("u"), (!t || t === "\\" || !isIdentifierPart(t.charCodeAt(0))) && throwError({}, MessageUnexpectedToken, ILLEGAL$1), n += t);
	return n;
}
function getIdentifier() {
	for (var t = index++, n; index < length;) {
		if (n = source.charCodeAt(index), n === 92) return index = t, getEscapedIdentifier();
		if (isIdentifierPart(n)) ++index;
		else break;
	}
	return source.slice(t, index);
}
function scanIdentifier() {
	var t = index, n = source.charCodeAt(index) === 92 ? getEscapedIdentifier() : getIdentifier();
	return {
		type: n.length === 1 ? TokenIdentifier : keywords.hasOwnProperty(n) ? TokenKeyword : n === "null" ? TokenNullLiteral : n === "true" || n === "false" ? TokenBooleanLiteral : TokenIdentifier,
		value: n,
		start: t,
		end: index
	};
}
function scanPunctuator() {
	var t = index, n = source.charCodeAt(index), r, i = source[index], o, s, l;
	switch (n) {
		case 46:
		case 40:
		case 41:
		case 59:
		case 44:
		case 123:
		case 125:
		case 91:
		case 93:
		case 58:
		case 63:
		case 126: return ++index, {
			type: TokenPunctuator,
			value: String.fromCharCode(n),
			start: t,
			end: index
		};
		default: if (r = source.charCodeAt(index + 1), r === 61) switch (n) {
			case 43:
			case 45:
			case 47:
			case 60:
			case 62:
			case 94:
			case 124:
			case 37:
			case 38:
			case 42: return index += 2, {
				type: TokenPunctuator,
				value: String.fromCharCode(n) + String.fromCharCode(r),
				start: t,
				end: index
			};
			case 33:
			case 61: return index += 2, source.charCodeAt(index) === 61 && ++index, {
				type: TokenPunctuator,
				value: source.slice(t, index),
				start: t,
				end: index
			};
		}
	}
	if (l = source.substr(index, 4), l === ">>>=") return index += 4, {
		type: TokenPunctuator,
		value: l,
		start: t,
		end: index
	};
	if (s = l.substr(0, 3), s === ">>>" || s === "<<=" || s === ">>=") return index += 3, {
		type: TokenPunctuator,
		value: s,
		start: t,
		end: index
	};
	if (o = s.substr(0, 2), i === o[1] && "+-<>&|".includes(i) || o === "=>") return index += 2, {
		type: TokenPunctuator,
		value: o,
		start: t,
		end: index
	};
	if (o === "//" && throwError({}, MessageUnexpectedToken, ILLEGAL$1), "<>=!+-*%&|^/".includes(i)) return ++index, {
		type: TokenPunctuator,
		value: i,
		start: t,
		end: index
	};
	throwError({}, MessageUnexpectedToken, ILLEGAL$1);
}
function scanHexLiteral(t) {
	let n = "";
	for (; index < length && isHexDigit(source[index]);) n += source[index++];
	return n.length === 0 && throwError({}, MessageUnexpectedToken, ILLEGAL$1), isIdentifierStart(source.charCodeAt(index)) && throwError({}, MessageUnexpectedToken, ILLEGAL$1), {
		type: TokenNumericLiteral,
		value: parseInt("0x" + n, 16),
		start: t,
		end: index
	};
}
function scanOctalLiteral(t) {
	let n = "0" + source[index++];
	for (; index < length && isOctalDigit(source[index]);) n += source[index++];
	return (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) && throwError({}, MessageUnexpectedToken, ILLEGAL$1), {
		type: TokenNumericLiteral,
		value: parseInt(n, 8),
		octal: !0,
		start: t,
		end: index
	};
}
function scanNumericLiteral() {
	var t, n, r = source[index];
	if (assert(isDecimalDigit(r.charCodeAt(0)) || r === ".", "Numeric literal must start with a decimal digit or a decimal point"), n = index, t = "", r !== ".") {
		if (t = source[index++], r = source[index], t === "0") {
			if (r === "x" || r === "X") return ++index, scanHexLiteral(n);
			if (isOctalDigit(r)) return scanOctalLiteral(n);
			r && isDecimalDigit(r.charCodeAt(0)) && throwError({}, MessageUnexpectedToken, ILLEGAL$1);
		}
		for (; isDecimalDigit(source.charCodeAt(index));) t += source[index++];
		r = source[index];
	}
	if (r === ".") {
		for (t += source[index++]; isDecimalDigit(source.charCodeAt(index));) t += source[index++];
		r = source[index];
	}
	if (r === "e" || r === "E") if (t += source[index++], r = source[index], (r === "+" || r === "-") && (t += source[index++]), isDecimalDigit(source.charCodeAt(index))) for (; isDecimalDigit(source.charCodeAt(index));) t += source[index++];
	else throwError({}, MessageUnexpectedToken, ILLEGAL$1);
	return isIdentifierStart(source.charCodeAt(index)) && throwError({}, MessageUnexpectedToken, ILLEGAL$1), {
		type: TokenNumericLiteral,
		value: parseFloat(t),
		start: n,
		end: index
	};
}
function scanStringLiteral() {
	var t = "", n, r, i, o, s = !1;
	for (n = source[index], assert(n === "'" || n === "\"", "String literal must starts with a quote"), r = index, ++index; index < length;) if (i = source[index++], i === n) {
		n = "";
		break;
	} else if (i === "\\") if (i = source[index++], !i || !isLineTerminator(i.charCodeAt(0))) switch (i) {
		case "u":
		case "x":
			source[index] === "{" ? (++index, t += scanUnicodeCodePointEscape()) : t += scanHexEscape(i);
			break;
		case "n":
			t += "\n";
			break;
		case "r":
			t += "\r";
			break;
		case "t":
			t += "	";
			break;
		case "b":
			t += "\b";
			break;
		case "f":
			t += "\f";
			break;
		case "v":
			t += "\v";
			break;
		default:
			isOctalDigit(i) ? (o = "01234567".indexOf(i), o !== 0 && (s = !0), index < length && isOctalDigit(source[index]) && (s = !0, o = o * 8 + "01234567".indexOf(source[index++]), "0123".includes(i) && index < length && isOctalDigit(source[index]) && (o = o * 8 + "01234567".indexOf(source[index++]))), t += String.fromCharCode(o)) : t += i;
			break;
	}
	else i === "\r" && source[index] === "\n" && ++index;
	else if (isLineTerminator(i.charCodeAt(0))) break;
	else t += i;
	return n !== "" && throwError({}, MessageUnexpectedToken, ILLEGAL$1), {
		type: TokenStringLiteral,
		value: t,
		octal: s,
		start: r,
		end: index
	};
}
function testRegExp(t, n) {
	let r = t;
	n.includes("u") && (r = r.replace(/\\u\{([0-9a-fA-F]+)\}/g, (t, n) => {
		if (parseInt(n, 16) <= 1114111) return "x";
		throwError({}, MessageInvalidRegExp);
	}).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x"));
	try {
		new RegExp(r);
	} catch {
		throwError({}, MessageInvalidRegExp);
	}
	try {
		return new RegExp(t, n);
	} catch {
		return null;
	}
}
function scanRegExpBody() {
	var t = source[index], n, r, i, o;
	for (assert(t === "/", "Regular expression literal must start with a slash"), n = source[index++], r = !1, i = !1; index < length;) if (t = source[index++], n += t, t === "\\") t = source[index++], isLineTerminator(t.charCodeAt(0)) && throwError({}, MessageUnterminatedRegExp), n += t;
	else if (isLineTerminator(t.charCodeAt(0))) throwError({}, MessageUnterminatedRegExp);
	else if (r) t === "]" && (r = !1);
	else if (t === "/") {
		i = !0;
		break;
	} else t === "[" && (r = !0);
	return i || throwError({}, MessageUnterminatedRegExp), o = n.substr(1, n.length - 2), {
		value: o,
		literal: n
	};
}
function scanRegExpFlags() {
	for (var t, n = "", r = ""; index < length && (t = source[index], isIdentifierPart(t.charCodeAt(0)));) ++index, t === "\\" && index < length ? throwError({}, MessageUnexpectedToken, ILLEGAL$1) : (r += t, n += t);
	return r.search(/[^gimuy]/g) >= 0 && throwError({}, MessageInvalidRegExp, r), {
		value: r,
		literal: n
	};
}
function scanRegExp() {
	var t, n, r, i;
	return lookahead = null, skipComment(), t = index, n = scanRegExpBody(), r = scanRegExpFlags(), i = testRegExp(n.value, r.value), {
		literal: n.literal + r.literal,
		value: i,
		regex: {
			pattern: n.value,
			flags: r.value
		},
		start: t,
		end: index
	};
}
function isIdentifierName(t) {
	return t.type === TokenIdentifier || t.type === TokenKeyword || t.type === TokenBooleanLiteral || t.type === TokenNullLiteral;
}
function advance() {
	if (skipComment(), index >= length) return {
		type: TokenEOF,
		start: index,
		end: index
	};
	let t = source.charCodeAt(index);
	return isIdentifierStart(t) ? scanIdentifier() : t === 40 || t === 41 || t === 59 ? scanPunctuator() : t === 39 || t === 34 ? scanStringLiteral() : t === 46 ? isDecimalDigit(source.charCodeAt(index + 1)) ? scanNumericLiteral() : scanPunctuator() : isDecimalDigit(t) ? scanNumericLiteral() : scanPunctuator();
}
function lex() {
	let t = lookahead;
	return index = t.end, lookahead = advance(), index = t.end, t;
}
function peek$1() {
	let t = index;
	lookahead = advance(), index = t;
}
function finishArrayExpression(t) {
	let n = new ASTNode(SyntaxArrayExpression);
	return n.elements = t, n;
}
function finishBinaryExpression(t, n, r) {
	let i = new ASTNode(t === "||" || t === "&&" ? SyntaxLogicalExpression : SyntaxBinaryExpression);
	return i.operator = t, i.left = n, i.right = r, i;
}
function finishCallExpression(t, n) {
	let r = new ASTNode(SyntaxCallExpression);
	return r.callee = t, r.arguments = n, r;
}
function finishConditionalExpression(t, n, r) {
	let i = new ASTNode(SyntaxConditionalExpression);
	return i.test = t, i.consequent = n, i.alternate = r, i;
}
function finishIdentifier(t) {
	let n = new ASTNode(SyntaxIdentifier);
	return n.name = t, n;
}
function finishLiteral(t) {
	let n = new ASTNode(SyntaxLiteral);
	return n.value = t.value, n.raw = source.slice(t.start, t.end), t.regex && (n.raw === "//" && (n.raw = "/(?:)/"), n.regex = t.regex), n;
}
function finishMemberExpression(t, n, r) {
	let i = new ASTNode(SyntaxMemberExpression);
	return i.computed = t === "[", i.object = n, i.property = r, i.computed || (r.member = !0), i;
}
function finishObjectExpression(t) {
	let n = new ASTNode(SyntaxObjectExpression);
	return n.properties = t, n;
}
function finishProperty(t, n, r) {
	let i = new ASTNode(SyntaxProperty);
	return i.key = n, i.value = r, i.kind = t, i;
}
function finishUnaryExpression(t, n) {
	let r = new ASTNode(SyntaxUnaryExpression);
	return r.operator = t, r.argument = n, r.prefix = !0, r;
}
function throwError(t, n) {
	var r, i = Array.prototype.slice.call(arguments, 2), o = n.replace(/%(\d)/g, (t, n) => (assert(n < i.length, "Message reference must be in range"), i[n]));
	throw r = Error(o), r.index = index, r.description = o, r;
}
function throwUnexpected(t) {
	t.type === TokenEOF && throwError(t, MessageUnexpectedEOS), t.type === TokenNumericLiteral && throwError(t, MessageUnexpectedNumber), t.type === TokenStringLiteral && throwError(t, MessageUnexpectedString), t.type === TokenIdentifier && throwError(t, MessageUnexpectedIdentifier), t.type === TokenKeyword && throwError(t, MessageUnexpectedReserved), throwError(t, MessageUnexpectedToken, t.value);
}
function expect(t) {
	let n = lex();
	(n.type !== TokenPunctuator || n.value !== t) && throwUnexpected(n);
}
function match(t) {
	return lookahead.type === TokenPunctuator && lookahead.value === t;
}
function matchKeyword(t) {
	return lookahead.type === TokenKeyword && lookahead.value === t;
}
function parseArrayInitialiser() {
	let t = [];
	for (index = lookahead.start, expect("["); !match("]");) match(",") ? (lex(), t.push(null)) : (t.push(parseConditionalExpression()), match("]") || expect(","));
	return lex(), finishArrayExpression(t);
}
function parseObjectPropertyKey() {
	index = lookahead.start;
	let t = lex();
	return t.type === TokenStringLiteral || t.type === TokenNumericLiteral ? (t.octal && throwError(t, MessageStrictOctalLiteral), finishLiteral(t)) : finishIdentifier(t.value);
}
function parseObjectProperty() {
	var t, n, r, i;
	if (index = lookahead.start, t = lookahead, t.type === TokenIdentifier) return r = parseObjectPropertyKey(), expect(":"), i = parseConditionalExpression(), finishProperty("init", r, i);
	if (t.type === TokenEOF || t.type === TokenPunctuator) throwUnexpected(t);
	else return n = parseObjectPropertyKey(), expect(":"), i = parseConditionalExpression(), finishProperty("init", n, i);
}
function parseObjectInitialiser() {
	var t = [], n, r, i, o = {}, s = String;
	for (index = lookahead.start, expect("{"); !match("}");) n = parseObjectProperty(), r = n.key.type === SyntaxIdentifier ? n.key.name : s(n.key.value), i = "$" + r, Object.prototype.hasOwnProperty.call(o, i) ? throwError({}, MessageStrictDuplicateProperty) : o[i] = !0, t.push(n), match("}") || expect(",");
	return expect("}"), finishObjectExpression(t);
}
function parseGroupExpression() {
	expect("(");
	let t = parseExpression$1();
	return expect(")"), t;
}
var legalKeywords = { if: 1 };
function parsePrimaryExpression() {
	var t, n, r;
	if (match("(")) return parseGroupExpression();
	if (match("[")) return parseArrayInitialiser();
	if (match("{")) return parseObjectInitialiser();
	if (t = lookahead.type, index = lookahead.start, t === TokenIdentifier || legalKeywords[lookahead.value]) r = finishIdentifier(lex().value);
	else if (t === TokenStringLiteral || t === TokenNumericLiteral) lookahead.octal && throwError(lookahead, MessageStrictOctalLiteral), r = finishLiteral(lex());
	else if (t === TokenKeyword) throw Error(DISABLED);
	else t === TokenBooleanLiteral ? (n = lex(), n.value = n.value === "true", r = finishLiteral(n)) : t === TokenNullLiteral ? (n = lex(), n.value = null, r = finishLiteral(n)) : match("/") || match("/=") ? (r = finishLiteral(scanRegExp()), peek$1()) : throwUnexpected(lex());
	return r;
}
function parseArguments() {
	let t = [];
	if (expect("("), !match(")")) for (; index < length && (t.push(parseConditionalExpression()), !match(")"));) expect(",");
	return expect(")"), t;
}
function parseNonComputedProperty() {
	index = lookahead.start;
	let t = lex();
	return isIdentifierName(t) || throwUnexpected(t), finishIdentifier(t.value);
}
function parseNonComputedMember() {
	return expect("."), parseNonComputedProperty();
}
function parseComputedMember() {
	expect("[");
	let t = parseExpression$1();
	return expect("]"), t;
}
function parseLeftHandSideExpressionAllowCall() {
	for (var t = parsePrimaryExpression(), n, r;;) if (match(".")) r = parseNonComputedMember(), t = finishMemberExpression(".", t, r);
	else if (match("(")) n = parseArguments(), t = finishCallExpression(t, n);
	else if (match("[")) r = parseComputedMember(), t = finishMemberExpression("[", t, r);
	else break;
	return t;
}
function parsePostfixExpression() {
	let t = parseLeftHandSideExpressionAllowCall();
	if (lookahead.type === TokenPunctuator && (match("++") || match("--"))) throw Error(DISABLED);
	return t;
}
function parseUnaryExpression() {
	var t, n;
	if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) n = parsePostfixExpression();
	else if (match("++") || match("--")) throw Error(DISABLED);
	else if (match("+") || match("-") || match("~") || match("!")) t = lex(), n = parseUnaryExpression(), n = finishUnaryExpression(t.value, n);
	else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) throw Error(DISABLED);
	else n = parsePostfixExpression();
	return n;
}
function binaryPrecedence(t) {
	let n = 0;
	if (t.type !== TokenPunctuator && t.type !== TokenKeyword) return 0;
	switch (t.value) {
		case "||":
			n = 1;
			break;
		case "&&":
			n = 2;
			break;
		case "|":
			n = 3;
			break;
		case "^":
			n = 4;
			break;
		case "&":
			n = 5;
			break;
		case "==":
		case "!=":
		case "===":
		case "!==":
			n = 6;
			break;
		case "<":
		case ">":
		case "<=":
		case ">=":
		case "instanceof":
		case "in":
			n = 7;
			break;
		case "<<":
		case ">>":
		case ">>>":
			n = 8;
			break;
		case "+":
		case "-":
			n = 9;
			break;
		case "*":
		case "/":
		case "%":
			n = 11;
			break;
	}
	return n;
}
function parseBinaryExpression() {
	var t = lookahead, n, r, i, o, s, l, u, d = parseUnaryExpression(), f;
	if (i = lookahead, o = binaryPrecedence(i), o === 0) return d;
	for (i.prec = o, lex(), n = [t, lookahead], l = parseUnaryExpression(), s = [
		d,
		i,
		l
	]; (o = binaryPrecedence(lookahead)) > 0;) {
		for (; s.length > 2 && o <= s[s.length - 2].prec;) l = s.pop(), u = s.pop().value, d = s.pop(), n.pop(), r = finishBinaryExpression(u, d, l), s.push(r);
		i = lex(), i.prec = o, s.push(i), n.push(lookahead), r = parseUnaryExpression(), s.push(r);
	}
	for (f = s.length - 1, r = s[f], n.pop(); f > 1;) n.pop(), r = finishBinaryExpression(s[f - 1].value, s[f - 2], r), f -= 2;
	return r;
}
function parseConditionalExpression() {
	var t = parseBinaryExpression(), n, r;
	return match("?") && (lex(), n = parseConditionalExpression(), expect(":"), r = parseConditionalExpression(), t = finishConditionalExpression(t, n, r)), t;
}
function parseExpression$1() {
	let t = parseConditionalExpression();
	if (match(",")) throw Error(DISABLED);
	return t;
}
function parser(t) {
	source = t, index = 0, length = source.length, lookahead = null, peek$1();
	let n = parseExpression$1();
	if (lookahead.type !== TokenEOF) throw Error("Unexpect token after expression.");
	return n;
}
var Constants$1 = {
	NaN: "NaN",
	E: "Math.E",
	LN2: "Math.LN2",
	LN10: "Math.LN10",
	LOG2E: "Math.LOG2E",
	LOG10E: "Math.LOG10E",
	PI: "Math.PI",
	SQRT1_2: "Math.SQRT1_2",
	SQRT2: "Math.SQRT2",
	MIN_VALUE: "Number.MIN_VALUE",
	MAX_VALUE: "Number.MAX_VALUE"
};
function Functions$1(t) {
	function n(n, r, i, o) {
		let s = t(r[0]);
		return i && (s = i + "(" + s + ")", i.lastIndexOf("new ", 0) === 0 && (s = "(" + s + ")")), s + "." + n + (o < 0 ? "" : o === 0 ? "()" : "(" + r.slice(1).map(t).join(",") + ")");
	}
	function r(t, r, i) {
		return (o) => n(t, o, r, i);
	}
	let i = "new Date", o = "String", s = "RegExp";
	return {
		isNaN: "Number.isNaN",
		isFinite: "Number.isFinite",
		abs: "Math.abs",
		acos: "Math.acos",
		asin: "Math.asin",
		atan: "Math.atan",
		atan2: "Math.atan2",
		ceil: "Math.ceil",
		cos: "Math.cos",
		exp: "Math.exp",
		floor: "Math.floor",
		hypot: "Math.hypot",
		log: "Math.log",
		max: "Math.max",
		min: "Math.min",
		pow: "Math.pow",
		random: "Math.random",
		round: "Math.round",
		sin: "Math.sin",
		sqrt: "Math.sqrt",
		tan: "Math.tan",
		clamp: function(n) {
			n.length < 3 && error$1("Missing arguments to clamp function."), n.length > 3 && error$1("Too many arguments to clamp function.");
			let r = n.map(t);
			return "Math.max(" + r[1] + ", Math.min(" + r[2] + "," + r[0] + "))";
		},
		now: "Date.now",
		utc: "Date.UTC",
		datetime: i,
		date: r("getDate", i, 0),
		day: r("getDay", i, 0),
		year: r("getFullYear", i, 0),
		month: r("getMonth", i, 0),
		hours: r("getHours", i, 0),
		minutes: r("getMinutes", i, 0),
		seconds: r("getSeconds", i, 0),
		milliseconds: r("getMilliseconds", i, 0),
		time: r("getTime", i, 0),
		timezoneoffset: r("getTimezoneOffset", i, 0),
		utcdate: r("getUTCDate", i, 0),
		utcday: r("getUTCDay", i, 0),
		utcyear: r("getUTCFullYear", i, 0),
		utcmonth: r("getUTCMonth", i, 0),
		utchours: r("getUTCHours", i, 0),
		utcminutes: r("getUTCMinutes", i, 0),
		utcseconds: r("getUTCSeconds", i, 0),
		utcmilliseconds: r("getUTCMilliseconds", i, 0),
		length: r("length", null, -1),
		parseFloat: "parseFloat",
		parseInt: "parseInt",
		upper: r("toUpperCase", o, 0),
		lower: r("toLowerCase", o, 0),
		substring: r("substring", o),
		split: r("split", o),
		trim: r("trim", o, 0),
		btoa: "btoa",
		atob: "atob",
		regexp: s,
		test: r("test", s),
		if: function(n) {
			n.length < 3 && error$1("Missing arguments to if function."), n.length > 3 && error$1("Too many arguments to if function.");
			let r = n.map(t);
			return "(" + r[0] + "?" + r[1] + ":" + r[2] + ")";
		}
	};
}
function stripQuotes(t) {
	let n = t && t.length - 1;
	return n && (t[0] === "\"" && t[n] === "\"" || t[0] === "'" && t[n] === "'") ? t.slice(1, -1) : t;
}
function codegen(t) {
	t ||= {};
	let n = t.allowed ? toSet(t.allowed) : {}, r = t.forbidden ? toSet(t.forbidden) : {}, i = t.constants || Constants$1, o = (t.functions || Functions$1)(g), s = t.globalvar, l = t.fieldvar, u = isFunction(s) ? s : (t) => `${s}["${t}"]`;
	new Set([...Object.getOwnPropertyNames(Object.prototype).filter((t) => typeof Object.prototype[t] == "function"), "__proto__"]);
	let d = {}, f = {}, p = 0;
	function g(t) {
		if (isString(t)) return t;
		let n = _[t.type];
		return n ?? error$1("Unsupported type: " + t.type), n(t);
	}
	let _ = {
		Literal: (t) => t.raw,
		Identifier: (t) => {
			let o = t.name;
			return p > 0 ? o : has(r, o) ? error$1("Illegal identifier: " + o) : has(i, o) ? i[o] : has(n, o) ? o : (d[o] = 1, u(o));
		},
		MemberExpression: (t) => {
			let n = !t.computed, r = g(t.object);
			n && (p += 1);
			let i = g(t.property);
			return r === l && (f[stripQuotes(i)] = 1), n && --p, r + (n ? "." + i : "[" + i + "]");
		},
		CallExpression: (t) => {
			t.callee.type !== "Identifier" && error$1("Illegal callee type: " + t.callee.type);
			let n = t.callee.name, r = t.arguments, i = has(o, n) && o[n];
			return i || error$1("Unrecognized function: " + n), isFunction(i) ? i(r) : i + "(" + r.map(g).join(",") + ")";
		},
		ArrayExpression: (t) => "[" + t.elements.map(g).join(",") + "]",
		BinaryExpression: (t) => "(" + g(t.left) + " " + t.operator + " " + g(t.right) + ")",
		UnaryExpression: (t) => "(" + t.operator + g(t.argument) + ")",
		ConditionalExpression: (t) => "(" + g(t.test) + "?" + g(t.consequent) + ":" + g(t.alternate) + ")",
		LogicalExpression: (t) => "(" + g(t.left) + t.operator + g(t.right) + ")",
		ObjectExpression: (t) => {
			for (let n of t.properties) {
				let t = n.key.name;
				DisallowedObjectProperties.has(t) && error$1("Illegal property: " + t);
			}
			return "{" + t.properties.map(g).join(",") + "}";
		},
		Property: (t) => {
			p += 1;
			let n = g(t.key);
			return --p, n + ":" + g(t.value);
		}
	};
	function v(t) {
		let n = {
			code: g(t),
			globals: Object.keys(d),
			fields: Object.keys(f)
		};
		return d = {}, f = {}, n;
	}
	return v.functions = o, v.constants = i, v;
}
var SELECTION_GETTER = Symbol("vega_selection_getter");
function getter(t) {
	return (!t.getter || !t.getter[SELECTION_GETTER]) && (t.getter = field$1(t.field), t.getter[SELECTION_GETTER] = !0), t.getter;
}
var Intersect = "intersect", Union = "union", VlMulti = "vlMulti", VlPoint = "vlPoint", Or = "or", And = "and", SelectionId = "_vgsid_", $selectionId = field$1(SelectionId), TYPE_ENUM = "E", TYPE_RANGE_INC = "R", TYPE_RANGE_EXC = "R-E", TYPE_RANGE_LE = "R-LE", TYPE_RANGE_RE = "R-RE", TYPE_PRED_LT = "E-LT", TYPE_PRED_LTE = "E-LTE", TYPE_PRED_GT = "E-GT", TYPE_PRED_GTE = "E-GTE", TYPE_PRED_VALID = "E-VALID", TYPE_PRED_ONE_OF = "E-ONE", UNIT_INDEX = "index:unit";
function testPoint(t, n) {
	for (var r = n.fields, i = n.values, o = r.length, s = 0, l, u; s < o; ++s) if (u = r[s], l = getter(u)(t), isDate(l) && (l = toNumber(l)), isDate(i[s]) && (i[s] = toNumber(i[s])), isArray(i[s]) && isDate(i[s][0]) && (i[s] = i[s].map(toNumber)), u.type === TYPE_ENUM) {
		if (isArray(i[s]) ? !i[s].includes(l) : l !== i[s]) return !1;
	} else if (u.type === TYPE_RANGE_INC) {
		if (!inrange(l, i[s])) return !1;
	} else if (u.type === TYPE_RANGE_RE) {
		if (!inrange(l, i[s], !0, !1)) return !1;
	} else if (u.type === TYPE_RANGE_EXC) {
		if (!inrange(l, i[s], !1, !1)) return !1;
	} else if (u.type === TYPE_RANGE_LE) {
		if (!inrange(l, i[s], !1, !0)) return !1;
	} else if (u.type === TYPE_PRED_LT) {
		if (l >= i[s]) return !1;
	} else if (u.type === TYPE_PRED_LTE) {
		if (l > i[s]) return !1;
	} else if (u.type === TYPE_PRED_GT) {
		if (l <= i[s]) return !1;
	} else if (u.type === TYPE_PRED_GTE) {
		if (l < i[s]) return !1;
	} else if (u.type === TYPE_PRED_VALID) {
		if (l === null || isNaN(l)) return !1;
	} else if (u.type === TYPE_PRED_ONE_OF && i[s].indexOf(l) === -1) return !1;
	return !0;
}
function selectionTest(t, n, r) {
	for (var i = this.context.data[t], o = i ? i.values.value : [], s = i ? i[UNIT_INDEX] && i[UNIT_INDEX].value : void 0, l = r === Intersect, u = o.length, d = 0, f, p, g, _, v; d < u; ++d) if (f = o[d], s && l) {
		if (p ||= {}, g = p[_ = f.unit] || 0, g === -1) continue;
		if (v = testPoint(n, f), p[_] = v ? -1 : ++g, v && s.size === 1) return !0;
		if (!v && g === s.get(_).count) return !1;
	} else if (v = testPoint(n, f), l ^ v) return v;
	return u && l;
}
var bisect = bisector($selectionId), bisectLeft = bisect.left, bisectRight = bisect.right;
function selectionIdTest(t, n, r) {
	let i = this.context.data[t], o = i ? i.values.value : [], s = i ? i[UNIT_INDEX] && i[UNIT_INDEX].value : void 0, l = r === Intersect, u = $selectionId(n), d = bisectLeft(o, u);
	if (d === o.length || $selectionId(o[d]) !== u) return !1;
	if (s && l) {
		if (s.size === 1) return !0;
		if (bisectRight(o, u) - d < s.size) return !1;
	}
	return !0;
}
function selectionTuples(t, n) {
	return t.map((t) => extend(n.fields ? { values: n.fields.map((n) => getter(n)(t.datum)) } : { [SelectionId]: $selectionId(t.datum) }, n));
}
function selectionResolve(t, n, r, i) {
	for (var o = this.context.data[t], s = o ? o.values.value : [], l = {}, u = {}, d = {}, f, p, g, _, v, S, T, E, O, k, A = s.length, j = 0, N, P; j < A; ++j) if (f = s[j], _ = f.unit, p = f.fields, g = f.values, p && g) {
		for (N = 0, P = p.length; N < P; ++N) v = p[N], T = l[v.field] || (l[v.field] = {}), E = T[_] || (T[_] = []), d[v.field] = O = v.type.charAt(0), k = ops[`${O}_union`], T[_] = k(E, array(g[N]));
		r && (E = u[_] || (u[_] = []), E.push(array(g).reduce((t, n, r) => (t[p[r].field] = n, t), {})));
	} else v = SelectionId, S = $selectionId(f), T = l[v] || (l[v] = {}), E = T[_] || (T[_] = []), E.push(S), r && (E = u[_] || (u[_] = []), E.push({ [SelectionId]: S }));
	if (n ||= Union, l[SelectionId] ? l[SelectionId] = ops[`${SelectionId}_${n}`](...Object.values(l[SelectionId])) : Object.keys(l).forEach((t) => {
		l[t] = Object.keys(l[t]).map((n) => l[t][n]).reduce((r, i) => r === void 0 ? i : ops[`${d[t]}_${n}`](r, i));
	}), s = Object.keys(u), r && s.length) {
		let t = i ? VlPoint : VlMulti;
		l[t] = n === Union ? { [Or]: s.reduce((t, n) => (t.push(...u[n]), t), []) } : { [And]: s.map((t) => ({ [Or]: u[t] })) };
	}
	return l;
}
var ops = {
	[`${SelectionId}_union`]: union,
	[`${SelectionId}_intersect`]: intersection,
	E_union: function(t, n) {
		if (!t.length) return n;
		for (var r = 0, i = n.length; r < i; ++r) t.includes(n[r]) || t.push(n[r]);
		return t;
	},
	E_intersect: function(t, n) {
		return t.length ? t.filter((t) => n.includes(t)) : n;
	},
	R_union: function(t, n) {
		var r = toNumber(n[0]), i = toNumber(n[1]);
		return r > i && (r = n[1], i = n[0]), t.length ? (t[0] > r && (t[0] = r), t[1] < i && (t[1] = i), t) : [r, i];
	},
	R_intersect: function(t, n) {
		var r = toNumber(n[0]), i = toNumber(n[1]);
		return r > i && (r = n[1], i = n[0]), t.length ? i < t[0] || t[1] < r ? [] : (t[0] < r && (t[0] = r), t[1] > i && (t[1] = i), t) : [r, i];
	}
}, DataPrefix$1 = ":", IndexPrefix$1 = "@";
function selectionVisitor(t, n, r, i) {
	n[0].type !== "Literal" && error$1("First argument to selection functions must be a string literal.");
	let o = n[0].value, s = n.length >= 2 && peek(n).value, l = "unit", u = IndexPrefix$1 + l, d = DataPrefix$1 + o;
	s === Intersect && !has(i, u) && (i[u] = r.getData(o).indataRef(r, l)), has(i, d) || (i[d] = r.getData(o).tuplesRef());
}
function data$1(t) {
	let n = this.context.data[t];
	return n ? n.values.value : [];
}
function indata(t, n, r) {
	let i = this.context.data[t]["index:" + n], o = i ? i.value.get(r) : void 0;
	return o && o.count;
}
function setdata(t, n) {
	let r = this.context.dataflow, i = this.context.data[t].input;
	return r.pulse(i, r.changeset().remove(truthy).insert(n)), 1;
}
function encode(t, n, r) {
	if (t) {
		let r = this.context.dataflow, i = t.mark.source;
		r.pulse(i, r.changeset().encode(t, n));
	}
	return r === void 0 ? t : r;
}
var wrap = (t) => function(n, r) {
	let i = this.context.dataflow.locale();
	return n === null ? "null" : i[t](r)(n);
}, format = wrap("format"), timeFormat$1 = wrap("timeFormat"), utcFormat = wrap("utcFormat"), timeParse = wrap("timeParse"), utcParse = wrap("utcParse"), dateObj = new Date(2e3, 0, 1);
function time(t, n, r) {
	return !Number.isInteger(t) || !Number.isInteger(n) ? "" : (dateObj.setYear(2e3), dateObj.setMonth(t), dateObj.setDate(n), timeFormat$1.call(this, dateObj, r));
}
function monthFormat(t) {
	return time.call(this, t, 1, "%B");
}
function monthAbbrevFormat(t) {
	return time.call(this, t, 1, "%b");
}
function dayFormat(t) {
	return time.call(this, 0, 2 + t, "%A");
}
function dayAbbrevFormat(t) {
	return time.call(this, 0, 2 + t, "%a");
}
function dataVisitor(t, n, r, i) {
	n[0].type !== "Literal" && error$1("First argument to data functions must be a string literal.");
	let o = n[0].value, s = ":" + o;
	if (!has(s, i)) try {
		i[s] = r.getData(o).tuplesRef();
	} catch {}
}
function indataVisitor(t, n, r, i) {
	n[0].type !== "Literal" && error$1("First argument to indata must be a string literal."), n[1].type !== "Literal" && error$1("Second argument to indata must be a string literal.");
	let o = n[0].value, s = n[1].value, l = "@" + s;
	has(l, i) || (i[l] = r.getData(o).indataRef(r, s));
}
function scaleVisitor(t, n, r, i) {
	if (n[0].type === "Literal") addScaleDependency(r, i, n[0].value);
	else for (t in r.scales) addScaleDependency(r, i, t);
}
function addScaleDependency(t, n, r) {
	let i = "%" + r;
	if (!has(n, i)) try {
		n[i] = t.scaleRef(r);
	} catch {}
}
function getScale(t, n) {
	if (isString(t)) {
		let r = n.scales[t];
		return r && isRegisteredScale(r.value) ? r.value : void 0;
	} else if (isFunction(t)) return isRegisteredScale(t) ? t : void 0;
}
function internalScaleFunctions(t, n, r) {
	n.__bandwidth = (t) => t && t.bandwidth ? t.bandwidth() : 0, r._bandwidth = scaleVisitor, r._range = scaleVisitor, r._scale = scaleVisitor;
	let i = (n) => "_[" + (n.type === "Literal" ? $("%" + n.value) : $("%") + "+" + t(n)) + "]";
	return {
		_bandwidth: (t) => `this.__bandwidth(${i(t[0])})`,
		_range: (t) => `${i(t[0])}.range()`,
		_scale: (n) => `${i(n[0])}(${t(n[1])})`
	};
}
function geoMethod(t, n) {
	return function(r, i, o) {
		if (r) {
			let n = getScale(r, (o || this).context);
			return n && n.path[t](i);
		} else return n(i);
	};
}
var geoArea = geoMethod("area", area_default), geoBounds = geoMethod("bounds", bounds_default), geoCentroid = geoMethod("centroid", centroid_default);
function geoScale(t, n) {
	let r = getScale(t, (n || this).context);
	return r && r.scale();
}
function inScope(t) {
	let n = this.context.group, r = !1;
	if (n) for (; t;) {
		if (t === n) {
			r = !0;
			break;
		}
		t = t.mark.group;
	}
	return r;
}
function log(t, n, r) {
	try {
		t[n].apply(t, ["EXPRESSION"].concat([].slice.call(r)));
	} catch (n) {
		t.warn(n);
	}
	return r[r.length - 1];
}
function warn$1() {
	return log(this.context.dataflow, "warn", arguments);
}
function info() {
	return log(this.context.dataflow, "info", arguments);
}
function debug$1() {
	return log(this.context.dataflow, "debug", arguments);
}
function channel_luminance_value(t) {
	let n = t / 255;
	return n <= .03928 ? n / 12.92 : ((n + .055) / 1.055) ** 2.4;
}
function luminance(t) {
	let n = rgb(t), r = channel_luminance_value(n.r), i = channel_luminance_value(n.g), o = channel_luminance_value(n.b);
	return .2126 * r + .7152 * i + .0722 * o;
}
function contrast(t, n) {
	let r = luminance(t), i = luminance(n), o = Math.max(r, i), s = Math.min(r, i);
	return (o + .05) / (s + .05);
}
function merge() {
	let t = [].slice.call(arguments);
	return t.unshift({}), extend(...t);
}
function equal(t, n) {
	return t === n || t !== t && n !== n ? !0 : isArray(t) ? isArray(n) && t.length === n.length ? equalArray(t, n) : !1 : isObject(t) && isObject(n) ? equalObject(t, n) : !1;
}
function equalArray(t, n) {
	for (let r = 0, i = t.length; r < i; ++r) if (!equal(t[r], n[r])) return !1;
	return !0;
}
function equalObject(t, n) {
	for (let r in t) if (!equal(t[r], n[r])) return !1;
	return !0;
}
function removePredicate(t) {
	return (n) => equalObject(t, n);
}
function modify(t, n, r, i, o, s) {
	let l = this.context.dataflow, u = this.context.data[t], d = u.input, f = l.stamp(), p = u.changes, g, _;
	if (l._trigger === !1 || !(d.value.length || n || i)) return 0;
	if ((!p || p.stamp < f) && (u.changes = p = l.changeset(), p.stamp = f, l.runAfter(() => {
		u.modified = !0, l.pulse(d, p).run();
	}, !0, 1)), r && (g = r === !0 ? truthy : isArray(r) || isTuple(r) ? r : removePredicate(r), p.remove(g)), n && p.insert(n), i && (g = removePredicate(i), d.value.some(g) ? p.remove(g) : p.insert(i)), o) for (_ in s) p.modify(o, _, s[_]);
	return 1;
}
function pinchDistance(t) {
	let n = t.touches, r = n[0].clientX - n[1].clientX, i = n[0].clientY - n[1].clientY;
	return Math.hypot(r, i);
}
function pinchAngle(t) {
	let n = t.touches;
	return Math.atan2(n[0].clientY - n[1].clientY, n[0].clientX - n[1].clientX);
}
var accessors = {};
function pluck(t, n) {
	let r = accessors[n] || (accessors[n] = field$1(n));
	return isArray(t) ? t.map(r) : r(t);
}
function array$1(t) {
	return isArray(t) || ArrayBuffer.isView(t) ? t : null;
}
function sequence(t) {
	return array$1(t) || (isString(t) ? t : null);
}
function join(t, ...n) {
	return array$1(t).join(...n);
}
function indexof(t, ...n) {
	return sequence(t).indexOf(...n);
}
function lastindexof(t, ...n) {
	return sequence(t).lastIndexOf(...n);
}
function slice$1(t, ...n) {
	return sequence(t).slice(...n);
}
function replace(t, n, r) {
	return isFunction(r) && error$1("Function argument passed to replace."), !isString(n) && !isRegExp(n) && error$1("Please pass a string or RegExp argument to replace."), String(t).replace(n, r);
}
function reverse$1(t) {
	return array$1(t).slice().reverse();
}
function sort(t) {
	return array$1(t).slice().sort(ascending);
}
function bandspace(t, n, r) {
	return bandSpace(t || 0, n || 0, r || 0);
}
function bandwidth(t, n) {
	let r = getScale(t, (n || this).context);
	return r && r.bandwidth ? r.bandwidth() : 0;
}
function copy(t, n) {
	let r = getScale(t, (n || this).context);
	return r ? r.copy() : void 0;
}
function domain$2(t, n) {
	let r = getScale(t, (n || this).context);
	return r ? r.domain() : [];
}
function invert(t, n, r) {
	let i = getScale(t, (r || this).context);
	return i ? isArray(n) ? (i.invertRange || i.invert)(n) : (i.invert || i.invertExtent)(n) : void 0;
}
function range$4(t, n) {
	let r = getScale(t, (n || this).context);
	return r && r.range ? r.range() : [];
}
function scale$3(t, n, r) {
	let i = getScale(t, (r || this).context);
	return i ? i(n) : void 0;
}
function scaleGradient(t, n, r, i, o) {
	t = getScale(t, (o || this).context);
	let s = Gradient$1(n, r), l = t.domain(), u = l[0], d = peek(l), f = identity;
	return d - u ? f = scaleFraction(t, u, d) : t = (t.interpolator ? scale("sequential")().interpolator(t.interpolator()) : scale("linear")().interpolate(t.interpolate()).range(t.range())).domain([u = 0, d = 1]), t.ticks && (l = t.ticks(+i || 15), u !== l[0] && l.unshift(u), d !== peek(l) && l.push(d)), l.forEach((n) => s.stop(f(n), t(n))), s;
}
function geoShape(t, n, r) {
	let i = getScale(t, (r || this).context);
	return function(t) {
		return i ? i.path.context(t)(n) : "";
	};
}
function pathShape(t) {
	let n = null;
	return function(r) {
		return r ? pathRender(r, n ||= parse$3(t)) : t;
	};
}
var datum = (t) => t.data;
function treeNodes(t, n) {
	let r = data$1.call(n, t);
	return r.root && r.root.lookup || {};
}
function treePath(t, n, r) {
	let i = treeNodes(t, this), o = i[n], s = i[r];
	return o && s ? o.path(s).map(datum) : void 0;
}
function treeAncestors(t, n) {
	let r = treeNodes(t, this)[n];
	return r ? r.ancestors().map(datum) : void 0;
}
var _window = () => typeof window < "u" && window || null;
function screen() {
	let t = _window();
	return t ? t.screen : {};
}
function windowSize() {
	let t = _window();
	return t ? [t.innerWidth, t.innerHeight] : [void 0, void 0];
}
function containerSize() {
	let t = this.context.dataflow, n = t.container && t.container();
	return n ? [n.clientWidth, n.clientHeight] : [void 0, void 0];
}
function intersect$1(t, n, r) {
	if (!t) return [];
	let [i, o] = t, s = new Bounds().set(i[0], i[1], o[0], o[1]);
	return intersect(r || this.context.dataflow.scenegraph().root, s, filter(n));
}
function filter(t) {
	let n = null;
	if (t) {
		let r = array(t.marktype), i = array(t.markname);
		n = (t) => (!r.length || r.some((n) => t.marktype === n)) && (!i.length || i.some((n) => t.name === n));
	}
	return n;
}
function lassoAppend(t, n, r, i = 5) {
	t = array(t);
	let o = t[t.length - 1];
	return o === void 0 || Math.hypot(o[0] - n, o[1] - r) > i ? [...t, [n, r]] : t;
}
function lassoPath(t) {
	return array(t).reduce((n, [r, i], o) => n += o == 0 ? `M ${r},${i} ` : o === t.length - 1 ? " Z" : `L ${r},${i} `, "");
}
function intersectLasso(t, n, r) {
	let { x: i, y: o, mark: s } = r, l = new Bounds().set(2 ** 53 - 1, 2 ** 53 - 1, -(2 ** 53 - 1), -(2 ** 53 - 1));
	for (let [t, r] of n) t < l.x1 && (l.x1 = t), t > l.x2 && (l.x2 = t), r < l.y1 && (l.y1 = r), r > l.y2 && (l.y2 = r);
	return l.translate(i, o), intersect$1([[l.x1, l.y1], [l.x2, l.y2]], t, s).filter((t) => pointInPolygon(t.x, t.y, n));
}
function pointInPolygon(t, n, r) {
	let i = 0;
	for (let o = 0, s = r.length - 1; o < r.length; s = o++) {
		let [l, u] = r[s], [d, f] = r[o];
		f > n != u > n && t < (l - d) * (n - f) / (u - f) + d && i++;
	}
	return i & 1;
}
var functionContext = {
	random() {
		return random();
	},
	cumulativeNormal,
	cumulativeLogNormal,
	cumulativeUniform,
	densityNormal,
	densityLogNormal,
	densityUniform,
	quantileNormal,
	quantileLogNormal,
	quantileUniform,
	sampleNormal,
	sampleLogNormal,
	sampleUniform,
	isArray,
	isBoolean,
	isDate,
	isDefined(t) {
		return t !== void 0;
	},
	isNumber,
	isObject,
	isRegExp,
	isString,
	isTuple,
	isValid(t) {
		return t != null && t === t;
	},
	toBoolean,
	toDate(t) {
		return toDate(t);
	},
	toNumber,
	toString,
	indexof,
	join,
	lastindexof,
	replace,
	reverse: reverse$1,
	sort,
	slice: slice$1,
	flush,
	lerp,
	merge,
	pad,
	peek,
	pluck,
	span,
	inrange,
	truncate,
	rgb,
	lab,
	hcl,
	hsl,
	luminance,
	contrast,
	sequence: range$3,
	format,
	utcFormat,
	utcParse,
	utcOffset,
	utcSequence,
	timeFormat: timeFormat$1,
	timeParse,
	timeOffset,
	timeSequence,
	timeUnitSpecifier,
	monthFormat,
	monthAbbrevFormat,
	dayFormat,
	dayAbbrevFormat,
	quarter,
	utcquarter,
	week,
	utcweek,
	dayofyear,
	utcdayofyear,
	warn: warn$1,
	info,
	debug: debug$1,
	extent(t) {
		return extent(t);
	},
	inScope,
	intersect: intersect$1,
	clampRange,
	pinchDistance,
	pinchAngle,
	screen,
	containerSize,
	windowSize,
	bandspace,
	setdata,
	pathShape,
	panLinear,
	panLog,
	panPow,
	panSymlog,
	zoomLinear,
	zoomLog,
	zoomPow,
	zoomSymlog,
	encode,
	modify,
	lassoAppend,
	lassoPath,
	intersectLasso
}, eventFunctions = [
	"view",
	"item",
	"group",
	"xy",
	"x",
	"y"
], eventPrefix = "event.vega.", thisPrefix = "this.", astVisitors = {}, codegenParams = {
	forbidden: ["_"],
	allowed: [
		"datum",
		"event",
		"item"
	],
	fieldvar: "datum",
	globalvar: (t) => `_[${$("$" + t)}]`,
	functions: buildFunctions,
	constants: Constants$1,
	visitors: astVisitors
}, codeGenerator = codegen(codegenParams);
function buildFunctions(t) {
	let n = Functions$1(t);
	for (let t in eventFunctions.forEach((t) => n[t] = eventPrefix + t), functionContext) n[t] = thisPrefix + t;
	return extend(n, internalScaleFunctions(t, functionContext, astVisitors)), n;
}
function expressionFunction(t, n, r) {
	return arguments.length === 1 ? functionContext[t] : (functionContext[t] = n, r && (astVisitors[t] = r), codeGenerator && (codeGenerator.functions[t] = thisPrefix + t), this);
}
expressionFunction("bandwidth", bandwidth, scaleVisitor), expressionFunction("copy", copy, scaleVisitor), expressionFunction("domain", domain$2, scaleVisitor), expressionFunction("range", range$4, scaleVisitor), expressionFunction("invert", invert, scaleVisitor), expressionFunction("scale", scale$3, scaleVisitor), expressionFunction("gradient", scaleGradient, scaleVisitor), expressionFunction("geoArea", geoArea, scaleVisitor), expressionFunction("geoBounds", geoBounds, scaleVisitor), expressionFunction("geoCentroid", geoCentroid, scaleVisitor), expressionFunction("geoShape", geoShape, scaleVisitor), expressionFunction("geoScale", geoScale, scaleVisitor), expressionFunction("indata", indata, indataVisitor), expressionFunction("data", data$1, dataVisitor), expressionFunction("treePath", treePath, dataVisitor), expressionFunction("treeAncestors", treeAncestors, dataVisitor), expressionFunction("vlSelectionTest", selectionTest, selectionVisitor), expressionFunction("vlSelectionIdTest", selectionIdTest, selectionVisitor), expressionFunction("vlSelectionResolve", selectionResolve, selectionVisitor), expressionFunction("vlSelectionTuples", selectionTuples);
function parser$1(t, n) {
	let r = {}, i;
	try {
		t = isString(t) ? t : $(t) + "", i = parser(t);
	} catch {
		error$1("Expression parse error: " + t);
	}
	i.visit((t) => {
		if (t.type !== "CallExpression") return;
		let i = t.callee.name, o = codegenParams.visitors[i];
		o && o(i, t.arguments, n, r);
	});
	let o = codeGenerator(i);
	return o.globals.forEach((t) => {
		let i = "$" + t;
		!has(r, i) && n.getSignal(t) && (r[i] = n.signalRef(t));
	}), {
		$expr: extend({ code: o.code }, n.options.ast ? { ast: i } : null),
		$fields: o.fields,
		$params: r
	};
}
function parse$2(t) {
	let n = this, r = t.operators || [];
	return t.background && (n.background = t.background), t.eventConfig && (n.eventConfig = t.eventConfig), t.locale && (n.locale = t.locale), r.forEach((t) => n.parseOperator(t)), r.forEach((t) => n.parseOperatorParameters(t)), (t.streams || []).forEach((t) => n.parseStream(t)), (t.updates || []).forEach((t) => n.parseUpdate(t)), n.resolve();
}
var Skip$2 = toSet(["rule"]), Swap = toSet([
	"group",
	"image",
	"rect"
]);
function adjustSpatial$1(t, n) {
	let r = "";
	return Skip$2[n] ? r : (t.x2 && (t.x ? (Swap[n] && (r += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"), r += "o.width=o.x2-o.x;") : r += "o.x=o.x2-(o.width||0);"), t.xc && (r += "o.x=o.xc-(o.width||0)/2;"), t.y2 && (t.y ? (Swap[n] && (r += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"), r += "o.height=o.y2-o.y;") : r += "o.y=o.y2-(o.height||0);"), t.yc && (r += "o.y=o.yc-(o.height||0)/2;"), r);
}
function canonicalType(t) {
	return (t + "").toLowerCase();
}
function isOperator(t) {
	return canonicalType(t) === "operator";
}
function isCollect(t) {
	return canonicalType(t) === "collect";
}
function expression$2(t, n, r) {
	r.endsWith(";") || (r = "return(" + r + ");");
	let i = Function(...n.concat(r));
	return t && t.functions ? i.bind(t.functions) : i;
}
function _compare(t, n, r, i) {
	return `((u = ${t}) < (v = ${n}) || u == null) && v != null ? ${r}
  : (u > v || v == null) && u != null ? ${i}
  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${r}
  : v !== v && u === u ? ${i} : `;
}
var expressionCodegen = {
	operator: (t, n) => expression$2(t, ["_"], n.code),
	parameter: (t, n) => expression$2(t, ["datum", "_"], n.code),
	event: (t, n) => expression$2(t, ["event"], n.code),
	handler: (t, n) => expression$2(t, ["_", "event"], `var datum=event.item&&event.item.datum;return ${n.code};`),
	encode: (t, n) => {
		let { marktype: r, channels: i } = n, o = "var o=item,datum=o.datum,m=0,$;";
		for (let t in i) {
			let n = "o[" + $(t) + "]";
			o += `$=${i[t].code};if(${n}!==$)${n}=$,m=1;`;
		}
		return o += adjustSpatial$1(i, r), o += "return m;", expression$2(t, ["item", "_"], o);
	},
	codegen: {
		get(t) {
			let n = `[${t.map($).join("][")}]`, r = Function("_", `return _${n};`);
			return r.path = n, r;
		},
		comparator(t, n) {
			let r, i = Function("a", "b", "var u, v; return " + t.map((t, i) => {
				let o = n[i], s, l;
				return t.path ? (s = `a${t.path}`, l = `b${t.path}`) : ((r ||= {})["f" + i] = t, s = `this.f${i}(a)`, l = `this.f${i}(b)`), _compare(s, l, -o, o);
			}).join("") + "0;");
			return r ? i.bind(r) : i;
		}
	}
};
function parseOperator(t) {
	let n = this;
	isOperator(t.type) || !t.type ? n.operator(t, t.update ? n.operatorExpression(t.update) : null) : n.transform(t, t.type);
}
function parseOperatorParameters(t) {
	let n = this;
	if (t.params) {
		let r = n.get(t.id);
		r || error$1("Invalid operator id: " + t.id), n.dataflow.connect(r, r.parameters(n.parseParameters(t.params), t.react, t.initonly));
	}
}
function parseParameters$1(t, n) {
	n ||= {};
	let r = this;
	for (let i in t) {
		let o = t[i];
		n[i] = isArray(o) ? o.map((t) => parseParameter$2(t, r, n)) : parseParameter$2(o, r, n);
	}
	return n;
}
function parseParameter$2(t, n, r) {
	if (!t || !isObject(t)) return t;
	for (let i = 0, o = PARSERS.length, s; i < o; ++i) if (s = PARSERS[i], has(t, s.key)) return s.parse(t, n, r);
	return t;
}
var PARSERS = [
	{
		key: "$ref",
		parse: getOperator
	},
	{
		key: "$key",
		parse: getKey
	},
	{
		key: "$expr",
		parse: getExpression
	},
	{
		key: "$field",
		parse: getField
	},
	{
		key: "$encode",
		parse: getEncode
	},
	{
		key: "$compare",
		parse: getCompare
	},
	{
		key: "$context",
		parse: getContext
	},
	{
		key: "$subflow",
		parse: getSubflow
	},
	{
		key: "$tupleid",
		parse: getTupleId
	}
];
function getOperator(t, n) {
	return n.get(t.$ref) || error$1("Operator not defined: " + t.$ref);
}
function getExpression(t, n, r) {
	t.$params && n.parseParameters(t.$params, r);
	let i = "e:" + t.$expr.code;
	return n.fn[i] || (n.fn[i] = accessor(n.parameterExpression(t.$expr), t.$fields));
}
function getKey(t, n) {
	let r = "k:" + t.$key + "_" + !!t.$flat;
	return n.fn[r] || (n.fn[r] = key(t.$key, t.$flat, n.expr.codegen));
}
function getField(t, n) {
	if (!t.$field) return null;
	let r = "f:" + t.$field + "_" + t.$name;
	return n.fn[r] || (n.fn[r] = field$1(t.$field, t.$name, n.expr.codegen));
}
function getCompare(t, n) {
	let r = "c:" + t.$compare + "_" + t.$order, i = array(t.$compare).map((t) => t && t.$tupleid ? tupleid : t);
	return n.fn[r] || (n.fn[r] = compare$1(i, t.$order, n.expr.codegen));
}
function getEncode(t, n) {
	let r = t.$encode, i = {};
	for (let t in r) {
		let o = r[t];
		i[t] = accessor(n.encodeExpression(o.$expr), o.$fields), i[t].output = o.$output;
	}
	return i;
}
function getContext(t, n) {
	return n;
}
function getSubflow(t, n) {
	let r = t.$subflow;
	return function(t, i, o) {
		let s = n.fork().parse(r), l = s.get(r.operators[0].id), u = s.signals.parent;
		return u && u.set(o), l.detachSubflow = () => n.detach(s), l;
	};
}
function getTupleId() {
	return tupleid;
}
function parseStream$2(t) {
	var n = this, r = t.filter == null ? void 0 : n.eventExpression(t.filter), i = t.stream == null ? void 0 : n.get(t.stream), o;
	t.source ? i = n.events(t.source, t.type, r) : t.merge && (o = t.merge.map((t) => n.get(t)), i = o[0].merge.apply(o[0], o.slice(1))), t.between && (o = t.between.map((t) => n.get(t)), i = i.between(o[0], o[1])), t.filter && (i = i.filter(r)), t.throttle != null && (i = i.throttle(+t.throttle)), t.debounce != null && (i = i.debounce(+t.debounce)), i ?? error$1("Invalid stream definition: " + JSON.stringify(t)), t.consume && i.consume(!0), n.stream(t, i);
}
function parseUpdate$1(t) {
	var n = this, r = isObject(r = t.source) ? r.$ref : r, i = n.get(r), o = null, s = t.update, l = void 0;
	i || error$1("Source not defined: " + t.source), o = t.target && t.target.$expr ? n.eventExpression(t.target.$expr) : n.get(t.target), s && s.$expr && (s.$params && (l = n.parseParameters(s.$params)), s = n.handlerExpression(s.$expr)), n.update(t, i, o, s, l);
}
var SKIP = { skip: !0 };
function getState$1(t) {
	var n = this, r = {};
	if (t.signals) {
		var i = r.signals = {};
		Object.keys(n.signals).forEach((r) => {
			let o = n.signals[r];
			t.signals(r, o) && (i[r] = o.value);
		});
	}
	if (t.data) {
		var o = r.data = {};
		Object.keys(n.data).forEach((r) => {
			let i = n.data[r];
			t.data(r, i) && (o[r] = i.input.value);
		});
	}
	return n.subcontext && t.recurse !== !1 && (r.subcontext = n.subcontext.map((n) => n.getState(t))), r;
}
function setState$1(t) {
	var n = this, r = n.dataflow, i = t.data, o = t.signals;
	Object.keys(o || {}).forEach((t) => {
		r.update(n.signals[t], o[t], SKIP);
	}), Object.keys(i || {}).forEach((t) => {
		r.pulse(n.data[t].input, r.changeset().remove(truthy).insert(i[t]));
	}), (t.subcontext || []).forEach((t, r) => {
		let i = n.subcontext[r];
		i && i.setState(t);
	});
}
function context(t, n, r, i) {
	return new Context(t, n, r, i);
}
function Context(t, n, r, i) {
	this.dataflow = t, this.transforms = n, this.events = t.events.bind(t), this.expr = i || expressionCodegen, this.signals = {}, this.scales = {}, this.nodes = {}, this.data = {}, this.fn = {}, r && (this.functions = Object.create(r), this.functions.context = this);
}
function Subcontext(t) {
	this.dataflow = t.dataflow, this.transforms = t.transforms, this.events = t.events, this.expr = t.expr, this.signals = Object.create(t.signals), this.scales = Object.create(t.scales), this.nodes = Object.create(t.nodes), this.data = Object.create(t.data), this.fn = Object.create(t.fn), t.functions && (this.functions = Object.create(t.functions), this.functions.context = this);
}
Context.prototype = Subcontext.prototype = {
	fork() {
		let t = new Subcontext(this);
		return (this.subcontext ||= []).push(t), t;
	},
	detach(t) {
		this.subcontext = this.subcontext.filter((n) => n !== t);
		let n = Object.keys(t.nodes);
		for (let r of n) t.nodes[r]._targets = null;
		for (let r of n) t.nodes[r].detach();
		t.nodes = null;
	},
	get(t) {
		return this.nodes[t];
	},
	set(t, n) {
		return this.nodes[t] = n;
	},
	add(t, n) {
		let r = this, i = r.dataflow, o = t.value;
		if (r.set(t.id, n), isCollect(t.type) && o && (o.$ingest ? i.ingest(n, o.$ingest, o.$format) : o.$request ? i.preload(n, o.$request, o.$format) : i.pulse(n, i.changeset().insert(o))), t.root && (r.root = n), t.parent) {
			let o = r.get(t.parent.$ref);
			o ? (i.connect(o, [n]), n.targets().add(o)) : (r.unresolved = r.unresolved || []).push(() => {
				o = r.get(t.parent.$ref), i.connect(o, [n]), n.targets().add(o);
			});
		}
		if (t.signal && (r.signals[t.signal] = n), t.scale && (r.scales[t.scale] = n), t.data) for (let i in t.data) {
			let o = r.data[i] || (r.data[i] = {});
			t.data[i].forEach((t) => o[t] = n);
		}
	},
	resolve() {
		return (this.unresolved || []).forEach((t) => t()), delete this.unresolved, this;
	},
	operator(t, n) {
		this.add(t, this.dataflow.add(t.value, n));
	},
	transform(t, n) {
		this.add(t, this.dataflow.add(this.transforms[canonicalType(n)]));
	},
	stream(t, n) {
		this.set(t.id, n);
	},
	update(t, n, r, i, o) {
		this.dataflow.on(n, r, i, o, t.options);
	},
	operatorExpression(t) {
		return this.expr.operator(this, t);
	},
	parameterExpression(t) {
		return this.expr.parameter(this, t);
	},
	eventExpression(t) {
		return this.expr.event(this, t);
	},
	handlerExpression(t) {
		return this.expr.handler(this, t);
	},
	encodeExpression(t) {
		return this.expr.encode(this, t);
	},
	parse: parse$2,
	parseOperator,
	parseOperatorParameters,
	parseParameters: parseParameters$1,
	parseStream: parseStream$2,
	parseUpdate: parseUpdate$1,
	getState: getState$1,
	setState: setState$1
};
function initializeAria(t) {
	let n = t.container();
	n && (n.setAttribute("role", "graphics-document"), n.setAttribute("aria-roleDescription", "visualization"), ariaLabel(n, t.description()));
}
function ariaLabel(t, n) {
	t && (n == null ? t.removeAttribute("aria-label") : t.setAttribute("aria-label", n));
}
function background(t) {
	t.add(null, (n) => (t._background = n.bg, t._resize = 1, n.bg), { bg: t._signals.background });
}
var Default = "default";
function cursor$1(t) {
	let n = t._signals.cursor || (t._signals.cursor = t.add({
		user: Default,
		item: null
	}));
	t.on(t.events("view", "pointermove"), n, (t, r) => {
		let i = n.value, o = i ? isString(i) ? i : i.user : Default, s = r.item && r.item.cursor || null;
		return i && o === i.user && s == i.item ? i : {
			user: o,
			item: s
		};
	}), t.add(null, function(n) {
		let r = n.cursor, i = this.value;
		return isString(r) || (i = r.item, r = r.user), setCursor(t, r && r !== Default ? r : i || r), i;
	}, { cursor: n });
}
function setCursor(t, n) {
	let r = t.globalCursor() ? typeof document < "u" && document.body : t.container();
	if (r) return n == null ? r.style.removeProperty("cursor") : r.style.cursor = n;
}
function dataref(t, n) {
	var r = t._runtime.data;
	return has(r, n) || error$1("Unrecognized data set: " + n), r[n];
}
function data(t, n) {
	return arguments.length < 2 ? dataref(this, t).values.value : change.call(this, t, changeset().remove(truthy).insert(n));
}
function change(t, n) {
	isChangeSet(n) || error$1("Second argument to changes must be a changeset.");
	let r = dataref(this, t);
	return r.modified = !0, this.pulse(r.input, n);
}
function insert(t, n) {
	return change.call(this, t, changeset().insert(n));
}
function remove(t, n) {
	return change.call(this, t, changeset().remove(n));
}
function width(t) {
	var n = t.padding();
	return Math.max(0, t._viewWidth + n.left + n.right);
}
function height(t) {
	var n = t.padding();
	return Math.max(0, t._viewHeight + n.top + n.bottom);
}
function offset(t) {
	var n = t.padding(), r = t._origin;
	return [n.left + r[0], n.top + r[1]];
}
function resizeRenderer(t) {
	var n = offset(t), r = width(t), i = height(t);
	t._renderer.background(t.background()), t._renderer.resize(r, i, n), t._handler.origin(n), t._resizeListeners.forEach((n) => {
		try {
			n(r, i);
		} catch (n) {
			t.error(n);
		}
	});
}
function eventExtend(t, n, r) {
	var i = t._renderer, o = i && i.canvas(), s, l, u;
	return o && (u = offset(t), l = n.changedTouches ? n.changedTouches[0] : n, s = point$2(l, o), s[0] -= u[0], s[1] -= u[1]), n.dataflow = t, n.item = r, n.vega = extension(t, r, s), n;
}
function extension(t, n, r) {
	let i = n ? n.mark.marktype === "group" ? n : n.mark.group : null;
	function o(t) {
		var r = i, o;
		if (t) {
			for (o = n; o; o = o.mark.group) if (o.mark.name === t) {
				r = o;
				break;
			}
		}
		return r && r.mark && r.mark.interactive ? r : {};
	}
	function s(t) {
		if (!t) return r;
		isString(t) && (t = o(t));
		let n = r.slice();
		for (; t;) n[0] -= t.x || 0, n[1] -= t.y || 0, t = t.mark && t.mark.group;
		return n;
	}
	return {
		view: constant(t),
		item: constant(n || {}),
		group: o,
		xy: s,
		x: (t) => s(t)[0],
		y: (t) => s(t)[1]
	};
}
var VIEW$1 = "view", TIMER = "timer", WINDOW = "window", NO_TRAP = { trap: !1 };
function initializeEventConfig(t) {
	let n = extend({ defaults: {} }, t), r = (t, n) => {
		n.forEach((n) => {
			isArray(t[n]) && (t[n] = toSet(t[n]));
		});
	};
	return r(n.defaults, ["prevent", "allow"]), r(n, [
		"view",
		"window",
		"selector"
	]), n;
}
function trackEventListener(t, n, r, i) {
	t._eventListeners.push({
		type: r,
		sources: array(n),
		handler: i
	});
}
function prevent(t, n) {
	var r = t._eventConfig.defaults, i = r.prevent, o = r.allow;
	return i === !1 || o === !0 ? !1 : i === !0 || o === !1 ? !0 : i ? i[n] : o ? !o[n] : t.preventDefault();
}
function permit(t, n, r) {
	let i = t._eventConfig && t._eventConfig[n];
	return i === !1 || isObject(i) && !i[r] ? (t.warn(`Blocked ${n} ${r} event listener.`), !1) : !0;
}
function events(t, n, r) {
	var i = this, o = new EventStream(r), s = function(r, s) {
		i.runAsync(null, () => {
			t === VIEW$1 && prevent(i, n) && r.preventDefault(), o.receive(eventExtend(i, r, s));
		});
	}, l;
	if (t === TIMER) permit(i, "timer", n) && i.timer(s, n);
	else if (t === VIEW$1) permit(i, "view", n) && i.addEventListener(n, s, NO_TRAP);
	else if (t === WINDOW ? permit(i, "window", n) && typeof window < "u" && (l = [window]) : typeof document < "u" && permit(i, "selector", n) && (l = Array.from(document.querySelectorAll(t))), !l) i.warn("Can not resolve event source: " + t);
	else {
		for (var u = 0, d = l.length; u < d; ++u) l[u].addEventListener(n, s);
		trackEventListener(i, l, n, s);
	}
	return o;
}
function itemFilter(t) {
	return t.item;
}
function markTarget(t) {
	return t.item.mark.source;
}
function invoke(t) {
	return function(n, r) {
		return r.vega.view().changeset().encode(r.item, t);
	};
}
function hover(t, n) {
	return t = [t || "hover"], n = [n || "update", t[0]], this.on(this.events("view", "pointerover", itemFilter), markTarget, invoke(t)), this.on(this.events("view", "pointerout", itemFilter), markTarget, invoke(n)), this;
}
function finalize() {
	for (var t = this._tooltip, n = this._timers, r = this._handler.handlers(), i = this._eventListeners, o = n.length, s, l, u, d; --o >= 0;) n[o].stop();
	for (o = i.length; --o >= 0;) for (l = i[o], s = l.sources.length; --s >= 0;) l.sources[s].removeEventListener(l.type, l.handler);
	for (t && t.call(this, this._handler, null, null, null), o = r.length; --o >= 0;) d = r[o].type, u = r[o].handler, this._handler.off(d, u);
	return this;
}
function element(t, n, r) {
	let i = document.createElement(t);
	for (let t in n) i.setAttribute(t, n[t]);
	return r != null && (i.textContent = r), i;
}
var BindClass = "vega-bind", NameClass = "vega-bind-name", RadioClass = "vega-bind-radio";
function bind(t, n, r) {
	if (!n) return;
	let i = r.param, o = r.state;
	return o || (o = r.state = {
		elements: null,
		active: !1,
		set: null,
		update: (n) => {
			n != t.signal(i.signal) && t.runAsync(null, () => {
				o.source = !0, t.signal(i.signal, n);
			});
		}
	}, i.debounce && (o.update = debounce(i.debounce, o.update))), (i.input == null && i.element ? target : generate$1)(o, n, i, t), o.active ||= (t.on(t._signals[i.signal], null, () => {
		o.source ? o.source = !1 : o.set(t.signal(i.signal));
	}), !0), o;
}
function target(t, n, r, i) {
	let o = r.event || "input", s = () => t.update(n.value);
	i.signal(r.signal, n.value), n.addEventListener(o, s), trackEventListener(i, n, o, s), t.set = (t) => {
		n.value = t, n.dispatchEvent(event(o));
	};
}
function event(t) {
	return typeof Event < "u" ? new Event(t) : { type: t };
}
function generate$1(t, n, r, i) {
	let o = i.signal(r.signal), s = element("div", { class: BindClass }), l = r.input === "radio" ? s : s.appendChild(element("label"));
	l.appendChild(element("span", { class: NameClass }, r.name || r.signal)), n.appendChild(s);
	let u = form;
	switch (r.input) {
		case "checkbox":
			u = checkbox;
			break;
		case "select":
			u = select;
			break;
		case "radio":
			u = radio;
			break;
		case "range":
			u = range$2;
			break;
	}
	u(t, l, r, o);
}
function form(t, n, r, i) {
	let o = element("input");
	for (let t in r) t !== "signal" && t !== "element" && o.setAttribute(t === "input" ? "type" : t, r[t]);
	o.setAttribute("name", r.signal), o.value = i, n.appendChild(o), o.addEventListener("input", () => t.update(o.value)), t.elements = [o], t.set = (t) => o.value = t;
}
function checkbox(t, n, r, i) {
	let o = {
		type: "checkbox",
		name: r.signal
	};
	i && (o.checked = !0);
	let s = element("input", o);
	n.appendChild(s), s.addEventListener("change", () => t.update(s.checked)), t.elements = [s], t.set = (t) => s.checked = !!t || null;
}
function select(t, n, r, i) {
	let o = element("select", { name: r.signal }), s = r.labels || [];
	r.options.forEach((t, n) => {
		let r = { value: t };
		valuesEqual(t, i) && (r.selected = !0), o.appendChild(element("option", r, (s[n] || t) + ""));
	}), n.appendChild(o), o.addEventListener("change", () => {
		t.update(r.options[o.selectedIndex]);
	}), t.elements = [o], t.set = (t) => {
		for (let n = 0, i = r.options.length; n < i; ++n) if (valuesEqual(r.options[n], t)) {
			o.selectedIndex = n;
			return;
		}
	};
}
function radio(t, n, r, i) {
	let o = element("span", { class: RadioClass }), s = r.labels || [];
	n.appendChild(o), t.elements = r.options.map((n, l) => {
		let u = {
			type: "radio",
			name: r.signal,
			value: n
		};
		valuesEqual(n, i) && (u.checked = !0);
		let d = element("input", u);
		d.addEventListener("change", () => t.update(n));
		let f = element("label", {}, (s[l] || n) + "");
		return f.prepend(d), o.appendChild(f), d;
	}), t.set = (n) => {
		let r = t.elements, i = r.length;
		for (let t = 0; t < i; ++t) valuesEqual(r[t].value, n) && (r[t].checked = !0);
	};
}
function range$2(t, n, r, i) {
	i = i === void 0 ? (+r.max + +r.min) / 2 : i;
	let o = r.max == null ? Math.max(100, +i) || 100 : r.max, s = r.min || Math.min(0, o, +i) || 0, l = r.step || tickStep(s, o, 100), u = element("input", {
		type: "range",
		name: r.signal,
		min: s,
		max: o,
		step: l
	});
	u.value = i;
	let d = element("span", {}, +i);
	n.appendChild(u), n.appendChild(d);
	let f = () => {
		d.textContent = u.value, t.update(+u.value);
	};
	u.addEventListener("input", f), u.addEventListener("change", f), t.elements = [u], t.set = (t) => {
		u.value = t, d.textContent = t;
	};
}
function valuesEqual(t, n) {
	return t === n || t + "" == n + "";
}
function initializeRenderer(t, n, r, i, o, s) {
	return n ||= new i(t.loader()), n.initialize(r, width(t), height(t), offset(t), o, s).background(t.background());
}
function trap(t, n) {
	return n ? function() {
		try {
			n.apply(this, arguments);
		} catch (n) {
			t.error(n);
		}
	} : null;
}
function initializeHandler(t, n, r, i) {
	let o = new i(t.loader(), trap(t, t.tooltip())).scene(t.scenegraph().root).initialize(r, offset(t), t);
	return n && n.handlers().forEach((t) => {
		o.on(t.type, t.handler);
	}), o;
}
function initialize(t, n) {
	let r = this, i = r._renderType, o = r._eventConfig.bind, s = renderModule(i);
	t = r._el = t ? lookup$1(r, t, !0) : null, initializeAria(r), s || r.error("Unrecognized renderer type: " + i);
	let l = s.handler || CanvasHandler, u = t ? s.renderer : s.headless;
	return r._renderer = u ? initializeRenderer(r, r._renderer, t, u) : null, r._handler = initializeHandler(r, r._handler, t, l), r._redraw = !0, t && o !== "none" && (n = n ? r._elBind = lookup$1(r, n, !0) : t.appendChild(element("form", { class: "vega-bindings" })), r._bind.forEach((t) => {
		t.param.element && o !== "container" && (t.element = lookup$1(r, t.param.element, !!t.param.input));
	}), r._bind.forEach((t) => {
		bind(r, t.element || n, t);
	})), r;
}
function lookup$1(t, n, r) {
	if (typeof n == "string") if (typeof document < "u") {
		if (n = document.querySelector(n), !n) return t.error("Signal bind element not found: " + n), null;
	} else return t.error("DOM document instance not found."), null;
	if (n && r) try {
		n.textContent = "";
	} catch (r) {
		n = null, t.error(r);
	}
	return n;
}
var number$1 = (t) => +t || 0, paddingObject$1 = (t) => ({
	top: t,
	bottom: t,
	left: t,
	right: t
});
function padding$1(t) {
	return isObject(t) ? {
		top: number$1(t.top),
		bottom: number$1(t.bottom),
		left: number$1(t.left),
		right: number$1(t.right)
	} : paddingObject$1(number$1(t));
}
async function renderHeadless(t, n, r, i) {
	let o = renderModule(n), s = o && o.headless;
	return s || error$1("Unrecognized renderer type: " + n), await t.runAsync(), initializeRenderer(t, null, null, s, r, i).renderAsync(t._scenegraph.root);
}
async function renderToImageURL(t, n) {
	t !== RenderType.Canvas && t !== RenderType.SVG && t !== RenderType.PNG && error$1("Unrecognized image type: " + t);
	let r = await renderHeadless(this, t, n);
	return t === RenderType.SVG ? toBlobURL(r.svg(), "image/svg+xml") : r.canvas().toDataURL("image/png");
}
function toBlobURL(t, n) {
	let r = new Blob([t], { type: n });
	return window.URL.createObjectURL(r);
}
async function renderToCanvas(t, n) {
	return (await renderHeadless(this, RenderType.Canvas, t, n)).canvas();
}
async function renderToSVG(t) {
	return (await renderHeadless(this, RenderType.SVG, t)).svg();
}
function runtime(t, n, r) {
	return context(t, transforms, functionContext, r).parse(n);
}
function scale$2(t) {
	var n = this._runtime.scales;
	return has(n, t) || error$1("Unrecognized scale or projection: " + t), n[t].value;
}
var Width = "width", Height = "height", Padding = "padding", Skip$1 = { skip: !0 };
function viewWidth(t, n) {
	var r = t.autosize(), i = t.padding();
	return n - (r && r.contains === Padding ? i.left + i.right : 0);
}
function viewHeight(t, n) {
	var r = t.autosize(), i = t.padding();
	return n - (r && r.contains === Padding ? i.top + i.bottom : 0);
}
function initializeResize(t) {
	var n = t._signals, r = n[Width], i = n[Height], o = n[Padding];
	function s() {
		t._autosize = t._resize = 1;
	}
	t._resizeWidth = t.add(null, (n) => {
		t._width = n.size, t._viewWidth = viewWidth(t, n.size), s();
	}, { size: r }), t._resizeHeight = t.add(null, (n) => {
		t._height = n.size, t._viewHeight = viewHeight(t, n.size), s();
	}, { size: i });
	let l = t.add(null, s, { pad: o });
	t._resizeWidth.rank = r.rank + 1, t._resizeHeight.rank = i.rank + 1, l.rank = o.rank + 1;
}
function resizeView(t, n, r, i, o, s) {
	this.runAfter((l) => {
		let u = 0;
		l._autosize = 0, l.width() !== r && (u = 1, l.signal(Width, r, Skip$1), l._resizeWidth.skip(!0)), l.height() !== i && (u = 1, l.signal(Height, i, Skip$1), l._resizeHeight.skip(!0)), l._viewWidth !== t && (l._resize = 1, l._viewWidth = t), l._viewHeight !== n && (l._resize = 1, l._viewHeight = n), (l._origin[0] !== o[0] || l._origin[1] !== o[1]) && (l._resize = 1, l._origin = o), u && l.run("enter"), s && l.runAfter((t) => t.resize());
	}, !1, 1);
}
function getState(t) {
	return this._runtime.getState(t || {
		data: dataTest,
		signals: signalTest,
		recurse: !0
	});
}
function dataTest(t, n) {
	return n.modified && isArray(n.input.value) && !t.startsWith("_:vega:_");
}
function signalTest(t, n) {
	return !(t === "parent" || n instanceof transforms.proxy);
}
function setState(t) {
	return this.runAsync(null, (n) => {
		n._trigger = !1, n._runtime.setState(t);
	}, (t) => {
		t._trigger = !0;
	}), this;
}
function timer(t, n) {
	function r(n) {
		t({
			timestamp: Date.now(),
			elapsed: n
		});
	}
	this._timers.push(interval_default(r, n));
}
function defaultTooltip(t, n, r, i) {
	let o = t.element();
	o && o.setAttribute("title", formatTooltip(i));
}
function formatTooltip(t) {
	return t == null ? "" : isArray(t) ? formatArray(t) : isObject(t) && !isDate(t) ? formatObject(t) : t + "";
}
function formatObject(t) {
	return Object.keys(t).map((n) => {
		let r = t[n];
		return n + ": " + (isArray(r) ? formatArray(r) : formatValue$1(r));
	}).join("\n");
}
function formatArray(t) {
	return "[" + t.map(formatValue$1).join(", ") + "]";
}
function formatValue$1(t) {
	return isArray(t) ? "[…]" : isObject(t) && !isDate(t) ? "{…}" : t;
}
function watchPixelRatio() {
	if (this.renderer() === "canvas" && this._renderer._canvas) {
		let t = null, n = () => {
			t?.();
			let r = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
			r.addEventListener("change", n), t = () => {
				r.removeEventListener("change", n);
			}, this._renderer._canvas.getContext("2d").pixelRatio = window.devicePixelRatio || 1, this._redraw = !0, this._resize = 1, this.resize().runAsync();
		};
		n();
	}
}
function View(t, n) {
	let r = this;
	if (n ||= {}, Dataflow.call(r), n.loader && r.loader(n.loader), n.logger && r.logger(n.logger), n.logLevel != null && r.logLevel(n.logLevel), n.locale || t.locale) {
		let i = extend({}, t.locale, n.locale);
		r.locale(locale(i.number, i.time));
	}
	r._el = null, r._elBind = null, r._renderType = n.renderer || RenderType.Canvas, r._scenegraph = new Scenegraph();
	let i = r._scenegraph.root;
	r._renderer = null, r._tooltip = n.tooltip || defaultTooltip, r._redraw = !0, r._handler = new CanvasHandler().scene(i), r._globalCursor = !1, r._preventDefault = !1, r._timers = [], r._eventListeners = [], r._resizeListeners = [], r._eventConfig = initializeEventConfig(t.eventConfig), r.globalCursor(r._eventConfig.globalCursor);
	let o = runtime(r, t, n.expr);
	r._runtime = o, r._signals = o.signals, r._bind = (t.bindings || []).map((t) => ({
		state: null,
		param: extend({}, t)
	})), o.root && o.root.set(i), i.source = o.data.root.input, r.pulse(o.data.root.input, r.changeset().insert(i.items)), r._width = r.width(), r._height = r.height(), r._viewWidth = viewWidth(r, r._width), r._viewHeight = viewHeight(r, r._height), r._origin = [0, 0], r._resize = 0, r._autosize = 1, initializeResize(r), background(r), cursor$1(r), r.description(t.description), n.hover && r.hover(), n.container && r.initialize(n.container, n.bind), n.watchPixelRatio && r._watchPixelRatio();
}
function lookupSignal(t, n) {
	return has(t._signals, n) ? t._signals[n] : error$1("Unrecognized signal name: " + $(n));
}
function findOperatorHandler(t, n) {
	let r = (t._targets || []).filter((t) => t._update && t._update.handler === n);
	return r.length ? r[0] : null;
}
function addOperatorListener(t, n, r, i) {
	let o = findOperatorHandler(r, i);
	return o || (o = trap(t, () => i(n, r.value)), o.handler = i, t.on(r, null, o)), t;
}
function removeOperatorListener(t, n, r) {
	let i = findOperatorHandler(n, r);
	return i && n._targets.remove(i), t;
}
inherits(View, Dataflow, {
	async evaluate(t, n, r) {
		if (await Dataflow.prototype.evaluate.call(this, t, n), this._redraw || this._resize) try {
			this._renderer && (this._resize && (this._resize = 0, resizeRenderer(this)), await this._renderer.renderAsync(this._scenegraph.root)), this._redraw = !1;
		} catch (t) {
			this.error(t);
		}
		return r && asyncCallback(this, r), this;
	},
	dirty(t) {
		this._redraw = !0, this._renderer && this._renderer.dirty(t);
	},
	description(t) {
		if (arguments.length) {
			let n = t == null ? null : t + "";
			return n !== this._desc && ariaLabel(this._el, this._desc = n), this;
		}
		return this._desc;
	},
	container() {
		return this._el;
	},
	scenegraph() {
		return this._scenegraph;
	},
	origin() {
		return this._origin.slice();
	},
	signal(t, n, r) {
		let i = lookupSignal(this, t);
		return arguments.length === 1 ? i.value : this.update(i, n, r);
	},
	width(t) {
		return arguments.length ? this.signal("width", t) : this.signal("width");
	},
	height(t) {
		return arguments.length ? this.signal("height", t) : this.signal("height");
	},
	padding(t) {
		return arguments.length ? this.signal("padding", padding$1(t)) : padding$1(this.signal("padding"));
	},
	autosize(t) {
		return arguments.length ? this.signal("autosize", t) : this.signal("autosize");
	},
	background(t) {
		return arguments.length ? this.signal("background", t) : this.signal("background");
	},
	renderer(t) {
		return arguments.length ? (renderModule(t) || error$1("Unrecognized renderer type: " + t), t !== this._renderType && (this._renderType = t, this._resetRenderer()), this) : this._renderType;
	},
	tooltip(t) {
		return arguments.length ? (t !== this._tooltip && (this._tooltip = t, this._resetRenderer()), this) : this._tooltip;
	},
	loader(t) {
		return arguments.length ? (t !== this._loader && (Dataflow.prototype.loader.call(this, t), this._resetRenderer()), this) : this._loader;
	},
	resize() {
		return this._autosize = 1, this.touch(lookupSignal(this, "autosize"));
	},
	_resetRenderer() {
		this._renderer && (this._renderer = null, this.initialize(this._el, this._elBind));
	},
	_resizeView: resizeView,
	addEventListener(t, n, r) {
		let i = n;
		return r && r.trap === !1 || (i = trap(this, n), i.raw = n), this._handler.on(t, i), this;
	},
	removeEventListener(t, n) {
		for (var r = this._handler.handlers(t), i = r.length, o, s; --i >= 0;) if (s = r[i].type, o = r[i].handler, t === s && (n === o || n === o.raw)) {
			this._handler.off(s, o);
			break;
		}
		return this;
	},
	addResizeListener(t) {
		let n = this._resizeListeners;
		return n.includes(t) || n.push(t), this;
	},
	removeResizeListener(t) {
		var n = this._resizeListeners, r = n.indexOf(t);
		return r >= 0 && n.splice(r, 1), this;
	},
	addSignalListener(t, n) {
		return addOperatorListener(this, t, lookupSignal(this, t), n);
	},
	removeSignalListener(t, n) {
		return removeOperatorListener(this, lookupSignal(this, t), n);
	},
	addDataListener(t, n) {
		return addOperatorListener(this, t, dataref(this, t).values, n);
	},
	removeDataListener(t, n) {
		return removeOperatorListener(this, dataref(this, t).values, n);
	},
	globalCursor(t) {
		if (arguments.length) {
			if (this._globalCursor !== !!t) {
				let n = setCursor(this, null);
				this._globalCursor = !!t, n && setCursor(this, n);
			}
			return this;
		} else return this._globalCursor;
	},
	preventDefault(t) {
		return arguments.length ? (this._preventDefault = t, this) : this._preventDefault;
	},
	timer,
	events,
	finalize,
	hover,
	data,
	change,
	insert,
	remove,
	scale: scale$2,
	initialize,
	toImageURL: renderToImageURL,
	toCanvas: renderToCanvas,
	toSVG: renderToSVG,
	getState,
	setState,
	_watchPixelRatio: watchPixelRatio
});
var VIEW = "view", LBRACK = "[", RBRACK = "]", LBRACE = "{", RBRACE = "}", COLON = ":", COMMA = ",", NAME = "@", GT = ">", ILLEGAL = /[[\]{}]/, DEFAULT_MARKS = {
	"*": 1,
	arc: 1,
	area: 1,
	group: 1,
	image: 1,
	line: 1,
	path: 1,
	rect: 1,
	rule: 1,
	shape: 1,
	symbol: 1,
	text: 1,
	trail: 1
}, DEFAULT_SOURCE, MARKS;
function eventSelector(t, n, r) {
	return DEFAULT_SOURCE = n || VIEW, MARKS = r || DEFAULT_MARKS, parseMerge(t.trim()).map(parseSelector);
}
function isMarkType(t) {
	return MARKS[t];
}
function find(t, n, r, i, o) {
	let s = t.length, l = 0, u;
	for (; n < s; ++n) {
		if (u = t[n], !l && u === r) return n;
		o && o.includes(u) ? --l : i && i.includes(u) && ++l;
	}
	return n;
}
function parseMerge(t) {
	let n = [], r = t.length, i = 0, o = 0;
	for (; o < r;) o = find(t, o, COMMA, LBRACK + LBRACE, RBRACK + RBRACE), n.push(t.substring(i, o).trim()), i = ++o;
	if (n.length === 0) throw "Empty event selector: " + t;
	return n;
}
function parseSelector(t) {
	return t[0] === "[" ? parseBetween(t) : parseStream$1(t);
}
function parseBetween(t) {
	let n = t.length, r = 1, i;
	if (r = find(t, r, RBRACK, LBRACK, RBRACK), r === n) throw "Empty between selector: " + t;
	if (i = parseMerge(t.substring(1, r)), i.length !== 2) throw "Between selector must have two elements: " + t;
	if (t = t.slice(r + 1).trim(), t[0] !== GT) throw "Expected '>' after between selector: " + t;
	i = i.map(parseSelector);
	let o = parseSelector(t.slice(1).trim());
	return o.between ? {
		between: i,
		stream: o
	} : (o.between = i, o);
}
function parseStream$1(t) {
	let n = { source: DEFAULT_SOURCE }, r = [], i = [0, 0], o = 0, s = 0, l = t.length, u = 0, d, f;
	if (t[l - 1] === RBRACE) {
		if (u = t.lastIndexOf(LBRACE), u >= 0) {
			try {
				i = parseThrottle(t.substring(u + 1, l - 1));
			} catch {
				throw "Invalid throttle specification: " + t;
			}
			t = t.slice(0, u).trim(), l = t.length;
		} else throw "Unmatched right brace: " + t;
		u = 0;
	}
	if (!l) throw t;
	if (t[0] === NAME && (o = ++u), d = find(t, u, COLON), d < l && (r.push(t.substring(s, d).trim()), s = u = ++d), u = find(t, u, LBRACK), u === l) r.push(t.substring(s, l).trim());
	else if (r.push(t.substring(s, u).trim()), f = [], s = ++u, s === l) throw "Unmatched left bracket: " + t;
	for (; u < l;) {
		if (u = find(t, u, RBRACK), u === l) throw "Unmatched left bracket: " + t;
		if (f.push(t.substring(s, u).trim()), u < l - 1 && t[++u] !== LBRACK) throw "Expected left bracket: " + t;
		s = ++u;
	}
	if (!(l = r.length) || ILLEGAL.test(r[l - 1])) throw "Invalid event selector: " + t;
	return l > 1 ? (n.type = r[1], o ? n.markname = r[0].slice(1) : isMarkType(r[0]) ? n.marktype = r[0] : n.source = r[0]) : n.type = r[0], n.type.slice(-1) === "!" && (n.consume = !0, n.type = n.type.slice(0, -1)), f != null && (n.filter = f), i[0] && (n.throttle = i[0]), i[1] && (n.debounce = i[1]), n;
}
function parseThrottle(t) {
	let n = t.split(COMMA);
	if (!t.length || n.length > 2) throw t;
	return n.map((n) => {
		let r = +n;
		if (r !== r) throw t;
		return r;
	});
}
function parseAutosize(t) {
	return isObject(t) ? t : { type: t || "pad" };
}
var number = (t) => +t || 0, paddingObject = (t) => ({
	top: t,
	bottom: t,
	left: t,
	right: t
});
function parsePadding(t) {
	return isObject(t) ? t.signal ? t : {
		top: number(t.top),
		bottom: number(t.bottom),
		left: number(t.left),
		right: number(t.right)
	} : paddingObject(number(t));
}
var encoder = (t) => isObject(t) && !isArray(t) ? extend({}, t) : { value: t };
function addEncode(t, n, r, i) {
	return r == null ? 0 : (isObject(r) && !isArray(r) || isArray(r) && r.length && isObject(r[0]) ? t.update[n] = r : t[i || "enter"][n] = { value: r }, 1);
}
function addEncoders(t, n, r) {
	for (let r in n) addEncode(t, r, n[r]);
	for (let n in r) addEncode(t, n, r[n], "update");
}
function extendEncode(t, n, r) {
	for (let i in n) r && has(r, i) || (t[i] = extend(t[i] || {}, n[i]));
	return t;
}
function has$1(t, n) {
	return n && (n.enter && n.enter[t] || n.update && n.update[t]);
}
var FrameRole = "frame", ScopeRole = "scope", AxisRole = "axis", AxisDomainRole = "axis-domain", AxisGridRole = "axis-grid", AxisLabelRole = "axis-label", AxisTickRole = "axis-tick", AxisTitleRole = "axis-title", LegendRole = "legend", LegendBandRole = "legend-band", LegendEntryRole = "legend-entry", LegendGradientRole = "legend-gradient", LegendLabelRole = "legend-label", LegendSymbolRole = "legend-symbol", LegendTitleRole = "legend-title", TitleRole = "title", TitleTextRole = "title-text", TitleSubtitleRole = "title-subtitle";
function applyDefaults(t, n, r, i, o) {
	let s = {}, l = {}, u, d, f, p;
	for (d in d = "lineBreak", n === "text" && o[d] != null && !has$1(d, t) && applyDefault(s, d, o[d]), (r == "legend" || String(r).startsWith("axis")) && (r = null), p = r === "frame" ? o.group : r === "mark" ? extend({}, o.mark, o[n]) : null, p) f = has$1(d, t) || (d === "fill" || d === "stroke") && (has$1("fill", t) || has$1("stroke", t)), f || applyDefault(s, d, p[d]);
	for (d in array(i).forEach((n) => {
		let r = o.style && o.style[n];
		for (let n in r) has$1(n, t) || applyDefault(s, n, r[n]);
	}), t = extend({}, t), s) p = s[d], p.signal ? (u ||= {})[d] = p : l[d] = p;
	return t.enter = extend(l, t.enter), u && (t.update = extend(u, t.update)), t;
}
function applyDefault(t, n, r) {
	t[n] = r && r.signal ? { signal: r.signal } : { value: r };
}
var scaleRef = (t) => isString(t) ? $(t) : t.signal ? `(${t.signal})` : field(t);
function entry$1(t) {
	if (t.gradient != null) return gradient$1(t);
	let n = t.signal ? `(${t.signal})` : t.color ? color$1(t.color) : t.field == null ? t.value === void 0 ? void 0 : $(t.value) : field(t.field);
	return t.scale != null && (n = scale$1(t, n)), n === void 0 && (n = null), t.exponent != null && (n = `pow(${n},${property(t.exponent)})`), t.mult != null && (n += `*${property(t.mult)}`), t.offset != null && (n += `+${property(t.offset)}`), t.round && (n = `round(${n})`), n;
}
var _color = (t, n, r, i) => `(${t}(${[
	n,
	r,
	i
].map(entry$1).join(",")})+'')`;
function color$1(t) {
	return t.c ? _color("hcl", t.h, t.c, t.l) : t.h || t.s ? _color("hsl", t.h, t.s, t.l) : t.l || t.a ? _color("lab", t.l, t.a, t.b) : t.r || t.g || t.b ? _color("rgb", t.r, t.g, t.b) : null;
}
function gradient$1(t) {
	let n = [
		t.start,
		t.stop,
		t.count
	].map((t) => t == null ? null : $(t));
	for (; n.length && peek(n) == null;) n.pop();
	return n.unshift(scaleRef(t.gradient)), `gradient(${n.join(",")})`;
}
function property(t) {
	return isObject(t) ? "(" + entry$1(t) + ")" : t;
}
function field(t) {
	return resolveField(isObject(t) ? t : { datum: t });
}
function resolveField(t) {
	let n, r, i;
	if (t.signal) n = "datum", i = t.signal;
	else if (t.group || t.parent) {
		for (r = Math.max(1, t.level || 1), n = "item"; r-- > 0;) n += ".mark.group";
		t.parent ? (i = t.parent, n += ".datum") : i = t.group;
	} else t.datum ? (n = "datum", i = t.datum) : error$1("Invalid field reference: " + $(t));
	return t.signal || (i = isString(i) ? splitAccessPath(i).map($).join("][") : resolveField(i)), n + "[" + i + "]";
}
function scale$1(t, n) {
	let r = scaleRef(t.scale);
	return t.range == null ? (n !== void 0 && (n = `_scale(${r}, ${n})`), t.band && (n = (n ? n + "+" : "") + `_bandwidth(${r})` + (+t.band == 1 ? "" : "*" + property(t.band)), t.extra && (n = `(datum.extra ? _scale(${r}, datum.extra.value) : ${n})`)), n ??= "0") : n = `lerp(_range(${r}), ${+t.range})`, n;
}
function rule$1(t) {
	let n = "";
	return t.forEach((t) => {
		let r = entry$1(t);
		n += t.test ? `(${t.test})?${r}:` : r;
	}), peek(n) === ":" && (n += "null"), n;
}
function parseEncode(t, n, r, i, o, s) {
	let l = {};
	for (let u in s ||= {}, s.encoders = { $encode: l }, t = applyDefaults(t, n, r, i, o.config), t) l[u] = parseBlock(t[u], n, s, o);
	return s;
}
function parseBlock(t, n, r, i) {
	let o = {}, s = {};
	for (let n in t) t[n] != null && (o[n] = parse$1(expr(t[n]), i, r, s));
	return {
		$expr: {
			marktype: n,
			channels: o
		},
		$fields: Object.keys(s),
		$output: Object.keys(t)
	};
}
function expr(t) {
	return isArray(t) ? rule$1(t) : entry$1(t);
}
function parse$1(t, n, r, i) {
	let o = parser$1(t, n);
	return o.$fields.forEach((t) => i[t] = 1), extend(r, o.$params), o.$expr;
}
var OUTER = "outer", OUTER_INVALID = [
	"value",
	"update",
	"init",
	"react",
	"bind"
];
function outerError(t, n) {
	error$1(t + " for \"outer\" push: " + $(n));
}
function parseSignal(t, n) {
	let r = t.name;
	if (t.push === OUTER) n.signals[r] || outerError("No prior signal definition", r), OUTER_INVALID.forEach((n) => {
		t[n] !== void 0 && outerError("Invalid property ", n);
	});
	else {
		let i = n.addSignal(r, t.value);
		t.react === !1 && (i.react = !1), t.bind && n.addBinding(r, t.bind);
	}
}
function Entry(t, n, r, i) {
	this.id = -1, this.type = t, this.value = n, this.params = r, i && (this.parent = i);
}
function entry(t, n, r, i) {
	return new Entry(t, n, r, i);
}
function operator(t, n) {
	return entry("operator", t, n);
}
function ref(t) {
	let n = { $ref: t.id };
	return t.id < 0 && (t.refs = t.refs || []).push(n), n;
}
function fieldRef$1(t, n) {
	return n ? {
		$field: t,
		$name: n
	} : { $field: t };
}
var keyFieldRef = fieldRef$1("key");
function compareRef(t, n) {
	return {
		$compare: t,
		$order: n
	};
}
function keyRef(t, n) {
	let r = { $key: t };
	return n && (r.$flat = !0), r;
}
var Ascending = "ascending", Descending = "descending";
function sortKey(t) {
	return isObject(t) ? (t.order === Descending ? "-" : "+") + aggrField(t.op, t.field) : "";
}
function aggrField(t, n) {
	return (t && t.signal ? "$" + t.signal : t || "") + (t && n ? "_" : "") + (n && n.signal ? "$" + n.signal : n || "");
}
var Scope$1 = "scope", View$1 = "view";
function isSignal(t) {
	return t && t.signal;
}
function isExpr$1(t) {
	return t && t.expr;
}
function hasSignal(t) {
	if (isSignal(t)) return !0;
	if (isObject(t)) {
		for (let n in t) if (hasSignal(t[n])) return !0;
	}
	return !1;
}
function value(t, n) {
	return t ?? n;
}
function deref(t) {
	return t && t.signal || t;
}
var Timer = "timer";
function parseStream(t, n) {
	return (t.merge ? mergeStream : t.stream ? nestedStream : t.type ? eventStream : error$1("Invalid stream specification: " + $(t)))(t, n);
}
function eventSource(t) {
	return t === Scope$1 ? View$1 : t || View$1;
}
function mergeStream(t, n) {
	let r = streamParameters({ merge: t.merge.map((t) => parseStream(t, n)) }, t, n);
	return n.addStream(r).id;
}
function nestedStream(t, n) {
	let r = streamParameters({ stream: parseStream(t.stream, n) }, t, n);
	return n.addStream(r).id;
}
function eventStream(t, n) {
	let r;
	t.type === Timer ? (r = n.event(Timer, t.throttle), t = {
		between: t.between,
		filter: t.filter
	}) : r = n.event(eventSource(t.source), t.type);
	let i = streamParameters({ stream: r }, t, n);
	return Object.keys(i).length === 1 ? r : n.addStream(i).id;
}
function streamParameters(t, n, r) {
	let i = n.between;
	return i && (i.length !== 2 && error$1("Stream \"between\" parameter must have 2 entries: " + $(n)), t.between = [parseStream(i[0], r), parseStream(i[1], r)]), i = n.filter ? [].concat(n.filter) : [], (n.marktype || n.markname || n.markrole) && i.push(filterMark(n.marktype, n.markname, n.markrole)), n.source === Scope$1 && i.push("inScope(event.item)"), i.length && (t.filter = parser$1("(" + i.join(")&&(") + ")", r).$expr), (i = n.throttle) != null && (t.throttle = +i), (i = n.debounce) != null && (t.debounce = +i), n.consume && (t.consume = !0), t;
}
function filterMark(t, n, r) {
	let i = "event.item";
	return i + (t && t !== "*" ? "&&" + i + ".mark.marktype==='" + t + "'" : "") + (r ? "&&" + i + ".mark.role==='" + r + "'" : "") + (n ? "&&" + i + ".mark.name==='" + n + "'" : "");
}
var OP_VALUE_EXPR = {
	code: "_.$value",
	ast: {
		type: "Identifier",
		value: "value"
	}
};
function parseUpdate(t, n, r) {
	let i = t.encode, o = { target: r }, s = t.events, l = t.update, u = [];
	s || error$1("Signal update missing events specification."), isString(s) && (s = eventSelector(s, n.isSubscope() ? Scope$1 : View$1)), s = array(s).filter((t) => t.signal || t.scale ? (u.push(t), 0) : 1), u.length > 1 && (u = [mergeSources(u)]), s.length && u.push(s.length > 1 ? { merge: s } : s[0]), i != null && (l && error$1("Signal encode and update are mutually exclusive."), l = "encode(item()," + $(i) + ")"), o.update = isString(l) ? parser$1(l, n) : l.expr == null ? l.value == null ? l.signal == null ? error$1("Invalid signal update specification.") : {
		$expr: OP_VALUE_EXPR,
		$params: { $value: n.signalRef(l.signal) }
	} : l.value : parser$1(l.expr, n), t.force && (o.options = { force: !0 }), u.forEach((t) => n.addUpdate(extend(streamSource(t, n), o)));
}
function streamSource(t, n) {
	return { source: t.signal ? n.signalRef(t.signal) : t.scale ? n.scaleRef(t.scale) : parseStream(t, n) };
}
function mergeSources(t) {
	return { signal: "[" + t.map((t) => t.scale ? "scale(\"" + t.scale + "\")" : t.signal) + "]" };
}
function parseSignalUpdates(t, n) {
	let r = n.getSignal(t.name), i = t.update;
	t.init && (i ? error$1("Signals can not include both init and update expressions.") : (i = t.init, r.initonly = !0)), i && (i = parser$1(i, n), r.update = i.$expr, r.params = i.$params), t.on && t.on.forEach((t) => parseUpdate(t, n, r.id));
}
var transform$1 = (t) => (n, r, i) => entry(t, r, n || void 0, i), Aggregate = transform$1("aggregate"), AxisTicks = transform$1("axisticks"), Bound = transform$1("bound"), Collect = transform$1("collect"), Compare = transform$1("compare"), DataJoin = transform$1("datajoin"), Encode = transform$1("encode"), Expression = transform$1("expression"), Facet = transform$1("facet"), Field = transform$1("field"), Key = transform$1("key"), LegendEntries = transform$1("legendentries"), Load = transform$1("load"), Mark$1 = transform$1("mark"), MultiExtent = transform$1("multiextent"), MultiValues = transform$1("multivalues"), Overlap = transform$1("overlap"), Params = transform$1("params"), PreFacet = transform$1("prefacet"), Projection = transform$1("projection"), Proxy = transform$1("proxy"), Relay = transform$1("relay"), Render = transform$1("render"), Scale = transform$1("scale"), Sieve = transform$1("sieve"), SortItems = transform$1("sortitems"), ViewLayout = transform$1("viewlayout"), Values = transform$1("values"), FIELD_REF_ID = 0, MULTIDOMAIN_SORT_OPS = {
	min: "min",
	max: "max",
	count: "sum"
};
function initScale(t, n) {
	let r = t.type || "linear";
	isValidScaleType(r) || error$1("Unrecognized scale type: " + $(r)), n.addScale(t.name, {
		type: r,
		domain: void 0
	});
}
function parseScale(t, n) {
	let r = n.getScale(t.name).params, i;
	for (i in r.domain = parseScaleDomain$1(t.domain, t, n), t.range != null && (r.range = parseScaleRange$1(t, n, r)), t.interpolate != null && parseScaleInterpolate(t.interpolate, r), t.nice != null && (r.nice = parseScaleNice(t.nice, n)), t.bins != null && (r.bins = parseScaleBins(t.bins, n)), t) has(r, i) || i === "name" || (r[i] = parseLiteral(t[i], n));
}
function parseLiteral(t, n) {
	return isObject(t) ? t.signal ? n.signalRef(t.signal) : error$1("Unsupported object: " + $(t)) : t;
}
function parseArray(t, n) {
	return t.signal ? n.signalRef(t.signal) : t.map((t) => parseLiteral(t, n));
}
function dataLookupError(t) {
	error$1("Can not find data set: " + $(t));
}
function parseScaleDomain$1(t, n, r) {
	if (!t) {
		(n.domainMin != null || n.domainMax != null) && error$1("No scale domain defined for domainMin/domainMax to override.");
		return;
	}
	return t.signal ? r.signalRef(t.signal) : (isArray(t) ? explicitDomain : t.fields ? multipleDomain : singularDomain)(t, n, r);
}
function explicitDomain(t, n, r) {
	return t.map((t) => parseLiteral(t, r));
}
function singularDomain(t, n, r) {
	let i = r.getData(t.data);
	return i || dataLookupError(t.data), isDiscrete$2(n.type) ? i.valuesRef(r, t.field, parseSort(t.sort, !1)) : isQuantile$1(n.type) ? i.domainRef(r, t.field) : i.extentRef(r, t.field);
}
function multipleDomain(t, n, r) {
	let i = t.data, o = t.fields.reduce((t, n) => (n = isString(n) ? {
		data: i,
		field: n
	} : isArray(n) || n.signal ? fieldRef(n, r) : n, t.push(n), t), []);
	return (isDiscrete$2(n.type) ? ordinalMultipleDomain : isQuantile$1(n.type) ? quantileMultipleDomain : numericMultipleDomain)(t, r, o);
}
function fieldRef(t, n) {
	let r = "_:vega:_" + FIELD_REF_ID++, i = Collect({});
	if (isArray(t)) i.value = { $ingest: t };
	else if (t.signal) {
		let o = "setdata(" + $(r) + "," + t.signal + ")";
		i.params.input = n.signalRef(o);
	}
	return n.addDataPipeline(r, [i, Sieve({})]), {
		data: r,
		field: "data"
	};
}
function ordinalMultipleDomain(t, n, r) {
	let i = parseSort(t.sort, !0), o, s, l = {
		groupby: keyFieldRef,
		pulse: r.map((t) => {
			let r = n.getData(t.data);
			return r || dataLookupError(t.data), r.countsRef(n, t.field, i);
		})
	};
	i && (o = i.op || "count", s = i.field ? aggrField(o, i.field) : "count", l.ops = [MULTIDOMAIN_SORT_OPS[o]], l.fields = [n.fieldRef(s)], l.as = [s]), o = n.add(Aggregate(l));
	let u = n.add(Collect({ pulse: ref(o) }));
	return s = n.add(Values({
		field: keyFieldRef,
		sort: n.sortRef(i),
		pulse: ref(u)
	})), ref(s);
}
function parseSort(t, n) {
	return t && (!t.field && !t.op ? isObject(t) ? t.field = "key" : t = { field: "key" } : !t.field && t.op !== "count" ? error$1("No field provided for sort aggregate op: " + t.op) : n && t.field && t.op && !MULTIDOMAIN_SORT_OPS[t.op] && error$1("Multiple domain scales can not be sorted using " + t.op)), t;
}
function quantileMultipleDomain(t, n, r) {
	let i = r.map((t) => {
		let r = n.getData(t.data);
		return r || dataLookupError(t.data), r.domainRef(n, t.field);
	});
	return ref(n.add(MultiValues({ values: i })));
}
function numericMultipleDomain(t, n, r) {
	let i = r.map((t) => {
		let r = n.getData(t.data);
		return r || dataLookupError(t.data), r.extentRef(n, t.field);
	});
	return ref(n.add(MultiExtent({ extents: i })));
}
function parseScaleBins(t, n) {
	return t.signal || isArray(t) ? parseArray(t, n) : n.objectProperty(t);
}
function parseScaleNice(t, n) {
	return t.signal ? n.signalRef(t.signal) : isObject(t) ? {
		interval: parseLiteral(t.interval),
		step: parseLiteral(t.step)
	} : parseLiteral(t);
}
function parseScaleInterpolate(t, n) {
	n.interpolate = parseLiteral(t.type || t), t.gamma != null && (n.interpolateGamma = parseLiteral(t.gamma));
}
function parseScaleRange$1(t, n, r) {
	let i = n.config.range, o = t.range;
	if (o.signal) return n.signalRef(o.signal);
	if (isString(o)) {
		if (i && has(i, o)) return t = extend({}, t, { range: i[o] }), parseScaleRange$1(t, n, r);
		o === "width" ? o = [0, { signal: "width" }] : o === "height" ? o = isDiscrete$2(t.type) ? [0, { signal: "height" }] : [{ signal: "height" }, 0] : error$1("Unrecognized scale range value: " + $(o));
	} else if (o.scheme) {
		r.scheme = isArray(o.scheme) ? parseArray(o.scheme, n) : parseLiteral(o.scheme, n), o.extent && (r.schemeExtent = parseArray(o.extent, n)), o.count && (r.schemeCount = parseLiteral(o.count, n));
		return;
	} else if (o.step) {
		r.rangeStep = parseLiteral(o.step, n);
		return;
	} else if (isDiscrete$2(t.type) && !isArray(o)) return parseScaleDomain$1(o, t, n);
	else isArray(o) || error$1("Unsupported range type: " + $(o));
	return o.map((t) => (isArray(t) ? parseArray : parseLiteral)(t, n));
}
function parseProjection$1(t, n) {
	let r = n.config.projection || {}, i = {};
	for (let r in t) r !== "name" && (i[r] = parseParameter$1(t[r], r, n));
	for (let t in r) i[t] ?? (i[t] = parseParameter$1(r[t], t, n));
	n.addProjection(t.name, i);
}
function parseParameter$1(t, n, r) {
	return isArray(t) ? t.map((t) => parseParameter$1(t, n, r)) : isObject(t) ? t.signal ? r.signalRef(t.signal) : n === "fit" ? t : error$1("Unsupported parameter object: " + $(t)) : t;
}
var Top = "top", Left = "left", Right = "right", Bottom = "bottom", Center = "center", Vertical = "vertical", Start = "start", Middle = "middle", End = "end", Index = "index", Label = "label", Offset = "offset", Perc = "perc", Value = "value", GuideLabelStyle = "guide-label", GuideTitleStyle = "guide-title", GroupTitleStyle = "group-title", GroupSubtitleStyle = "group-subtitle", Symbols = "symbol", Gradient = "gradient", Discrete = "discrete", Size = "size", LegendScales = [
	Size,
	"shape",
	"fill",
	"stroke",
	"strokeWidth",
	"strokeDash",
	"opacity"
], Skip = {
	name: 1,
	style: 1,
	interactive: 1
}, zero$1 = { value: 0 }, one = { value: 1 }, GroupMark = "group", RectMark = "rect", RuleMark = "rule", SymbolMark = "symbol", TextMark = "text";
function guideGroup(t) {
	return t.type = GroupMark, t.interactive = t.interactive || !1, t;
}
function lookup(t, n) {
	let r = (r, i) => value(t[r], value(n[r], i));
	return r.isVertical = (r) => Vertical === value(t.direction, n.direction || (r ? n.symbolDirection : n.gradientDirection)), r.gradientLength = () => value(t.gradientLength, n.gradientLength || n.gradientWidth), r.gradientThickness = () => value(t.gradientThickness, n.gradientThickness || n.gradientHeight), r.entryColumns = () => value(t.columns, value(n.columns, +r.isVertical(!0))), r;
}
function getEncoding(t, n) {
	let r = n && (n.update && n.update[t] || n.enter && n.enter[t]);
	return r && r.signal ? r : r ? r.value : null;
}
function getStyle(t, n, r) {
	let i = n.config.style[r];
	return i && i[t];
}
function anchorExpr(t, n, r) {
	return `item.anchor === '${Start}' ? ${t} : item.anchor === '${End}' ? ${n} : ${r}`;
}
var alignExpr$1 = anchorExpr($(Left), $(Right), $(Center));
function tickBand(t) {
	let n = t("tickBand"), r = t("tickOffset"), i, o;
	return n ? n.signal ? (i = { signal: `(${n.signal}) === 'extent' ? 1 : 0.5` }, o = { signal: `(${n.signal}) === 'extent'` }, isObject(r) || (r = { signal: `(${n.signal}) === 'extent' ? 0 : ${r}` })) : n === "extent" ? (i = 1, o = !0, r = 0) : (i = .5, o = !1) : (i = t("bandPosition"), o = t("tickExtra")), {
		extra: o,
		band: i,
		offset: r
	};
}
function extendOffset(t, n) {
	return n ? t ? isObject(t) ? Object.assign({}, t, { offset: extendOffset(t.offset, n) }) : {
		value: t,
		offset: n
	} : n : t;
}
function guideMark(t, n) {
	return n ? (t.name = n.name, t.style = n.style || t.style, t.interactive = !!n.interactive, t.encode = extendEncode(t.encode, n, Skip)) : t.interactive = !1, t;
}
function legendGradient(t, n, r, i) {
	let o = lookup(t, r), s = o.isVertical(), l = o.gradientThickness(), u = o.gradientLength(), d, f, p, g, _;
	s ? (f = [0, 1], p = [0, 0], g = l, _ = u) : (f = [0, 0], p = [1, 0], g = u, _ = l);
	let v = {
		enter: d = {
			opacity: zero$1,
			x: zero$1,
			y: zero$1,
			width: encoder(g),
			height: encoder(_)
		},
		update: extend({}, d, {
			opacity: one,
			fill: {
				gradient: n,
				start: f,
				stop: p
			}
		}),
		exit: { opacity: zero$1 }
	};
	return addEncoders(v, {
		stroke: o("gradientStrokeColor"),
		strokeWidth: o("gradientStrokeWidth")
	}, { opacity: o("gradientOpacity") }), guideMark({
		type: RectMark,
		role: LegendGradientRole,
		encode: v
	}, i);
}
function legendGradientDiscrete(t, n, r, i, o) {
	let s = lookup(t, r), l = s.isVertical(), u = s.gradientThickness(), d = s.gradientLength(), f, p, g, _, v = "";
	l ? (f = "y", g = "y2", p = "x", _ = "width", v = "1-") : (f = "x", g = "x2", p = "y", _ = "height");
	let S = {
		opacity: zero$1,
		fill: {
			scale: n,
			field: Value
		}
	};
	S[f] = {
		signal: v + "datum.perc",
		mult: d
	}, S[p] = zero$1, S[g] = {
		signal: v + "datum.perc2",
		mult: d
	}, S[_] = encoder(u);
	let T = {
		enter: S,
		update: extend({}, S, { opacity: one }),
		exit: { opacity: zero$1 }
	};
	return addEncoders(T, {
		stroke: s("gradientStrokeColor"),
		strokeWidth: s("gradientStrokeWidth")
	}, { opacity: s("gradientOpacity") }), guideMark({
		type: RectMark,
		role: LegendBandRole,
		key: Value,
		from: o,
		encode: T
	}, i);
}
var alignExpr = `datum.${Perc}<=0?"${Left}":datum.${Perc}>=1?"${Right}":"${Center}"`, baselineExpr = `datum.${Perc}<=0?"${Bottom}":datum.${Perc}>=1?"${Top}":"${Middle}"`;
function legendGradientLabels(t, n, r, i) {
	let o = lookup(t, n), s = o.isVertical(), l = encoder(o.gradientThickness()), u = o.gradientLength(), d = o("labelOverlap"), f, p, g, _, v = "", S = {
		enter: f = { opacity: zero$1 },
		update: p = {
			opacity: one,
			text: { field: Label }
		},
		exit: { opacity: zero$1 }
	};
	return addEncoders(S, {
		fill: o("labelColor"),
		fillOpacity: o("labelOpacity"),
		font: o("labelFont"),
		fontSize: o("labelFontSize"),
		fontStyle: o("labelFontStyle"),
		fontWeight: o("labelFontWeight"),
		limit: value(t.labelLimit, n.gradientLabelLimit)
	}), s ? (f.align = { value: "left" }, f.baseline = p.baseline = { signal: baselineExpr }, g = "y", _ = "x", v = "1-") : (f.align = p.align = { signal: alignExpr }, f.baseline = { value: "top" }, g = "x", _ = "y"), f[g] = p[g] = {
		signal: v + "datum.perc",
		mult: u
	}, f[_] = p[_] = l, l.offset = value(t.labelOffset, n.gradientLabelOffset) || 0, d = d ? {
		separation: o("labelSeparation"),
		method: d,
		order: "datum." + Index
	} : void 0, guideMark({
		type: TextMark,
		role: LegendLabelRole,
		style: GuideLabelStyle,
		key: Value,
		from: i,
		encode: S,
		overlap: d
	}, r);
}
function legendSymbolGroups(t, n, r, i, o) {
	let s = lookup(t, n), l = r.entries, u = !!(l && l.interactive), d = l ? l.name : void 0, f = s("clipHeight"), p = s("symbolOffset"), g = { data: "value" }, _ = `(${o}) ? datum.${Offset} : datum.${Size}`, v = f ? encoder(f) : { field: Size }, S = `datum.${Index}`, T = `max(1, ${o})`, E, O, k, A, j;
	v.mult = .5, E = {
		enter: O = {
			opacity: zero$1,
			x: {
				signal: _,
				mult: .5,
				offset: p
			},
			y: v
		},
		update: k = {
			opacity: one,
			x: O.x,
			y: O.y
		},
		exit: { opacity: zero$1 }
	};
	let N = null, P = null;
	t.fill || (N = n.symbolBaseFillColor, P = n.symbolBaseStrokeColor), addEncoders(E, {
		fill: s("symbolFillColor", N),
		shape: s("symbolType"),
		size: s("symbolSize"),
		stroke: s("symbolStrokeColor", P),
		strokeDash: s("symbolDash"),
		strokeDashOffset: s("symbolDashOffset"),
		strokeWidth: s("symbolStrokeWidth")
	}, { opacity: s("symbolOpacity") }), LegendScales.forEach((n) => {
		t[n] && (k[n] = O[n] = {
			scale: t[n],
			field: Value
		});
	});
	let F = guideMark({
		type: SymbolMark,
		role: LegendSymbolRole,
		key: Value,
		from: g,
		clip: f ? !0 : void 0,
		encode: E
	}, r.symbols), I = encoder(p);
	I.offset = s("labelOffset"), E = {
		enter: O = {
			opacity: zero$1,
			x: {
				signal: _,
				offset: I
			},
			y: v
		},
		update: k = {
			opacity: one,
			text: { field: Label },
			x: O.x,
			y: O.y
		},
		exit: { opacity: zero$1 }
	}, addEncoders(E, {
		align: s("labelAlign"),
		baseline: s("labelBaseline"),
		fill: s("labelColor"),
		fillOpacity: s("labelOpacity"),
		font: s("labelFont"),
		fontSize: s("labelFontSize"),
		fontStyle: s("labelFontStyle"),
		fontWeight: s("labelFontWeight"),
		limit: s("labelLimit")
	});
	let L = guideMark({
		type: TextMark,
		role: LegendLabelRole,
		style: GuideLabelStyle,
		key: Value,
		from: g,
		encode: E
	}, r.labels);
	return E = {
		enter: {
			noBound: { value: !f },
			width: zero$1,
			height: f ? encoder(f) : zero$1,
			opacity: zero$1
		},
		exit: { opacity: zero$1 },
		update: k = {
			opacity: one,
			row: { signal: null },
			column: { signal: null }
		}
	}, s.isVertical(!0) ? (A = `ceil(item.mark.items.length / ${T})`, k.row.signal = `${S}%${A}`, k.column.signal = `floor(${S} / ${A})`, j = { field: ["row", S] }) : (k.row.signal = `floor(${S} / ${T})`, k.column.signal = `${S} % ${T}`, j = { field: S }), k.column.signal = `(${o})?${k.column.signal}:${S}`, i = { facet: {
		data: i,
		name: "value",
		groupby: Index
	} }, guideGroup({
		role: ScopeRole,
		from: i,
		encode: extendEncode(E, l, Skip),
		marks: [F, L],
		name: d,
		interactive: u,
		sort: j
	});
}
function legendSymbolLayout(t, n) {
	let r = lookup(t, n);
	return {
		align: r("gridAlign"),
		columns: r.entryColumns(),
		center: {
			row: !0,
			column: !1
		},
		padding: {
			row: r("rowPadding"),
			column: r("columnPadding")
		}
	};
}
var isL = "item.orient === \"left\"", isR = "item.orient === \"right\"", isLR = `(${isL} || ${isR})`, isVG = `datum.vgrad && ${isLR}`, baseline$1 = anchorExpr("\"top\"", "\"bottom\"", "\"middle\""), exprAlign = `datum.vgrad && ${isR} ? (${anchorExpr("\"right\"", "\"left\"", "\"center\"")}) : (${isLR} && !(datum.vgrad && ${isL})) ? "left" : ${alignExpr$1}`, exprAnchor = `item._anchor || (${isLR} ? "middle" : "start")`, exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`, exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? "bottom" : "top") : ${baseline$1}) : "top"`;
function legendTitle(t, n, r, i) {
	let o = lookup(t, n), s = {
		enter: { opacity: zero$1 },
		update: {
			opacity: one,
			x: { field: { group: "padding" } },
			y: { field: { group: "padding" } }
		},
		exit: { opacity: zero$1 }
	};
	return addEncoders(s, {
		orient: o("titleOrient"),
		_anchor: o("titleAnchor"),
		anchor: { signal: exprAnchor },
		angle: { signal: exprAngle },
		align: { signal: exprAlign },
		baseline: { signal: exprBaseline },
		text: t.title,
		fill: o("titleColor"),
		fillOpacity: o("titleOpacity"),
		font: o("titleFont"),
		fontSize: o("titleFontSize"),
		fontStyle: o("titleFontStyle"),
		fontWeight: o("titleFontWeight"),
		limit: o("titleLimit"),
		lineHeight: o("titleLineHeight")
	}, {
		align: o("titleAlign"),
		baseline: o("titleBaseline")
	}), guideMark({
		type: TextMark,
		role: LegendTitleRole,
		style: GuideTitleStyle,
		from: i,
		encode: s
	}, r);
}
function clip(t, n) {
	let r;
	return isObject(t) && (t.signal ? r = t.signal : t.path ? r = "pathShape(" + param(t.path) + ")" : t.sphere && (r = "geoShape(" + param(t.sphere) + ", {type: \"Sphere\"})")), r ? n.signalRef(r) : !!t;
}
function param(t) {
	return isObject(t) && t.signal ? t.signal : $(t);
}
function getRole(t) {
	let n = t.role || "";
	return n.startsWith("axis") || n.startsWith("legend") || n.startsWith("title") ? n : t.type === GroupMark ? ScopeRole : n || "mark";
}
function definition$1(t) {
	return {
		marktype: t.type,
		name: t.name || void 0,
		role: t.role || getRole(t),
		zindex: +t.zindex || void 0,
		aria: t.aria,
		description: t.description
	};
}
function interactive(t, n) {
	return t && t.signal ? n.signalRef(t.signal) : t !== !1;
}
function parseTransform(t, n) {
	let r = definition(t.type);
	r || error$1("Unrecognized transform type: " + $(t.type));
	let i = entry(r.type.toLowerCase(), null, parseParameters(r, t, n));
	return t.signal && n.addSignal(t.signal, n.proxy(i)), i.metadata = r.metadata || {}, i;
}
function parseParameters(t, n, r) {
	let i = {}, o = t.params.length;
	for (let s = 0; s < o; ++s) {
		let o = t.params[s];
		i[o.name] = parseParameter(o, n, r);
	}
	return i;
}
function parseParameter(t, n, r) {
	let i = t.type, o = n[t.name];
	if (i === "index") return parseIndexParameter(t, n, r);
	if (o === void 0) {
		t.required && error$1("Missing required " + $(n.type) + " parameter: " + $(t.name));
		return;
	} else if (i === "param") return parseSubParameters(t, n, r);
	else if (i === "projection") return r.projectionRef(n[t.name]);
	return t.array && !isSignal(o) ? o.map((n) => parameterValue(t, n, r)) : parameterValue(t, o, r);
}
function parameterValue(t, n, r) {
	let i = t.type;
	if (isSignal(n)) return isExpr(i) ? error$1("Expression references can not be signals.") : isField(i) ? r.fieldRef(n) : isCompare(i) ? r.compareRef(n) : r.signalRef(n.signal);
	{
		let o = t.expr || isField(i);
		return o && outerExpr(n) ? r.exprRef(n.expr, n.as) : o && outerField(n) ? fieldRef$1(n.field, n.as) : isExpr(i) ? parser$1(n, r) : isData(i) ? ref(r.getData(n).values) : isField(i) ? fieldRef$1(n) : isCompare(i) ? r.compareRef(n) : n;
	}
}
function parseIndexParameter(t, n, r) {
	return isString(n.from) || error$1("Lookup \"from\" parameter must be a string literal."), r.getData(n.from).lookupRef(r, n.key);
}
function parseSubParameters(t, n, r) {
	let i = n[t.name];
	return t.array ? (isArray(i) || error$1("Expected an array of sub-parameters. Instead: " + $(i)), i.map((n) => parseSubParameter(t, n, r))) : parseSubParameter(t, i, r);
}
function parseSubParameter(t, n, r) {
	let i = t.params.length, o;
	for (let r = 0; r < i; ++r) {
		for (let i in o = t.params[r], o.key) if (o.key[i] !== n[i]) {
			o = null;
			break;
		}
		if (o) break;
	}
	o || error$1("Unsupported parameter: " + $(n));
	let s = extend(parseParameters(o, n, r), o.key);
	return ref(r.add(Params(s)));
}
var outerExpr = (t) => t && t.expr, outerField = (t) => t && t.field, isData = (t) => t === "data", isExpr = (t) => t === "expr", isField = (t) => t === "field", isCompare = (t) => t === "compare";
function parseData$1(t, n, r) {
	let i, o, s, l, u;
	return t ? (i = t.facet) && (n || error$1("Only group marks can be faceted."), i.field == null ? (t.data ? u = ref(r.getData(t.data).aggregate) : (s = parseTransform(extend({
		type: "aggregate",
		groupby: array(i.groupby)
	}, i.aggregate), r), s.params.key = r.keyRef(i.groupby), s.params.pulse = getDataRef(i, r), l = u = ref(r.add(s))), o = r.keyRef(i.groupby, !0)) : l = u = getDataRef(i, r)) : l = ref(r.add(Collect(null, [{}]))), l ||= getDataRef(t, r), {
		key: o,
		pulse: l,
		parent: u
	};
}
function getDataRef(t, n) {
	return t.$ref ? t : t.data && t.data.$ref ? t.data : ref(n.getData(t.data).output);
}
function DataScope(t, n, r, i, o) {
	this.scope = t, this.input = n, this.output = r, this.values = i, this.aggregate = o, this.index = {};
}
DataScope.fromEntries = function(t, n) {
	let r = n.length, i = n[r - 1], o = n[r - 2], s = n[0], l = null, u = 1;
	for (s && s.type === "load" && (s = n[1]), t.add(n[0]); u < r; ++u) n[u].params.pulse = ref(n[u - 1]), t.add(n[u]), n[u].type === "aggregate" && (l = n[u]);
	return new DataScope(t, s, o, i, l);
};
function fieldKey(t) {
	return isString(t) ? t : null;
}
function addSortField(t, n, r) {
	let i = aggrField(r.op, r.field), o;
	if (n.ops) {
		for (let t = 0, r = n.as.length; t < r; ++t) if (n.as[t] === i) return;
	} else n.ops = ["count"], n.fields = [null], n.as = ["count"];
	r.op && (n.ops.push((o = r.op.signal) ? t.signalRef(o) : r.op), n.fields.push(t.fieldRef(r.field)), n.as.push(i));
}
function cache(t, n, r, i, o, s, l) {
	let u = n[r] || (n[r] = {}), d = sortKey(s), f = fieldKey(o), p, g;
	if (f != null && (t = n.scope, f += d ? "|" + d : "", p = u[f]), !p) {
		let r = s ? {
			field: keyFieldRef,
			pulse: n.countsRef(t, o, s)
		} : {
			field: t.fieldRef(o),
			pulse: ref(n.output)
		};
		d && (r.sort = t.sortRef(s)), g = t.add(entry(i, void 0, r)), l && (n.index[o] = g), p = ref(g), f != null && (u[f] = p);
	}
	return p;
}
DataScope.prototype = {
	countsRef(t, n, r) {
		let i = this, o = i.counts ||= {}, s = fieldKey(n), l, u, d;
		return s != null && (t = i.scope, l = o[s]), l ? r && r.field && addSortField(t, l.agg.params, r) : (d = {
			groupby: t.fieldRef(n, "key"),
			pulse: ref(i.output)
		}, r && r.field && addSortField(t, d, r), u = t.add(Aggregate(d)), l = t.add(Collect({ pulse: ref(u) })), l = {
			agg: u,
			ref: ref(l)
		}, s != null && (o[s] = l)), l.ref;
	},
	tuplesRef() {
		return ref(this.values);
	},
	extentRef(t, n) {
		return cache(t, this, "extent", "extent", n, !1);
	},
	domainRef(t, n) {
		return cache(t, this, "domain", "values", n, !1);
	},
	valuesRef(t, n, r) {
		return cache(t, this, "vals", "values", n, r || !0);
	},
	lookupRef(t, n) {
		return cache(t, this, "lookup", "tupleindex", n, !1);
	},
	indataRef(t, n) {
		return cache(t, this, "indata", "tupleindex", n, !0, !0);
	}
};
function parseFacet(t, n, r) {
	let i = t.from.facet, o = i.name, s = getDataRef(i, n), l;
	i.name || error$1("Facet must have a name: " + $(i)), i.data || error$1("Facet must reference a data set: " + $(i)), i.field ? l = n.add(PreFacet({
		field: n.fieldRef(i.field),
		pulse: s
	})) : i.groupby ? l = n.add(Facet({
		key: n.keyRef(i.groupby),
		group: ref(n.proxy(r.parent)),
		pulse: s
	})) : error$1("Facet must specify groupby or field: " + $(i));
	let u = n.fork(), d = u.add(Collect()), f = u.add(Sieve({ pulse: ref(d) }));
	u.addData(o, new DataScope(u, d, d, f)), u.addSignal("parent", null), l.params.subflow = { $subflow: u.parse(t).toRuntime() };
}
function parseSubflow(t, n, r) {
	let i = n.add(PreFacet({ pulse: r.pulse })), o = n.fork();
	o.add(Sieve()), o.addSignal("parent", null), i.params.subflow = { $subflow: o.parse(t).toRuntime() };
}
function parseTrigger(t, n, r) {
	let i = t.remove, o = t.insert, s = t.toggle, l = t.modify, u = t.values, d = n.add(operator()), f = parser$1("if(" + t.trigger + ",modify(\"" + r + "\"," + [
		o,
		i,
		s,
		l,
		u
	].map((t) => t ?? "null").join(",") + "),0)", n);
	d.update = f.$expr, d.params = f.$params;
}
function parseMark(t, n) {
	let r = getRole(t), i = t.type === GroupMark, o = t.from && t.from.facet, s = t.overlap, l = t.layout || r === "scope" || r === "frame", u, d, f, p, g, _, v, S = r === "mark" || l || o, T = parseData$1(t.from, i, n);
	d = n.add(DataJoin({
		key: T.key || (t.key ? fieldRef$1(t.key) : void 0),
		pulse: T.pulse,
		clean: !i
	}));
	let E = ref(d);
	d = f = n.add(Collect({ pulse: E })), d = n.add(Mark$1({
		markdef: definition$1(t),
		interactive: interactive(t.interactive, n),
		clip: clip(t.clip, n),
		context: { $context: !0 },
		groups: n.lookup(),
		parent: n.signals.parent ? n.signalRef("parent") : null,
		index: n.markpath(),
		pulse: ref(d)
	}));
	let O = ref(d);
	d = p = n.add(Encode(parseEncode(t.encode, t.type, r, t.style, n, {
		mod: !1,
		pulse: O
	}))), d.params.parent = n.encode(), t.transform && t.transform.forEach((t) => {
		let r = parseTransform(t, n), i = r.metadata;
		(i.generates || i.changes) && error$1("Mark transforms should not generate new data."), i.nomod || (p.params.mod = !0), r.params.pulse = ref(d), n.add(d = r);
	}), t.sort && (d = n.add(SortItems({
		sort: n.compareRef(t.sort),
		pulse: ref(d)
	})));
	let k = ref(d);
	(o || l) && (l = n.add(ViewLayout({
		layout: n.objectProperty(t.layout),
		legends: n.legends,
		mark: O,
		pulse: k
	})), _ = ref(l));
	let A = n.add(Bound({
		mark: O,
		pulse: _ || k
	}));
	v = ref(A), i && (S && (u = n.operators, u.pop(), l && u.pop()), n.pushState(k, _ || v, E), o ? parseFacet(t, n, T) : S ? parseSubflow(t, n, T) : n.parse(t), n.popState(), S && (l && u.push(l), u.push(A))), s && (v = parseOverlap(s, v, n));
	let j = n.add(Render({ pulse: v })), N = n.add(Sieve({ pulse: ref(j) }, void 0, n.parent()));
	t.name != null && (g = t.name, n.addData(g, new DataScope(n, f, j, N)), t.on && t.on.forEach((t) => {
		(t.insert || t.remove || t.toggle) && error$1("Marks only support modify triggers."), parseTrigger(t, n, g);
	}));
}
function parseOverlap(t, n, r) {
	let i = t.method, o = t.bound, s = t.separation, l = {
		separation: isSignal(s) ? r.signalRef(s.signal) : s,
		method: isSignal(i) ? r.signalRef(i.signal) : i,
		pulse: n
	};
	if (t.order && (l.sort = r.compareRef({ field: t.order })), o) {
		let t = o.tolerance;
		l.boundTolerance = isSignal(t) ? r.signalRef(t.signal) : +t, l.boundScale = r.scaleRef(o.scale), l.boundOrient = o.orient;
	}
	return ref(r.add(Overlap(l)));
}
function parseLegend$1(t, n) {
	let r = n.config.legend, i = t.encode || {}, o = lookup(t, r), s = i.legend || {}, l = s.name || void 0, u = s.interactive, d = s.style, f = {}, p = 0, g, _, v;
	LegendScales.forEach((n) => t[n] ? (f[n] = t[n], p ||= t[n]) : 0), p || error$1("Missing valid scale for legend.");
	let S = legendType(t, n.scaleType(p)), T = {
		title: t.title != null,
		scales: f,
		type: S,
		vgrad: S !== "symbol" && o.isVertical()
	}, E = ref(n.add(Collect(null, [T]))), O = { enter: {
		x: { value: 0 },
		y: { value: 0 }
	} }, k = ref(n.add(LegendEntries(_ = {
		type: S,
		scale: n.scaleRef(p),
		count: n.objectProperty(o("tickCount")),
		limit: n.property(o("symbolLimit")),
		values: n.objectProperty(t.values),
		minstep: n.property(t.tickMinStep),
		formatType: n.property(t.formatType),
		formatSpecifier: n.property(t.format)
	})));
	return S === Gradient ? (v = [legendGradient(t, p, r, i.gradient), legendGradientLabels(t, r, i.labels, k)], _.count = _.count || n.signalRef(`max(2,2*floor((${deref(o.gradientLength())})/100))`)) : S === Discrete ? v = [legendGradientDiscrete(t, p, r, i.gradient, k), legendGradientLabels(t, r, i.labels, k)] : (g = legendSymbolLayout(t, r), v = [legendSymbolGroups(t, r, i, k, deref(g.columns))], _.size = sizeExpression(t, n, v[0].marks)), v = [guideGroup({
		role: LegendEntryRole,
		from: E,
		encode: O,
		marks: v,
		layout: g,
		interactive: u
	})], T.title && v.push(legendTitle(t, r, i.title, E)), parseMark(guideGroup({
		role: LegendRole,
		from: E,
		encode: extendEncode(buildLegendEncode(o, t, r), s, Skip),
		marks: v,
		aria: o("aria"),
		description: o("description"),
		zindex: o("zindex"),
		name: l,
		interactive: u,
		style: d
	}), n);
}
function legendType(t, n) {
	let r = t.type || Symbols;
	return !t.type && scaleCount(t) === 1 && (t.fill || t.stroke) && (r = isContinuous$1(n) ? Gradient : isDiscretizing$1(n) ? Discrete : Symbols), r === Gradient ? isDiscretizing$1(n) ? Discrete : Gradient : r;
}
function scaleCount(t) {
	return LegendScales.reduce((n, r) => n + (t[r] ? 1 : 0), 0);
}
function buildLegendEncode(t, n, r) {
	let i = {
		enter: {},
		update: {}
	};
	return addEncoders(i, {
		orient: t("orient"),
		offset: t("offset"),
		padding: t("padding"),
		titlePadding: t("titlePadding"),
		cornerRadius: t("cornerRadius"),
		fill: t("fillColor"),
		stroke: t("strokeColor"),
		strokeWidth: r.strokeWidth,
		strokeDash: r.strokeDash,
		x: t("legendX"),
		y: t("legendY"),
		format: n.format,
		formatType: n.formatType
	}), i;
}
function sizeExpression(t, n, r) {
	return parser$1(`max(ceil(sqrt(${deref(getChannel("size", t, r))})+${deref(getChannel("strokeWidth", t, r))}),${deref(getFontSize(r[1].encode, n, GuideLabelStyle))})`, n);
}
function getChannel(t, n, r) {
	return n[t] ? `scale("${n[t]}",datum)` : getEncoding(t, r[0].encode);
}
function getFontSize(t, n, r) {
	return getEncoding("fontSize", t) || getStyle("fontSize", n, r);
}
var angleExpr = `item.orient==="${Left}"?-90:item.orient==="${Right}"?90:0`;
function parseTitle(t, n) {
	t = isString(t) ? { text: t } : t;
	let r = lookup(t, n.config.title), i = t.encode || {}, o = i.group || {}, s = o.name || void 0, l = o.interactive, u = o.style, d = [], f = ref(n.add(Collect(null, [{}])));
	return d.push(buildTitle(t, r, titleEncode(t), f)), t.subtitle && d.push(buildSubTitle(t, r, i.subtitle, f)), parseMark(guideGroup({
		role: TitleRole,
		from: f,
		encode: groupEncode(r, o),
		marks: d,
		aria: r("aria"),
		description: r("description"),
		zindex: r("zindex"),
		name: s,
		interactive: l,
		style: u
	}), n);
}
function titleEncode(t) {
	let n = t.encode;
	return n && n.title || extend({
		name: t.name,
		interactive: t.interactive,
		style: t.style
	}, n);
}
function groupEncode(t, n) {
	let r = {
		enter: {},
		update: {}
	};
	return addEncoders(r, {
		orient: t("orient"),
		anchor: t("anchor"),
		align: { signal: alignExpr$1 },
		angle: { signal: angleExpr },
		limit: t("limit"),
		frame: t("frame"),
		offset: t("offset") || 0,
		padding: t("subtitlePadding")
	}), extendEncode(r, n, Skip);
}
function buildTitle(t, n, r, i) {
	let o = { value: 0 }, s = t.text, l = {
		enter: { opacity: o },
		update: { opacity: { value: 1 } },
		exit: { opacity: o }
	};
	return addEncoders(l, {
		text: s,
		align: { signal: "item.mark.group.align" },
		angle: { signal: "item.mark.group.angle" },
		limit: { signal: "item.mark.group.limit" },
		baseline: "top",
		dx: n("dx"),
		dy: n("dy"),
		fill: n("color"),
		font: n("font"),
		fontSize: n("fontSize"),
		fontStyle: n("fontStyle"),
		fontWeight: n("fontWeight"),
		lineHeight: n("lineHeight")
	}, {
		align: n("align"),
		angle: n("angle"),
		baseline: n("baseline")
	}), guideMark({
		type: TextMark,
		role: TitleTextRole,
		style: GroupTitleStyle,
		from: i,
		encode: l
	}, r);
}
function buildSubTitle(t, n, r, i) {
	let o = { value: 0 }, s = t.subtitle, l = {
		enter: { opacity: o },
		update: { opacity: { value: 1 } },
		exit: { opacity: o }
	};
	return addEncoders(l, {
		text: s,
		align: { signal: "item.mark.group.align" },
		angle: { signal: "item.mark.group.angle" },
		limit: { signal: "item.mark.group.limit" },
		baseline: "top",
		dx: n("dx"),
		dy: n("dy"),
		fill: n("subtitleColor"),
		font: n("subtitleFont"),
		fontSize: n("subtitleFontSize"),
		fontStyle: n("subtitleFontStyle"),
		fontWeight: n("subtitleFontWeight"),
		lineHeight: n("subtitleLineHeight")
	}, {
		align: n("align"),
		angle: n("angle"),
		baseline: n("baseline")
	}), guideMark({
		type: TextMark,
		role: TitleSubtitleRole,
		style: GroupSubtitleStyle,
		from: i,
		encode: l
	}, r);
}
function parseData$2(t, n) {
	let r = [];
	t.transform && t.transform.forEach((t) => {
		r.push(parseTransform(t, n));
	}), t.on && t.on.forEach((r) => {
		parseTrigger(r, n, t.name);
	}), n.addDataPipeline(t.name, analyze(t, n, r));
}
function analyze(t, n, r) {
	let i = [], o = null, s = !1, l = !1, u, d, f, p, g;
	for (t.values ? isSignal(t.values) || hasSignal(t.format) ? (i.push(load(n, t)), i.push(o = collect())) : i.push(o = collect({
		$ingest: t.values,
		$format: t.format
	})) : t.url ? hasSignal(t.url) || hasSignal(t.format) ? (i.push(load(n, t)), i.push(o = collect())) : i.push(o = collect({
		$request: t.url,
		$format: t.format
	})) : t.source && (o = u = array(t.source).map((t) => ref(n.getData(t).output)), i.push(null)), d = 0, f = r.length; d < f; ++d) p = r[d], g = p.metadata, !o && !g.source && i.push(o = collect()), i.push(p), g.generates && (l = !0), g.modifies && !l && (s = !0), g.source ? o = p : g.changes && (o = null);
	return u && (f = u.length - 1, i[0] = Relay({
		derive: s,
		pulse: f ? u : u[0]
	}), (s || f) && i.splice(1, 0, collect())), o || i.push(collect()), i.push(Sieve({})), i;
}
function collect(t) {
	let n = Collect({}, t);
	return n.metadata = { source: !0 }, n;
}
function load(t, n) {
	return Load({
		url: n.url ? t.property(n.url) : void 0,
		async: n.async ? t.property(n.async) : void 0,
		values: n.values ? t.property(n.values) : void 0,
		format: t.objectProperty(n.format)
	});
}
var isX = (t) => t === Bottom || t === Top, getSign = (t, n, r) => isSignal(t) ? ifLeftTopExpr(t.signal, n, r) : t === Left || t === Top ? n : r, ifX = (t, n, r) => isSignal(t) ? ifXEnc(t.signal, n, r) : isX(t) ? n : r, ifY = (t, n, r) => isSignal(t) ? ifYEnc(t.signal, n, r) : isX(t) ? r : n, ifTop = (t, n, r) => isSignal(t) ? ifTopExpr(t.signal, n, r) : t === Top ? { value: n } : { value: r }, ifRight = (t, n, r) => isSignal(t) ? ifRightExpr(t.signal, n, r) : t === Right ? { value: n } : { value: r }, ifXEnc = (t, n, r) => ifEnc(`${t} === '${Top}' || ${t} === '${Bottom}'`, n, r), ifYEnc = (t, n, r) => ifEnc(`${t} !== '${Top}' && ${t} !== '${Bottom}'`, n, r), ifLeftTopExpr = (t, n, r) => ifExpr(`${t} === '${Left}' || ${t} === '${Top}'`, n, r), ifTopExpr = (t, n, r) => ifExpr(`${t} === '${Top}'`, n, r), ifRightExpr = (t, n, r) => ifExpr(`${t} === '${Right}'`, n, r), ifEnc = (t, n, r) => (n = n == null ? n : encoder(n), r = r == null ? r : encoder(r), isSimple(n) && isSimple(r) ? (n = n ? n.signal || $(n.value) : null, r = r ? r.signal || $(r.value) : null, { signal: `${t} ? (${n}) : (${r})` }) : [extend({ test: t }, n)].concat(r || [])), isSimple = (t) => t == null || Object.keys(t).length === 1, ifExpr = (t, n, r) => ({ signal: `${t} ? (${toExpr(n)}) : (${toExpr(r)})` }), ifOrient = (t, n, r, i, o) => ({ signal: (i == null ? "" : `${t} === '${Left}' ? (${toExpr(i)}) : `) + (r == null ? "" : `${t} === '${Bottom}' ? (${toExpr(r)}) : `) + (o == null ? "" : `${t} === '${Right}' ? (${toExpr(o)}) : `) + (n == null ? "" : `${t} === '${Top}' ? (${toExpr(n)}) : `) + "(null)" }), toExpr = (t) => isSignal(t) ? t.signal : t == null ? null : $(t), mult = (t, n) => n === 0 ? 0 : isSignal(t) ? { signal: `(${t.signal}) * ${n}` } : { value: t * n }, patch = (t, n) => {
	let r = t.signal;
	return r && r.endsWith("(null)") ? { signal: r.slice(0, -6) + n.signal } : t;
};
function fallback(t, n, r, i) {
	let o;
	if (n && has(n, t)) return n[t];
	if (has(r, t)) return r[t];
	if (t.startsWith("title")) {
		switch (t) {
			case "titleColor":
				o = "fill";
				break;
			case "titleFont":
			case "titleFontSize":
			case "titleFontWeight": o = t[5].toLowerCase() + t.slice(6);
		}
		return i[GuideTitleStyle][o];
	} else if (t.startsWith("label")) {
		switch (t) {
			case "labelColor":
				o = "fill";
				break;
			case "labelFont":
			case "labelFontSize": o = t[5].toLowerCase() + t.slice(6);
		}
		return i[GuideLabelStyle][o];
	}
	return null;
}
function keys$1(t) {
	let n = {};
	for (let r of t) if (r) for (let t in r) n[t] = 1;
	return Object.keys(n);
}
function axisConfig(t, n) {
	var r = n.config, i = r.style, o = r.axis, s = n.scaleType(t.scale) === "band" && r.axisBand, l = t.orient, u, d, f;
	if (isSignal(l)) {
		let t = keys$1([r.axisX, r.axisY]), n = keys$1([
			r.axisTop,
			r.axisBottom,
			r.axisLeft,
			r.axisRight
		]);
		u = {};
		for (f of t) u[f] = ifX(l, fallback(f, r.axisX, o, i), fallback(f, r.axisY, o, i));
		d = {};
		for (f of n) d[f] = ifOrient(l.signal, fallback(f, r.axisTop, o, i), fallback(f, r.axisBottom, o, i), fallback(f, r.axisLeft, o, i), fallback(f, r.axisRight, o, i));
	} else u = l === Top || l === Bottom ? r.axisX : r.axisY, d = r["axis" + l[0].toUpperCase() + l.slice(1)];
	return u || d || s ? extend({}, o, u, d, s) : o;
}
function axisDomain(t, n, r, i) {
	let o = lookup(t, n), s = t.orient, l, u, d = {
		enter: l = { opacity: zero$1 },
		update: u = { opacity: one },
		exit: { opacity: zero$1 }
	};
	addEncoders(d, {
		stroke: o("domainColor"),
		strokeCap: o("domainCap"),
		strokeDash: o("domainDash"),
		strokeDashOffset: o("domainDashOffset"),
		strokeWidth: o("domainWidth"),
		strokeOpacity: o("domainOpacity")
	});
	let f = position(t, 0), p = position(t, 1);
	return l.x = u.x = ifX(s, f, zero$1), l.x2 = u.x2 = ifX(s, p), l.y = u.y = ifY(s, f, zero$1), l.y2 = u.y2 = ifY(s, p), guideMark({
		type: RuleMark,
		role: AxisDomainRole,
		from: i,
		encode: d
	}, r);
}
function position(t, n) {
	return {
		scale: t.scale,
		range: n
	};
}
function axisGrid(t, n, r, i, o) {
	let s = lookup(t, n), l = t.orient, u = t.gridScale, d = getSign(l, 1, -1), f = offsetValue(t.offset, d), p, g, _, v = {
		enter: p = { opacity: zero$1 },
		update: _ = { opacity: one },
		exit: g = { opacity: zero$1 }
	};
	addEncoders(v, {
		stroke: s("gridColor"),
		strokeCap: s("gridCap"),
		strokeDash: s("gridDash"),
		strokeDashOffset: s("gridDashOffset"),
		strokeOpacity: s("gridOpacity"),
		strokeWidth: s("gridWidth")
	});
	let S = {
		scale: t.scale,
		field: Value,
		band: o.band,
		extra: o.extra,
		offset: o.offset,
		round: s("tickRound")
	}, T = ifX(l, { signal: "height" }, { signal: "width" }), E = u ? {
		scale: u,
		range: 0,
		mult: d,
		offset: f
	} : {
		value: 0,
		offset: f
	}, O = u ? {
		scale: u,
		range: 1,
		mult: d,
		offset: f
	} : extend(T, {
		mult: d,
		offset: f
	});
	return p.x = _.x = ifX(l, S, E), p.y = _.y = ifY(l, S, E), p.x2 = _.x2 = ifY(l, O), p.y2 = _.y2 = ifX(l, O), g.x = ifX(l, S), g.y = ifY(l, S), guideMark({
		type: RuleMark,
		role: AxisGridRole,
		key: Value,
		from: i,
		encode: v
	}, r);
}
function offsetValue(t, n) {
	if (n !== 1) if (!isObject(t)) t = isSignal(n) ? { signal: `(${n.signal}) * (${t || 0})` } : n * (t || 0);
	else {
		let r = t = extend({}, t);
		for (; r.mult != null;) if (isObject(r.mult)) r = r.mult = extend({}, r.mult);
		else return r.mult = isSignal(n) ? { signal: `(${r.mult}) * (${n.signal})` } : r.mult * n, t;
		r.mult = n;
	}
	return t;
}
function axisTicks(t, n, r, i, o, s) {
	let l = lookup(t, n), u = t.orient, d = getSign(u, -1, 1), f, p, g, _ = {
		enter: f = { opacity: zero$1 },
		update: g = { opacity: one },
		exit: p = { opacity: zero$1 }
	};
	addEncoders(_, {
		stroke: l("tickColor"),
		strokeCap: l("tickCap"),
		strokeDash: l("tickDash"),
		strokeDashOffset: l("tickDashOffset"),
		strokeOpacity: l("tickOpacity"),
		strokeWidth: l("tickWidth")
	});
	let v = encoder(o);
	v.mult = d;
	let S = {
		scale: t.scale,
		field: Value,
		band: s.band,
		extra: s.extra,
		offset: s.offset,
		round: l("tickRound")
	};
	return g.y = f.y = ifX(u, zero$1, S), g.y2 = f.y2 = ifX(u, v), p.x = ifX(u, S), g.x = f.x = ifY(u, zero$1, S), g.x2 = f.x2 = ifY(u, v), p.y = ifY(u, S), guideMark({
		type: RuleMark,
		role: AxisTickRole,
		key: Value,
		from: i,
		encode: _
	}, r);
}
function flushExpr(t, n, r, i, o) {
	return { signal: "flush(range(\"" + t + "\"), scale(\"" + t + "\", datum.value), " + n + "," + r + "," + i + "," + o + ")" };
}
function axisLabels(t, n, r, i, o, s) {
	let l = lookup(t, n), u = t.orient, d = t.scale, f = getSign(u, -1, 1), p = deref(l("labelFlush")), g = deref(l("labelFlushOffset")), _ = l("labelAlign"), v = l("labelBaseline"), S = p === 0 || !!p, T, E = encoder(o);
	E.mult = f, E.offset = encoder(l("labelPadding") || 0), E.offset.mult = f;
	let O = {
		scale: d,
		field: Value,
		band: .5,
		offset: extendOffset(s.offset, l("labelOffset"))
	}, k = ifX(u, S ? flushExpr(d, p, "\"left\"", "\"right\"", "\"center\"") : { value: "center" }, ifRight(u, "left", "right")), A = ifX(u, ifTop(u, "bottom", "top"), S ? flushExpr(d, p, "\"top\"", "\"bottom\"", "\"middle\"") : { value: "middle" }), j = flushExpr(d, p, `-(${g})`, g, 0);
	S &&= g;
	let N = {
		opacity: zero$1,
		x: ifX(u, O, E),
		y: ifY(u, O, E)
	}, P = {
		enter: N,
		update: T = {
			opacity: one,
			text: { field: Label },
			x: N.x,
			y: N.y,
			align: k,
			baseline: A
		},
		exit: {
			opacity: zero$1,
			x: N.x,
			y: N.y
		}
	};
	addEncoders(P, {
		dx: !_ && S ? ifX(u, j) : null,
		dy: !v && S ? ifY(u, j) : null
	}), addEncoders(P, {
		angle: l("labelAngle"),
		fill: l("labelColor"),
		fillOpacity: l("labelOpacity"),
		font: l("labelFont"),
		fontSize: l("labelFontSize"),
		fontWeight: l("labelFontWeight"),
		fontStyle: l("labelFontStyle"),
		limit: l("labelLimit"),
		lineHeight: l("labelLineHeight")
	}, {
		align: _,
		baseline: v
	});
	let F = l("labelBound"), I = l("labelOverlap");
	return I = I || F ? {
		separation: l("labelSeparation"),
		method: I,
		order: "datum.index",
		bound: F ? {
			scale: d,
			orient: u,
			tolerance: F
		} : null
	} : void 0, T.align !== k && (T.align = patch(T.align, k)), T.baseline !== A && (T.baseline = patch(T.baseline, A)), guideMark({
		type: TextMark,
		role: AxisLabelRole,
		style: GuideLabelStyle,
		key: Value,
		from: i,
		encode: P,
		overlap: I
	}, r);
}
function axisTitle(t, n, r, i) {
	let o = lookup(t, n), s = t.orient, l = getSign(s, -1, 1), u, d, f = {
		enter: u = {
			opacity: zero$1,
			anchor: encoder(o("titleAnchor", null)),
			align: { signal: alignExpr$1 }
		},
		update: d = extend({}, u, {
			opacity: one,
			text: encoder(t.title)
		}),
		exit: { opacity: zero$1 }
	}, p = { signal: `lerp(range("${t.scale}"), ${anchorExpr(0, 1, .5)})` };
	return d.x = ifX(s, p), d.y = ifY(s, p), u.angle = ifX(s, zero$1, mult(l, 90)), u.baseline = ifX(s, ifTop(s, Bottom, Top), { value: Bottom }), d.angle = u.angle, d.baseline = u.baseline, addEncoders(f, {
		fill: o("titleColor"),
		fillOpacity: o("titleOpacity"),
		font: o("titleFont"),
		fontSize: o("titleFontSize"),
		fontStyle: o("titleFontStyle"),
		fontWeight: o("titleFontWeight"),
		limit: o("titleLimit"),
		lineHeight: o("titleLineHeight")
	}, {
		align: o("titleAlign"),
		angle: o("titleAngle"),
		baseline: o("titleBaseline")
	}), autoLayout(o, s, f, r), f.update.align = patch(f.update.align, u.align), f.update.angle = patch(f.update.angle, u.angle), f.update.baseline = patch(f.update.baseline, u.baseline), guideMark({
		type: TextMark,
		role: AxisTitleRole,
		style: GuideTitleStyle,
		from: i,
		encode: f
	}, r);
}
function autoLayout(t, n, r, i) {
	let o = (t, n) => t == null ? !has$1(n, i) : (r.update[n] = patch(encoder(t), r.update[n]), !1), s = o(t("titleX"), "x"), l = o(t("titleY"), "y");
	r.enter.auto = l === s ? encoder(l) : ifX(n, encoder(l), encoder(s));
}
function parseAxis$1(t, n) {
	let r = axisConfig(t, n), i = t.encode || {}, o = i.axis || {}, s = o.name || void 0, l = o.interactive, u = o.style, d = lookup(t, r), f = tickBand(d), p = {
		scale: t.scale,
		ticks: !!d("ticks"),
		labels: !!d("labels"),
		grid: !!d("grid"),
		domain: !!d("domain"),
		title: t.title != null
	}, g = ref(n.add(Collect({}, [p]))), _ = ref(n.add(AxisTicks({
		scale: n.scaleRef(t.scale),
		extra: n.property(f.extra),
		count: n.objectProperty(t.tickCount),
		values: n.objectProperty(t.values),
		minstep: n.property(t.tickMinStep),
		formatType: n.property(t.formatType),
		formatSpecifier: n.property(t.format)
	}))), v = [], S;
	return p.grid && v.push(axisGrid(t, r, i.grid, _, f)), p.ticks && (S = d("tickSize"), v.push(axisTicks(t, r, i.ticks, _, S, f))), p.labels && (S = p.ticks ? S : 0, v.push(axisLabels(t, r, i.labels, _, S, f))), p.domain && v.push(axisDomain(t, r, i.domain, g)), p.title && v.push(axisTitle(t, r, i.title, g)), parseMark(guideGroup({
		role: AxisRole,
		from: g,
		encode: extendEncode(buildAxisEncode(d, t), o, Skip),
		marks: v,
		aria: d("aria"),
		description: d("description"),
		zindex: d("zindex"),
		name: s,
		interactive: l,
		style: u
	}), n);
}
function buildAxisEncode(t, n) {
	let r = {
		enter: {},
		update: {}
	};
	return addEncoders(r, {
		orient: t("orient"),
		offset: t("offset") || 0,
		position: value(n.position, 0),
		titlePadding: t("titlePadding"),
		minExtent: t("minExtent"),
		maxExtent: t("maxExtent"),
		range: { signal: `abs(span(range("${n.scale}")))` },
		translate: t("translate"),
		format: n.format,
		formatType: n.formatType
	}), r;
}
function parseScope(t, n, r) {
	let i = array(t.signals), o = array(t.scales);
	return r || i.forEach((t) => parseSignal(t, n)), array(t.projections).forEach((t) => parseProjection$1(t, n)), o.forEach((t) => initScale(t, n)), array(t.data).forEach((t) => parseData$2(t, n)), o.forEach((t) => parseScale(t, n)), (r || i).forEach((t) => parseSignalUpdates(t, n)), array(t.axes).forEach((t) => parseAxis$1(t, n)), array(t.marks).forEach((t) => parseMark(t, n)), array(t.legends).forEach((t) => parseLegend$1(t, n)), t.title && parseTitle(t.title, n), n.parseLambdas(), n;
}
var rootEncode = (t) => extendEncode({
	enter: {
		x: { value: 0 },
		y: { value: 0 }
	},
	update: {
		width: { signal: "width" },
		height: { signal: "height" }
	}
}, t);
function parseView(t, n) {
	let r = n.config, i = ref(n.root = n.add(operator())), o = collectSignals(t, r);
	o.forEach((t) => parseSignal(t, n)), n.description = t.description || r.description, n.eventConfig = r.events, n.legends = n.objectProperty(r.legend && r.legend.layout), n.locale = r.locale;
	let s = n.add(Collect()), l = n.add(Encode(parseEncode(rootEncode(t.encode), GroupMark, FrameRole, t.style, n, { pulse: ref(s) }))), u = n.add(ViewLayout({
		layout: n.objectProperty(t.layout),
		legends: n.legends,
		autosize: n.signalRef("autosize"),
		mark: i,
		pulse: ref(l)
	}));
	n.operators.pop(), n.pushState(ref(l), ref(u), null), parseScope(t, n, o), n.operators.push(u);
	let d = n.add(Bound({
		mark: i,
		pulse: ref(u)
	}));
	return d = n.add(Render({ pulse: ref(d) })), d = n.add(Sieve({ pulse: ref(d) })), n.addData("root", new DataScope(n, s, s, d)), n;
}
function signalObject(t, n) {
	return n && n.signal ? {
		name: t,
		update: n.signal
	} : {
		name: t,
		value: n
	};
}
function collectSignals(t, n) {
	let r = (r) => value(t[r], n[r]), i = [
		signalObject("background", r("background")),
		signalObject("autosize", parseAutosize(r("autosize"))),
		signalObject("padding", parsePadding(r("padding"))),
		signalObject("width", r("width") || 0),
		signalObject("height", r("height") || 0)
	], o = i.reduce((t, n) => (t[n.name] = n, t), {}), s = {};
	return array(t.signals).forEach((t) => {
		has(o, t.name) ? t = extend(o[t.name], t) : i.push(t), s[t.name] = t;
	}), array(n.signals).forEach((t) => {
		!has(s, t.name) && !has(o, t.name) && i.push(t);
	}), i;
}
function Scope(t, n) {
	this.config = t || {}, this.options = n || {}, this.bindings = [], this.field = {}, this.signals = {}, this.lambdas = {}, this.scales = {}, this.events = {}, this.data = {}, this.streams = [], this.updates = [], this.operators = [], this.eventConfig = null, this.locale = null, this._id = 0, this._subid = 0, this._nextsub = [0], this._parent = [], this._encode = [], this._lookup = [], this._markpath = [];
}
function Subscope(t) {
	this.config = t.config, this.options = t.options, this.legends = t.legends, this.field = Object.create(t.field), this.signals = Object.create(t.signals), this.lambdas = Object.create(t.lambdas), this.scales = Object.create(t.scales), this.events = Object.create(t.events), this.data = Object.create(t.data), this.streams = [], this.updates = [], this.operators = [], this._id = 0, this._subid = ++t._nextsub[0], this._nextsub = t._nextsub, this._parent = t._parent.slice(), this._encode = t._encode.slice(), this._lookup = t._lookup.slice(), this._markpath = t._markpath;
}
Scope.prototype = Subscope.prototype = {
	parse(t) {
		return parseScope(t, this);
	},
	fork() {
		return new Subscope(this);
	},
	isSubscope() {
		return this._subid > 0;
	},
	toRuntime() {
		return this.finish(), {
			description: this.description,
			operators: this.operators,
			streams: this.streams,
			updates: this.updates,
			bindings: this.bindings,
			eventConfig: this.eventConfig,
			locale: this.locale
		};
	},
	id() {
		return (this._subid ? this._subid + ":" : 0) + this._id++;
	},
	add(t) {
		return this.operators.push(t), t.id = this.id(), t.refs &&= (t.refs.forEach((n) => {
			n.$ref = t.id;
		}), null), t;
	},
	proxy(t) {
		let n = t instanceof Entry ? ref(t) : t;
		return this.add(Proxy({ value: n }));
	},
	addStream(t) {
		return this.streams.push(t), t.id = this.id(), t;
	},
	addUpdate(t) {
		return this.updates.push(t), t;
	},
	finish() {
		let t, n;
		for (t in this.root && (this.root.root = !0), this.signals) this.signals[t].signal = t;
		for (t in this.scales) this.scales[t].scale = t;
		function r(t, n, r) {
			let i, o;
			t && (i = t.data ||= {}, o = i[n] || (i[n] = []), o.push(r));
		}
		for (t in this.data) for (let i in n = this.data[t], r(n.input, t, "input"), r(n.output, t, "output"), r(n.values, t, "values"), n.index) r(n.index[i], t, "index:" + i);
		return this;
	},
	pushState(t, n, r) {
		this._encode.push(ref(this.add(Sieve({ pulse: t })))), this._parent.push(n), this._lookup.push(r ? ref(this.proxy(r)) : null), this._markpath.push(-1);
	},
	popState() {
		this._encode.pop(), this._parent.pop(), this._lookup.pop(), this._markpath.pop();
	},
	parent() {
		return peek(this._parent);
	},
	encode() {
		return peek(this._encode);
	},
	lookup() {
		return peek(this._lookup);
	},
	markpath() {
		let t = this._markpath;
		return ++t[t.length - 1];
	},
	fieldRef(t, n) {
		if (isString(t)) return fieldRef$1(t, n);
		t.signal || error$1("Unsupported field reference: " + $(t));
		let r = t.signal, i = this.field[r];
		if (!i) {
			let t = { name: this.signalRef(r) };
			n && (t.as = n), this.field[r] = i = ref(this.add(Field(t)));
		}
		return i;
	},
	compareRef(t) {
		let n = !1, r = (t) => isSignal(t) ? (n = !0, this.signalRef(t.signal)) : isExpr$1(t) ? (n = !0, this.exprRef(t.expr)) : t, i = array(t.field).map(r), o = array(t.order).map(r);
		return n ? ref(this.add(Compare({
			fields: i,
			orders: o
		}))) : compareRef(i, o);
	},
	keyRef(t, n) {
		let r = !1, i = (t) => isSignal(t) ? (r = !0, ref(o[t.signal])) : t, o = this.signals;
		return t = array(t).map(i), r ? ref(this.add(Key({
			fields: t,
			flat: n
		}))) : keyRef(t, n);
	},
	sortRef(t) {
		if (!t) return t;
		let n = aggrField(t.op, t.field), r = t.order || Ascending;
		return r.signal ? ref(this.add(Compare({
			fields: n,
			orders: this.signalRef(r.signal)
		}))) : compareRef(n, r);
	},
	event(t, n) {
		let r = t + ":" + n;
		if (!this.events[r]) {
			let i = this.id();
			this.streams.push({
				id: i,
				source: t,
				type: n
			}), this.events[r] = i;
		}
		return this.events[r];
	},
	hasOwnSignal(t) {
		return has(this.signals, t);
	},
	addSignal(t, n) {
		this.hasOwnSignal(t) && error$1("Duplicate signal name: " + $(t));
		let r = n instanceof Entry ? n : this.add(operator(n));
		return this.signals[t] = r;
	},
	getSignal(t) {
		return this.signals[t] || error$1("Unrecognized signal name: " + $(t)), this.signals[t];
	},
	signalRef(t) {
		return this.signals[t] ? ref(this.signals[t]) : (has(this.lambdas, t) || (this.lambdas[t] = this.add(operator(null))), ref(this.lambdas[t]));
	},
	parseLambdas() {
		let t = Object.keys(this.lambdas);
		for (let n = 0, r = t.length; n < r; ++n) {
			let r = t[n], i = parser$1(r, this), o = this.lambdas[r];
			o.params = i.$params, o.update = i.$expr;
		}
	},
	property(t) {
		return t && t.signal ? this.signalRef(t.signal) : t;
	},
	objectProperty(t) {
		return !t || !isObject(t) ? t : this.signalRef(t.signal || propertyLambda(t));
	},
	exprRef(t, n) {
		let r = { expr: parser$1(t, this) };
		return n && (r.expr.$name = n), ref(this.add(Expression(r)));
	},
	addBinding(t, n) {
		this.bindings || error$1("Nested signals do not support binding: " + $(t)), this.bindings.push(extend({ signal: t }, n));
	},
	addScaleProj(t, n) {
		has(this.scales, t) && error$1("Duplicate scale or projection name: " + $(t)), this.scales[t] = this.add(n);
	},
	addScale(t, n) {
		this.addScaleProj(t, Scale(n));
	},
	addProjection(t, n) {
		this.addScaleProj(t, Projection(n));
	},
	getScale(t) {
		return this.scales[t] || error$1("Unrecognized scale name: " + $(t)), this.scales[t];
	},
	scaleRef(t) {
		return ref(this.getScale(t));
	},
	scaleType(t) {
		return this.getScale(t).params.type;
	},
	projectionRef(t) {
		return this.scaleRef(t);
	},
	projectionType(t) {
		return this.scaleType(t);
	},
	addData(t, n) {
		return has(this.data, t) && error$1("Duplicate data set name: " + $(t)), this.data[t] = n;
	},
	getData(t) {
		return this.data[t] || error$1("Undefined data set name: " + $(t)), this.data[t];
	},
	addDataPipeline(t, n) {
		return has(this.data, t) && error$1("Duplicate data set name: " + $(t)), this.addData(t, DataScope.fromEntries(this, n));
	}
};
function propertyLambda(t) {
	return (isArray(t) ? arrayLambda : objectLambda)(t);
}
function arrayLambda(t) {
	let n = t.length, r = "[";
	for (let i = 0; i < n; ++i) {
		let n = t[i];
		r += (i > 0 ? "," : "") + (isObject(n) ? n.signal || propertyLambda(n) : $(n));
	}
	return r + "]";
}
function objectLambda(t) {
	let n = "{", r = 0, i, o;
	for (i in t) o = t[i], n += (++r > 1 ? "," : "") + $(i) + ":" + (isObject(o) ? o.signal || propertyLambda(o) : $(o));
	return n + "}";
}
function defaults() {
	let t = "sans-serif", n = "#4c78a8", r = "#000", i = "#888", o = "#ddd";
	return {
		description: "Vega visualization",
		padding: 0,
		autosize: "pad",
		background: null,
		events: { defaults: { allow: ["wheel"] } },
		group: null,
		mark: null,
		arc: { fill: n },
		area: { fill: n },
		image: null,
		line: {
			stroke: n,
			strokeWidth: 2
		},
		path: { stroke: n },
		rect: { fill: n },
		rule: { stroke: r },
		shape: { stroke: n },
		symbol: {
			fill: n,
			size: 64
		},
		text: {
			fill: r,
			font: t,
			fontSize: 11
		},
		trail: {
			fill: n,
			size: 2
		},
		style: {
			"guide-label": {
				fill: r,
				font: t,
				fontSize: 10
			},
			"guide-title": {
				fill: r,
				font: t,
				fontSize: 11,
				fontWeight: "bold"
			},
			"group-title": {
				fill: r,
				font: t,
				fontSize: 13,
				fontWeight: "bold"
			},
			"group-subtitle": {
				fill: r,
				font: t,
				fontSize: 12
			},
			point: {
				size: 30,
				strokeWidth: 2,
				shape: "circle"
			},
			circle: {
				size: 30,
				strokeWidth: 2
			},
			square: {
				size: 30,
				strokeWidth: 2,
				shape: "square"
			},
			cell: {
				fill: "transparent",
				stroke: o
			},
			view: { fill: "transparent" }
		},
		title: {
			orient: "top",
			anchor: "middle",
			offset: 4,
			subtitlePadding: 3
		},
		axis: {
			minExtent: 0,
			maxExtent: 200,
			bandPosition: .5,
			domain: !0,
			domainWidth: 1,
			domainColor: i,
			grid: !1,
			gridWidth: 1,
			gridColor: o,
			labels: !0,
			labelAngle: 0,
			labelLimit: 180,
			labelOffset: 0,
			labelPadding: 2,
			ticks: !0,
			tickColor: i,
			tickOffset: 0,
			tickRound: !0,
			tickSize: 5,
			tickWidth: 1,
			titlePadding: 4
		},
		axisBand: { tickOffset: -.5 },
		projection: { type: "mercator" },
		legend: {
			orient: "right",
			padding: 0,
			gridAlign: "each",
			columnPadding: 10,
			rowPadding: 2,
			symbolDirection: "vertical",
			gradientDirection: "vertical",
			gradientLength: 200,
			gradientThickness: 16,
			gradientStrokeColor: o,
			gradientStrokeWidth: 0,
			gradientLabelOffset: 2,
			labelAlign: "left",
			labelBaseline: "middle",
			labelLimit: 160,
			labelOffset: 4,
			labelOverlap: !0,
			symbolLimit: 30,
			symbolType: "circle",
			symbolSize: 100,
			symbolOffset: 0,
			symbolStrokeWidth: 1.5,
			symbolBaseFillColor: "transparent",
			symbolBaseStrokeColor: i,
			titleLimit: 180,
			titleOrient: "top",
			titlePadding: 5,
			layout: {
				offset: 18,
				direction: "horizontal",
				left: { direction: "vertical" },
				right: { direction: "vertical" }
			}
		},
		range: {
			category: { scheme: "tableau10" },
			ordinal: { scheme: "blues" },
			heatmap: { scheme: "yellowgreenblue" },
			ramp: { scheme: "blues" },
			diverging: {
				scheme: "blueorange",
				extent: [1, 0]
			},
			symbol: [
				"circle",
				"square",
				"triangle-up",
				"cross",
				"diamond",
				"triangle-right",
				"triangle-down",
				"triangle-left"
			]
		}
	};
}
function parse(t, n, r) {
	return isObject(t) || error$1("Input Vega specification must be an object."), n = mergeConfig(defaults(), n, t.config), parseView(t, new Scope(n, r)).toRuntime();
}
var vega_module_exports = /* @__PURE__ */ __export({
	Bounds: () => Bounds,
	CanvasHandler: () => CanvasHandler,
	CanvasRenderer: () => CanvasRenderer,
	DATE: () => DATE,
	DAY: () => "day",
	DAYOFYEAR: () => DAYOFYEAR,
	Dataflow: () => Dataflow,
	Debug: () => 4,
	DisallowedObjectProperties: () => DisallowedObjectProperties,
	Error: () => 1,
	EventStream: () => EventStream,
	Gradient: () => Gradient$1,
	GroupItem: () => GroupItem,
	HOURS: () => HOURS,
	Handler: () => Handler$1,
	HybridHandler: () => HybridHandler,
	HybridRenderer: () => HybridRenderer,
	Info: () => 3,
	Item: () => Item,
	MILLISECONDS: () => MILLISECONDS,
	MINUTES: () => MINUTES,
	MONTH: () => MONTH,
	Marks: () => Marks,
	MultiPulse: () => MultiPulse,
	None: () => 0,
	Operator: () => Operator,
	Parameters: () => Parameters,
	Pulse: () => Pulse,
	QUARTER: () => QUARTER,
	RenderType: () => RenderType,
	Renderer: () => Renderer,
	ResourceLoader: () => ResourceLoader,
	SECONDS: () => SECONDS,
	SVGHandler: () => SVGHandler,
	SVGRenderer: () => SVGRenderer,
	SVGStringRenderer: () => SVGStringRenderer,
	Scenegraph: () => Scenegraph,
	TIME_UNITS: () => TIME_UNITS,
	Transform: () => Transform,
	View: () => View,
	WEEK: () => WEEK,
	Warn: () => 2,
	YEAR: () => YEAR,
	accessor: () => accessor,
	accessorFields: () => accessorFields,
	accessorName: () => accessorName,
	array: () => array,
	ascending: () => ascending,
	bandwidthNRD: () => estimateBandwidth,
	bin: () => bin,
	bootstrapCI: () => bootstrapCI,
	boundClip: () => boundClip,
	boundContext: () => boundContext,
	boundItem: () => boundItem$1,
	boundMark: () => boundMark,
	boundStroke: () => boundStroke,
	changeset: () => changeset,
	clampRange: () => clampRange,
	codegenExpression: () => codegen,
	compare: () => compare$1,
	constant: () => constant,
	cumulativeLogNormal: () => cumulativeLogNormal,
	cumulativeNormal: () => cumulativeNormal,
	cumulativeUniform: () => cumulativeUniform,
	dayofyear: () => dayofyear,
	debounce: () => debounce,
	defaultLocale: () => defaultLocale,
	definition: () => definition,
	densityLogNormal: () => densityLogNormal,
	densityNormal: () => densityNormal,
	densityUniform: () => densityUniform,
	domChild: () => domChild,
	domClear: () => domClear,
	domCreate: () => domCreate,
	domFind: () => domFind,
	dotbin: () => dotbin,
	error: () => error$1,
	expressionFunction: () => expressionFunction,
	extend: () => extend,
	extent: () => extent,
	extentIndex: () => extentIndex,
	falsy: () => falsy,
	fastmap: () => fastmap,
	field: () => field$1,
	flush: () => flush,
	font: () => font$1,
	fontFamily: () => fontFamily,
	fontSize: () => fontSize,
	format: () => format$2,
	formatLocale: () => numberFormatDefaultLocale,
	formats: () => formats$1,
	hasOwnProperty: () => has,
	id: () => id,
	identity: () => identity,
	inferType: () => inferType,
	inferTypes: () => inferTypes,
	ingest: () => ingest$1,
	inherits: () => inherits,
	inrange: () => inrange,
	interpolate: () => interpolate$1,
	interpolateColors: () => interpolateColors,
	interpolateRange: () => interpolateRange$1,
	intersect: () => intersect,
	intersectBoxLine: () => intersectBoxLine,
	intersectPath: () => intersectPath,
	intersectPoint: () => intersectPoint,
	intersectRule: () => intersectRule,
	isArray: () => isArray,
	isBoolean: () => isBoolean,
	isDate: () => isDate,
	isFunction: () => isFunction,
	isIterable: () => isIterable,
	isNumber: () => isNumber,
	isObject: () => isObject,
	isRegExp: () => isRegExp,
	isString: () => isString,
	isTuple: () => isTuple,
	key: () => key,
	lerp: () => lerp,
	lineHeight: () => lineHeight,
	loader: () => loader,
	locale: () => locale,
	logger: () => logger,
	lruCache: () => lruCache,
	markup: () => markup,
	merge: () => merge$2,
	mergeConfig: () => mergeConfig,
	multiLineOffset: () => multiLineOffset,
	one: () => one$1,
	pad: () => pad,
	panLinear: () => panLinear,
	panLog: () => panLog,
	panPow: () => panPow,
	panSymlog: () => panSymlog,
	parse: () => parse,
	parseExpression: () => parser,
	parseSelector: () => eventSelector,
	path: () => path,
	pathCurves: () => curves,
	pathEqual: () => pathEqual,
	pathParse: () => parse$3,
	pathRectangle: () => vg_rect,
	pathRender: () => pathRender,
	pathSymbols: () => symbols$1,
	pathTrail: () => vg_trail,
	peek: () => peek,
	point: () => point$2,
	projection: () => projection,
	quantileLogNormal: () => quantileLogNormal,
	quantileNormal: () => quantileNormal,
	quantileUniform: () => quantileUniform,
	quantiles: () => quantiles,
	quantizeInterpolator: () => quantizeInterpolator,
	quarter: () => quarter,
	quartiles: () => quartiles,
	random: () => random,
	randomInteger: () => integer,
	randomKDE: () => kde,
	randomLCG: () => lcg,
	randomLogNormal: () => lognormal,
	randomMixture: () => mixture,
	randomNormal: () => gaussian,
	randomUniform: () => uniform,
	read: () => read,
	regressionConstant: () => constant$1,
	regressionExp: () => exp,
	regressionLinear: () => linear,
	regressionLoess: () => loess,
	regressionLog: () => log$1,
	regressionPoly: () => poly,
	regressionPow: () => pow,
	regressionQuad: () => quad,
	renderModule: () => renderModule,
	repeat: () => repeat,
	resetDefaultLocale: () => resetDefaultLocale,
	resetSVGDefIds: () => resetSVGDefIds,
	responseType: () => responseType,
	runtimeContext: () => context,
	sampleCurve: () => sampleCurve,
	sampleLogNormal: () => sampleLogNormal,
	sampleNormal: () => sampleNormal,
	sampleUniform: () => sampleUniform,
	scale: () => scale,
	sceneEqual: () => sceneEqual,
	sceneFromJSON: () => sceneFromJSON,
	scenePickVisit: () => pickVisit,
	sceneToJSON: () => sceneToJSON,
	sceneVisit: () => visit,
	sceneZOrder: () => zorder,
	scheme: () => scheme$1,
	serializeXML: () => serializeXML,
	setHybridRendererOptions: () => setHybridRendererOptions,
	setRandom: () => setRandom,
	span: () => span,
	splitAccessPath: () => splitAccessPath,
	stringValue: () => $,
	textMetrics: () => textMetrics,
	timeBin: () => bin$1,
	timeFloor: () => timeFloor,
	timeFormatLocale: () => timeFormatDefaultLocale,
	timeInterval: () => timeInterval,
	timeOffset: () => timeOffset,
	timeSequence: () => timeSequence,
	timeUnitSpecifier: () => timeUnitSpecifier,
	timeUnits: () => timeUnits,
	toBoolean: () => toBoolean,
	toDate: () => toDate,
	toNumber: () => toNumber,
	toSet: () => toSet,
	toString: () => toString,
	transform: () => transform,
	transforms: () => transforms,
	truncate: () => truncate,
	truthy: () => truthy,
	tupleid: () => tupleid,
	typeParsers: () => typeParsers,
	utcFloor: () => utcFloor,
	utcInterval: () => utcInterval,
	utcOffset: () => utcOffset,
	utcSequence: () => utcSequence,
	utcdayofyear: () => utcdayofyear,
	utcquarter: () => utcquarter,
	utcweek: () => utcweek,
	version: () => version$4,
	visitArray: () => visitArray,
	week: () => week,
	writeConfig: () => writeConfig,
	zero: () => zero$2,
	zoomLinear: () => zoomLinear,
	zoomLog: () => zoomLog,
	zoomPow: () => zoomPow,
	zoomSymlog: () => zoomSymlog
}), version$1$1 = "6.2.0";
extend(transforms, vega_transforms_exports, vega_view_transforms_exports, vega_encode_exports, vega_geo_exports, vega_force_exports, vega_label_exports, vega_hierarchy_exports, vega_regression_exports, vega_voronoi_exports, vega_wordcloud_exports, vega_crossfilter_exports);
var version$4 = version$1$1;
function adjustSpatial(t, n, r) {
	let i;
	n.x2 && (n.x ? (r && t.x > t.x2 && (i = t.x, t.x = t.x2, t.x2 = i), t.width = t.x2 - t.x) : t.x = t.x2 - (t.width || 0)), n.xc && (t.x = t.xc - (t.width || 0) / 2), n.y2 && (n.y ? (r && t.y > t.y2 && (i = t.y, t.y = t.y2, t.y2 = i), t.height = t.y2 - t.y) : t.y = t.y2 - (t.height || 0)), n.yc && (t.y = t.yc - (t.height || 0) / 2);
}
var Constants = {
	NaN: NaN,
	E: Math.E,
	LN2: Math.LN2,
	LN10: Math.LN10,
	LOG2E: Math.LOG2E,
	LOG10E: Math.LOG10E,
	PI: Math.PI,
	SQRT1_2: Math.SQRT1_2,
	SQRT2: Math.SQRT2,
	MIN_VALUE: Number.MIN_VALUE,
	MAX_VALUE: Number.MAX_VALUE
}, Ops = {
	"*": (t, n) => t * n,
	"+": (t, n) => t + n,
	"-": (t, n) => t - n,
	"/": (t, n) => t / n,
	"%": (t, n) => t % n,
	">": (t, n) => t > n,
	"<": (t, n) => t < n,
	"<=": (t, n) => t <= n,
	">=": (t, n) => t >= n,
	"==": (t, n) => t == n,
	"!=": (t, n) => t != n,
	"===": (t, n) => t === n,
	"!==": (t, n) => t !== n,
	"&": (t, n) => t & n,
	"|": (t, n) => t | n,
	"^": (t, n) => t ^ n,
	"<<": (t, n) => t << n,
	">>": (t, n) => t >> n,
	">>>": (t, n) => t >>> n
}, Unary = {
	"+": (t) => +t,
	"-": (t) => -t,
	"~": (t) => ~t,
	"!": (t) => !t
}, slice = Array.prototype.slice, apply = (t, n, r) => {
	let i = r ? r(n[0]) : n[0];
	return i[t].apply(i, slice.call(n, 1));
}, Functions = {
	isNaN: Number.isNaN,
	isFinite: Number.isFinite,
	abs: Math.abs,
	acos: Math.acos,
	asin: Math.asin,
	atan: Math.atan,
	atan2: Math.atan2,
	ceil: Math.ceil,
	cos: Math.cos,
	exp: Math.exp,
	floor: Math.floor,
	log: Math.log,
	max: Math.max,
	min: Math.min,
	pow: Math.pow,
	random: Math.random,
	round: Math.round,
	sin: Math.sin,
	sqrt: Math.sqrt,
	tan: Math.tan,
	clamp: (t, n, r) => Math.max(n, Math.min(r, t)),
	now: Date.now,
	utc: Date.UTC,
	datetime: (t, n = 0, r = 1, i = 0, o = 0, s = 0, l = 0) => isString(t) ? new Date(t) : new Date(t, n, r, i, o, s, l),
	date: (t) => new Date(t).getDate(),
	day: (t) => new Date(t).getDay(),
	year: (t) => new Date(t).getFullYear(),
	month: (t) => new Date(t).getMonth(),
	hours: (t) => new Date(t).getHours(),
	minutes: (t) => new Date(t).getMinutes(),
	seconds: (t) => new Date(t).getSeconds(),
	milliseconds: (t) => new Date(t).getMilliseconds(),
	time: (t) => new Date(t).getTime(),
	timezoneoffset: (t) => new Date(t).getTimezoneOffset(),
	utcdate: (t) => new Date(t).getUTCDate(),
	utcday: (t) => new Date(t).getUTCDay(),
	utcyear: (t) => new Date(t).getUTCFullYear(),
	utcmonth: (t) => new Date(t).getUTCMonth(),
	utchours: (t) => new Date(t).getUTCHours(),
	utcminutes: (t) => new Date(t).getUTCMinutes(),
	utcseconds: (t) => new Date(t).getUTCSeconds(),
	utcmilliseconds: (t) => new Date(t).getUTCMilliseconds(),
	length: (t) => t.length,
	join: function() {
		return apply("join", arguments);
	},
	indexof: function() {
		return apply("indexOf", arguments);
	},
	lastindexof: function() {
		return apply("lastIndexOf", arguments);
	},
	slice: function() {
		return apply("slice", arguments);
	},
	reverse: (t) => t.slice().reverse(),
	sort: (t) => t.slice().sort(ascending),
	parseFloat,
	parseInt,
	upper: (t) => String(t).toUpperCase(),
	lower: (t) => String(t).toLowerCase(),
	substring: function() {
		return apply("substring", arguments, String);
	},
	split: function() {
		return apply("split", arguments, String);
	},
	replace: function() {
		return apply("replace", arguments, String);
	},
	trim: (t) => String(t).trim(),
	btoa: (t) => btoa(t),
	atob: (t) => atob(t),
	regexp: RegExp,
	test: (t, n) => RegExp(t).test(n)
}, EventFunctions = [
	"view",
	"item",
	"group",
	"xy",
	"x",
	"y"
], DisallowedMethods = new Set([
	Function,
	eval,
	setTimeout,
	setInterval
]);
typeof setImmediate == "function" && DisallowedMethods.add(setImmediate);
var Visitors = {
	Literal: (t, n) => n.value,
	Identifier: (t, n) => {
		let r = n.name;
		return t.memberDepth > 0 ? r : r === "datum" ? t.datum : r === "event" ? t.event : r === "item" ? t.item : Constants[r] || t.params["$" + r];
	},
	MemberExpression: (t, n) => {
		let r = !n.computed, i = t(n.object);
		r && (t.memberDepth += 1);
		let o = t(n.property);
		if (r && --t.memberDepth, DisallowedMethods.has(i[o])) {
			console.error(`Prevented interpretation of member "${o}" which could lead to insecure code execution`);
			return;
		}
		return i[o];
	},
	CallExpression: (t, n) => {
		let r = n.arguments, i = n.callee.name;
		return i.startsWith("_") && (i = i.slice(1)), i === "if" ? t(r[0]) ? t(r[1]) : t(r[2]) : (t.fn[i] || Functions[i]).apply(t.fn, r.map(t));
	},
	ArrayExpression: (t, n) => n.elements.map(t),
	BinaryExpression: (t, n) => Ops[n.operator](t(n.left), t(n.right)),
	UnaryExpression: (t, n) => Unary[n.operator](t(n.argument)),
	ConditionalExpression: (t, n) => t(n.test) ? t(n.consequent) : t(n.alternate),
	LogicalExpression: (t, n) => n.operator === "&&" ? t(n.left) && t(n.right) : t(n.left) || t(n.right),
	ObjectExpression: (t, n) => n.properties.reduce((n, r) => {
		t.memberDepth += 1;
		let i = t(r.key);
		--t.memberDepth;
		let o = t(r.value);
		return DisallowedObjectProperties.has(i) ? console.error(`Prevented interpretation of property "${i}" which could lead to insecure code execution`) : DisallowedMethods.has(o) ? console.error(`Prevented interpretation of method "${i}" which could lead to insecure code execution`) : n[i] = o, n;
	}, {})
};
function interpret(t, n, r, i, o, s) {
	let l = (t) => Visitors[t.type](l, t);
	return l.memberDepth = 0, l.fn = Object.create(n), l.params = r, l.datum = i, l.event = o, l.item = s, EventFunctions.forEach((t) => l.fn[t] = (...n) => o.vega[t](...n)), l(t);
}
var expression = {
	operator(t, n) {
		let r = n.ast, i = t.functions;
		return (t) => interpret(r, i, t);
	},
	parameter(t, n) {
		let r = n.ast, i = t.functions;
		return (t, n) => interpret(r, i, n, t);
	},
	event(t, n) {
		let r = n.ast, i = t.functions;
		return (t) => interpret(r, i, void 0, void 0, t);
	},
	handler(t, n) {
		let r = n.ast, i = t.functions;
		return (t, n) => interpret(r, i, t, n.item && n.item.datum, n);
	},
	encode(t, n) {
		let { marktype: r, channels: i } = n, o = t.functions, s = r === "group" || r === "image" || r === "rect";
		return (t, n) => {
			let l = t.datum, u = 0, d;
			for (let r in i) d = interpret(i[r].ast, o, n, l, void 0, t), t[r] !== d && (t[r] = d, u = 1);
			return r !== "rule" && adjustSpatial(t, i, s), u;
		};
	}
}, build_exports = /* @__PURE__ */ __export({
	accessPathDepth: () => accessPathDepth,
	accessPathWithDatum: () => accessPathWithDatum,
	accessWithDatumToUnescapedPath: () => accessWithDatumToUnescapedPath,
	compile: () => compile,
	contains: () => contains,
	deepEqual: () => deepEqual,
	deleteNestedProperty: () => deleteNestedProperty,
	duplicate: () => duplicate,
	entries: () => entries$1,
	every: () => every,
	fieldIntersection: () => fieldIntersection,
	flatAccessWithDatum: () => flatAccessWithDatum,
	getFirstDefined: () => getFirstDefined,
	hasIntersection: () => hasIntersection,
	hasProperty: () => hasProperty,
	hash: () => hash,
	internalField: () => internalField,
	isBoolean: () => isBoolean$1,
	isEmpty: () => isEmpty,
	isEqual: () => isEqual,
	isInternalField: () => isInternalField,
	isNullOrFalse: () => isNullOrFalse,
	isNumeric: () => isNumeric,
	keys: () => keys,
	logicalExpr: () => logicalExpr,
	mergeDeep: () => mergeDeep$1,
	never: () => never,
	normalize: () => normalize,
	normalizeAngle: () => normalizeAngle,
	omit: () => omit,
	pick: () => pick,
	prefixGenerator: () => prefixGenerator,
	removePathFromField: () => removePathFromField,
	replaceAll: () => replaceAll,
	replacePathInField: () => replacePathInField,
	resetIdCounter: () => resetIdCounter,
	setEqual: () => setEqual,
	some: () => some,
	stringify: () => stringify$2,
	titleCase: () => titleCase,
	unescapeSingleQuoteAndPathDot: () => unescapeSingleQuoteAndPathDot,
	unique: () => unique,
	uniqueId: () => uniqueId,
	vals: () => vals,
	varName: () => varName,
	version: () => version$3
}), pkg$2 = { version: "6.4.1" };
function isLogicalOr(t) {
	return hasProperty(t, "or");
}
function isLogicalAnd(t) {
	return hasProperty(t, "and");
}
function isLogicalNot(t) {
	return hasProperty(t, "not");
}
function forEachLeaf(t, n) {
	if (isLogicalNot(t)) forEachLeaf(t.not, n);
	else if (isLogicalAnd(t)) for (let r of t.and) forEachLeaf(r, n);
	else if (isLogicalOr(t)) for (let r of t.or) forEachLeaf(r, n);
	else n(t);
}
function normalizeLogicalComposition(t, n) {
	return isLogicalNot(t) ? { not: normalizeLogicalComposition(t.not, n) } : isLogicalAnd(t) ? { and: t.and.map((t) => normalizeLogicalComposition(t, n)) } : isLogicalOr(t) ? { or: t.or.map((t) => normalizeLogicalComposition(t, n)) } : n(t);
}
var duplicate = structuredClone;
function never(t) {
	throw Error(t);
}
function pick(t, n) {
	let r = {};
	for (let i of n) has(t, i) && (r[i] = t[i]);
	return r;
}
function omit(t, n) {
	let r = { ...t };
	for (let t of n) delete r[t];
	return r;
}
Set.prototype.toJSON = function() {
	return `Set(${[...this].map((t) => stringify$2(t)).join(",")})`;
};
function hash(t) {
	if (isNumber(t)) return t;
	let n = isString(t) ? t : stringify$2(t);
	if (n.length < 250) return n;
	let r = 0;
	for (let t = 0; t < n.length; t++) {
		let i = n.charCodeAt(t);
		r = (r << 5) - r + i, r &= r;
	}
	return r;
}
function isNullOrFalse(t) {
	return t === !1 || t === null;
}
function contains(t, n) {
	return t.includes(n);
}
function some(t, n) {
	let r = 0;
	for (let [i, o] of t.entries()) if (n(o, i, r++)) return !0;
	return !1;
}
function every(t, n) {
	let r = 0;
	for (let [i, o] of t.entries()) if (!n(o, i, r++)) return !1;
	return !0;
}
function mergeDeep$1(t, ...n) {
	for (let r of n) deepMerge_$1(t, r ?? {});
	return t;
}
function deepMerge_$1(t, n) {
	for (let r of keys(n)) writeConfig(t, r, n[r], !0);
}
function unique(t, n) {
	let r = [], i = {}, o;
	for (let s of t) o = n(s), !(o in i) && (i[o] = 1, r.push(s));
	return r;
}
function isEqual(t, n) {
	let r = keys(t), i = keys(n);
	if (r.length !== i.length) return !1;
	for (let i of r) if (t[i] !== n[i]) return !1;
	return !0;
}
function setEqual(t, n) {
	if (t.size !== n.size) return !1;
	for (let r of t) if (!n.has(r)) return !1;
	return !0;
}
function hasIntersection(t, n) {
	for (let r of t) if (n.has(r)) return !0;
	return !1;
}
function prefixGenerator(t) {
	let n = /* @__PURE__ */ new Set();
	for (let r of t) {
		let t = splitAccessPath(r).map((t, n) => n === 0 ? t : `[${t}]`), i = t.map((n, r) => t.slice(0, r + 1).join(""));
		for (let t of i) n.add(t);
	}
	return n;
}
function fieldIntersection(t, n) {
	return t === void 0 || n === void 0 ? !0 : hasIntersection(prefixGenerator(t), prefixGenerator(n));
}
function isEmpty(t) {
	return keys(t).length === 0;
}
var keys = Object.keys, vals = Object.values, entries$1 = Object.entries;
function isBoolean$1(t) {
	return t === !0 || t === !1;
}
function varName(t) {
	let n = t.replace(/\W/g, "_");
	return (t.match(/^\d+/) ? "_" : "") + n;
}
function logicalExpr(t, n) {
	return isLogicalNot(t) ? `!(${logicalExpr(t.not, n)})` : isLogicalAnd(t) ? `(${t.and.map((t) => logicalExpr(t, n)).join(") && (")})` : isLogicalOr(t) ? `(${t.or.map((t) => logicalExpr(t, n)).join(") || (")})` : n(t);
}
function deleteNestedProperty(t, n) {
	if (n.length === 0) return !0;
	let r = n.shift();
	return r in t && deleteNestedProperty(t[r], n) && delete t[r], isEmpty(t);
}
function titleCase(t) {
	return t.charAt(0).toUpperCase() + t.substr(1);
}
function accessPathWithDatum(t, n = "datum") {
	let r = splitAccessPath(t), i = [];
	for (let t = 1; t <= r.length; t++) {
		let o = `[${r.slice(0, t).map($).join("][")}]`;
		i.push(`${n}${o}`);
	}
	return i.join(" && ");
}
function flatAccessWithDatum(t, n = "datum") {
	return `${n}[${$(splitAccessPath(t).join("."))}]`;
}
function accessWithDatumToUnescapedPath(t) {
	return `datum['${t.replaceAll("'", "\\'")}']`;
}
function unescapeSingleQuoteAndPathDot(t) {
	return t.replaceAll("\\'", "'").replaceAll("\\.", ".");
}
function escapePathAccess(t) {
	return t.replace(/(\[|\]|\.|'|")/g, "\\$1");
}
function replacePathInField(t) {
	return `${splitAccessPath(t).map(escapePathAccess).join("\\.")}`;
}
function replaceAll(t, n, r) {
	return t.replace(new RegExp(n.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), r);
}
function removePathFromField(t) {
	return `${splitAccessPath(t).join(".")}`;
}
function accessPathDepth(t) {
	return t ? splitAccessPath(t).length : 0;
}
function getFirstDefined(...t) {
	return t.find((t) => t !== void 0);
}
var idCounter = 42;
function uniqueId(t) {
	let n = ++idCounter;
	return t ? String(t) + n : n;
}
function resetIdCounter() {
	idCounter = 42;
}
function internalField(t) {
	return isInternalField(t) ? t : `__${t}`;
}
function isInternalField(t) {
	return t.startsWith("__");
}
function normalizeAngle(t) {
	if (t !== void 0) return (t % 360 + 360) % 360;
}
function isNumeric(t) {
	return isNumber(t) ? !0 : !isNaN(t) && !isNaN(parseFloat(t));
}
var clonedProto = Object.getPrototypeOf(structuredClone({}));
function deepEqual(t, n) {
	if (t === n) return !0;
	if (t && n && typeof t == "object" && typeof n == "object") {
		if (t.constructor.name !== n.constructor.name) return !1;
		let r, i;
		if (Array.isArray(t)) {
			if (r = t.length, r != n.length) return !1;
			for (i = r; i-- !== 0;) if (!deepEqual(t[i], n[i])) return !1;
			return !0;
		}
		if (t instanceof Map && n instanceof Map) {
			if (t.size !== n.size) return !1;
			for (let r of t.entries()) if (!n.has(r[0])) return !1;
			for (let r of t.entries()) if (!deepEqual(r[1], n.get(r[0]))) return !1;
			return !0;
		}
		if (t instanceof Set && n instanceof Set) {
			if (t.size !== n.size) return !1;
			for (let r of t.entries()) if (!n.has(r[0])) return !1;
			return !0;
		}
		if (ArrayBuffer.isView(t) && ArrayBuffer.isView(n)) {
			if (r = t.length, r != n.length) return !1;
			for (i = r; i-- !== 0;) if (t[i] !== n[i]) return !1;
			return !0;
		}
		if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
		if (t.valueOf !== Object.prototype.valueOf && t.valueOf !== clonedProto.valueOf) return t.valueOf() === n.valueOf();
		if (t.toString !== Object.prototype.toString && t.toString !== clonedProto.toString) return t.toString() === n.toString();
		let o = Object.keys(t);
		if (r = o.length, r !== Object.keys(n).length) return !1;
		for (i = r; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(n, o[i])) return !1;
		for (i = r; i-- !== 0;) {
			let r = o[i];
			if (!deepEqual(t[r], n[r])) return !1;
		}
		return !0;
	}
	return t !== t && n !== n;
}
function stringify$2(t) {
	let n = [];
	return (function t(r) {
		if (r?.toJSON && typeof r.toJSON == "function" && (r = r.toJSON()), r === void 0) return;
		if (typeof r == "number") return isFinite(r) ? `${r}` : "null";
		if (typeof r != "object") return JSON.stringify(r);
		let i, o;
		if (Array.isArray(r)) {
			for (o = "[", i = 0; i < r.length; i++) i && (o += ","), o += t(r[i]) || "null";
			return `${o}]`;
		}
		if (r === null) return "null";
		if (n.includes(r)) throw TypeError("Converting circular structure to JSON");
		let s = n.push(r) - 1, l = Object.keys(r).sort();
		for (o = "", i = 0; i < l.length; i++) {
			let n = l[i], s = t(r[n]);
			s && (o && (o += ","), o += `${JSON.stringify(n)}:${s}`);
		}
		return n.splice(s, 1), `{${o}}`;
	})(t);
}
function hasProperty(t, n) {
	return isObject(t) && has(t, n) && t[n] !== void 0;
}
var ROW = "row", COLUMN = "column", FACET = "facet", X = "x", Y = "y", X2 = "x2", Y2 = "y2", XOFFSET = "xOffset", YOFFSET = "yOffset", RADIUS = "radius", RADIUS2 = "radius2", THETA = "theta", THETA2 = "theta2", LATITUDE = "latitude", LONGITUDE = "longitude", LATITUDE2 = "latitude2", LONGITUDE2 = "longitude2", TIME = "time", COLOR = "color", FILL = "fill", STROKE = "stroke", SHAPE = "shape", SIZE = "size", ANGLE = "angle", OPACITY = "opacity", FILLOPACITY = "fillOpacity", STROKEOPACITY = "strokeOpacity", STROKEWIDTH = "strokeWidth", STROKEDASH = "strokeDash", TEXT$1 = "text", ORDER = "order", DETAIL = "detail", KEY = "key", TOOLTIP = "tooltip", HREF = "href", URL$1 = "url", DESCRIPTION = "description", POSITION_CHANNEL_INDEX = {
	x: 1,
	y: 1,
	x2: 1,
	y2: 1
}, POLAR_POSITION_CHANNEL_INDEX = {
	theta: 1,
	theta2: 1,
	radius: 1,
	radius2: 1
};
function isPolarPositionChannel(t) {
	return has(POLAR_POSITION_CHANNEL_INDEX, t);
}
var GEO_POSIITON_CHANNEL_INDEX = {
	longitude: 1,
	longitude2: 1,
	latitude: 1,
	latitude2: 1
};
function getPositionChannelFromLatLong(t) {
	switch (t) {
		case LATITUDE: return "y";
		case LATITUDE2: return "y2";
		case LONGITUDE: return "x";
		case LONGITUDE2: return "x2";
	}
}
function isGeoPositionChannel(t) {
	return has(GEO_POSIITON_CHANNEL_INDEX, t);
}
var GEOPOSITION_CHANNELS = keys(GEO_POSIITON_CHANNEL_INDEX), UNIT_CHANNEL_INDEX = {
	...POSITION_CHANNEL_INDEX,
	...POLAR_POSITION_CHANNEL_INDEX,
	...GEO_POSIITON_CHANNEL_INDEX,
	xOffset: 1,
	yOffset: 1,
	color: 1,
	fill: 1,
	stroke: 1,
	time: 1,
	opacity: 1,
	fillOpacity: 1,
	strokeOpacity: 1,
	strokeWidth: 1,
	strokeDash: 1,
	size: 1,
	angle: 1,
	shape: 1,
	order: 1,
	text: 1,
	detail: 1,
	key: 1,
	tooltip: 1,
	href: 1,
	url: 1,
	description: 1
};
function isColorChannel(t) {
	return t === COLOR || t === FILL || t === STROKE;
}
var FACET_CHANNEL_INDEX = {
	row: 1,
	column: 1,
	facet: 1
}, FACET_CHANNELS = keys(FACET_CHANNEL_INDEX), CHANNEL_INDEX = {
	...UNIT_CHANNEL_INDEX,
	...FACET_CHANNEL_INDEX
}, CHANNELS = keys(CHANNEL_INDEX), { order: _o, detail: _d, tooltip: _tt1,...SINGLE_DEF_CHANNEL_INDEX } = CHANNEL_INDEX, { row: _r, column: _c, facet: _f,...SINGLE_DEF_UNIT_CHANNEL_INDEX } = SINGLE_DEF_CHANNEL_INDEX;
function isSingleDefUnitChannel(t) {
	return has(SINGLE_DEF_UNIT_CHANNEL_INDEX, t);
}
function isChannel(t) {
	return has(CHANNEL_INDEX, t);
}
var SECONDARY_RANGE_CHANNEL = [
	X2,
	Y2,
	LATITUDE2,
	LONGITUDE2,
	THETA2,
	RADIUS2
];
function isSecondaryRangeChannel(t) {
	return getMainRangeChannel(t) !== t;
}
function getMainRangeChannel(t) {
	switch (t) {
		case X2: return X;
		case Y2: return Y;
		case LATITUDE2: return LATITUDE;
		case LONGITUDE2: return LONGITUDE;
		case THETA2: return THETA;
		case RADIUS2: return RADIUS;
	}
	return t;
}
function getVgPositionChannel(t) {
	if (isPolarPositionChannel(t)) switch (t) {
		case THETA: return "startAngle";
		case THETA2: return "endAngle";
		case RADIUS: return "outerRadius";
		case RADIUS2: return "innerRadius";
	}
	return t;
}
function getSecondaryRangeChannel(t) {
	switch (t) {
		case X: return X2;
		case Y: return Y2;
		case LATITUDE: return LATITUDE2;
		case LONGITUDE: return LONGITUDE2;
		case THETA: return THETA2;
		case RADIUS: return RADIUS2;
	}
}
function getSizeChannel(t) {
	switch (t) {
		case X:
		case X2: return "width";
		case Y:
		case Y2: return "height";
	}
}
function getOffsetChannel(t) {
	switch (t) {
		case X: return "xOffset";
		case Y: return "yOffset";
		case X2: return "x2Offset";
		case Y2: return "y2Offset";
		case THETA: return "thetaOffset";
		case RADIUS: return "radiusOffset";
		case THETA2: return "theta2Offset";
		case RADIUS2: return "radius2Offset";
	}
}
function getOffsetScaleChannel(t) {
	switch (t) {
		case X: return "xOffset";
		case Y: return "yOffset";
	}
}
function getMainChannelFromOffsetChannel(t) {
	switch (t) {
		case "xOffset": return "x";
		case "yOffset": return "y";
	}
}
var UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX), { x: _x, y: _y, x2: _x2, y2: _y2, xOffset: _xo, yOffset: _yo, latitude: _latitude, longitude: _longitude, latitude2: _latitude2, longitude2: _longitude2, theta: _theta, theta2: _theta2, radius: _radius, radius2: _radius2,...NONPOSITION_CHANNEL_INDEX } = UNIT_CHANNEL_INDEX, NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX), POSITION_SCALE_CHANNEL_INDEX = {
	x: 1,
	y: 1
}, POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);
function isXorY(t) {
	return has(POSITION_SCALE_CHANNEL_INDEX, t);
}
var POLAR_POSITION_SCALE_CHANNEL_INDEX = {
	theta: 1,
	radius: 1
}, POLAR_POSITION_SCALE_CHANNELS = keys(POLAR_POSITION_SCALE_CHANNEL_INDEX);
function getPositionScaleChannel(t) {
	return t === "width" ? X : Y;
}
var OFFSET_SCALE_CHANNEL_INDEX = {
	xOffset: 1,
	yOffset: 1
};
function isXorYOffset(t) {
	return has(OFFSET_SCALE_CHANNEL_INDEX, t);
}
var TIME_SCALE_CHANNEL_INDEX = { time: 1 };
function isTime(t) {
	return t in TIME_SCALE_CHANNEL_INDEX;
}
var { text: _t, tooltip: _tt, href: _hr, url: _u, description: _al, detail: _dd, key: _k, order: _oo,...NONPOSITION_SCALE_CHANNEL_INDEX } = NONPOSITION_CHANNEL_INDEX, NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);
function isNonPositionScaleChannel(t) {
	return has(NONPOSITION_CHANNEL_INDEX, t);
}
function supportLegend(t) {
	switch (t) {
		case COLOR:
		case FILL:
		case STROKE:
		case SIZE:
		case SHAPE:
		case OPACITY:
		case STROKEWIDTH:
		case STROKEDASH: return !0;
		case FILLOPACITY:
		case STROKEOPACITY:
		case ANGLE:
		case TIME: return !1;
	}
}
var SCALE_CHANNEL_INDEX = {
	...POSITION_SCALE_CHANNEL_INDEX,
	...POLAR_POSITION_SCALE_CHANNEL_INDEX,
	...OFFSET_SCALE_CHANNEL_INDEX,
	...NONPOSITION_SCALE_CHANNEL_INDEX
}, SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);
function isScaleChannel(t) {
	return has(SCALE_CHANNEL_INDEX, t);
}
function supportMark(t, n) {
	return getSupportedMark(t)[n];
}
var ALL_MARKS = {
	arc: "always",
	area: "always",
	bar: "always",
	circle: "always",
	geoshape: "always",
	image: "always",
	line: "always",
	rule: "always",
	point: "always",
	rect: "always",
	square: "always",
	trail: "always",
	text: "always",
	tick: "always"
}, { geoshape: _g,...ALL_MARKS_EXCEPT_GEOSHAPE } = ALL_MARKS;
function getSupportedMark(t) {
	switch (t) {
		case COLOR:
		case FILL:
		case STROKE:
		case DESCRIPTION:
		case DETAIL:
		case KEY:
		case TOOLTIP:
		case HREF:
		case ORDER:
		case OPACITY:
		case FILLOPACITY:
		case STROKEOPACITY:
		case STROKEWIDTH:
		case FACET:
		case ROW:
		case COLUMN: return ALL_MARKS;
		case X:
		case Y:
		case XOFFSET:
		case YOFFSET:
		case LATITUDE:
		case LONGITUDE:
		case TIME: return ALL_MARKS_EXCEPT_GEOSHAPE;
		case X2:
		case Y2:
		case LATITUDE2:
		case LONGITUDE2: return {
			area: "always",
			bar: "always",
			image: "always",
			rect: "always",
			rule: "always",
			circle: "binned",
			point: "binned",
			square: "binned",
			tick: "binned",
			line: "binned",
			trail: "binned"
		};
		case SIZE: return {
			point: "always",
			tick: "always",
			rule: "always",
			circle: "always",
			square: "always",
			bar: "always",
			text: "always",
			line: "always",
			trail: "always"
		};
		case STROKEDASH: return {
			line: "always",
			point: "always",
			tick: "always",
			rule: "always",
			circle: "always",
			square: "always",
			bar: "always",
			geoshape: "always"
		};
		case SHAPE: return {
			point: "always",
			geoshape: "always"
		};
		case TEXT$1: return { text: "always" };
		case ANGLE: return {
			point: "always",
			square: "always",
			text: "always"
		};
		case URL$1: return { image: "always" };
		case THETA: return {
			text: "always",
			arc: "always"
		};
		case RADIUS: return {
			text: "always",
			arc: "always"
		};
		case THETA2:
		case RADIUS2: return { arc: "always" };
	}
}
function rangeType(t) {
	switch (t) {
		case X:
		case Y:
		case THETA:
		case RADIUS:
		case XOFFSET:
		case YOFFSET:
		case SIZE:
		case ANGLE:
		case STROKEWIDTH:
		case OPACITY:
		case FILLOPACITY:
		case STROKEOPACITY:
		case TIME:
		case X2:
		case Y2:
		case THETA2:
		case RADIUS2: return;
		case FACET:
		case ROW:
		case COLUMN:
		case SHAPE:
		case STROKEDASH:
		case TEXT$1:
		case TOOLTIP:
		case HREF:
		case URL$1:
		case DESCRIPTION: return "discrete";
		case COLOR:
		case FILL:
		case STROKE: return "flexible";
		case LATITUDE:
		case LONGITUDE:
		case LATITUDE2:
		case LONGITUDE2:
		case DETAIL:
		case KEY:
		case ORDER: return;
	}
}
var AGGREGATE_OP_INDEX = {
	argmax: 1,
	argmin: 1,
	average: 1,
	count: 1,
	distinct: 1,
	exponential: 1,
	exponentialb: 1,
	product: 1,
	max: 1,
	mean: 1,
	median: 1,
	min: 1,
	missing: 1,
	q1: 1,
	q3: 1,
	ci0: 1,
	ci1: 1,
	stderr: 1,
	stdev: 1,
	stdevp: 1,
	sum: 1,
	valid: 1,
	values: 1,
	variance: 1,
	variancep: 1
}, MULTIDOMAIN_SORT_OP_INDEX = {
	count: 1,
	min: 1,
	max: 1
};
function isArgminDef(t) {
	return hasProperty(t, "argmin");
}
function isArgmaxDef(t) {
	return hasProperty(t, "argmax");
}
function isAggregateOp(t) {
	return isString(t) && has(AGGREGATE_OP_INDEX, t);
}
var COUNTING_OPS = new Set([
	"count",
	"valid",
	"missing",
	"distinct"
]);
function isCountingAggregateOp(t) {
	return isString(t) && COUNTING_OPS.has(t);
}
function isMinMaxOp(t) {
	return isString(t) && contains(["min", "max"], t);
}
var SUM_OPS = new Set([
	"count",
	"sum",
	"distinct",
	"valid",
	"missing"
]), SHARED_DOMAIN_OPS = new Set([
	"mean",
	"average",
	"median",
	"q1",
	"q3",
	"min",
	"max"
]);
function binToString(t) {
	return isBoolean(t) && (t = normalizeBin(t, void 0)), `bin${keys(t).map((n) => isParameterExtent(t[n]) ? varName(`_${n}_${entries$1(t[n])}`) : varName(`_${n}_${t[n]}`)).join("")}`;
}
function isBinning(t) {
	return t === !0 || isBinParams(t) && !t.binned;
}
function isBinned(t) {
	return t === "binned" || isBinParams(t) && t.binned === !0;
}
function isBinParams(t) {
	return isObject(t);
}
function isParameterExtent(t) {
	return hasProperty(t, "param");
}
function autoMaxBins(t) {
	switch (t) {
		case ROW:
		case COLUMN:
		case SIZE:
		case COLOR:
		case FILL:
		case STROKE:
		case STROKEWIDTH:
		case OPACITY:
		case FILLOPACITY:
		case STROKEOPACITY:
		case SHAPE: return 6;
		case STROKEDASH: return 4;
		default: return 10;
	}
}
function isExprRef(t) {
	return hasProperty(t, "expr");
}
function replaceExprRef(t, { level: n } = { level: 0 }) {
	let r = keys(t || {}), i = {};
	for (let o of r) i[o] = n === 0 ? signalRefOrValue(t[o]) : replaceExprRef(t[o], { level: n - 1 });
	return i;
}
function extractTitleConfig(t) {
	let { anchor: n, frame: r, offset: i, orient: o, angle: s, limit: l, color: u, subtitleColor: d, subtitleFont: f, subtitleFontSize: p, subtitleFontStyle: g, subtitleFontWeight: _, subtitleLineHeight: v, subtitlePadding: S,...T } = t, E = {
		...T,
		...u ? { fill: u } : {}
	}, O = {
		...n ? { anchor: n } : {},
		...r ? { frame: r } : {},
		...i ? { offset: i } : {},
		...o ? { orient: o } : {},
		...s === void 0 ? {} : { angle: s },
		...l === void 0 ? {} : { limit: l }
	}, k = {
		...d ? { subtitleColor: d } : {},
		...f ? { subtitleFont: f } : {},
		...p ? { subtitleFontSize: p } : {},
		...g ? { subtitleFontStyle: g } : {},
		..._ ? { subtitleFontWeight: _ } : {},
		...v ? { subtitleLineHeight: v } : {},
		...S ? { subtitlePadding: S } : {}
	};
	return {
		titleMarkConfig: E,
		subtitleMarkConfig: pick(t, [
			"align",
			"baseline",
			"dx",
			"dy",
			"limit"
		]),
		nonMarkTitleProperties: O,
		subtitle: k
	};
}
function isText(t) {
	return isString(t) || isArray(t) && isString(t[0]);
}
function isSignalRef(t) {
	return hasProperty(t, "signal");
}
function isVgRangeStep(t) {
	return hasProperty(t, "step");
}
function isDataRefUnionedDomain(t) {
	return isArray(t) ? !1 : hasProperty(t, "fields") && !hasProperty(t, "data");
}
function isFieldRefUnionDomain(t) {
	return isArray(t) ? !1 : hasProperty(t, "fields") && hasProperty(t, "data");
}
function isDataRefDomain(t) {
	return isArray(t) ? !1 : hasProperty(t, "field") && hasProperty(t, "data");
}
var VG_MARK_CONFIGS = keys({
	aria: 1,
	description: 1,
	ariaRole: 1,
	ariaRoleDescription: 1,
	blend: 1,
	opacity: 1,
	fill: 1,
	fillOpacity: 1,
	stroke: 1,
	strokeCap: 1,
	strokeWidth: 1,
	strokeOpacity: 1,
	strokeDash: 1,
	strokeDashOffset: 1,
	strokeJoin: 1,
	strokeOffset: 1,
	strokeMiterLimit: 1,
	startAngle: 1,
	endAngle: 1,
	padAngle: 1,
	innerRadius: 1,
	outerRadius: 1,
	size: 1,
	shape: 1,
	interpolate: 1,
	tension: 1,
	orient: 1,
	align: 1,
	baseline: 1,
	text: 1,
	dir: 1,
	dx: 1,
	dy: 1,
	ellipsis: 1,
	limit: 1,
	radius: 1,
	theta: 1,
	angle: 1,
	font: 1,
	fontSize: 1,
	fontWeight: 1,
	fontStyle: 1,
	lineBreak: 1,
	lineHeight: 1,
	cursor: 1,
	href: 1,
	tooltip: 1,
	cornerRadius: 1,
	cornerRadiusTopLeft: 1,
	cornerRadiusTopRight: 1,
	cornerRadiusBottomLeft: 1,
	cornerRadiusBottomRight: 1,
	aspect: 1,
	width: 1,
	height: 1,
	url: 1,
	smooth: 1
}), VG_MARK_INDEX = {
	arc: 1,
	area: 1,
	group: 1,
	image: 1,
	line: 1,
	path: 1,
	rect: 1,
	rule: 1,
	shape: 1,
	symbol: 1,
	text: 1,
	trail: 1
}, VG_CORNERRADIUS_CHANNELS = [
	"cornerRadius",
	"cornerRadiusTopLeft",
	"cornerRadiusTopRight",
	"cornerRadiusBottomLeft",
	"cornerRadiusBottomRight"
], BIN_RANGE_DELIMITER = " – ";
function signalOrValueRefWithCondition(t) {
	let n = isArray(t.condition) ? t.condition.map(conditionalSignalRefOrValue) : conditionalSignalRefOrValue(t.condition);
	return {
		...signalRefOrValue(t),
		condition: n
	};
}
function signalRefOrValue(t) {
	if (isExprRef(t)) {
		let { expr: n,...r } = t;
		return {
			signal: n,
			...r
		};
	}
	return t;
}
function conditionalSignalRefOrValue(t) {
	if (isExprRef(t)) {
		let { expr: n,...r } = t;
		return {
			signal: n,
			...r
		};
	}
	return t;
}
function signalOrValueRef(t) {
	if (isExprRef(t)) {
		let { expr: n,...r } = t;
		return {
			signal: n,
			...r
		};
	}
	return isSignalRef(t) ? t : t === void 0 ? void 0 : { value: t };
}
function exprFromSignalRefOrValue(t) {
	return isSignalRef(t) ? t.signal : $(t);
}
function exprFromValueRefOrSignalRef(t) {
	return isSignalRef(t) ? t.signal : $(t.value);
}
function signalOrStringValue(t) {
	return isSignalRef(t) ? t.signal : t == null ? null : $(t);
}
function applyMarkConfig(t, n, r) {
	for (let i of r) {
		let r = getMarkConfig(i, n.markDef, n.config);
		r !== void 0 && (t[i] = signalOrValueRef(r));
	}
	return t;
}
function getStyles(t) {
	return [].concat(t.type, t.style ?? []);
}
function getMarkPropOrConfig(t, n, r, i = {}) {
	let { vgChannel: o, ignoreVgConfig: s } = i;
	return o && hasProperty(n, o) ? n[o] : n[t] === void 0 ? s && (!o || o === t) ? void 0 : getMarkConfig(t, n, r, i) : n[t];
}
function getMarkConfig(t, n, r, { vgChannel: i } = {}) {
	let o = getMarkStyleConfig(t, n, r.style);
	return getFirstDefined(i ? o : void 0, o, i ? r[n.type][i] : void 0, r[n.type][t], i ? r.mark[i] : r.mark[t]);
}
function getMarkStyleConfig(t, n, r) {
	return getStyleConfig(t, getStyles(n), r);
}
function getStyleConfig(t, n, r) {
	n = array(n);
	let i;
	for (let o of n) {
		let n = r[o];
		hasProperty(n, t) && (i = n[t]);
	}
	return i;
}
function sortParams(t, n) {
	return array(t).reduce((t, r) => (t.field.push(vgField(r, n)), t.order.push(r.sort ?? "ascending"), t), {
		field: [],
		order: []
	});
}
function mergeTitleFieldDefs(t, n) {
	let r = [...t];
	return n.forEach((t) => {
		for (let n of r) if (deepEqual(n, t)) return;
		r.push(t);
	}), r;
}
function mergeTitle(t, n) {
	return deepEqual(t, n) || !n ? t : t ? [...array(t), ...array(n)].join(", ") : n;
}
function mergeTitleComponent(t, n) {
	let r = t.value, i = n.value;
	if (r == null || i === null) return {
		explicit: t.explicit,
		value: null
	};
	if ((isText(r) || isSignalRef(r)) && (isText(i) || isSignalRef(i))) return {
		explicit: t.explicit,
		value: mergeTitle(r, i)
	};
	if (isText(r) || isSignalRef(r)) return {
		explicit: t.explicit,
		value: r
	};
	if (isText(i) || isSignalRef(i)) return {
		explicit: t.explicit,
		value: i
	};
	if (!isText(r) && !isSignalRef(r) && !isText(i) && !isSignalRef(i)) return {
		explicit: t.explicit,
		value: mergeTitleFieldDefs(r, i)
	};
	/* istanbul ignore next: Condition should not happen -- only for warning in development. */
	throw Error("It should never reach here");
}
function invalidSpec(t) {
	return `Invalid specification ${stringify$2(t)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
}
var FIT_NON_SINGLE = "Autosize \"fit\" only works for single views and layered views.";
function containerSizeNonSingle(t) {
	return `${t == "width" ? "Width" : "Height"} "container" only works for single views and layered views.`;
}
function containerSizeNotCompatibleWithAutosize(t) {
	return `${t == "width" ? "Width" : "Height"} "container" only works well with autosize "fit" or "fit-${t == "width" ? "x" : "y"}".`;
}
function droppingFit(t) {
	return t ? `Dropping "fit-${t}" because spec has discrete ${getSizeChannel(t)}.` : "Dropping \"fit\" because spec has discrete size.";
}
function unknownField(t) {
	return `Unknown field for ${t}. Cannot calculate view size.`;
}
function cannotProjectOnChannelWithoutField(t) {
	return `Cannot project a selection on encoding channel "${t}", which has no field.`;
}
function cannotProjectAggregate(t, n) {
	return `Cannot project a selection on encoding channel "${t}" as it uses an aggregate function ("${n}").`;
}
function nearestNotSupportForContinuous(t) {
	return `The "nearest" transform is not supported for ${t} marks.`;
}
function selectionNotSupported(t) {
	return `Selection not supported for ${t} yet.`;
}
function selectionNotFound(t) {
	return `Cannot find a selection named "${t}".`;
}
var SCALE_BINDINGS_CONTINUOUS = "Scale bindings are currently only supported for scales with unbinned, continuous domains.", SEQUENTIAL_SCALE_DEPRECATED = "Sequntial scales are deprecated. The available quantitative scale type values are linear, log, pow, sqrt, symlog, time and utc", LEGEND_BINDINGS_MUST_HAVE_PROJECTION = "Legend bindings are only supported for selections over an individual field or encoding channel.";
function cannotLookupVariableParameter(t) {
	return `Lookups can only be performed on selection parameters. "${t}" is a variable parameter.`;
}
function noSameUnitLookup(t) {
	return `Cannot define and lookup the "${t}" selection in the same view. Try moving the lookup into a second, layered view?`;
}
var NEEDS_SAME_SELECTION = "The same selection must be used to override scale domains in a layered view.", INTERVAL_INITIALIZED_WITH_POS = "Interval selections should be initialized using \"x\", \"y\", \"longitude\", or \"latitude\" keys.";
function noSuchRepeatedValue(t) {
	return `Unknown repeated value "${t}".`;
}
function columnsNotSupportByRowCol(t) {
	return `The "columns" property cannot be used when "${t}" has nested row/column.`;
}
var MULTIPLE_TIMER_ANIMATION_SELECTION = "Multiple timer selections in one unit spec are not supported. Ignoring all but the first.", MULTI_VIEW_ANIMATION_UNSUPPORTED = "Animation involving facet, layer, or concat is currently unsupported.";
function selectionAsScaleDomainWithoutField(t) {
	return `A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${$(t)}.`;
}
function selectionAsScaleDomainWrongEncodings(t, n, r, i) {
	return `${t.length ? "Multiple " : "No "}matching ${$(n)} encoding found for selection ${$(r.param)}. Using "field": ${$(i)}.`;
}
var CONCAT_CANNOT_SHARE_AXIS = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
function unrecognizedParse(t) {
	return `Unrecognized parse "${t}".`;
}
function differentParse(t, n, r) {
	return `An ancestor parsed field "${t}" as ${r} but a child wants to parse the field as ${n}.`;
}
var ADD_SAME_CHILD_TWICE = "Attempt to add the same child twice.";
function invalidTransformIgnored(t) {
	return `Ignoring an invalid transform: ${stringify$2(t)}.`;
}
var NO_FIELDS_NEEDS_AS = "If \"from.fields\" is not specified, \"as\" has to be a string that specifies the key to be used for the data from the secondary source.";
function customFormatTypeNotAllowed(t) {
	return `Config.customFormatTypes is not true, thus custom format type and format for channel ${t} are dropped.`;
}
function projectionOverridden(t) {
	let { parentProjection: n, projection: r } = t;
	return `Layer's shared projection ${stringify$2(n)} is overridden by a child projection ${stringify$2(r)}.`;
}
var REPLACE_ANGLE_WITH_THETA = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
function offsetNestedInsideContinuousPositionScaleDropped(t) {
	return `${t}Offset dropped because ${t} is continuous`;
}
function primitiveChannelDef(t, n, r) {
	return `Channel ${t} is a ${n}. Converted to {value: ${stringify$2(r)}}.`;
}
function invalidFieldType(t) {
	return `Invalid field type "${t}".`;
}
function invalidFieldTypeForCountAggregate(t, n) {
	return `Invalid field type "${t}" for aggregate: "${n}", using "quantitative" instead.`;
}
function invalidAggregate(t) {
	return `Invalid aggregation operator "${t}".`;
}
function droppingColor(t, n) {
	let { fill: r, stroke: i } = n;
	return `Dropping color ${t} as the plot also has ${r && i ? "fill and stroke" : r ? "fill" : "stroke"}.`;
}
function relativeBandSizeNotSupported(t) {
	return `Position range does not support relative band size for ${t}.`;
}
function emptyFieldDef(t, n) {
	return `Dropping ${stringify$2(t)} from channel "${n}" since it does not contain any data field, datum, value, or signal.`;
}
var LINE_WITH_VARYING_SIZE = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
function incompatibleChannel(t, n, r) {
	return `${t} dropped as it is incompatible with "${n}".`;
}
function invalidEncodingChannel(t) {
	return `${t}-encoding is dropped as ${t} is not a valid encoding channel.`;
}
function channelShouldBeDiscrete(t) {
	return `${t} encoding should be discrete (ordinal / nominal / binned).`;
}
function channelShouldBeDiscreteOrDiscretizing(t) {
	return `${t} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;
}
function facetChannelDropped(t) {
	return `Facet encoding dropped as ${t.join(" and ")} ${t.length > 1 ? "are" : "is"} also specified.`;
}
function discreteChannelCannotEncode(t, n) {
	return `Using discrete channel "${t}" to encode "${n}" field can be misleading as it does not encode ${n === "ordinal" ? "order" : "magnitude"}.`;
}
function rangeMarkAlignmentCannotBeExpression(t) {
	return `The ${t} for range marks cannot be an expression`;
}
function lineWithRange(t, n) {
	return `Line mark is for continuous lines and thus cannot be used with ${t && n ? "x2 and y2" : t ? "x2" : "y2"}. We will use the rule mark (line segments) instead.`;
}
function orientOverridden(t, n) {
	return `Specified orient "${t}" overridden with "${n}".`;
}
function cannotUseScalePropertyWithNonColor(t) {
	return `Cannot use the scale property "${t}" with non-color channel.`;
}
function cannotUseRelativeBandSizeWithNonBandScale(t) {
	return `Cannot use the relative band size with ${t} scale.`;
}
function unaggregateDomainHasNoEffectForRawField(t) {
	return `Using unaggregated domain with raw field has no effect (${stringify$2(t)}).`;
}
function unaggregateDomainWithNonSharedDomainOp(t) {
	return `Unaggregated domain not applicable for "${t}" since it produces values outside the origin domain of the source data.`;
}
function unaggregatedDomainWithLogScale(t) {
	return `Unaggregated domain is currently unsupported for log scale (${stringify$2(t)}).`;
}
function cannotApplySizeToNonOrientedMark(t) {
	return `Cannot apply size to non-oriented mark "${t}".`;
}
function scaleTypeNotWorkWithChannel(t, n, r) {
	return `Channel "${t}" does not work with "${n}" scale. We are using "${r}" scale instead.`;
}
function scaleTypeNotWorkWithFieldDef(t, n) {
	return `FieldDef does not work with "${t}" scale. We are using "${n}" scale instead.`;
}
function scalePropertyNotWorkWithScaleType(t, n, r) {
	return `${r}-scale's "${n}" is dropped as it does not work with ${t} scale.`;
}
function stepDropped(t) {
	return `The step for "${t}" is dropped because the ${t === "width" ? "x" : "y"} is continuous.`;
}
function mergeConflictingProperty(t, n, r, i) {
	return `Conflicting ${n.toString()} property "${t.toString()}" (${stringify$2(r)} and ${stringify$2(i)}). Using ${stringify$2(r)}.`;
}
function mergeConflictingDomainProperty(t, n, r, i) {
	return `Conflicting ${n.toString()} property "${t.toString()}" (${stringify$2(r)} and ${stringify$2(i)}). Using the union of the two domains.`;
}
function independentScaleMeansIndependentGuide(t) {
	return `Setting the scale to be independent for "${t}" means we also have to set the guide (axis or legend) to be independent.`;
}
function domainSortDropped(t) {
	return `Dropping sort property ${stringify$2(t)} as unioned domains only support boolean or op "count", "min", and "max".`;
}
var MORE_THAN_ONE_SORT = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.", FACETED_INDEPENDENT_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.", FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.", FACETED_INDEPENDENT_SAME_SOURCE = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
function cannotStackRangedMark(t) {
	return `Cannot stack "${t}" if there is already "${t}2".`;
}
function stackNonLinearScale(t) {
	return `Stack is applied to a non-linear scale (${t}).`;
}
function stackNonSummativeAggregate(t) {
	return `Stacking is applied even though the aggregate function is non-summative ("${t}").`;
}
function invalidTimeUnit(t, n) {
	return `Invalid ${t}: ${stringify$2(n)}.`;
}
function droppedDay(t) {
	return `Dropping day from datetime ${stringify$2(t)} as day cannot be combined with other units.`;
}
function errorBarCenterAndExtentAreNotNeeded(t, n) {
	return `${n ? "extent " : ""}${n && t ? "and " : ""}${t ? "center " : ""}${n && t ? "are " : "is "}not needed when data are aggregated.`;
}
function errorBarCenterIsUsedWithWrongExtent(t, n, r) {
	return `${t} is not usually used with ${n} for ${r}.`;
}
function errorBarContinuousAxisHasCustomizedAggregate(t, n) {
	return `Continuous axis should not have customized aggregation function ${t}; ${n} already agregates the axis.`;
}
function errorBand1DNotSupport(t) {
	return `1D error band does not support ${t}.`;
}
function channelRequiredForBinned(t) {
	return `Channel ${t} is required for "binned" bin.`;
}
function channelShouldNotBeUsedForBinned(t) {
	return `Channel ${t} should not be used with "binned" bin.`;
}
function domainRequiredForThresholdScale(t) {
	return `Domain for ${t} is required for threshold scale.`;
}
var main = logger(2), current = main;
function set(t) {
	return current = t, current;
}
function reset() {
	return current = main, current;
}
function error(...t) {
	current.error(...t);
}
function warn(...t) {
	current.warn(...t);
}
function debug(...t) {
	current.debug(...t);
}
function isDateTime(t) {
	if (t && isObject(t)) {
		for (let n of TIMEUNIT_PARTS) if (hasProperty(t, n)) return !0;
	}
	return !1;
}
var MONTHS = [
	"january",
	"february",
	"march",
	"april",
	"may",
	"june",
	"july",
	"august",
	"september",
	"october",
	"november",
	"december"
], SHORT_MONTHS = MONTHS.map((t) => t.substr(0, 3)), DAYS = [
	"sunday",
	"monday",
	"tuesday",
	"wednesday",
	"thursday",
	"friday",
	"saturday"
], SHORT_DAYS = DAYS.map((t) => t.substr(0, 3));
function normalizeQuarter(t) {
	if (isNumeric(t) && (t = +t), isNumber(t)) return t > 4 && warn(invalidTimeUnit("quarter", t)), t - 1;
	throw Error(invalidTimeUnit("quarter", t));
}
function normalizeMonth(t) {
	if (isNumeric(t) && (t = +t), isNumber(t)) return t - 1;
	{
		let n = t.toLowerCase(), r = MONTHS.indexOf(n);
		if (r !== -1) return r;
		let i = n.substr(0, 3), o = SHORT_MONTHS.indexOf(i);
		if (o !== -1) return o;
		throw Error(invalidTimeUnit("month", t));
	}
}
function normalizeDay(t) {
	if (isNumeric(t) && (t = +t), isNumber(t)) return t % 7;
	{
		let n = t.toLowerCase(), r = DAYS.indexOf(n);
		if (r !== -1) return r;
		let i = n.substr(0, 3), o = SHORT_DAYS.indexOf(i);
		if (o !== -1) return o;
		throw Error(invalidTimeUnit("day", t));
	}
}
function dateTimeParts(t, n) {
	let r = [];
	if (n && t.day !== void 0 && keys(t).length > 1 && (warn(droppedDay(t)), t = duplicate(t), delete t.day), t.year === void 0 ? r.push(2012) : r.push(t.year), t.month !== void 0) {
		let i = n ? normalizeMonth(t.month) : t.month;
		r.push(i);
	} else if (t.quarter !== void 0) {
		let i = n ? normalizeQuarter(t.quarter) : t.quarter;
		r.push(isNumber(i) ? i * 3 : `${i}*3`);
	} else r.push(0);
	if (t.date !== void 0) r.push(t.date);
	else if (t.day !== void 0) {
		let i = n ? normalizeDay(t.day) : t.day;
		r.push(isNumber(i) ? i + 1 : `${i}+1`);
	} else r.push(1);
	for (let n of [
		"hours",
		"minutes",
		"seconds",
		"milliseconds"
	]) {
		let i = t[n];
		r.push(i === void 0 ? 0 : i);
	}
	return r;
}
function dateTimeToExpr(t) {
	let n = dateTimeParts(t, !0).join(", ");
	return t.utc ? `utc(${n})` : `datetime(${n})`;
}
function dateTimeExprToExpr(t) {
	let n = dateTimeParts(t, !1).join(", ");
	return t.utc ? `utc(${n})` : `datetime(${n})`;
}
function dateTimeToTimestamp(t) {
	let n = dateTimeParts(t, !0);
	return t.utc ? +new Date(Date.UTC(...n)) : +new Date(...n);
}
var LOCAL_SINGLE_TIMEUNIT_INDEX = {
	year: 1,
	quarter: 1,
	month: 1,
	week: 1,
	day: 1,
	dayofyear: 1,
	date: 1,
	hours: 1,
	minutes: 1,
	seconds: 1,
	milliseconds: 1
}, TIMEUNIT_PARTS = keys(LOCAL_SINGLE_TIMEUNIT_INDEX);
function isLocalSingleTimeUnit(t) {
	return has(LOCAL_SINGLE_TIMEUNIT_INDEX, t);
}
function isBinnedTimeUnit(t) {
	return isObject(t) ? t.binned : isBinnedTimeUnitString(t);
}
function isBinnedTimeUnitString(t) {
	return t?.startsWith("binned");
}
function isUTCTimeUnit(t) {
	return t.startsWith("utc");
}
function getLocalTimeUnitFromUTCTimeUnit(t) {
	return t.substring(3);
}
var VEGALITE_TIMEFORMAT = {
	"year-month": "%b %Y ",
	"year-month-date": "%b %d, %Y "
};
function getTimeUnitParts(t) {
	return TIMEUNIT_PARTS.filter((n) => containsTimeUnit(t, n));
}
function getSmallestTimeUnitPart(t) {
	let n = getTimeUnitParts(t);
	return n[n.length - 1];
}
function containsTimeUnit(t, n) {
	let r = t.indexOf(n);
	return !(r < 0 || r > 0 && n === "seconds" && t.charAt(r - 1) === "i" || t.length > r + 3 && n === "day" && t.charAt(r + 3) === "o" || r > 0 && n === "year" && t.charAt(r - 1) === "f");
}
function fieldExpr(t, n, { end: r } = { end: !1 }) {
	let i = accessPathWithDatum(n), o = isUTCTimeUnit(t) ? "utc" : "";
	function s(t) {
		return t === "quarter" ? `(${o}quarter(${i})-1)` : `${o}${t}(${i})`;
	}
	let l, u = {};
	for (let n of TIMEUNIT_PARTS) containsTimeUnit(t, n) && (u[n] = s(n), l = n);
	return r && (u[l] += "+1"), dateTimeExprToExpr(u);
}
function timeUnitSpecifierExpression(t) {
	if (t) return `timeUnitSpecifier(${stringify$2(getTimeUnitParts(t))}, ${stringify$2(VEGALITE_TIMEFORMAT)})`;
}
function formatExpression(t, n, r) {
	if (!t) return;
	let i = timeUnitSpecifierExpression(t);
	return `${r || isUTCTimeUnit(t) ? "utc" : "time"}Format(${n}, ${i})`;
}
function normalizeTimeUnit(t) {
	if (!t) return;
	let n;
	return isString(t) ? n = isBinnedTimeUnitString(t) ? {
		unit: t.substring(6),
		binned: !0
	} : { unit: t } : isObject(t) && (n = {
		...t,
		...t.unit ? { unit: t.unit } : {}
	}), isUTCTimeUnit(n.unit) && (n.utc = !0, n.unit = getLocalTimeUnitFromUTCTimeUnit(n.unit)), n;
}
function timeUnitToString(t) {
	let { utc: n,...r } = normalizeTimeUnit(t);
	return r.unit ? (n ? "utc" : "") + keys(r).map((t) => varName(`${t === "unit" ? "" : `_${t}_`}${r[t]}`)).join("") : `${n ? "utc" : ""}timeunit${keys(r).map((t) => varName(`_${t}_${r[t]}`)).join("")}`;
}
function durationExpr(t, n = (t) => t) {
	let r = normalizeTimeUnit(t), i = getSmallestTimeUnitPart(r.unit);
	if (i && i !== "day") {
		let t = {
			year: 2001,
			month: 1,
			date: 1,
			hours: 0,
			minutes: 0,
			seconds: 0,
			milliseconds: 0
		}, { step: o, part: s } = getDateTimePartAndStep(i, r.step);
		return `${n(dateTimeToExpr({
			...t,
			[s]: +t[s] + o
		}))} - ${n(dateTimeToExpr(t))}`;
	}
}
var DATE_PARTS = {
	year: 1,
	month: 1,
	date: 1,
	hours: 1,
	minutes: 1,
	seconds: 1,
	milliseconds: 1
};
function isDatePart(t) {
	return has(DATE_PARTS, t);
}
function getDateTimePartAndStep(t, n = 1) {
	if (isDatePart(t)) return {
		part: t,
		step: n
	};
	switch (t) {
		case "day":
		case "dayofyear": return {
			part: "date",
			step: n
		};
		case "quarter": return {
			part: "month",
			step: n * 3
		};
		case "week": return {
			part: "date",
			step: n * 7
		};
	}
}
function isSelectionPredicate(t) {
	return hasProperty(t, "param");
}
function isFieldEqualPredicate(t) {
	return !!t?.field && t.equal !== void 0;
}
function isFieldLTPredicate(t) {
	return !!t?.field && t.lt !== void 0;
}
function isFieldLTEPredicate(t) {
	return !!t?.field && t.lte !== void 0;
}
function isFieldGTPredicate(t) {
	return !!t?.field && t.gt !== void 0;
}
function isFieldGTEPredicate(t) {
	return !!t?.field && t.gte !== void 0;
}
function isFieldRangePredicate(t) {
	return !!(t?.field && (isArray(t.range) && t.range.length === 2 || isSignalRef(t.range)));
}
function isFieldOneOfPredicate(t) {
	return !!t?.field && (isArray(t.oneOf) || isArray(t.in));
}
function isFieldValidPredicate(t) {
	return !!t?.field && t.valid !== void 0;
}
function isFieldPredicate(t) {
	return isFieldOneOfPredicate(t) || isFieldEqualPredicate(t) || isFieldRangePredicate(t) || isFieldLTPredicate(t) || isFieldGTPredicate(t) || isFieldLTEPredicate(t) || isFieldGTEPredicate(t);
}
function predicateValueExpr(t, n) {
	return valueExpr(t, {
		timeUnit: n,
		wrapTime: !0
	});
}
function predicateValuesExpr(t, n) {
	return t.map((t) => predicateValueExpr(t, n));
}
function fieldFilterExpression(t, n = !0) {
	let { field: r } = t, { unit: i, binned: o } = normalizeTimeUnit(t.timeUnit) || {}, s = vgField(t, { expr: "datum" }), l = i ? `time(${o ? s : fieldExpr(i, r)})` : s;
	if (isFieldEqualPredicate(t)) return `${l}===${predicateValueExpr(t.equal, i)}`;
	if (isFieldLTPredicate(t)) {
		let n = t.lt;
		return `${l}<${predicateValueExpr(n, i)}`;
	} else if (isFieldGTPredicate(t)) {
		let n = t.gt;
		return `${l}>${predicateValueExpr(n, i)}`;
	} else if (isFieldLTEPredicate(t)) {
		let n = t.lte;
		return `${l}<=${predicateValueExpr(n, i)}`;
	} else if (isFieldGTEPredicate(t)) {
		let n = t.gte;
		return `${l}>=${predicateValueExpr(n, i)}`;
	} else if (isFieldOneOfPredicate(t)) return `indexof([${predicateValuesExpr(t.oneOf, i).join(",")}], ${l}) !== -1`;
	else if (isFieldValidPredicate(t)) return fieldValidPredicate(l, t.valid);
	else if (isFieldRangePredicate(t)) {
		let { range: r } = replaceExprRef(t), o = isSignalRef(r) ? { signal: `${r.signal}[0]` } : r[0], s = isSignalRef(r) ? { signal: `${r.signal}[1]` } : r[1];
		if (o !== null && s !== null && n) return `inrange(${l}, [${predicateValueExpr(o, i)}, ${predicateValueExpr(s, i)}])`;
		let u = [];
		return o !== null && u.push(`${l} >= ${predicateValueExpr(o, i)}`), s !== null && u.push(`${l} <= ${predicateValueExpr(s, i)}`), u.length > 0 ? u.join(" && ") : "true";
	}
	/* istanbul ignore next: it should never reach here */
	throw Error(`Invalid field predicate: ${stringify$2(t)}`);
}
function fieldValidPredicate(t, n = !0) {
	return n ? `isValid(${t}) && isFinite(+${t})` : `!isValid(${t}) || !isFinite(+${t})`;
}
function normalizePredicate$1(t) {
	return isFieldPredicate(t) && t.timeUnit ? {
		...t,
		timeUnit: normalizeTimeUnit(t.timeUnit)
	} : t;
}
var Type = {
	quantitative: "quantitative",
	ordinal: "ordinal",
	temporal: "temporal",
	nominal: "nominal",
	geojson: "geojson"
};
function isContinuous(t) {
	return t === "quantitative" || t === "temporal";
}
function isDiscrete$1(t) {
	return t === "ordinal" || t === "nominal";
}
var QUANTITATIVE = Type.quantitative, ORDINAL = Type.ordinal, TEMPORAL = Type.temporal, NOMINAL = Type.nominal, GEOJSON = Type.geojson;
function getFullName(t) {
	if (t) switch (t = t.toLowerCase(), t) {
		case "q":
		case QUANTITATIVE: return "quantitative";
		case "t":
		case TEMPORAL: return "temporal";
		case "o":
		case ORDINAL: return "ordinal";
		case "n":
		case NOMINAL: return "nominal";
		case GEOJSON: return "geojson";
	}
}
var ScaleType = {
	LINEAR: "linear",
	LOG: "log",
	POW: "pow",
	SQRT: "sqrt",
	TIME: "time",
	UTC: "utc",
	POINT: "point",
	BAND: "band"
}, SCALE_CATEGORY_INDEX = {
	linear: "numeric",
	log: "numeric",
	pow: "numeric",
	sqrt: "numeric",
	symlog: "numeric",
	identity: "numeric",
	sequential: "numeric",
	time: "time",
	utc: "time",
	ordinal: "ordinal",
	"bin-ordinal": "bin-ordinal",
	point: "ordinal-position",
	band: "ordinal-position",
	quantile: "discretizing",
	quantize: "discretizing",
	threshold: "discretizing"
};
function scaleCompatible(t, n) {
	let r = SCALE_CATEGORY_INDEX[t], i = SCALE_CATEGORY_INDEX[n];
	return r === i || r === "ordinal-position" && i === "time" || i === "ordinal-position" && r === "time";
}
var SCALE_PRECEDENCE_INDEX = {
	linear: 0,
	log: 1,
	pow: 1,
	sqrt: 1,
	symlog: 1,
	identity: 1,
	sequential: 1,
	time: 0,
	utc: 0,
	point: 10,
	band: 11,
	ordinal: 0,
	"bin-ordinal": 0,
	quantile: 0,
	quantize: 0,
	threshold: 0
};
function scaleTypePrecedence(t) {
	return SCALE_PRECEDENCE_INDEX[t];
}
var QUANTITATIVE_SCALES = new Set([
	"linear",
	"log",
	"pow",
	"sqrt",
	"symlog"
]), CONTINUOUS_TO_CONTINUOUS_SCALES = new Set([
	...QUANTITATIVE_SCALES,
	"time",
	"utc"
]);
function isQuantitative(t) {
	return QUANTITATIVE_SCALES.has(t);
}
var CONTINUOUS_TO_DISCRETE_SCALES = new Set([
	"quantile",
	"quantize",
	"threshold"
]), CONTINUOUS_DOMAIN_SCALES = new Set([
	...CONTINUOUS_TO_CONTINUOUS_SCALES,
	...CONTINUOUS_TO_DISCRETE_SCALES,
	"sequential",
	"identity"
]), DISCRETE_DOMAIN_SCALES = new Set([
	"ordinal",
	"bin-ordinal",
	"point",
	"band"
]);
function hasDiscreteDomain(t) {
	return DISCRETE_DOMAIN_SCALES.has(t);
}
function hasContinuousDomain(t) {
	return CONTINUOUS_DOMAIN_SCALES.has(t);
}
function isContinuousToContinuous(t) {
	return CONTINUOUS_TO_CONTINUOUS_SCALES.has(t);
}
function isContinuousToDiscrete(t) {
	return CONTINUOUS_TO_DISCRETE_SCALES.has(t);
}
var defaultScaleConfig = {
	pointPadding: .5,
	barBandPaddingInner: .1,
	rectBandPaddingInner: 0,
	tickBandPaddingInner: .25,
	bandWithNestedOffsetPaddingInner: .2,
	bandWithNestedOffsetPaddingOuter: .2,
	minBandSize: 2,
	minFontSize: 8,
	maxFontSize: 40,
	minOpacity: .3,
	maxOpacity: .8,
	minSize: 4,
	minStrokeWidth: 1,
	maxStrokeWidth: 4,
	quantileCount: 4,
	quantizeCount: 4,
	zero: !0,
	framesPerSecond: 2,
	animationDuration: 5
};
function isExtendedScheme(t) {
	return !isString(t) && hasProperty(t, "name");
}
function isParameterDomain(t) {
	return hasProperty(t, "param");
}
function isDomainUnionWith(t) {
	return hasProperty(t, "unionWith");
}
function isFieldRange(t) {
	return isObject(t) && "field" in t;
}
var { type, domain: domain$1, range: range$1, rangeMax, rangeMin, scheme,...NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX } = {
	type: 1,
	domain: 1,
	domainMax: 1,
	domainMin: 1,
	domainMid: 1,
	domainRaw: 1,
	align: 1,
	range: 1,
	rangeMax: 1,
	rangeMin: 1,
	scheme: 1,
	bins: 1,
	reverse: 1,
	round: 1,
	clamp: 1,
	nice: 1,
	base: 1,
	exponent: 1,
	constant: 1,
	interpolate: 1,
	zero: 1,
	padding: 1,
	paddingInner: 1,
	paddingOuter: 1
}, NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = keys(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);
function scaleTypeSupportProperty(t, n) {
	switch (n) {
		case "type":
		case "domain":
		case "reverse":
		case "range": return !0;
		case "scheme":
		case "interpolate": return ![
			"point",
			"band",
			"identity"
		].includes(t);
		case "bins": return ![
			"point",
			"band",
			"identity",
			"ordinal"
		].includes(t);
		case "round": return isContinuousToContinuous(t) || t === "band" || t === "point";
		case "padding":
		case "rangeMin":
		case "rangeMax": return isContinuousToContinuous(t) || ["point", "band"].includes(t);
		case "paddingOuter":
		case "align": return ["point", "band"].includes(t);
		case "paddingInner": return t === "band";
		case "domainMax":
		case "domainMid":
		case "domainMin":
		case "domainRaw":
		case "clamp": return isContinuousToContinuous(t);
		case "nice": return isContinuousToContinuous(t) || t === "quantize" || t === "threshold";
		case "exponent": return t === "pow";
		case "base": return t === "log";
		case "constant": return t === "symlog";
		case "zero": return hasContinuousDomain(t) && !contains([
			"log",
			"time",
			"utc",
			"threshold",
			"quantile"
		], t);
	}
}
function channelScalePropertyIncompatability(t, n) {
	switch (n) {
		case "interpolate":
		case "scheme":
		case "domainMid": return isColorChannel(t) ? void 0 : cannotUseScalePropertyWithNonColor(n);
		case "align":
		case "type":
		case "bins":
		case "domain":
		case "domainMax":
		case "domainMin":
		case "domainRaw":
		case "range":
		case "base":
		case "exponent":
		case "constant":
		case "nice":
		case "padding":
		case "paddingInner":
		case "paddingOuter":
		case "rangeMax":
		case "rangeMin":
		case "reverse":
		case "round":
		case "clamp":
		case "zero": return;
	}
}
function scaleTypeSupportDataType(t, n) {
	return contains([ORDINAL, NOMINAL], n) ? t === void 0 || hasDiscreteDomain(t) : n === TEMPORAL ? contains([
		ScaleType.TIME,
		ScaleType.UTC,
		void 0
	], t) : n === QUANTITATIVE ? isQuantitative(t) || isContinuousToDiscrete(t) || t === void 0 : !0;
}
function channelSupportScaleType(t, n, r = !1) {
	if (!isScaleChannel(t)) return !1;
	switch (t) {
		case X:
		case Y:
		case XOFFSET:
		case YOFFSET:
		case THETA:
		case RADIUS: return isContinuousToContinuous(n) || n === "band" ? !0 : n === "point" ? !r : !1;
		case TIME: return contains(["linear", "band"], n);
		case SIZE:
		case STROKEWIDTH:
		case OPACITY:
		case FILLOPACITY:
		case STROKEOPACITY:
		case ANGLE: return isContinuousToContinuous(n) || isContinuousToDiscrete(n) || contains([
			"band",
			"point",
			"ordinal"
		], n);
		case COLOR:
		case FILL:
		case STROKE: return n !== "band";
		case STROKEDASH:
		case SHAPE: return n === "ordinal" || isContinuousToDiscrete(n);
	}
}
function isScaleInvalidDataIncludeAsValue(t) {
	return isObject(t) && "value" in t;
}
var Mark = {
	arc: "arc",
	area: "area",
	bar: "bar",
	image: "image",
	line: "line",
	point: "point",
	rect: "rect",
	rule: "rule",
	text: "text",
	tick: "tick",
	trail: "trail",
	circle: "circle",
	square: "square",
	geoshape: "geoshape"
}, ARC = Mark.arc, AREA = Mark.area, BAR = Mark.bar, IMAGE = Mark.image, LINE = Mark.line, POINT = Mark.point, RECT = Mark.rect, RULE = Mark.rule, TEXT = Mark.text, TICK = Mark.tick, TRAIL = Mark.trail, CIRCLE = Mark.circle, SQUARE = Mark.square, GEOSHAPE = Mark.geoshape;
function isPathMark(t) {
	return [
		"line",
		"area",
		"trail"
	].includes(t);
}
function isRectBasedMark(t) {
	return [
		"rect",
		"bar",
		"image",
		"arc",
		"tick"
	].includes(t);
}
var PRIMITIVE_MARKS = new Set(keys(Mark));
function isMarkDef(t) {
	return hasProperty(t, "type");
}
var STROKE_CONFIG = [
	"stroke",
	"strokeWidth",
	"strokeDash",
	"strokeDashOffset",
	"strokeOpacity",
	"strokeJoin",
	"strokeMiterLimit"
], FILL_CONFIG = ["fill", "fillOpacity"], FILL_STROKE_CONFIG = [...STROKE_CONFIG, ...FILL_CONFIG], VL_ONLY_MARK_CONFIG_PROPERTIES = keys({
	color: 1,
	filled: 1,
	invalid: 1,
	order: 1,
	radius2: 1,
	theta2: 1,
	timeUnitBandSize: 1,
	timeUnitBandPosition: 1
}), VL_ONLY_RECT_CONFIG = [
	"binSpacing",
	"continuousBandSize",
	"discreteBandSize",
	"minBandSize"
], VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {
	area: ["line", "point"],
	bar: VL_ONLY_RECT_CONFIG,
	rect: VL_ONLY_RECT_CONFIG,
	line: ["point"],
	tick: [
		"bandSize",
		"thickness",
		...VL_ONLY_RECT_CONFIG
	]
}, defaultMarkConfig = {
	color: "#4c78a8",
	invalid: "break-paths-show-path-domains",
	timeUnitBandSize: 1
}, MARK_CONFIGS = keys({
	mark: 1,
	arc: 1,
	area: 1,
	bar: 1,
	circle: 1,
	image: 1,
	line: 1,
	point: 1,
	rect: 1,
	rule: 1,
	square: 1,
	text: 1,
	tick: 1,
	trail: 1,
	geoshape: 1
});
function isRelativeBandSize(t) {
	return hasProperty(t, "band");
}
var BAR_CORNER_RADIUS_INDEX = {
	horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
	vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
}, defaultRectConfig = {
	binSpacing: 0,
	continuousBandSize: 5,
	minBandSize: .25,
	timeUnitBandPosition: .5
}, defaultBarConfig = {
	...defaultRectConfig,
	binSpacing: 1
}, defaultTickConfig = {
	...defaultRectConfig,
	thickness: 1
};
function getMarkType(t) {
	return isMarkDef(t) ? t.type : t;
}
function normalizeInvalidDataMode(t, { isPath: n }) {
	return t === void 0 || t === "break-paths-show-path-domains" ? n ? "break-paths-show-domains" : "filter" : t === null ? "show" : t;
}
function getScaleInvalidDataMode({ markDef: t, config: n, scaleChannel: r, scaleType: i, isCountAggregate: o }) {
	if (!i || !hasContinuousDomain(i) || o) return "always-valid";
	let s = normalizeInvalidDataMode(getMarkPropOrConfig("invalid", t, n), { isPath: isPathMark(t.type) });
	return n.scale?.invalid?.[r] === void 0 ? s : "show";
}
function shouldBreakPath(t) {
	return t === "break-paths-filter-domains" || t === "break-paths-show-domains";
}
function scaledZeroOrMinOrMax({ scaleName: t, scale: n, mode: r }) {
	let i = `domain('${t}')`;
	if (!n || !t) return;
	let o = `${i}[0]`, s = `peek(${i})`, l = n.domainHasZero();
	return l === "definitely" ? {
		scale: t,
		value: 0
	} : l === "maybe" ? { signal: `scale('${t}', inrange(0, ${i}) ? 0 : ${r === "zeroOrMin" ? o : s})` } : { signal: `scale('${t}', ${r === "zeroOrMin" ? o : s})` };
}
function getConditionalValueRefForIncludingInvalidValue({ scaleChannel: t, channelDef: n, scale: r, scaleName: i, markDef: o, config: s }) {
	let l = r?.get("type"), u = getFieldDef(n), d = getScaleInvalidDataMode({
		scaleChannel: t,
		markDef: o,
		config: s,
		scaleType: l,
		isCountAggregate: isCountingAggregateOp(u?.aggregate)
	});
	if (u && d === "show") {
		let n = s.scale.invalid?.[t] ?? "zero-or-min";
		return {
			test: fieldValidPredicate(vgField(u, { expr: "datum" }), !1),
			...refForInvalidValues(n, r, i)
		};
	}
}
function refForInvalidValues(t, n, r) {
	if (isScaleInvalidDataIncludeAsValue(t)) {
		let { value: n } = t;
		return isSignalRef(n) ? { signal: n.signal } : { value: n };
	}
	return scaledZeroOrMinOrMax({
		scale: n,
		scaleName: r,
		mode: "zeroOrMin"
	});
}
function midPointRefWithPositionInvalidTest(t) {
	let { channel: n, channelDef: r, markDef: i, scale: o, scaleName: s, config: l } = t, u = getMainRangeChannel(n), d = midPoint(t), f = getConditionalValueRefForIncludingInvalidValue({
		scaleChannel: u,
		channelDef: r,
		scale: o,
		scaleName: s,
		markDef: i,
		config: l
	});
	return f === void 0 ? d : [f, d];
}
function datumDefToExpr(t) {
	let { datum: n } = t;
	return isDateTime(n) ? dateTimeToExpr(n) : `${stringify$2(n)}`;
}
function valueRefForFieldOrDatumDef(t, n, r, i) {
	let o = {};
	if (n && (o.scale = n), isDatumDef(t)) {
		let { datum: n } = t;
		isDateTime(n) ? o.signal = dateTimeToExpr(n) : isSignalRef(n) ? o.signal = n.signal : isExprRef(n) ? o.signal = n.expr : o.value = n;
	} else o.field = vgField(t, r);
	if (i) {
		let { offset: t, band: n } = i;
		t && (o.offset = t), n && (o.band = n);
	}
	return o;
}
function interpolatedSignalRef({ scaleName: t, fieldOrDatumDef: n, fieldOrDatumDef2: r, offset: i, startSuffix: o, endSuffix: s = "end", bandPosition: l = .5 }) {
	let u = !isSignalRef(l) && 0 < l && l < 1 ? "datum" : void 0, d = vgField(n, {
		expr: u,
		suffix: o
	}), f = r === void 0 ? vgField(n, {
		suffix: s,
		expr: u
	}) : vgField(r, { expr: u }), p = {};
	return l === 0 || l === 1 ? (p.scale = t, p.field = l === 0 ? d : f) : p.signal = `scale("${t}", ${isSignalRef(l) ? `(1-${l.signal}) * ${d} + ${l.signal} * ${f}` : `${1 - l} * ${d} + ${l} * ${f}`})`, i && (p.offset = i), p;
}
function binSizeExpr({ scaleName: t, fieldDef: n }) {
	let r = vgField(n, { expr: "datum" });
	return `abs(scale("${t}", ${vgField(n, {
		expr: "datum",
		suffix: "end"
	})}) - scale("${t}", ${r}))`;
}
function midPoint({ channel: t, channelDef: n, channel2Def: r, markDef: i, config: o, scaleName: s, scale: l, stack: u, offset: d, defaultRef: f, bandPosition: p }) {
	if (n) {
		/* istanbul ignore else */
		if (isFieldOrDatumDef(n)) {
			let f = l?.get("type");
			if (isTypedFieldDef(n)) {
				p ??= getBandPosition({
					fieldDef: n,
					fieldDef2: r,
					markDef: i,
					config: o
				});
				let { bin: l, timeUnit: g, type: _ } = n;
				if (isBinning(l) || p && g && _ === TEMPORAL) return u?.impute ? valueRefForFieldOrDatumDef(n, s, { binSuffix: "mid" }, { offset: d }) : p && !hasDiscreteDomain(f) ? interpolatedSignalRef({
					scaleName: s,
					fieldOrDatumDef: n,
					bandPosition: p,
					offset: d
				}) : valueRefForFieldOrDatumDef(n, s, binRequiresRange(n, t) ? { binSuffix: "range" } : {}, { offset: d });
				if (isBinned(l)) {
					if (isFieldDef(r)) return interpolatedSignalRef({
						scaleName: s,
						fieldOrDatumDef: n,
						fieldOrDatumDef2: r,
						bandPosition: p,
						offset: d
					});
					warn(channelRequiredForBinned(t === X ? X2 : Y2));
				}
			}
			return valueRefForFieldOrDatumDef(n, s, hasDiscreteDomain(f) ? { binSuffix: "range" } : {}, {
				offset: d,
				band: f === "band" ? p ?? n.bandPosition ?? .5 : void 0
			});
		} else if (isValueDef(n)) {
			let r = n.value, i = d ? { offset: d } : {};
			return {
				...widthHeightValueOrSignalRef(t, r),
				...i
			};
		}
	}
	return isFunction(f) && (f = f()), f && {
		...f,
		...d ? { offset: d } : {}
	};
}
function widthHeightValueOrSignalRef(t, n) {
	return contains(["x", "x2"], t) && n === "width" ? { field: { group: "width" } } : contains(["y", "y2"], t) && n === "height" ? { field: { group: "height" } } : signalOrValueRef(n);
}
function isCustomFormatType(t) {
	return t && t !== "number" && t !== "time";
}
function customFormatExpr(t, n, r) {
	return `${t}(${n}${r ? `, ${stringify$2(r)}` : ""})`;
}
function formatSignalRef({ fieldOrDatumDef: t, format: n, formatType: r, expr: i, normalizeStack: o, config: s }) {
	if (isCustomFormatType(r)) return formatCustomType({
		fieldOrDatumDef: t,
		format: n,
		formatType: r,
		expr: i,
		config: s
	});
	let l = fieldToFormat(t, i, o), u = channelDefType(t);
	if (n === void 0 && r === void 0 && s.customFormatTypes) {
		if (u === "quantitative") {
			if (o && s.normalizedNumberFormatType) return formatCustomType({
				fieldOrDatumDef: t,
				format: s.normalizedNumberFormat,
				formatType: s.normalizedNumberFormatType,
				expr: i,
				config: s
			});
			if (s.numberFormatType) return formatCustomType({
				fieldOrDatumDef: t,
				format: s.numberFormat,
				formatType: s.numberFormatType,
				expr: i,
				config: s
			});
		}
		if (u === "temporal" && s.timeFormatType && isFieldDef(t) && t.timeUnit === void 0) return formatCustomType({
			fieldOrDatumDef: t,
			format: s.timeFormat,
			formatType: s.timeFormatType,
			expr: i,
			config: s
		});
	}
	function d(t) {
		return isFieldDef(t) ? normalizeTimeUnit(t.timeUnit) || {} : {
			unit: void 0,
			utc: void 0
		};
	}
	if (isFieldOrDatumDefForTimeFormat(t)) {
		let { unit: r, utc: i } = d(t), o = timeFormatExpression({
			field: l,
			timeUnit: r,
			format: n,
			formatType: s.timeFormatType,
			rawTimeFormat: s.timeFormat,
			isUTCScale: i || isScaleFieldDef(t) && t.scale?.type === ScaleType.UTC
		});
		return o ? { signal: o } : void 0;
	}
	return n = numberFormat({
		type: u,
		specifiedFormat: n,
		config: s,
		normalizeStack: o
	}), isFieldDef(t) && isBinning(t.bin) ? { signal: binFormatExpression(l, vgField(t, {
		expr: i,
		binSuffix: "end"
	}), n, r, s) } : n || channelDefType(t) === "quantitative" ? { signal: `${formatExpr(l, n)}` } : { signal: `isValid(${l}) ? ${l} : ""+${l}` };
}
function fieldToFormat(t, n, r) {
	return isFieldDef(t) ? r ? `${vgField(t, {
		expr: n,
		suffix: "end"
	})}-${vgField(t, {
		expr: n,
		suffix: "start"
	})}` : vgField(t, { expr: n }) : datumDefToExpr(t);
}
function formatCustomType({ fieldOrDatumDef: t, format: n, formatType: r, expr: i, normalizeStack: o, config: s, field: l }) {
	if (l ??= fieldToFormat(t, i, o), l !== "datum.value" && isFieldDef(t) && isBinning(t.bin)) {
		let o = vgField(t, {
			expr: i,
			binSuffix: "end"
		});
		return { signal: binFormatExpression(l, o, n, r, s) };
	}
	return { signal: customFormatExpr(r, l, n) };
}
function guideFormat(t, n, r, i, o, s) {
	if (!(isString(i) && isCustomFormatType(i)) && !(r === void 0 && i === void 0 && o.customFormatTypes && channelDefType(t) === "quantitative" && (o.normalizedNumberFormatType && isPositionFieldOrDatumDef(t) && t.stack === "normalize" || o.numberFormatType))) {
		if (isPositionFieldOrDatumDef(t) && t.stack === "normalize" && o.normalizedNumberFormat) return numberFormat({
			type: "quantitative",
			config: o,
			normalizeStack: !0
		});
		if (isFieldOrDatumDefForTimeFormat(t)) {
			let n = isFieldDef(t) ? normalizeTimeUnit(t.timeUnit)?.unit : void 0;
			return n === void 0 && o.customFormatTypes && o.timeFormatType ? void 0 : timeFormat({
				specifiedFormat: r,
				timeUnit: n,
				config: o,
				omitTimeFormatConfig: s
			});
		}
		return numberFormat({
			type: n,
			specifiedFormat: r,
			config: o
		});
	}
}
function guideFormatType(t, n, r) {
	if (t && (isSignalRef(t) || t === "number" || t === "time")) return t;
	if (isFieldOrDatumDefForTimeFormat(n) && r !== "time" && r !== "utc") return isFieldDef(n) && normalizeTimeUnit(n?.timeUnit)?.utc ? "utc" : "time";
}
function numberFormat({ type: t, specifiedFormat: n, config: r, normalizeStack: i }) {
	if (isString(n)) return n;
	if (t === QUANTITATIVE) return i ? r.normalizedNumberFormat : r.numberFormat;
}
function timeFormat({ specifiedFormat: t, timeUnit: n, config: r, omitTimeFormatConfig: i }) {
	return t || (n ? { signal: timeUnitSpecifierExpression(n) } : i ? void 0 : r.timeFormat);
}
function formatExpr(t, n) {
	return `format(${t}, "${n || ""}")`;
}
function binNumberFormatExpr(t, n, r, i) {
	return isCustomFormatType(r) ? customFormatExpr(r, t, n) : formatExpr(t, (isString(n) ? n : void 0) ?? i.numberFormat);
}
function binFormatExpression(t, n, r, i, o) {
	if (r === void 0 && i === void 0 && o.customFormatTypes && o.numberFormatType) return binFormatExpression(t, n, o.numberFormat, o.numberFormatType, o);
	let s = binNumberFormatExpr(t, r, i, o), l = binNumberFormatExpr(n, r, i, o);
	return `${fieldValidPredicate(t, !1)} ? "null" : ${s} + "${BIN_RANGE_DELIMITER}" + ${l}`;
}
function timeFormatExpression({ field: t, timeUnit: n, format: r, formatType: i, rawTimeFormat: o, isUTCScale: s }) {
	return !n || r ? !n && i ? `${i}(${t}, ${stringify$2(r)})` : (r = isString(r) ? r : o, `${s ? "utc" : "time"}Format(${t}, ${stringify$2(r)})`) : formatExpression(n, t, s);
}
var DEFAULT_SORT_OP = "min", SORT_BY_CHANNEL_INDEX = {
	x: 1,
	y: 1,
	color: 1,
	fill: 1,
	stroke: 1,
	strokeWidth: 1,
	size: 1,
	shape: 1,
	fillOpacity: 1,
	strokeOpacity: 1,
	opacity: 1,
	text: 1
};
function isSortByChannel(t) {
	return has(SORT_BY_CHANNEL_INDEX, t);
}
function isSortByEncoding(t) {
	return hasProperty(t, "encoding");
}
function isSortField(t) {
	return t && (t.op === "count" || hasProperty(t, "field"));
}
function isSortArray(t) {
	return t && isArray(t);
}
function isFacetMapping(t) {
	return hasProperty(t, "row") || hasProperty(t, "column");
}
function isFacetFieldDef(t) {
	return hasProperty(t, "header");
}
function isFacetSpec(t) {
	return hasProperty(t, "facet");
}
function isConditionalParameter(t) {
	return hasProperty(t, "param");
}
function isRepeatRef(t) {
	return !isString(t) && hasProperty(t, "repeat");
}
function toFieldDefBase(t) {
	let { field: n, timeUnit: r, bin: i, aggregate: o } = t;
	return {
		...r ? { timeUnit: r } : {},
		...i ? { bin: i } : {},
		...o ? { aggregate: o } : {},
		field: n
	};
}
function isSortableFieldDef(t) {
	return hasProperty(t, "sort");
}
function getBandPosition({ fieldDef: t, fieldDef2: n, markDef: r, config: i }) {
	if (isFieldOrDatumDef(t) && t.bandPosition !== void 0) return t.bandPosition;
	if (isFieldDef(t)) {
		let { timeUnit: o, bin: s } = t;
		if (o && !n) return getMarkConfig("timeUnitBandPosition", r, i);
		if (isBinning(s)) return .5;
	}
}
function getBandSize({ channel: t, fieldDef: n, fieldDef2: r, markDef: i, config: o, scaleType: s, useVlSizeChannel: l }) {
	let u = getSizeChannel(t), d = getMarkPropOrConfig(l ? "size" : u, i, o, { vgChannel: u });
	if (d !== void 0) return d;
	if (isFieldDef(n)) {
		let { timeUnit: t, bin: l } = n;
		if (t && !r) return { band: getMarkConfig("timeUnitBandSize", i, o) };
		if (isBinning(l) && !hasDiscreteDomain(s)) return { band: 1 };
	}
	if (isRectBasedMark(i.type)) return s ? hasDiscreteDomain(s) ? o[i.type]?.discreteBandSize || { band: 1 } : o[i.type]?.continuousBandSize : o[i.type]?.discreteBandSize;
}
function hasBandEnd(t, n, r, i) {
	return isBinning(t.bin) || t.timeUnit && isTypedFieldDef(t) && t.type === "temporal" ? getBandPosition({
		fieldDef: t,
		fieldDef2: n,
		markDef: r,
		config: i
	}) !== void 0 : !1;
}
function isOrderOnlyDef(t) {
	return hasProperty(t, "sort") && !hasProperty(t, "field");
}
function isConditionalDef(t) {
	return hasProperty(t, "condition");
}
function hasConditionalFieldDef(t) {
	let n = t?.condition;
	return !!n && !isArray(n) && isFieldDef(n);
}
function hasConditionalFieldOrDatumDef(t) {
	let n = t?.condition;
	return !!n && !isArray(n) && isFieldOrDatumDef(n);
}
function hasConditionalValueDef(t) {
	let n = t?.condition;
	return !!n && (isArray(n) || isValueDef(n));
}
function isFieldDef(t) {
	return hasProperty(t, "field") || t?.aggregate === "count";
}
function channelDefType(t) {
	return t?.type;
}
function isDatumDef(t) {
	return hasProperty(t, "datum");
}
function isContinuousFieldOrDatumDef(t) {
	return isTypedFieldDef(t) && !isDiscrete(t) || isNumericDataDef(t);
}
function isUnbinnedQuantitativeFieldOrDatumDef(t) {
	return isTypedFieldDef(t) && t.type === "quantitative" && !t.bin || isNumericDataDef(t);
}
function isNumericDataDef(t) {
	return isDatumDef(t) && isNumber(t.datum);
}
function isFieldOrDatumDef(t) {
	return isFieldDef(t) || isDatumDef(t);
}
function isTypedFieldDef(t) {
	return t && (hasProperty(t, "field") || t.aggregate === "count") && hasProperty(t, "type");
}
function isValueDef(t) {
	return hasProperty(t, "value");
}
function isScaleFieldDef(t) {
	return hasProperty(t, "scale") || hasProperty(t, "sort");
}
function isPositionFieldOrDatumDef(t) {
	return hasProperty(t, "axis") || hasProperty(t, "stack") || hasProperty(t, "impute");
}
function isMarkPropFieldOrDatumDef(t) {
	return hasProperty(t, "legend");
}
function isStringFieldOrDatumDef(t) {
	return hasProperty(t, "format") || hasProperty(t, "formatType");
}
function toStringFieldDef(t) {
	return omit(t, [
		"legend",
		"axis",
		"header",
		"scale"
	]);
}
function isOpFieldDef(t) {
	return hasProperty(t, "op");
}
function vgField(t, n = {}) {
	let r = t.field, i = n.prefix, o = n.suffix, s = "";
	if (isCount(t)) r = internalField("count");
	else {
		let i;
		if (!n.nofn) if (isOpFieldDef(t)) i = t.op;
		else {
			let { bin: l, aggregate: u, timeUnit: d } = t;
			isBinning(l) ? (i = binToString(l), o = (n.binSuffix ?? "") + (n.suffix ?? "")) : u ? isArgmaxDef(u) ? (s = `["${r}"]`, r = `argmax_${u.argmax}`) : isArgminDef(u) ? (s = `["${r}"]`, r = `argmin_${u.argmin}`) : i = String(u) : d && !isBinnedTimeUnit(d) && (i = timeUnitToString(d), o = (!["range", "mid"].includes(n.binSuffix) && n.binSuffix || "") + (n.suffix ?? ""));
		}
		i && (r = r ? `${i}_${r}` : i);
	}
	return o && (r = `${r}_${o}`), i && (r = `${i}_${r}`), n.forAs ? removePathFromField(r) : n.expr ? flatAccessWithDatum(r, n.expr) + s : replacePathInField(r) + s;
}
function isDiscrete(t) {
	switch (t.type) {
		case "nominal":
		case "ordinal":
		case "geojson": return !0;
		case "quantitative": return isFieldDef(t) && !!t.bin;
		case "temporal": return !1;
	}
	throw Error(invalidFieldType(t.type));
}
function isDiscretizing(t) {
	return isScaleFieldDef(t) && isContinuousToDiscrete(t.scale?.type);
}
function isCount(t) {
	return t.aggregate === "count";
}
function verbalTitleFormatter(t, n) {
	let { field: r, bin: i, timeUnit: o, aggregate: s } = t;
	if (s === "count") return n.countTitle;
	if (isBinning(i)) return `${r} (binned)`;
	if (o && !isBinnedTimeUnit(o)) {
		let t = normalizeTimeUnit(o)?.unit;
		if (t) return `${r} (${getTimeUnitParts(t).join("-")})`;
	} else if (s) return isArgmaxDef(s) ? `${r} for max ${s.argmax}` : isArgminDef(s) ? `${r} for min ${s.argmin}` : `${titleCase(s)} of ${r}`;
	return r;
}
function functionalTitleFormatter(t) {
	let { aggregate: n, bin: r, timeUnit: i, field: o } = t;
	if (isArgmaxDef(n)) return `${o} for argmax(${n.argmax})`;
	if (isArgminDef(n)) return `${o} for argmin(${n.argmin})`;
	let s = i && !isBinnedTimeUnit(i) ? normalizeTimeUnit(i) : void 0, l = n || s?.unit || s?.maxbins && "timeunit" || isBinning(r) && "bin";
	return l ? `${l.toUpperCase()}(${o})` : o;
}
var defaultTitleFormatter = (t, n) => {
	switch (n.fieldTitle) {
		case "plain": return t.field;
		case "functional": return functionalTitleFormatter(t);
		default: return verbalTitleFormatter(t, n);
	}
}, titleFormatter = defaultTitleFormatter;
function setTitleFormatter(t) {
	titleFormatter = t;
}
function resetTitleFormatter() {
	setTitleFormatter(defaultTitleFormatter);
}
function title(t, n, { allowDisabling: r, includeDefault: i = !0 }) {
	let o = getGuide(t)?.title;
	if (!isFieldDef(t)) return o ?? t.title;
	let s = t, l = i ? defaultTitle(s, n) : void 0;
	return r ? getFirstDefined(o, s.title, l) : o ?? s.title ?? l;
}
function getGuide(t) {
	if (isPositionFieldOrDatumDef(t) && t.axis) return t.axis;
	if (isMarkPropFieldOrDatumDef(t) && t.legend) return t.legend;
	if (isFacetFieldDef(t) && t.header) return t.header;
}
function defaultTitle(t, n) {
	return titleFormatter(t, n);
}
function getFormatMixins(t) {
	if (isStringFieldOrDatumDef(t)) {
		let { format: n, formatType: r } = t;
		return {
			format: n,
			formatType: r
		};
	} else {
		let { format: n, formatType: r } = getGuide(t) ?? {};
		return {
			format: n,
			formatType: r
		};
	}
}
function defaultType$2(t, n) {
	switch (n) {
		case "latitude":
		case "longitude": return "quantitative";
		case "row":
		case "column":
		case "facet":
		case "shape":
		case "strokeDash": return "nominal";
		case "order": return "ordinal";
	}
	if (isSortableFieldDef(t) && isArray(t.sort)) return "ordinal";
	let { aggregate: r, bin: i, timeUnit: o } = t;
	if (o) return "temporal";
	if (i || r && !isArgmaxDef(r) && !isArgminDef(r)) return "quantitative";
	if (isScaleFieldDef(t) && t.scale?.type) switch (SCALE_CATEGORY_INDEX[t.scale.type]) {
		case "numeric":
		case "discretizing": return "quantitative";
		case "time": return "temporal";
	}
	return "nominal";
}
function getFieldDef(t) {
	if (isFieldDef(t)) return t;
	if (hasConditionalFieldDef(t)) return t.condition;
}
function getFieldOrDatumDef(t) {
	if (isFieldOrDatumDef(t)) return t;
	if (hasConditionalFieldOrDatumDef(t)) return t.condition;
}
function initChannelDef(t, n, r, i = {}) {
	return isString(t) || isNumber(t) || isBoolean(t) ? (warn(primitiveChannelDef(n, isString(t) ? "string" : isNumber(t) ? "number" : "boolean", t)), { value: t }) : isFieldOrDatumDef(t) ? initFieldOrDatumDef(t, n, r, i) : hasConditionalFieldOrDatumDef(t) ? {
		...t,
		condition: initFieldOrDatumDef(t.condition, n, r, i)
	} : t;
}
function initFieldOrDatumDef(t, n, r, i) {
	if (isStringFieldOrDatumDef(t)) {
		let { format: o, formatType: s,...l } = t;
		if (isCustomFormatType(s) && !r.customFormatTypes) return warn(customFormatTypeNotAllowed(n)), initFieldOrDatumDef(l, n, r, i);
	} else {
		let o = isPositionFieldOrDatumDef(t) ? "axis" : isMarkPropFieldOrDatumDef(t) ? "legend" : isFacetFieldDef(t) ? "header" : null;
		if (o && t[o]) {
			let { format: s, formatType: l,...u } = t[o];
			if (isCustomFormatType(l) && !r.customFormatTypes) return warn(customFormatTypeNotAllowed(n)), initFieldOrDatumDef({
				...t,
				[o]: u
			}, n, r, i);
		}
	}
	return isFieldDef(t) ? initFieldDef(t, n, i) : initDatumDef(t);
}
function initDatumDef(t) {
	let n = t.type;
	if (n) return t;
	let { datum: r } = t;
	return n = isNumber(r) ? "quantitative" : isString(r) ? "nominal" : isDateTime(r) ? "temporal" : void 0, {
		...t,
		type: n
	};
}
function initFieldDef(t, n, { compositeMark: r = !1 } = {}) {
	let { aggregate: i, timeUnit: o, bin: s, field: l } = t, u = { ...t };
	if (!r && i && !isAggregateOp(i) && !isArgmaxDef(i) && !isArgminDef(i) && (warn(invalidAggregate(i)), delete u.aggregate), o && (u.timeUnit = normalizeTimeUnit(o)), l && (u.field = `${l}`), isBinning(s) && (u.bin = normalizeBin(s, n)), isBinned(s) && !isXorY(n) && warn(channelShouldNotBeUsedForBinned(n)), isTypedFieldDef(u)) {
		let { type: t } = u, n = getFullName(t);
		t !== n && (u.type = n), t !== "quantitative" && isCountingAggregateOp(i) && (warn(invalidFieldTypeForCountAggregate(t, i)), u.type = "quantitative");
	} else isSecondaryRangeChannel(n) || (u.type = defaultType$2(u, n));
	if (isTypedFieldDef(u)) {
		let { compatible: t, warning: r } = channelCompatibility(u, n) || {};
		t === !1 && warn(r);
	}
	if (isSortableFieldDef(u) && isString(u.sort)) {
		let { sort: t } = u;
		if (isSortByChannel(t)) return {
			...u,
			sort: { encoding: t }
		};
		let n = t.substring(1);
		if (t.charAt(0) === "-" && isSortByChannel(n)) return {
			...u,
			sort: {
				encoding: n,
				order: "descending"
			}
		};
	}
	if (isFacetFieldDef(u)) {
		let { header: t } = u;
		if (t) {
			let { orient: n,...r } = t;
			if (n) return {
				...u,
				header: {
					...r,
					labelOrient: t.labelOrient || n,
					titleOrient: t.titleOrient || n
				}
			};
		}
	}
	return u;
}
function normalizeBin(t, n) {
	return isBoolean(t) ? { maxbins: autoMaxBins(n) } : t === "binned" ? { binned: !0 } : !t.maxbins && !t.step ? {
		...t,
		maxbins: autoMaxBins(n)
	} : t;
}
var COMPATIBLE = { compatible: !0 };
function channelCompatibility(t, n) {
	let r = t.type;
	if (r === "geojson" && n !== "shape") return {
		compatible: !1,
		warning: `Channel ${n} should not be used with a geojson data.`
	};
	switch (n) {
		case ROW:
		case COLUMN:
		case FACET: return isDiscrete(t) ? COMPATIBLE : {
			compatible: !1,
			warning: channelShouldBeDiscrete(n)
		};
		case X:
		case Y:
		case XOFFSET:
		case YOFFSET:
		case COLOR:
		case FILL:
		case STROKE:
		case TEXT$1:
		case DETAIL:
		case KEY:
		case TOOLTIP:
		case HREF:
		case URL$1:
		case ANGLE:
		case THETA:
		case RADIUS:
		case DESCRIPTION: return COMPATIBLE;
		case LONGITUDE:
		case LONGITUDE2:
		case LATITUDE:
		case LATITUDE2: return r === QUANTITATIVE ? COMPATIBLE : {
			compatible: !1,
			warning: `Channel ${n} should be used with a quantitative field only, not ${t.type} field.`
		};
		case OPACITY:
		case FILLOPACITY:
		case STROKEOPACITY:
		case STROKEWIDTH:
		case SIZE:
		case THETA2:
		case RADIUS2:
		case X2:
		case Y2:
		case TIME: return r === "nominal" && !t.sort ? {
			compatible: !1,
			warning: `Channel ${n} should not be used with an unsorted discrete field.`
		} : COMPATIBLE;
		case SHAPE:
		case STROKEDASH: return !isDiscrete(t) && !isDiscretizing(t) ? {
			compatible: !1,
			warning: channelShouldBeDiscreteOrDiscretizing(n)
		} : COMPATIBLE;
		case ORDER: return t.type === "nominal" && !("sort" in t) ? {
			compatible: !1,
			warning: "Channel order is inappropriate for nominal field, which has no inherent order."
		} : COMPATIBLE;
	}
}
function isFieldOrDatumDefForTimeFormat(t) {
	let { formatType: n } = getFormatMixins(t);
	return n === "time" || !n && isTemporalFieldDef(t);
}
function isTemporalFieldDef(t) {
	return t && (t.type === "temporal" || isFieldDef(t) && !!t.timeUnit);
}
function valueExpr(t, { timeUnit: n, type: r, wrapTime: i, undefinedIfExprNotRequired: o }) {
	let s = n && normalizeTimeUnit(n)?.unit, l = s || r === "temporal", u;
	return isExprRef(t) ? u = t.expr : isSignalRef(t) ? u = t.signal : isDateTime(t) ? (l = !0, u = dateTimeToExpr(t)) : (isString(t) || isNumber(t)) && l && (u = `datetime(${stringify$2(t)})`, isLocalSingleTimeUnit(s) && (isNumber(t) && t < 1e4 || isString(t) && isNaN(Date.parse(t))) && (u = dateTimeToExpr({ [s]: t }))), u ? i && l ? `time(${u})` : u : o ? void 0 : stringify$2(t);
}
function valueArray(t, n) {
	let { type: r } = t;
	return n.map((n) => {
		let i = valueExpr(n, {
			timeUnit: isFieldDef(t) && !isBinnedTimeUnit(t.timeUnit) ? t.timeUnit : void 0,
			type: r,
			undefinedIfExprNotRequired: !0
		});
		return i === void 0 ? n : { signal: i };
	});
}
function binRequiresRange(t, n) {
	return isBinning(t.bin) ? isScaleChannel(n) && ["ordinal", "nominal"].includes(t.type) : (console.warn("Only call this method for binned field defs."), !1);
}
var CONDITIONAL_AXIS_PROP_INDEX = {
	labelAlign: {
		part: "labels",
		vgProp: "align"
	},
	labelBaseline: {
		part: "labels",
		vgProp: "baseline"
	},
	labelColor: {
		part: "labels",
		vgProp: "fill"
	},
	labelFont: {
		part: "labels",
		vgProp: "font"
	},
	labelFontSize: {
		part: "labels",
		vgProp: "fontSize"
	},
	labelFontStyle: {
		part: "labels",
		vgProp: "fontStyle"
	},
	labelFontWeight: {
		part: "labels",
		vgProp: "fontWeight"
	},
	labelOpacity: {
		part: "labels",
		vgProp: "opacity"
	},
	labelOffset: null,
	labelPadding: null,
	gridColor: {
		part: "grid",
		vgProp: "stroke"
	},
	gridDash: {
		part: "grid",
		vgProp: "strokeDash"
	},
	gridDashOffset: {
		part: "grid",
		vgProp: "strokeDashOffset"
	},
	gridOpacity: {
		part: "grid",
		vgProp: "opacity"
	},
	gridWidth: {
		part: "grid",
		vgProp: "strokeWidth"
	},
	tickColor: {
		part: "ticks",
		vgProp: "stroke"
	},
	tickDash: {
		part: "ticks",
		vgProp: "strokeDash"
	},
	tickDashOffset: {
		part: "ticks",
		vgProp: "strokeDashOffset"
	},
	tickOpacity: {
		part: "ticks",
		vgProp: "opacity"
	},
	tickSize: null,
	tickWidth: {
		part: "ticks",
		vgProp: "strokeWidth"
	}
};
function isConditionalAxisValue(t) {
	return t?.condition;
}
var AXIS_PARTS = [
	"domain",
	"grid",
	"labels",
	"ticks",
	"title"
], AXIS_PROPERTY_TYPE = {
	grid: "grid",
	gridCap: "grid",
	gridColor: "grid",
	gridDash: "grid",
	gridDashOffset: "grid",
	gridOpacity: "grid",
	gridScale: "grid",
	gridWidth: "grid",
	orient: "main",
	bandPosition: "both",
	aria: "main",
	description: "main",
	domain: "main",
	domainCap: "main",
	domainColor: "main",
	domainDash: "main",
	domainDashOffset: "main",
	domainOpacity: "main",
	domainWidth: "main",
	format: "main",
	formatType: "main",
	labelAlign: "main",
	labelAngle: "main",
	labelBaseline: "main",
	labelBound: "main",
	labelColor: "main",
	labelFlush: "main",
	labelFlushOffset: "main",
	labelFont: "main",
	labelFontSize: "main",
	labelFontStyle: "main",
	labelFontWeight: "main",
	labelLimit: "main",
	labelLineHeight: "main",
	labelOffset: "main",
	labelOpacity: "main",
	labelOverlap: "main",
	labelPadding: "main",
	labels: "main",
	labelSeparation: "main",
	maxExtent: "main",
	minExtent: "main",
	offset: "both",
	position: "main",
	tickCap: "main",
	tickColor: "main",
	tickDash: "main",
	tickDashOffset: "main",
	tickMinStep: "both",
	tickOffset: "both",
	tickOpacity: "main",
	tickRound: "both",
	ticks: "main",
	tickSize: "main",
	tickWidth: "both",
	title: "main",
	titleAlign: "main",
	titleAnchor: "main",
	titleAngle: "main",
	titleBaseline: "main",
	titleColor: "main",
	titleFont: "main",
	titleFontSize: "main",
	titleFontStyle: "main",
	titleFontWeight: "main",
	titleLimit: "main",
	titleLineHeight: "main",
	titleOpacity: "main",
	titlePadding: "main",
	titleX: "main",
	titleY: "main",
	encode: "both",
	scale: "both",
	tickBand: "both",
	tickCount: "both",
	tickExtra: "both",
	translate: "both",
	values: "both",
	zindex: "both"
}, COMMON_AXIS_PROPERTIES_INDEX = {
	orient: 1,
	aria: 1,
	bandPosition: 1,
	description: 1,
	domain: 1,
	domainCap: 1,
	domainColor: 1,
	domainDash: 1,
	domainDashOffset: 1,
	domainOpacity: 1,
	domainWidth: 1,
	format: 1,
	formatType: 1,
	grid: 1,
	gridCap: 1,
	gridColor: 1,
	gridDash: 1,
	gridDashOffset: 1,
	gridOpacity: 1,
	gridWidth: 1,
	labelAlign: 1,
	labelAngle: 1,
	labelBaseline: 1,
	labelBound: 1,
	labelColor: 1,
	labelFlush: 1,
	labelFlushOffset: 1,
	labelFont: 1,
	labelFontSize: 1,
	labelFontStyle: 1,
	labelFontWeight: 1,
	labelLimit: 1,
	labelLineHeight: 1,
	labelOffset: 1,
	labelOpacity: 1,
	labelOverlap: 1,
	labelPadding: 1,
	labels: 1,
	labelSeparation: 1,
	maxExtent: 1,
	minExtent: 1,
	offset: 1,
	position: 1,
	tickBand: 1,
	tickCap: 1,
	tickColor: 1,
	tickCount: 1,
	tickDash: 1,
	tickDashOffset: 1,
	tickExtra: 1,
	tickMinStep: 1,
	tickOffset: 1,
	tickOpacity: 1,
	tickRound: 1,
	ticks: 1,
	tickSize: 1,
	tickWidth: 1,
	title: 1,
	titleAlign: 1,
	titleAnchor: 1,
	titleAngle: 1,
	titleBaseline: 1,
	titleColor: 1,
	titleFont: 1,
	titleFontSize: 1,
	titleFontStyle: 1,
	titleFontWeight: 1,
	titleLimit: 1,
	titleLineHeight: 1,
	titleOpacity: 1,
	titlePadding: 1,
	titleX: 1,
	titleY: 1,
	translate: 1,
	values: 1,
	zindex: 1
}, AXIS_PROPERTIES_INDEX = {
	...COMMON_AXIS_PROPERTIES_INDEX,
	style: 1,
	labelExpr: 1,
	encoding: 1
};
function isAxisProperty(t) {
	return has(AXIS_PROPERTIES_INDEX, t);
}
var AXIS_CONFIGS = keys({
	axis: 1,
	axisBand: 1,
	axisBottom: 1,
	axisDiscrete: 1,
	axisLeft: 1,
	axisPoint: 1,
	axisQuantitative: 1,
	axisRight: 1,
	axisTemporal: 1,
	axisTop: 1,
	axisX: 1,
	axisXBand: 1,
	axisXDiscrete: 1,
	axisXPoint: 1,
	axisXQuantitative: 1,
	axisXTemporal: 1,
	axisY: 1,
	axisYBand: 1,
	axisYDiscrete: 1,
	axisYPoint: 1,
	axisYQuantitative: 1,
	axisYTemporal: 1
});
function isUnitSpec(t) {
	return hasProperty(t, "mark");
}
var CompositeMarkNormalizer = class {
	name;
	run;
	constructor(t, n) {
		this.name = t, this.run = n;
	}
	hasMatchingType(t) {
		return isUnitSpec(t) ? getMarkType(t.mark) === this.name : !1;
	}
};
function channelHasField(t, n) {
	let r = t?.[n];
	return r ? isArray(r) ? some(r, (t) => !!t.field) : isFieldDef(r) || hasConditionalFieldDef(r) : !1;
}
function channelHasFieldOrDatum(t, n) {
	let r = t?.[n];
	return r ? isArray(r) ? some(r, (t) => !!t.field) : isFieldDef(r) || isDatumDef(r) || hasConditionalFieldOrDatumDef(r) : !1;
}
function channelHasNestedOffsetScale(t, n) {
	if (isXorY(n)) {
		let r = t[n];
		if ((isFieldDef(r) || isDatumDef(r)) && (isDiscrete$1(r.type) || isFieldDef(r) && r.timeUnit)) return channelHasFieldOrDatum(t, getOffsetScaleChannel(n));
	}
	return !1;
}
function isAggregate$1(t) {
	return some(CHANNELS, (n) => {
		if (channelHasField(t, n)) {
			let r = t[n];
			if (isArray(r)) return some(r, (t) => !!t.aggregate);
			{
				let t = getFieldDef(r);
				return t && !!t.aggregate;
			}
		}
		return !1;
	});
}
function extractTransformsFromEncoding(t, n) {
	let r = [], i = [], o = [], s = [], l = {};
	return forEach(t, (u, d) => {
		if (isFieldDef(u)) {
			let { field: f, aggregate: p, bin: g, timeUnit: _,...v } = u;
			if (p || _ || g) {
				let t = getGuide(u)?.title, S = vgField(u, { forAs: !0 }), T = {
					...t ? [] : { title: title(u, n, { allowDisabling: !0 }) },
					...v,
					field: S
				};
				if (p) {
					let t;
					if (isArgmaxDef(p) ? (t = "argmax", S = vgField({
						op: "argmax",
						field: p.argmax
					}, { forAs: !0 }), T.field = `${S}.${f}`) : isArgminDef(p) ? (t = "argmin", S = vgField({
						op: "argmin",
						field: p.argmin
					}, { forAs: !0 }), T.field = `${S}.${f}`) : p !== "boxplot" && p !== "errorbar" && p !== "errorband" && (t = p), t) {
						let n = {
							op: t,
							as: S
						};
						f && (n.field = f), s.push(n);
					}
				} else if (r.push(S), isTypedFieldDef(u) && isBinning(g)) {
					if (i.push({
						bin: g,
						field: f,
						as: S
					}), r.push(vgField(u, { binSuffix: "end" })), binRequiresRange(u, d) && r.push(vgField(u, { binSuffix: "range" })), isXorY(d)) {
						let t = { field: `${S}_end` };
						l[`${d}2`] = t;
					}
					T.bin = "binned", isSecondaryRangeChannel(d) || (T.type = QUANTITATIVE);
				} else if (_ && !isBinnedTimeUnit(_)) {
					o.push({
						timeUnit: _,
						field: f,
						as: S
					});
					let t = isTypedFieldDef(u) && u.type !== TEMPORAL && "time";
					t && (d === TEXT$1 || d === TOOLTIP ? T.formatType = t : isNonPositionScaleChannel(d) ? T.legend = {
						formatType: t,
						...T.legend
					} : isXorY(d) && (T.axis = {
						formatType: t,
						...T.axis
					}));
				}
				l[d] = T;
			} else r.push(f), l[d] = t[d];
		} else l[d] = t[d];
	}), {
		bins: i,
		timeUnits: o,
		aggregate: s,
		groupby: r,
		encoding: l
	};
}
function markChannelCompatible(t, n, r) {
	let i = supportMark(n, r);
	if (i) {
		if (i === "binned") {
			let r = t[n === X2 ? X : Y];
			return !!(isFieldDef(r) && isFieldDef(t[n]) && isBinned(r.bin));
		}
	} else return !1;
	return !0;
}
function initEncoding(t, n, r, i) {
	let o = {};
	for (let n of keys(t)) isChannel(n) || warn(invalidEncodingChannel(n));
	for (let s of UNIT_CHANNELS) {
		if (!t[s]) continue;
		let l = t[s];
		if (isXorYOffset(s)) {
			let t = getMainChannelFromOffsetChannel(s), n = o[t];
			if (isFieldDef(n) && isContinuous(n.type) && isFieldDef(l) && !n.timeUnit) {
				warn(offsetNestedInsideContinuousPositionScaleDropped(t));
				continue;
			}
		}
		if (s === "angle" && n === "arc" && !t.theta && (warn(REPLACE_ANGLE_WITH_THETA), s = THETA), !markChannelCompatible(t, s, n)) {
			warn(incompatibleChannel(s, n));
			continue;
		}
		if (s === SIZE && n === "line" && getFieldDef(t[s])?.aggregate) {
			warn(LINE_WITH_VARYING_SIZE);
			continue;
		}
		if (s === COLOR && (r ? "fill" in t : "stroke" in t)) {
			warn(droppingColor("encoding", {
				fill: "fill" in t,
				stroke: "stroke" in t
			}));
			continue;
		}
		if (s === DETAIL || s === ORDER && !isArray(l) && !isValueDef(l) || s === TOOLTIP && isArray(l)) {
			if (l) {
				if (s === ORDER) {
					let n = t[s];
					if (isOrderOnlyDef(n)) {
						o[s] = n;
						continue;
					}
				}
				o[s] = array(l).reduce((t, n) => (isFieldDef(n) ? t.push(initFieldDef(n, s)) : warn(emptyFieldDef(n, s)), t), []);
			}
		} else {
			if (s === TOOLTIP && l === null) o[s] = null;
			else if (!isFieldDef(l) && !isDatumDef(l) && !isValueDef(l) && !isConditionalDef(l) && !isSignalRef(l)) {
				warn(emptyFieldDef(l, s));
				continue;
			}
			o[s] = initChannelDef(l, s, i);
		}
	}
	return o;
}
function normalizeEncoding(t, n) {
	let r = {};
	for (let i of keys(t)) r[i] = initChannelDef(t[i], i, n, { compositeMark: !0 });
	return r;
}
function fieldDefs(t) {
	let n = [];
	for (let r of keys(t)) if (channelHasField(t, r)) {
		let i = t[r], o = array(i);
		for (let t of o) isFieldDef(t) ? n.push(t) : hasConditionalFieldDef(t) && n.push(t.condition);
	}
	return n;
}
function forEach(t, n, r) {
	if (t) for (let i of keys(t)) {
		let o = t[i];
		if (isArray(o)) for (let t of o) n.call(r, t, i);
		else n.call(r, o, i);
	}
}
function reduce(t, n, r, i) {
	return t ? keys(t).reduce((r, o) => {
		let s = t[o];
		return isArray(s) ? s.reduce((t, r) => n.call(i, t, r, o), r) : n.call(i, r, s, o);
	}, r) : r;
}
function pathGroupingFields(t, n) {
	return keys(n).reduce((r, i) => {
		switch (i) {
			case X:
			case Y:
			case HREF:
			case DESCRIPTION:
			case URL$1:
			case X2:
			case Y2:
			case XOFFSET:
			case YOFFSET:
			case THETA:
			case THETA2:
			case RADIUS:
			case RADIUS2:
			case TIME:
			case LATITUDE:
			case LONGITUDE:
			case LATITUDE2:
			case LONGITUDE2:
			case TEXT$1:
			case SHAPE:
			case ANGLE:
			case TOOLTIP: return r;
			case ORDER: if (t === "line" || t === "trail") return r;
			case DETAIL:
			case KEY: {
				let t = n[i];
				if (isArray(t) || isFieldDef(t)) for (let n of array(t)) n.aggregate || r.push(vgField(n, {}));
				return r;
			}
			case SIZE: if (t === "trail") return r;
			case COLOR:
			case FILL:
			case STROKE:
			case OPACITY:
			case FILLOPACITY:
			case STROKEOPACITY:
			case STROKEDASH:
			case STROKEWIDTH: {
				let t = getFieldDef(n[i]);
				return t && !t.aggregate && r.push(vgField(t, {})), r;
			}
		}
	}, []);
}
function filterTooltipWithAggregatedField(t) {
	let { tooltip: n,...r } = t;
	if (!n) return { filteredEncoding: r };
	let i, o;
	if (isArray(n)) {
		for (let t of n) t.aggregate ? (i ||= [], i.push(t)) : (o ||= [], o.push(t));
		i && (r.tooltip = i);
	} else n.aggregate ? r.tooltip = n : o = n;
	return isArray(o) && o.length === 1 && (o = o[0]), {
		customTooltipWithoutAggregatedField: o,
		filteredEncoding: r
	};
}
function getCompositeMarkTooltip(t, n, r, i = !0) {
	if ("tooltip" in r) return { tooltip: r.tooltip };
	let o = t.map(({ fieldPrefix: t, titlePrefix: r }) => {
		let o = i ? ` of ${getTitle(n)}` : "";
		return {
			field: t + n.field,
			type: n.type,
			title: isSignalRef(r) ? { signal: `${r}"${escape(o)}"` } : r + o
		};
	}), s = fieldDefs(r).map(toStringFieldDef);
	return { tooltip: [...o, ...unique(s, hash)] };
}
function getTitle(t) {
	let { title: n, field: r } = t;
	return getFirstDefined(n, r);
}
function makeCompositeAggregatePartFactory(t, n, r, i, o) {
	let { scale: s, axis: l } = r;
	return ({ partName: u, mark: d, positionPrefix: f, endPositionPrefix: p = void 0, extraEncoding: g = {} }) => {
		let _ = getTitle(r);
		return partLayerMixins(t, u, o, {
			mark: d,
			encoding: {
				[n]: {
					field: `${f}_${r.field}`,
					type: r.type,
					..._ === void 0 ? {} : { title: _ },
					...s === void 0 ? {} : { scale: s },
					...l === void 0 ? {} : { axis: l }
				},
				...isString(p) ? { [`${n}2`]: { field: `${p}_${r.field}` } } : {},
				...i,
				...g
			}
		});
	};
}
function partLayerMixins(t, n, r, i) {
	let { clip: o, color: s, opacity: l } = t, u = t.type;
	return t[n] || t[n] === void 0 && r[n] ? [{
		...i,
		mark: {
			...r[n],
			...o ? { clip: o } : {},
			...s ? { color: s } : {},
			...l ? { opacity: l } : {},
			...isMarkDef(i.mark) ? i.mark : { type: i.mark },
			style: `${u}-${String(n)}`,
			...isBoolean(t[n]) ? {} : t[n]
		}
	}] : [];
}
function compositeMarkContinuousAxis(t, n, r) {
	let { encoding: i } = t, o = n === "vertical" ? "y" : "x", s = i[o], l = i[`${o}2`], u = i[`${o}Error`], d = i[`${o}Error2`];
	return {
		continuousAxisChannelDef: filterAggregateFromChannelDef(s, r),
		continuousAxisChannelDef2: filterAggregateFromChannelDef(l, r),
		continuousAxisChannelDefError: filterAggregateFromChannelDef(u, r),
		continuousAxisChannelDefError2: filterAggregateFromChannelDef(d, r),
		continuousAxis: o
	};
}
function filterAggregateFromChannelDef(t, n) {
	if (t?.aggregate) {
		let { aggregate: r,...i } = t;
		return r !== n && warn(errorBarContinuousAxisHasCustomizedAggregate(r, n)), i;
	} else return t;
}
function compositeMarkOrient(t, n) {
	let { mark: r, encoding: i } = t, { x: o, y: s } = i;
	if (isMarkDef(r) && r.orient) return r.orient;
	if (isContinuousFieldOrDatumDef(o)) {
		if (isContinuousFieldOrDatumDef(s)) {
			let t = isFieldDef(o) && o.aggregate, r = isFieldDef(s) && s.aggregate;
			if (!t && r === n) return "vertical";
			if (!r && t === n) return "horizontal";
			if (t === n && r === n) throw Error("Both x and y cannot have aggregate");
			return isFieldOrDatumDefForTimeFormat(s) && !isFieldOrDatumDefForTimeFormat(o) ? "horizontal" : "vertical";
		}
		return "horizontal";
	} else if (isContinuousFieldOrDatumDef(s)) return "vertical";
	else throw Error(`Need a valid continuous axis for ${n}s`);
}
var BOXPLOT = "boxplot", BOXPLOT_PARTS = [
	"box",
	"median",
	"outliers",
	"rule",
	"ticks"
], boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);
function getBoxPlotType(t) {
	return isNumber(t) ? "tukey" : t;
}
function normalizeBoxPlot(t, { config: n }) {
	t = {
		...t,
		encoding: normalizeEncoding(t.encoding, n)
	};
	let { mark: r, encoding: i, params: o, projection: s,...l } = t, u = isMarkDef(r) ? r : { type: r };
	o && warn(selectionNotSupported("boxplot"));
	let d = u.extent ?? n.boxplot.extent, f = getMarkPropOrConfig("size", u, n), p = u.invalid, g = getBoxPlotType(d), { bins: _, timeUnits: v, transform: S, continuousAxisChannelDef: T, continuousAxis: E, groupby: O, aggregate: k, encodingWithoutContinuousAxis: A, ticksOrient: j, boxOrient: N, customTooltipWithoutAggregatedField: P } = boxParams(t, d, n), F = removePathFromField(T.field), { color: I, size: L,...R } = A, z = (t) => makeCompositeAggregatePartFactory(u, E, T, t, n.boxplot), V = z(R), H = z(A), U = (isObject(n.boxplot.box) ? n.boxplot.box.color : n.mark.color) || "#4c78a8", W = z({
		...R,
		...L ? { size: L } : {},
		color: { condition: {
			test: `${accessWithDatumToUnescapedPath(`lower_box_${T.field}`)} >= ${accessWithDatumToUnescapedPath(`upper_box_${T.field}`)}`,
			...I || { value: U }
		} }
	}), G = getCompositeMarkTooltip([
		{
			fieldPrefix: g === "min-max" ? "upper_whisker_" : "max_",
			titlePrefix: "Max"
		},
		{
			fieldPrefix: "upper_box_",
			titlePrefix: "Q3"
		},
		{
			fieldPrefix: "mid_box_",
			titlePrefix: "Median"
		},
		{
			fieldPrefix: "lower_box_",
			titlePrefix: "Q1"
		},
		{
			fieldPrefix: g === "min-max" ? "lower_whisker_" : "min_",
			titlePrefix: "Min"
		}
	], T, A), K = {
		type: "tick",
		color: "black",
		opacity: 1,
		orient: j,
		invalid: p,
		aria: !1
	}, q = g === "min-max" ? G : getCompositeMarkTooltip([{
		fieldPrefix: "upper_whisker_",
		titlePrefix: "Upper Whisker"
	}, {
		fieldPrefix: "lower_whisker_",
		titlePrefix: "Lower Whisker"
	}], T, A), J = [
		...V({
			partName: "rule",
			mark: {
				type: "rule",
				invalid: p,
				aria: !1
			},
			positionPrefix: "lower_whisker",
			endPositionPrefix: "lower_box",
			extraEncoding: q
		}),
		...V({
			partName: "rule",
			mark: {
				type: "rule",
				invalid: p,
				aria: !1
			},
			positionPrefix: "upper_box",
			endPositionPrefix: "upper_whisker",
			extraEncoding: q
		}),
		...V({
			partName: "ticks",
			mark: K,
			positionPrefix: "lower_whisker",
			extraEncoding: q
		}),
		...V({
			partName: "ticks",
			mark: K,
			positionPrefix: "upper_whisker",
			extraEncoding: q
		})
	], z9 = [
		...g === "tukey" ? [] : J,
		...H({
			partName: "box",
			mark: {
				type: "bar",
				...f ? { size: f } : {},
				orient: N,
				invalid: p,
				ariaRoleDescription: "box"
			},
			positionPrefix: "lower_box",
			endPositionPrefix: "upper_box",
			extraEncoding: G
		}),
		...W({
			partName: "median",
			mark: {
				type: "tick",
				invalid: p,
				...isObject(n.boxplot.median) && n.boxplot.median.color ? { color: n.boxplot.median.color } : {},
				...f ? { size: f } : {},
				orient: j,
				aria: !1
			},
			positionPrefix: "mid_box",
			extraEncoding: G
		})
	];
	if (g === "min-max") return {
		...l,
		transform: (l.transform ?? []).concat(S),
		layer: z9
	};
	let B9 = accessWithDatumToUnescapedPath(`lower_box_${T.field}`), V9 = accessWithDatumToUnescapedPath(`upper_box_${T.field}`), H9 = `(${V9} - ${B9})`, U9 = `${B9} - ${d} * ${H9}`, W9 = `${V9} + ${d} * ${H9}`, Z = accessWithDatumToUnescapedPath(T.field), G9 = {
		joinaggregate: boxParamsQuartiles(T.field),
		groupby: O
	}, K9 = {
		transform: [{ filter: `(${U9} <= ${Z}) && (${Z} <= ${W9})` }, {
			aggregate: [
				{
					op: "min",
					field: T.field,
					as: `lower_whisker_${F}`
				},
				{
					op: "max",
					field: T.field,
					as: `upper_whisker_${F}`
				},
				{
					op: "min",
					field: `lower_box_${T.field}`,
					as: `lower_box_${F}`
				},
				{
					op: "max",
					field: `upper_box_${T.field}`,
					as: `upper_box_${F}`
				},
				...k
			],
			groupby: O
		}],
		layer: J
	}, { tooltip: q9,...J9 } = R, { scale: Y9, axis: X9 } = T, Z9 = getTitle(T), Q9 = partLayerMixins(u, "outliers", n.boxplot, {
		transform: [{ filter: `(${Z} < ${U9}) || (${Z} > ${W9})` }],
		mark: "point",
		encoding: {
			[E]: {
				field: T.field,
				type: T.type,
				...Z9 === void 0 ? {} : { title: Z9 },
				...Y9 === void 0 ? {} : { scale: Y9 },
				...X9 === void 0 ? {} : { axis: X9 }
			},
			...J9,
			...I ? { color: I } : {},
			...P ? { tooltip: P } : {}
		}
	})[0], Q, $9 = [
		..._,
		...v,
		G9
	];
	return Q9 ? Q = {
		transform: $9,
		layer: [Q9, K9]
	} : (Q = K9, Q.transform.unshift(...$9)), {
		...l,
		layer: [Q, {
			transform: S,
			layer: z9
		}]
	};
}
function boxParamsQuartiles(t) {
	let n = removePathFromField(t);
	return [{
		op: "q1",
		field: t,
		as: `lower_box_${n}`
	}, {
		op: "q3",
		field: t,
		as: `upper_box_${n}`
	}];
}
function boxParams(t, n, r) {
	let i = compositeMarkOrient(t, BOXPLOT), { continuousAxisChannelDef: o, continuousAxis: s } = compositeMarkContinuousAxis(t, i, BOXPLOT), l = o.field, u = removePathFromField(l), d = getBoxPlotType(n), f = [
		...boxParamsQuartiles(l),
		{
			op: "median",
			field: l,
			as: `mid_box_${u}`
		},
		{
			op: "min",
			field: l,
			as: (d === "min-max" ? "lower_whisker_" : "min_") + u
		},
		{
			op: "max",
			field: l,
			as: (d === "min-max" ? "upper_whisker_" : "max_") + u
		}
	], p = d === "min-max" || d === "tukey" ? [] : [
		{
			calculate: `${accessWithDatumToUnescapedPath(`upper_box_${u}`)} - ${accessWithDatumToUnescapedPath(`lower_box_${u}`)}`,
			as: `iqr_${u}`
		},
		{
			calculate: `min(${accessWithDatumToUnescapedPath(`upper_box_${u}`)} + ${accessWithDatumToUnescapedPath(`iqr_${u}`)} * ${n}, ${accessWithDatumToUnescapedPath(`max_${u}`)})`,
			as: `upper_whisker_${u}`
		},
		{
			calculate: `max(${accessWithDatumToUnescapedPath(`lower_box_${u}`)} - ${accessWithDatumToUnescapedPath(`iqr_${u}`)} * ${n}, ${accessWithDatumToUnescapedPath(`min_${u}`)})`,
			as: `lower_whisker_${u}`
		}
	], { [s]: g,..._ } = t.encoding, { customTooltipWithoutAggregatedField: v, filteredEncoding: S } = filterTooltipWithAggregatedField(_), { bins: T, timeUnits: E, aggregate: O, groupby: k, encoding: A } = extractTransformsFromEncoding(S, r), j = i === "vertical" ? "horizontal" : "vertical", N = i;
	return {
		bins: T,
		timeUnits: E,
		transform: [
			...T,
			...E,
			{
				aggregate: [...O, ...f],
				groupby: k
			},
			...p
		],
		groupby: k,
		aggregate: O,
		continuousAxisChannelDef: o,
		continuousAxis: s,
		encodingWithoutContinuousAxis: A,
		ticksOrient: j,
		boxOrient: N,
		customTooltipWithoutAggregatedField: v
	};
}
var ERRORBAR = "errorbar", ERRORBAR_PARTS = ["ticks", "rule"], errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);
function normalizeErrorBar(t, { config: n }) {
	t = {
		...t,
		encoding: normalizeEncoding(t.encoding, n)
	};
	let { transform: r, continuousAxisChannelDef: i, continuousAxis: o, encodingWithoutContinuousAxis: s, ticksOrient: l, markDef: u, outerSpec: d, tooltipEncoding: f } = errorBarParams(t, ERRORBAR, n);
	delete s.size;
	let p = makeCompositeAggregatePartFactory(u, o, i, s, n.errorbar), g = u.thickness, _ = u.size, v = {
		type: "tick",
		orient: l,
		aria: !1,
		...g === void 0 ? {} : { thickness: g },
		..._ === void 0 ? {} : { size: _ }
	}, S = [
		...p({
			partName: "ticks",
			mark: v,
			positionPrefix: "lower",
			extraEncoding: f
		}),
		...p({
			partName: "ticks",
			mark: v,
			positionPrefix: "upper",
			extraEncoding: f
		}),
		...p({
			partName: "rule",
			mark: {
				type: "rule",
				ariaRoleDescription: "errorbar",
				...g === void 0 ? {} : { size: g }
			},
			positionPrefix: "lower",
			endPositionPrefix: "upper",
			extraEncoding: f
		})
	];
	return {
		...d,
		transform: r,
		...S.length > 1 ? { layer: S } : { ...S[0] }
	};
}
function errorBarOrientAndInputType(t, n) {
	let { encoding: r } = t;
	if (errorBarIsInputTypeRaw(r)) return {
		orient: compositeMarkOrient(t, n),
		inputType: "raw"
	};
	let i = errorBarIsInputTypeAggregatedUpperLower(r), o = errorBarIsInputTypeAggregatedError(r), s = r.x, l = r.y;
	if (i) {
		if (o) throw Error(`${n} cannot be both type aggregated-upper-lower and aggregated-error`);
		let t = r.x2, i = r.y2;
		if (isFieldOrDatumDef(t) && isFieldOrDatumDef(i)) throw Error(`${n} cannot have both x2 and y2`);
		if (isFieldOrDatumDef(t)) {
			if (isContinuousFieldOrDatumDef(s)) return {
				orient: "horizontal",
				inputType: "aggregated-upper-lower"
			};
			throw Error(`Both x and x2 have to be quantitative in ${n}`);
		} else if (isFieldOrDatumDef(i)) {
			if (isContinuousFieldOrDatumDef(l)) return {
				orient: "vertical",
				inputType: "aggregated-upper-lower"
			};
			throw Error(`Both y and y2 have to be quantitative in ${n}`);
		}
		throw Error("No ranged axis");
	} else {
		let t = r.xError, i = r.xError2, o = r.yError, u = r.yError2;
		if (isFieldOrDatumDef(i) && !isFieldOrDatumDef(t)) throw Error(`${n} cannot have xError2 without xError`);
		if (isFieldOrDatumDef(u) && !isFieldOrDatumDef(o)) throw Error(`${n} cannot have yError2 without yError`);
		if (isFieldOrDatumDef(t) && isFieldOrDatumDef(o)) throw Error(`${n} cannot have both xError and yError with both are quantiative`);
		if (isFieldOrDatumDef(t)) {
			if (isContinuousFieldOrDatumDef(s)) return {
				orient: "horizontal",
				inputType: "aggregated-error"
			};
			throw Error("All x, xError, and xError2 (if exist) have to be quantitative");
		} else if (isFieldOrDatumDef(o)) {
			if (isContinuousFieldOrDatumDef(l)) return {
				orient: "vertical",
				inputType: "aggregated-error"
			};
			throw Error("All y, yError, and yError2 (if exist) have to be quantitative");
		}
		throw Error("No ranged axis");
	}
}
function errorBarIsInputTypeRaw(t) {
	return (isFieldOrDatumDef(t.x) || isFieldOrDatumDef(t.y)) && !isFieldOrDatumDef(t.x2) && !isFieldOrDatumDef(t.y2) && !isFieldOrDatumDef(t.xError) && !isFieldOrDatumDef(t.xError2) && !isFieldOrDatumDef(t.yError) && !isFieldOrDatumDef(t.yError2);
}
function errorBarIsInputTypeAggregatedUpperLower(t) {
	return isFieldOrDatumDef(t.x2) || isFieldOrDatumDef(t.y2);
}
function errorBarIsInputTypeAggregatedError(t) {
	return isFieldOrDatumDef(t.xError) || isFieldOrDatumDef(t.xError2) || isFieldOrDatumDef(t.yError) || isFieldOrDatumDef(t.yError2);
}
function errorBarParams(t, n, r) {
	let { mark: i, encoding: o, params: s, projection: l,...u } = t, d = isMarkDef(i) ? i : { type: i };
	s && warn(selectionNotSupported(n));
	let { orient: f, inputType: p } = errorBarOrientAndInputType(t, n), { continuousAxisChannelDef: g, continuousAxisChannelDef2: _, continuousAxisChannelDefError: v, continuousAxisChannelDefError2: S, continuousAxis: T } = compositeMarkContinuousAxis(t, f, n), { errorBarSpecificAggregate: E, postAggregateCalculates: O, tooltipSummary: k, tooltipTitleWithFieldName: A } = errorBarAggregationAndCalculation(d, g, _, v, S, p, n, r), { [T]: j, [T === "x" ? "x2" : "y2"]: N, [T === "x" ? "xError" : "yError"]: P, [T === "x" ? "xError2" : "yError2"]: F,...I } = o, { bins: L, timeUnits: R, aggregate: z, groupby: V, encoding: H } = extractTransformsFromEncoding(I, r), U = [...z, ...E], W = p === "raw" ? V : [], G = getCompositeMarkTooltip(k, g, H, A);
	return {
		transform: [
			...u.transform ?? [],
			...L,
			...R,
			...U.length === 0 ? [] : [{
				aggregate: U,
				groupby: W
			}],
			...O
		],
		groupby: W,
		continuousAxisChannelDef: g,
		continuousAxis: T,
		encodingWithoutContinuousAxis: H,
		ticksOrient: f === "vertical" ? "horizontal" : "vertical",
		markDef: d,
		outerSpec: u,
		tooltipEncoding: G
	};
}
function errorBarAggregationAndCalculation(t, n, r, i, o, s, l, u) {
	let d = [], f = [], p = n.field, g, _ = !1;
	if (s === "raw") {
		let n = t.center ? t.center : t.extent ? t.extent === "iqr" ? "median" : "mean" : u.errorbar.center, r = t.extent ? t.extent : n === "mean" ? "stderr" : "iqr";
		if (n === "median" != (r === "iqr") && warn(errorBarCenterIsUsedWithWrongExtent(n, r, l)), r === "stderr" || r === "stdev") d = [{
			op: r,
			field: p,
			as: `extent_${p}`
		}, {
			op: n,
			field: p,
			as: `center_${p}`
		}], f = [{
			calculate: `${accessWithDatumToUnescapedPath(`center_${p}`)} + ${accessWithDatumToUnescapedPath(`extent_${p}`)}`,
			as: `upper_${p}`
		}, {
			calculate: `${accessWithDatumToUnescapedPath(`center_${p}`)} - ${accessWithDatumToUnescapedPath(`extent_${p}`)}`,
			as: `lower_${p}`
		}], g = [
			{
				fieldPrefix: "center_",
				titlePrefix: titleCase(n)
			},
			{
				fieldPrefix: "upper_",
				titlePrefix: getTitlePrefix(n, r, "+")
			},
			{
				fieldPrefix: "lower_",
				titlePrefix: getTitlePrefix(n, r, "-")
			}
		], _ = !0;
		else {
			let t, n, i;
			r === "ci" ? (t = "mean", n = "ci0", i = "ci1") : (t = "median", n = "q1", i = "q3"), d = [
				{
					op: n,
					field: p,
					as: `lower_${p}`
				},
				{
					op: i,
					field: p,
					as: `upper_${p}`
				},
				{
					op: t,
					field: p,
					as: `center_${p}`
				}
			], g = [
				{
					fieldPrefix: "upper_",
					titlePrefix: title({
						field: p,
						aggregate: i,
						type: "quantitative"
					}, u, { allowDisabling: !1 })
				},
				{
					fieldPrefix: "lower_",
					titlePrefix: title({
						field: p,
						aggregate: n,
						type: "quantitative"
					}, u, { allowDisabling: !1 })
				},
				{
					fieldPrefix: "center_",
					titlePrefix: title({
						field: p,
						aggregate: t,
						type: "quantitative"
					}, u, { allowDisabling: !1 })
				}
			];
		}
	} else {
		(t.center || t.extent) && warn(errorBarCenterAndExtentAreNotNeeded(t.center, t.extent)), s === "aggregated-upper-lower" ? (g = [], f = [{
			calculate: accessWithDatumToUnescapedPath(r.field),
			as: `upper_${p}`
		}, {
			calculate: accessWithDatumToUnescapedPath(p),
			as: `lower_${p}`
		}]) : s === "aggregated-error" && (g = [{
			fieldPrefix: "",
			titlePrefix: p
		}], f = [{
			calculate: `${accessWithDatumToUnescapedPath(p)} + ${accessWithDatumToUnescapedPath(i.field)}`,
			as: `upper_${p}`
		}], o ? f.push({
			calculate: `${accessWithDatumToUnescapedPath(p)} + ${accessWithDatumToUnescapedPath(o.field)}`,
			as: `lower_${p}`
		}) : f.push({
			calculate: `${accessWithDatumToUnescapedPath(p)} - ${accessWithDatumToUnescapedPath(i.field)}`,
			as: `lower_${p}`
		}));
		for (let t of f) g.push({
			fieldPrefix: t.as.substring(0, 6),
			titlePrefix: replaceAll(replaceAll(t.calculate, "datum['", ""), "']", "")
		});
	}
	return {
		postAggregateCalculates: f,
		errorBarSpecificAggregate: d,
		tooltipSummary: g,
		tooltipTitleWithFieldName: _
	};
}
function getTitlePrefix(t, n, r) {
	return `${titleCase(t)} ${r} ${n}`;
}
var ERRORBAND = "errorband", ERRORBAND_PARTS = ["band", "borders"], errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);
function normalizeErrorBand(t, { config: n }) {
	t = {
		...t,
		encoding: normalizeEncoding(t.encoding, n)
	};
	let { transform: r, continuousAxisChannelDef: i, continuousAxis: o, encodingWithoutContinuousAxis: s, markDef: l, outerSpec: u, tooltipEncoding: d } = errorBarParams(t, ERRORBAND, n), f = l, p = makeCompositeAggregatePartFactory(f, o, i, s, n.errorband), g = t.encoding.x !== void 0 && t.encoding.y !== void 0, _ = { type: g ? "area" : "rect" }, v = { type: g ? "line" : "rule" }, S = {
		...f.interpolate ? { interpolate: f.interpolate } : {},
		...f.tension && f.interpolate ? { tension: f.tension } : {}
	};
	return g ? (_ = {
		..._,
		...S,
		ariaRoleDescription: "errorband"
	}, v = {
		...v,
		...S,
		aria: !1
	}) : f.interpolate ? warn(errorBand1DNotSupport("interpolate")) : f.tension && warn(errorBand1DNotSupport("tension")), {
		...u,
		transform: r,
		layer: [
			...p({
				partName: "band",
				mark: _,
				positionPrefix: "lower",
				endPositionPrefix: "upper",
				extraEncoding: d
			}),
			...p({
				partName: "borders",
				mark: v,
				positionPrefix: "lower",
				extraEncoding: d
			}),
			...p({
				partName: "borders",
				mark: v,
				positionPrefix: "upper",
				extraEncoding: d
			})
		]
	};
}
var compositeMarkRegistry = {};
function add(t, n, r) {
	compositeMarkRegistry[t] = {
		normalizer: new CompositeMarkNormalizer(t, n),
		parts: r
	};
}
function getAllCompositeMarks() {
	return keys(compositeMarkRegistry);
}
add(BOXPLOT, normalizeBoxPlot, BOXPLOT_PARTS), add(ERRORBAR, normalizeErrorBar, ERRORBAR_PARTS), add(ERRORBAND, normalizeErrorBand, ERRORBAND_PARTS);
var VL_ONLY_LEGEND_CONFIG = [
	"gradientHorizontalMaxLength",
	"gradientHorizontalMinLength",
	"gradientVerticalMaxLength",
	"gradientVerticalMinLength",
	"unselectedOpacity"
], HEADER_TITLE_PROPERTIES_MAP = {
	titleAlign: "align",
	titleAnchor: "anchor",
	titleAngle: "angle",
	titleBaseline: "baseline",
	titleColor: "color",
	titleFont: "font",
	titleFontSize: "fontSize",
	titleFontStyle: "fontStyle",
	titleFontWeight: "fontWeight",
	titleLimit: "limit",
	titleLineHeight: "lineHeight",
	titleOrient: "orient",
	titlePadding: "offset"
}, HEADER_LABEL_PROPERTIES_MAP = {
	labelAlign: "align",
	labelAnchor: "anchor",
	labelAngle: "angle",
	labelBaseline: "baseline",
	labelColor: "color",
	labelFont: "font",
	labelFontSize: "fontSize",
	labelFontStyle: "fontStyle",
	labelFontWeight: "fontWeight",
	labelLimit: "limit",
	labelLineHeight: "lineHeight",
	labelOrient: "orient",
	labelPadding: "offset"
}, HEADER_TITLE_PROPERTIES = keys(HEADER_TITLE_PROPERTIES_MAP), HEADER_LABEL_PROPERTIES = keys(HEADER_LABEL_PROPERTIES_MAP), HEADER_CONFIGS = keys({
	header: 1,
	headerRow: 1,
	headerColumn: 1,
	headerFacet: 1
}), LEGEND_SCALE_CHANNELS = [
	"size",
	"shape",
	"fill",
	"stroke",
	"strokeDash",
	"strokeWidth",
	"opacity"
], defaultLegendConfig = {
	gradientHorizontalMaxLength: 200,
	gradientHorizontalMinLength: 100,
	gradientVerticalMaxLength: 200,
	gradientVerticalMinLength: 64,
	unselectedOpacity: .35
}, COMMON_LEGEND_PROPERTY_INDEX = {
	aria: 1,
	clipHeight: 1,
	columnPadding: 1,
	columns: 1,
	cornerRadius: 1,
	description: 1,
	direction: 1,
	fillColor: 1,
	format: 1,
	formatType: 1,
	gradientLength: 1,
	gradientOpacity: 1,
	gradientStrokeColor: 1,
	gradientStrokeWidth: 1,
	gradientThickness: 1,
	gridAlign: 1,
	labelAlign: 1,
	labelBaseline: 1,
	labelColor: 1,
	labelFont: 1,
	labelFontSize: 1,
	labelFontStyle: 1,
	labelFontWeight: 1,
	labelLimit: 1,
	labelOffset: 1,
	labelOpacity: 1,
	labelOverlap: 1,
	labelPadding: 1,
	labelSeparation: 1,
	legendX: 1,
	legendY: 1,
	offset: 1,
	orient: 1,
	padding: 1,
	rowPadding: 1,
	strokeColor: 1,
	symbolDash: 1,
	symbolDashOffset: 1,
	symbolFillColor: 1,
	symbolLimit: 1,
	symbolOffset: 1,
	symbolOpacity: 1,
	symbolSize: 1,
	symbolStrokeColor: 1,
	symbolStrokeWidth: 1,
	symbolType: 1,
	tickCount: 1,
	tickMinStep: 1,
	title: 1,
	titleAlign: 1,
	titleAnchor: 1,
	titleBaseline: 1,
	titleColor: 1,
	titleFont: 1,
	titleFontSize: 1,
	titleFontStyle: 1,
	titleFontWeight: 1,
	titleLimit: 1,
	titleLineHeight: 1,
	titleOpacity: 1,
	titleOrient: 1,
	titlePadding: 1,
	type: 1,
	values: 1,
	zindex: 1
}, SELECTION_ID = "_vgsid_", defaultConfig$1 = {
	point: {
		on: "click",
		fields: [SELECTION_ID],
		toggle: "event.shiftKey",
		resolve: "global",
		clear: "dblclick"
	},
	interval: {
		on: "[pointerdown, window:pointerup] > window:pointermove!",
		encodings: ["x", "y"],
		translate: "[pointerdown, window:pointerup] > window:pointermove!",
		zoom: "wheel!",
		mark: {
			fill: "#333",
			fillOpacity: .125,
			stroke: "white"
		},
		resolve: "global",
		clear: "dblclick"
	}
};
function isLegendBinding(t) {
	return t === "legend" || !!t?.legend;
}
function isLegendStreamBinding(t) {
	return isLegendBinding(t) && isObject(t);
}
function isSelectionParameter(t) {
	return !!t?.select;
}
function assembleParameterSignals(t) {
	let n = [];
	for (let r of t || []) {
		if (isSelectionParameter(r)) continue;
		let { expr: t, bind: i,...o } = r;
		if (i && t) {
			let r = {
				...o,
				bind: i,
				init: t
			};
			n.push(r);
		} else {
			let r = {
				...o,
				...t ? { update: t } : {},
				...i ? { bind: i } : {}
			};
			n.push(r);
		}
	}
	return n;
}
function isAnyConcatSpec(t) {
	return isVConcatSpec(t) || isHConcatSpec(t) || isConcatSpec(t);
}
function isConcatSpec(t) {
	return hasProperty(t, "concat");
}
function isVConcatSpec(t) {
	return hasProperty(t, "vconcat");
}
function isHConcatSpec(t) {
	return hasProperty(t, "hconcat");
}
function getStepFor({ step: t, offsetIsDiscrete: n }) {
	return n ? t.for ?? "offset" : "position";
}
function isStep(t) {
	return hasProperty(t, "step");
}
function isFrameMixins(t) {
	return hasProperty(t, "view") || hasProperty(t, "width") || hasProperty(t, "height");
}
var DEFAULT_SPACING = 20, COMPOSITION_LAYOUT_PROPERTIES = keys({
	align: 1,
	bounds: 1,
	center: 1,
	columns: 1,
	spacing: 1
});
function extractCompositionLayout(t, n, r) {
	let i = r[n], o = {}, { spacing: s, columns: l } = i;
	s !== void 0 && (o.spacing = s), l !== void 0 && (isFacetSpec(t) && !isFacetMapping(t.facet) || isConcatSpec(t)) && (o.columns = l), isVConcatSpec(t) && (o.columns = 1);
	for (let n of COMPOSITION_LAYOUT_PROPERTIES) if (t[n] !== void 0) if (n === "spacing") {
		let r = t[n];
		o[n] = isNumber(r) ? r : {
			row: r.row ?? s,
			column: r.column ?? s
		};
	} else o[n] = t[n];
	return o;
}
function getViewConfigContinuousSize(t, n) {
	return t[n] ?? t[n === "width" ? "continuousWidth" : "continuousHeight"];
}
function getViewConfigDiscreteStep(t, n) {
	let r = getViewConfigDiscreteSize(t, n);
	return isStep(r) ? r.step : DEFAULT_STEP;
}
function getViewConfigDiscreteSize(t, n) {
	return getFirstDefined(t[n] ?? t[n === "width" ? "discreteWidth" : "discreteHeight"], { step: t.step });
}
var DEFAULT_STEP = 20, defaultConfig = {
	background: "white",
	padding: 5,
	timeFormat: "%b %d, %Y",
	countTitle: "Count of Records",
	view: {
		continuousWidth: 300,
		continuousHeight: 300,
		step: DEFAULT_STEP
	},
	mark: defaultMarkConfig,
	arc: {},
	area: {},
	bar: defaultBarConfig,
	circle: {},
	geoshape: {},
	image: {},
	line: {},
	point: {},
	rect: defaultRectConfig,
	rule: { color: "black" },
	square: {},
	text: { color: "black" },
	tick: defaultTickConfig,
	trail: {},
	boxplot: {
		size: 14,
		extent: 1.5,
		box: {},
		median: { color: "white" },
		outliers: {},
		rule: {},
		ticks: null
	},
	errorbar: {
		center: "mean",
		rule: !0,
		ticks: !1
	},
	errorband: {
		band: { opacity: .3 },
		borders: !1
	},
	scale: defaultScaleConfig,
	projection: {},
	legend: defaultLegendConfig,
	header: {
		titlePadding: 10,
		labelPadding: 10
	},
	headerColumn: {},
	headerRow: {},
	headerFacet: {},
	selection: defaultConfig$1,
	style: {},
	title: {},
	facet: { spacing: DEFAULT_SPACING },
	concat: { spacing: DEFAULT_SPACING },
	normalizedNumberFormat: ".0%"
}, tab10 = [
	"#4c78a8",
	"#f58518",
	"#e45756",
	"#72b7b2",
	"#54a24b",
	"#eeca3b",
	"#b279a2",
	"#ff9da6",
	"#9d755d",
	"#bab0ac"
], DEFAULT_FONT_SIZE = {
	text: 11,
	guideLabel: 10,
	guideTitle: 11,
	groupTitle: 13,
	groupSubtitle: 12
}, DEFAULT_COLOR = {
	blue: tab10[0],
	orange: tab10[1],
	red: tab10[2],
	teal: tab10[3],
	green: tab10[4],
	yellow: tab10[5],
	purple: tab10[6],
	pink: tab10[7],
	brown: tab10[8],
	gray0: "#000",
	gray1: "#111",
	gray2: "#222",
	gray3: "#333",
	gray4: "#444",
	gray5: "#555",
	gray6: "#666",
	gray7: "#777",
	gray8: "#888",
	gray9: "#999",
	gray10: "#aaa",
	gray11: "#bbb",
	gray12: "#ccc",
	gray13: "#ddd",
	gray14: "#eee",
	gray15: "#fff"
};
function colorSignalConfig(t = {}) {
	return {
		signals: [{
			name: "color",
			value: isObject(t) ? {
				...DEFAULT_COLOR,
				...t
			} : DEFAULT_COLOR
		}],
		mark: { color: { signal: "color.blue" } },
		rule: { color: { signal: "color.gray0" } },
		text: { color: { signal: "color.gray0" } },
		style: {
			"guide-label": { fill: { signal: "color.gray0" } },
			"guide-title": { fill: { signal: "color.gray0" } },
			"group-title": { fill: { signal: "color.gray0" } },
			"group-subtitle": { fill: { signal: "color.gray0" } },
			cell: { stroke: { signal: "color.gray8" } }
		},
		axis: {
			domainColor: { signal: "color.gray13" },
			gridColor: { signal: "color.gray8" },
			tickColor: { signal: "color.gray13" }
		},
		range: { category: [
			{ signal: "color.blue" },
			{ signal: "color.orange" },
			{ signal: "color.red" },
			{ signal: "color.teal" },
			{ signal: "color.green" },
			{ signal: "color.yellow" },
			{ signal: "color.purple" },
			{ signal: "color.pink" },
			{ signal: "color.brown" },
			{ signal: "color.grey8" }
		] }
	};
}
function fontSizeSignalConfig(t) {
	return {
		signals: [{
			name: "fontSize",
			value: isObject(t) ? {
				...DEFAULT_FONT_SIZE,
				...t
			} : DEFAULT_FONT_SIZE
		}],
		text: { fontSize: { signal: "fontSize.text" } },
		style: {
			"guide-label": { fontSize: { signal: "fontSize.guideLabel" } },
			"guide-title": { fontSize: { signal: "fontSize.guideTitle" } },
			"group-title": { fontSize: { signal: "fontSize.groupTitle" } },
			"group-subtitle": { fontSize: { signal: "fontSize.groupSubtitle" } }
		}
	};
}
function fontConfig(t) {
	return {
		text: { font: t },
		style: {
			"guide-label": { font: t },
			"guide-title": { font: t },
			"group-title": { font: t },
			"group-subtitle": { font: t }
		}
	};
}
function getAxisConfigInternal(t) {
	let n = keys(t || {}), r = {};
	for (let i of n) {
		let n = t[i];
		r[i] = isConditionalAxisValue(n) ? signalOrValueRefWithCondition(n) : signalRefOrValue(n);
	}
	return r;
}
function getStyleConfigInternal(t) {
	let n = keys(t), r = {};
	for (let i of n) r[i] = getAxisConfigInternal(t[i]);
	return r;
}
var configPropsWithExpr = [
	...MARK_CONFIGS,
	...AXIS_CONFIGS,
	...HEADER_CONFIGS,
	"background",
	"padding",
	"legend",
	"lineBreak",
	"scale",
	"style",
	"title",
	"view"
];
function initConfig(t = {}) {
	let { color: n, font: r, fontSize: i, selection: o,...s } = t, l = mergeConfig({}, duplicate(defaultConfig), r ? fontConfig(r) : {}, n ? colorSignalConfig(n) : {}, i ? fontSizeSignalConfig(i) : {}, s || {});
	o && writeConfig(l, "selection", o, !0);
	let u = omit(l, configPropsWithExpr);
	for (let t of [
		"background",
		"lineBreak",
		"padding"
	]) l[t] && (u[t] = signalRefOrValue(l[t]));
	for (let t of MARK_CONFIGS) l[t] && (u[t] = replaceExprRef(l[t]));
	for (let t of AXIS_CONFIGS) l[t] && (u[t] = getAxisConfigInternal(l[t]));
	for (let t of HEADER_CONFIGS) l[t] && (u[t] = replaceExprRef(l[t]));
	if (l.legend && (u.legend = replaceExprRef(l.legend)), l.scale) {
		let { invalid: t,...n } = l.scale, r = replaceExprRef(t, { level: 1 });
		u.scale = {
			...replaceExprRef(n),
			...keys(r).length > 0 ? { invalid: r } : {}
		};
	}
	return l.style && (u.style = getStyleConfigInternal(l.style)), l.title && (u.title = replaceExprRef(l.title)), l.view && (u.view = replaceExprRef(l.view)), u;
}
var MARK_STYLES = new Set(["view", ...PRIMITIVE_MARKS]), VL_ONLY_CONFIG_PROPERTIES = /* @__PURE__ */ "color.fontSize.background.padding.facet.concat.numberFormat.numberFormatType.normalizedNumberFormat.normalizedNumberFormatType.timeFormat.countTitle.header.axisQuantitative.axisTemporal.axisDiscrete.axisPoint.axisXBand.axisXPoint.axisXDiscrete.axisXQuantitative.axisXTemporal.axisYBand.axisYPoint.axisYDiscrete.axisYQuantitative.axisYTemporal.scale.selection.overlay".split("."), VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {
	view: [
		"continuousWidth",
		"continuousHeight",
		"discreteWidth",
		"discreteHeight",
		"step"
	],
	...VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX
};
function stripAndRedirectConfig(t) {
	t = duplicate(t);
	for (let n of VL_ONLY_CONFIG_PROPERTIES) delete t[n];
	if (t.axis) for (let n in t.axis) isConditionalAxisValue(t.axis[n]) && delete t.axis[n];
	if (t.legend) for (let n of VL_ONLY_LEGEND_CONFIG) delete t.legend[n];
	if (t.mark) {
		for (let n of VL_ONLY_MARK_CONFIG_PROPERTIES) delete t.mark[n];
		t.mark.tooltip && isObject(t.mark.tooltip) && delete t.mark.tooltip;
	}
	t.params && (t.signals = (t.signals || []).concat(assembleParameterSignals(t.params)), delete t.params);
	for (let n of MARK_STYLES) {
		for (let r of VL_ONLY_MARK_CONFIG_PROPERTIES) delete t[n][r];
		let r = VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[n];
		if (r) for (let i of r) delete t[n][i];
		redirectConfigToStyleConfig(t, n);
	}
	for (let n of getAllCompositeMarks()) delete t[n];
	for (let n in redirectTitleConfig(t), t) isObject(t[n]) && isEmpty(t[n]) && delete t[n];
	return isEmpty(t) ? void 0 : t;
}
function redirectTitleConfig(t) {
	let { titleMarkConfig: n, subtitleMarkConfig: r, subtitle: i } = extractTitleConfig(t.title);
	isEmpty(n) || (t.style["group-title"] = {
		...t.style["group-title"],
		...n
	}), isEmpty(r) || (t.style["group-subtitle"] = {
		...t.style["group-subtitle"],
		...r
	}), isEmpty(i) ? delete t.title : t.title = i;
}
function redirectConfigToStyleConfig(t, n, r, i) {
	let o = t[n];
	n === "view" && (r = "cell");
	let s = {
		...o,
		...t.style[r ?? n]
	};
	isEmpty(s) || (t.style[r ?? n] = s), delete t[n];
}
function isLayerSpec(t) {
	return hasProperty(t, "layer");
}
function isRepeatSpec(t) {
	return hasProperty(t, "repeat");
}
function isLayerRepeatSpec(t) {
	return !isArray(t.repeat) && hasProperty(t.repeat, "layer");
}
var SpecMapper = class {
	map(t, n) {
		return isFacetSpec(t) ? this.mapFacet(t, n) : isRepeatSpec(t) ? this.mapRepeat(t, n) : isHConcatSpec(t) ? this.mapHConcat(t, n) : isVConcatSpec(t) ? this.mapVConcat(t, n) : isConcatSpec(t) ? this.mapConcat(t, n) : this.mapLayerOrUnit(t, n);
	}
	mapLayerOrUnit(t, n) {
		if (isLayerSpec(t)) return this.mapLayer(t, n);
		if (isUnitSpec(t)) return this.mapUnit(t, n);
		throw Error(invalidSpec(t));
	}
	mapLayer(t, n) {
		return {
			...t,
			layer: t.layer.map((t) => this.mapLayerOrUnit(t, n))
		};
	}
	mapHConcat(t, n) {
		return {
			...t,
			hconcat: t.hconcat.map((t) => this.map(t, n))
		};
	}
	mapVConcat(t, n) {
		return {
			...t,
			vconcat: t.vconcat.map((t) => this.map(t, n))
		};
	}
	mapConcat(t, n) {
		let { concat: r,...i } = t;
		return {
			...i,
			concat: r.map((t) => this.map(t, n))
		};
	}
	mapFacet(t, n) {
		return {
			...t,
			spec: this.map(t.spec, n)
		};
	}
	mapRepeat(t, n) {
		return {
			...t,
			spec: this.map(t.spec, n)
		};
	}
}, STACK_OFFSET_INDEX = {
	zero: 1,
	center: 1,
	normalize: 1
};
function isStackOffset(t) {
	return has(STACK_OFFSET_INDEX, t);
}
var STACKABLE_MARKS = new Set([
	ARC,
	BAR,
	AREA,
	RULE,
	POINT,
	CIRCLE,
	SQUARE,
	LINE,
	TEXT,
	TICK
]), STACK_BY_DEFAULT_MARKS = new Set([
	BAR,
	AREA,
	ARC
]);
function isUnbinnedQuantitative(t) {
	return isFieldDef(t) && channelDefType(t) === "quantitative" && !t.bin;
}
function potentialStackedChannel(t, n, { orient: r, type: i }) {
	let o = n === "x" ? "y" : "radius", s = n === "x" && ["bar", "area"].includes(i), l = t[n], u = t[o];
	if (isFieldDef(l) && isFieldDef(u)) {
		if (isUnbinnedQuantitative(l) && isUnbinnedQuantitative(u)) {
			if (l.stack) return n;
			if (u.stack) return o;
			let t = isFieldDef(l) && !!l.aggregate;
			if (t !== (isFieldDef(u) && !!u.aggregate)) return t ? n : o;
			if (s) {
				if (r === "vertical") return o;
				if (r === "horizontal") return n;
			}
		} else if (isUnbinnedQuantitative(l)) return n;
		else if (isUnbinnedQuantitative(u)) return o;
	} else if (isUnbinnedQuantitative(l)) return s && r === "vertical" ? void 0 : n;
	else if (isUnbinnedQuantitative(u)) return s && r === "horizontal" ? void 0 : o;
}
function getDimensionChannel(t) {
	switch (t) {
		case "x": return "y";
		case "y": return "x";
		case "theta": return "radius";
		case "radius": return "theta";
	}
}
function stack(t, n) {
	let r = isMarkDef(t) ? t : { type: t }, i = r.type;
	if (!STACKABLE_MARKS.has(i)) return null;
	let o = potentialStackedChannel(n, "x", r) || potentialStackedChannel(n, "theta", r);
	if (!o) return null;
	let s = n[o], l = isFieldDef(s) ? vgField(s, {}) : void 0, u = getDimensionChannel(o), d = [], f = /* @__PURE__ */ new Set();
	if (n[u]) {
		let t = n[u], r = isFieldDef(t) ? vgField(t, {}) : void 0;
		r && r !== l && (d.push(u), f.add(r));
	}
	let p = u === "x" ? "xOffset" : "yOffset", g = n[p], _ = isFieldDef(g) ? vgField(g, {}) : void 0;
	_ && _ !== l && (d.push(p), f.add(_));
	let v = NONPOSITION_CHANNELS.reduce((t, r) => {
		if (r !== "tooltip" && channelHasField(n, r)) {
			let i = n[r];
			for (let n of array(i)) {
				let i = getFieldDef(n);
				if (i.aggregate) continue;
				let o = vgField(i, {});
				(!o || !f.has(o)) && t.push({
					channel: r,
					fieldDef: i
				});
			}
		}
		return t;
	}, []), S;
	return s.stack === void 0 ? STACK_BY_DEFAULT_MARKS.has(i) && (S = "zero") : S = isBoolean(s.stack) ? s.stack ? "zero" : null : s.stack, !S || !isStackOffset(S) || isAggregate$1(n) && v.length === 0 ? null : (s?.scale?.type && s?.scale?.type !== ScaleType.LINEAR && s?.stack && warn(stackNonLinearScale(s.scale.type)), isFieldOrDatumDef(n[getSecondaryRangeChannel(o)]) ? (s.stack !== void 0 && warn(cannotStackRangedMark(o)), null) : (isFieldDef(s) && s.aggregate && !SUM_OPS.has(s.aggregate) && warn(stackNonSummativeAggregate(s.aggregate)), {
		groupbyChannels: d,
		groupbyFields: f,
		fieldChannel: o,
		impute: s.impute === null ? !1 : isPathMark(i),
		stackBy: v,
		offset: S
	}));
}
function initMarkdef(t, n, r) {
	let i = replaceExprRef(t), o = getMarkPropOrConfig("orient", i, r);
	if (i.orient = orient(i.type, n, o), o !== void 0 && o !== i.orient && warn(orientOverridden(i.orient, o)), i.type === "bar" && i.orient) {
		let t = getMarkPropOrConfig("cornerRadiusEnd", i, r);
		if (t !== void 0) {
			let r = i.orient === "horizontal" && n.x2 || i.orient === "vertical" && n.y2 ? ["cornerRadius"] : BAR_CORNER_RADIUS_INDEX[i.orient];
			for (let n of r) i[n] = t;
			i.cornerRadiusEnd !== void 0 && delete i.cornerRadiusEnd;
		}
	}
	let s = getMarkPropOrConfig("opacity", i, r), l = getMarkPropOrConfig("fillOpacity", i, r);
	return s === void 0 && l === void 0 && (i.opacity = opacity(i.type, n)), getMarkPropOrConfig("cursor", i, r) === void 0 && (i.cursor = cursor(i, n, r)), i;
}
function cursor(t, n, r) {
	return n.href || t.href || getMarkPropOrConfig("href", t, r) ? "pointer" : t.cursor;
}
var DEFAULT_REDUCED_OPACITY = .7;
function opacity(t, n) {
	if (contains([
		POINT,
		TICK,
		CIRCLE,
		SQUARE
	], t) && !isAggregate$1(n)) return DEFAULT_REDUCED_OPACITY;
}
function defaultFilled(t, n, { graticule: r }) {
	if (r) return !1;
	let i = getMarkConfig("filled", t, n), o = t.type;
	return getFirstDefined(i, o !== POINT && o !== LINE && o !== RULE);
}
function orient(t, n, r) {
	switch (t) {
		case POINT:
		case CIRCLE:
		case SQUARE:
		case RECT:
		case IMAGE: return;
	}
	let { x: i, y: o, x2: s, y2: l } = n;
	switch (t) {
		case TEXT:
		case BAR:
			if (isFieldDef(i) && (isBinned(i.bin) || isFieldDef(o) && o.aggregate && !i.aggregate)) return "vertical";
			if (isFieldDef(o) && (isBinned(o.bin) || isFieldDef(i) && i.aggregate && !o.aggregate)) return "horizontal";
			if (l || s) {
				if (r) return r;
				if (!s) return (isFieldDef(i) && i.type === QUANTITATIVE && !isBinning(i.bin) || isNumericDataDef(i)) && isFieldDef(o) && isBinned(o.bin) ? "horizontal" : "vertical";
				if (!l) return (isFieldDef(o) && o.type === QUANTITATIVE && !isBinning(o.bin) || isNumericDataDef(o)) && isFieldDef(i) && isBinned(i.bin) ? "vertical" : "horizontal";
			}
		case RULE: if (s && !(isFieldDef(i) && isBinned(i.bin)) && l && !(isFieldDef(o) && isBinned(o.bin))) return;
		case AREA:
			if (l) return isFieldDef(o) && isBinned(o.bin) ? "horizontal" : "vertical";
			if (s) return isFieldDef(i) && isBinned(i.bin) ? "vertical" : "horizontal";
			if (t === RULE) {
				if (i && !o) return "vertical";
				if (o && !i) return "horizontal";
			}
		case LINE:
		case TICK: {
			let n = isUnbinnedQuantitativeFieldOrDatumDef(i), s = isUnbinnedQuantitativeFieldOrDatumDef(o);
			if (r) return r;
			if (n && !s) return t === "tick" ? "vertical" : "horizontal";
			if (!n && s) return t === "tick" ? "horizontal" : "vertical";
			if (n && s) return "vertical";
			{
				let t = isTypedFieldDef(i) && i.type === TEMPORAL, n = isTypedFieldDef(o) && o.type === TEMPORAL;
				if (t && !n) return "vertical";
				if (!t && n) return "horizontal";
			}
			return;
		}
	}
	return "vertical";
}
function dropLineAndPoint(t) {
	let { point: n, line: r,...i } = t;
	return keys(i).length > 1 ? i : i.type;
}
function dropLineAndPointFromConfig(t) {
	for (let n of [
		"line",
		"area",
		"rule",
		"trail"
	]) t[n] && (t = {
		...t,
		[n]: omit(t[n], ["point", "line"])
	});
	return t;
}
function getPointOverlay(t, n = {}, r) {
	return t.point === "transparent" ? { opacity: 0 } : t.point ? isObject(t.point) ? t.point : {} : t.point === void 0 ? n.point || r.shape ? isObject(n.point) ? n.point : {} : void 0 : null;
}
function getLineOverlay(t, n = {}) {
	return t.line ? t.line === !0 ? {} : t.line : t.line === void 0 ? n.line ? n.line === !0 ? {} : n.line : void 0 : null;
}
var PathOverlayNormalizer = class {
	name = "path-overlay";
	hasMatchingType(t, n) {
		if (isUnitSpec(t)) {
			let { mark: r, encoding: i } = t, o = isMarkDef(r) ? r : { type: r };
			switch (o.type) {
				case "line":
				case "rule":
				case "trail": return !!getPointOverlay(o, n[o.type], i);
				case "area": return !!getPointOverlay(o, n[o.type], i) || !!getLineOverlay(o, n[o.type]);
			}
		}
		return !1;
	}
	run(t, n, r) {
		let { config: i } = n, { params: o, projection: s, mark: l, name: u, encoding: d,...f } = t, p = normalizeEncoding(d, i), g = isMarkDef(l) ? l : { type: l }, _ = getPointOverlay(g, i[g.type], p), v = g.type === "area" && getLineOverlay(g, i[g.type]), S = [{
			name: u,
			...o ? { params: o } : {},
			mark: dropLineAndPoint({
				...g.type === "area" && getMarkPropOrConfig("opacity", g, i) == null && getMarkPropOrConfig("fillOpacity", g, i) == null ? { opacity: DEFAULT_REDUCED_OPACITY } : {},
				...g
			}),
			encoding: omit(p, ["shape"])
		}], T = stack(initMarkdef(g, p, i), p), E = p;
		if (T) {
			let { fieldChannel: t, offset: n } = T;
			E = {
				...p,
				[t]: {
					...p[t],
					...n ? { stack: n } : {}
				}
			};
		}
		return E = omit(E, ["y2", "x2"]), v && S.push({
			...s ? { projection: s } : {},
			mark: {
				type: "line",
				...pick(g, [
					"clip",
					"interpolate",
					"tension",
					"tooltip"
				]),
				...v
			},
			encoding: E
		}), _ && S.push({
			...s ? { projection: s } : {},
			mark: {
				type: "point",
				opacity: 1,
				filled: !0,
				...pick(g, ["clip", "tooltip"]),
				..._
			},
			encoding: E
		}), r({
			...f,
			layer: S
		}, {
			...n,
			config: dropLineAndPointFromConfig(i)
		});
	}
};
function replaceRepeaterInFacet(t, n) {
	return n ? isFacetMapping(t) ? replaceRepeaterInMapping(t, n) : replaceRepeaterInFieldDef(t, n) : t;
}
function replaceRepeaterInEncoding(t, n) {
	return n ? replaceRepeaterInMapping(t, n) : t;
}
function replaceRepeatInProp(t, n, r) {
	let i = n[t];
	if (isRepeatRef(i)) {
		if (i.repeat in r) return {
			...n,
			[t]: r[i.repeat]
		};
		warn(noSuchRepeatedValue(i.repeat));
		return;
	}
	return n;
}
function replaceRepeaterInFieldDef(t, n) {
	if (t = replaceRepeatInProp("field", t, n), t !== void 0) {
		if (t === null) return null;
		if (isSortableFieldDef(t) && isSortField(t.sort)) {
			let r = replaceRepeatInProp("field", t.sort, n);
			t = {
				...t,
				...r ? { sort: r } : {}
			};
		}
		return t;
	}
}
function replaceRepeaterInFieldOrDatumDef(t, n) {
	if (isFieldDef(t)) return replaceRepeaterInFieldDef(t, n);
	{
		let r = replaceRepeatInProp("datum", t, n);
		return r !== t && !r.type && (r.type = "nominal"), r;
	}
}
function replaceRepeaterInChannelDef(t, n) {
	if (isFieldOrDatumDef(t)) {
		let r = replaceRepeaterInFieldOrDatumDef(t, n);
		if (r) return r;
		if (isConditionalDef(t)) return { condition: t.condition };
	} else {
		if (hasConditionalFieldOrDatumDef(t)) {
			let r = replaceRepeaterInFieldOrDatumDef(t.condition, n);
			if (r) return {
				...t,
				condition: r
			};
			{
				let { condition: n,...r } = t;
				return r;
			}
		}
		return t;
	}
}
function replaceRepeaterInMapping(t, n) {
	let r = {};
	for (let i in t) if (hasProperty(t, i)) {
		let o = t[i];
		if (isArray(o)) r[i] = o.map((t) => replaceRepeaterInChannelDef(t, n)).filter((t) => t);
		else {
			let t = replaceRepeaterInChannelDef(o, n);
			t !== void 0 && (r[i] = t);
		}
	}
	return r;
}
var RuleForRangedLineNormalizer = class {
	name = "RuleForRangedLine";
	hasMatchingType(t) {
		if (isUnitSpec(t)) {
			let { encoding: n, mark: r } = t;
			if (r === "line" || isMarkDef(r) && r.type === "line") for (let t of SECONDARY_RANGE_CHANNEL) {
				let r = n[getMainRangeChannel(t)];
				if (n[t] && (isFieldDef(r) && !isBinned(r.bin) || isDatumDef(r))) return !0;
			}
		}
		return !1;
	}
	run(t, n, r) {
		let { encoding: i, mark: o } = t;
		return warn(lineWithRange(!!i.x2, !!i.y2)), r({
			...t,
			mark: isObject(o) ? {
				...o,
				type: "rule"
			} : "rule"
		}, n);
	}
}, CoreNormalizer = class extends SpecMapper {
	nonFacetUnitNormalizers = [
		boxPlotNormalizer,
		errorBarNormalizer,
		errorBandNormalizer,
		new PathOverlayNormalizer(),
		new RuleForRangedLineNormalizer()
	];
	map(t, n) {
		if (isUnitSpec(t)) {
			let r = channelHasField(t.encoding, ROW), i = channelHasField(t.encoding, COLUMN), o = channelHasField(t.encoding, FACET);
			if (r || i || o) return this.mapFacetedUnit(t, n);
		}
		return super.map(t, n);
	}
	mapUnit(t, n) {
		let { parentEncoding: r, parentProjection: i } = n, o = replaceRepeaterInEncoding(t.encoding, n.repeater), s = {
			...t,
			...t.name ? { name: [n.repeaterPrefix, t.name].filter((t) => t).join("_") } : {},
			...o ? { encoding: o } : {}
		};
		if (r || i) return this.mapUnitWithParentEncodingOrProjection(s, n);
		let l = this.mapLayerOrUnit.bind(this);
		for (let t of this.nonFacetUnitNormalizers) if (t.hasMatchingType(s, n.config)) return t.run(s, n, l);
		return s;
	}
	mapRepeat(t, n) {
		return isLayerRepeatSpec(t) ? this.mapLayerRepeat(t, n) : this.mapNonLayerRepeat(t, n);
	}
	mapLayerRepeat(t, n) {
		let { repeat: r, spec: i,...o } = t, { row: s, column: l, layer: u } = r, { repeater: d = {}, repeaterPrefix: f = "" } = n;
		return s || l ? this.mapRepeat({
			...t,
			repeat: {
				...s ? { row: s } : {},
				...l ? { column: l } : {}
			},
			spec: {
				repeat: { layer: u },
				spec: i
			}
		}, n) : {
			...o,
			layer: u.map((t) => {
				let r = {
					...d,
					layer: t
				}, o = `${(i.name ? `${i.name}_` : "") + f}child__layer_${varName(t)}`, s = this.mapLayerOrUnit(i, {
					...n,
					repeater: r,
					repeaterPrefix: o
				});
				return s.name = o, s;
			})
		};
	}
	mapNonLayerRepeat(t, n) {
		let { repeat: r, spec: i, data: o,...s } = t;
		!isArray(r) && t.columns && (t = omit(t, ["columns"]), warn(columnsNotSupportByRowCol("repeat")));
		let l = [], { repeater: u = {}, repeaterPrefix: d = "" } = n, f = !isArray(r) && r.row || [u ? u.row : null], p = !isArray(r) && r.column || [u ? u.column : null], g = isArray(r) && r || [u ? u.repeat : null];
		for (let t of g) for (let o of f) for (let s of p) {
			let f = {
				repeat: t,
				row: o,
				column: s,
				layer: u.layer
			}, p = `${(i.name ? `${i.name}_` : "") + d}child__${isArray(r) ? `${varName(t)}` : (r.row ? `row_${varName(o)}` : "") + (r.column ? `column_${varName(s)}` : "")}`, g = this.map(i, {
				...n,
				repeater: f,
				repeaterPrefix: p
			});
			g.name = p, l.push(omit(g, ["data"]));
		}
		let _ = isArray(r) ? t.columns : r.column ? r.column.length : 1;
		return {
			data: i.data ?? o,
			align: "all",
			...s,
			columns: _,
			concat: l
		};
	}
	mapFacet(t, n) {
		let { facet: r } = t;
		return isFacetMapping(r) && t.columns && (t = omit(t, ["columns"]), warn(columnsNotSupportByRowCol("facet"))), super.mapFacet(t, n);
	}
	mapUnitWithParentEncodingOrProjection(t, n) {
		let { encoding: r, projection: i } = t, { parentEncoding: o, parentProjection: s, config: l } = n, u = mergeProjection({
			parentProjection: s,
			projection: i
		}), d = mergeEncoding({
			parentEncoding: o,
			encoding: replaceRepeaterInEncoding(r, n.repeater)
		});
		return this.mapUnit({
			...t,
			...u ? { projection: u } : {},
			...d ? { encoding: d } : {}
		}, { config: l });
	}
	mapFacetedUnit(t, n) {
		let { row: r, column: i, facet: o,...s } = t.encoding, { mark: l, width: u, projection: d, height: f, view: p, params: g, encoding: _,...v } = t, { facetMapping: S, layout: T } = this.getFacetMappingAndLayout({
			row: r,
			column: i,
			facet: o
		}, n), E = replaceRepeaterInEncoding(s, n.repeater);
		return this.mapFacet({
			...v,
			...T,
			facet: S,
			spec: {
				...u ? { width: u } : {},
				...f ? { height: f } : {},
				...p ? { view: p } : {},
				...d ? { projection: d } : {},
				mark: l,
				encoding: E,
				...g ? { params: g } : {}
			}
		}, n);
	}
	getFacetMappingAndLayout(t, n) {
		let { row: r, column: i, facet: o } = t;
		if (r || i) {
			o && warn(facetChannelDropped([...r ? [ROW] : [], ...i ? [COLUMN] : []]));
			let n = {}, s = {};
			for (let r of [ROW, COLUMN]) {
				let i = t[r];
				if (i) {
					let { align: t, center: o, spacing: l, columns: u,...d } = i;
					n[r] = d;
					for (let t of [
						"align",
						"center",
						"spacing"
					]) i[t] !== void 0 && (s[t] ??= {}, s[t][r] = i[t]);
				}
			}
			return {
				facetMapping: n,
				layout: s
			};
		} else {
			let { align: t, center: r, spacing: i, columns: s,...l } = o;
			return {
				facetMapping: replaceRepeaterInFacet(l, n.repeater),
				layout: {
					...t ? { align: t } : {},
					...r ? { center: r } : {},
					...i ? { spacing: i } : {},
					...s ? { columns: s } : {}
				}
			};
		}
	}
	mapLayer(t, { parentEncoding: n, parentProjection: r,...i }) {
		let { encoding: o, projection: s,...l } = t, u = {
			...i,
			parentEncoding: mergeEncoding({
				parentEncoding: n,
				encoding: o,
				layer: !0
			}),
			parentProjection: mergeProjection({
				parentProjection: r,
				projection: s
			})
		};
		return super.mapLayer({
			...l,
			...t.name ? { name: [u.repeaterPrefix, t.name].filter((t) => t).join("_") } : {}
		}, u);
	}
};
function mergeEncoding({ parentEncoding: t, encoding: n = {}, layer: r }) {
	let i = {};
	if (t) {
		let o = new Set([...keys(t), ...keys(n)]);
		for (let s of o) {
			let o = n[s], l = t[s];
			isFieldOrDatumDef(o) ? i[s] = {
				...l,
				...o
			} : hasConditionalFieldOrDatumDef(o) ? i[s] = {
				...o,
				condition: {
					...l,
					...o.condition
				}
			} : o || o === null ? i[s] = o : (r || isValueDef(l) || isSignalRef(l) || isFieldOrDatumDef(l) || isArray(l)) && (i[s] = l);
		}
	} else i = n;
	return !i || isEmpty(i) ? void 0 : i;
}
function mergeProjection(t) {
	let { parentProjection: n, projection: r } = t;
	return n && r && warn(projectionOverridden({
		parentProjection: n,
		projection: r
	})), r ?? n;
}
function isFilter(t) {
	return hasProperty(t, "filter");
}
function isImputeSequence(t) {
	return hasProperty(t, "stop");
}
function isLookup(t) {
	return hasProperty(t, "lookup");
}
function isLookupData(t) {
	return hasProperty(t, "data");
}
function isLookupSelection(t) {
	return hasProperty(t, "param");
}
function isPivot(t) {
	return hasProperty(t, "pivot");
}
function isDensity(t) {
	return hasProperty(t, "density");
}
function isQuantile(t) {
	return hasProperty(t, "quantile");
}
function isRegression(t) {
	return hasProperty(t, "regression");
}
function isLoess(t) {
	return hasProperty(t, "loess");
}
function isSample(t) {
	return hasProperty(t, "sample");
}
function isWindow(t) {
	return hasProperty(t, "window");
}
function isJoinAggregate(t) {
	return hasProperty(t, "joinaggregate");
}
function isFlatten(t) {
	return hasProperty(t, "flatten");
}
function isCalculate(t) {
	return hasProperty(t, "calculate");
}
function isBin(t) {
	return hasProperty(t, "bin");
}
function isImpute(t) {
	return hasProperty(t, "impute");
}
function isTimeUnit(t) {
	return hasProperty(t, "timeUnit");
}
function isAggregate(t) {
	return hasProperty(t, "aggregate");
}
function isStack(t) {
	return hasProperty(t, "stack");
}
function isFold(t) {
	return hasProperty(t, "fold");
}
function isExtent(t) {
	return hasProperty(t, "extent") && !hasProperty(t, "density") && !hasProperty(t, "regression");
}
function normalizeTransform(t) {
	return t.map((t) => isFilter(t) ? { filter: normalizeLogicalComposition(t.filter, normalizePredicate$1) } : t);
}
var SelectionCompatibilityNormalizer = class extends SpecMapper {
	map(t, n) {
		return n.emptySelections ??= {}, n.selectionPredicates ??= {}, t = normalizeTransforms(t, n), super.map(t, n);
	}
	mapLayerOrUnit(t, n) {
		if (t = normalizeTransforms(t, n), t.encoding) {
			let r = {};
			for (let [i, o] of entries$1(t.encoding)) r[i] = normalizeChannelDef(o, n);
			t = {
				...t,
				encoding: r
			};
		}
		return super.mapLayerOrUnit(t, n);
	}
	mapUnit(t, n) {
		let { selection: r,...i } = t;
		return r ? {
			...i,
			params: entries$1(r).map(([t, r]) => {
				let { init: i, bind: o, empty: s,...l } = r;
				l.type === "single" ? (l.type = "point", l.toggle = !1) : l.type === "multi" && (l.type = "point"), n.emptySelections[t] = s !== "none";
				for (let r of vals(n.selectionPredicates[t] ?? {})) r.empty = s !== "none";
				return {
					name: t,
					value: i,
					select: l,
					bind: o
				};
			})
		} : t;
	}
};
function normalizeTransforms(t, n) {
	let { transform: r,...i } = t;
	if (r) {
		let t = r.map((t) => {
			if (isFilter(t)) return { filter: normalizePredicate(t, n) };
			if (isBin(t) && isBinParams(t.bin)) return {
				...t,
				bin: normalizeBinExtent(t.bin)
			};
			if (isLookup(t)) {
				let { selection: n,...r } = t.from;
				return n ? {
					...t,
					from: {
						param: n,
						...r
					}
				} : t;
			}
			return t;
		});
		return {
			...i,
			transform: t
		};
	}
	return t;
}
function normalizeChannelDef(t, n) {
	let r = duplicate(t);
	if (isFieldDef(r) && isBinParams(r.bin) && (r.bin = normalizeBinExtent(r.bin)), isScaleFieldDef(r) && r.scale?.domain?.selection) {
		let { selection: t,...n } = r.scale.domain;
		r.scale.domain = {
			...n,
			...t ? { param: t } : {}
		};
	}
	if (isConditionalDef(r)) if (isArray(r.condition)) r.condition = r.condition.map((t) => {
		let { selection: r, param: i, test: o,...s } = t;
		return i ? t : {
			...s,
			test: normalizePredicate(t, n)
		};
	});
	else {
		let { selection: t, param: i, test: o,...s } = normalizeChannelDef(r.condition, n);
		r.condition = i ? r.condition : {
			...s,
			test: normalizePredicate(r.condition, n)
		};
	}
	return r;
}
function normalizeBinExtent(t) {
	let n = t.extent;
	if (n?.selection) {
		let { selection: r,...i } = n;
		return {
			...t,
			extent: {
				...i,
				param: r
			}
		};
	}
	return t;
}
function normalizePredicate(t, n) {
	let r = (t) => normalizeLogicalComposition(t, (t) => {
		let r = {
			param: t,
			empty: n.emptySelections[t] ?? !0
		};
		return n.selectionPredicates[t] ??= [], n.selectionPredicates[t].push(r), r;
	});
	return t.selection ? r(t.selection) : normalizeLogicalComposition(t.test || t.filter, (t) => t.selection ? r(t.selection) : t);
}
var TopLevelSelectionsNormalizer = class extends SpecMapper {
	map(t, n) {
		let r = n.selections ?? [];
		if (t.params && !isUnitSpec(t)) {
			let n = [];
			for (let i of t.params) isSelectionParameter(i) ? r.push(i) : n.push(i);
			t.params = n;
		}
		return n.selections = r, super.map(t, n);
	}
	mapUnit(t, n) {
		let r = n.selections;
		if (!r || !r.length) return t;
		let i = (n.path ?? []).concat(t.name), o = [];
		for (let n of r) if (!n.views || !n.views.length) o.push(n);
		else for (let r of n.views) (isString(r) && (r === t.name || i.includes(r)) || isArray(r) && r.map((t) => i.indexOf(t)).every((t, n, r) => t !== -1 && (n === 0 || t > r[n - 1]))) && o.push(n);
		return o.length && (t.params = o), t;
	}
};
for (let t of [
	"mapFacet",
	"mapRepeat",
	"mapHConcat",
	"mapVConcat",
	"mapLayer"
]) {
	let n = TopLevelSelectionsNormalizer.prototype[t];
	TopLevelSelectionsNormalizer.prototype[t] = function(t, r) {
		return n.call(this, t, addSpecNameToParams(t, r));
	};
}
function addSpecNameToParams(t, n) {
	return t.name ? {
		...n,
		path: (n.path ?? []).concat(t.name)
	} : n;
}
function normalize(t, n) {
	n === void 0 && (n = initConfig(t.config));
	let r = normalizeGenericSpec(t, n), { width: i, height: o } = t, s = normalizeAutoSize(r, {
		width: i,
		height: o,
		autosize: t.autosize
	}, n);
	return {
		...r,
		...s ? { autosize: s } : {}
	};
}
var coreNormalizer = new CoreNormalizer(), selectionCompatNormalizer = new SelectionCompatibilityNormalizer(), topLevelSelectionNormalizer = new TopLevelSelectionsNormalizer();
function normalizeGenericSpec(t, n = {}) {
	let r = { config: n };
	return topLevelSelectionNormalizer.map(coreNormalizer.map(selectionCompatNormalizer.map(t, r), r), r);
}
function _normalizeAutoSize(t) {
	return isString(t) ? { type: t } : t ?? {};
}
function normalizeAutoSize(t, n, r) {
	let { width: i, height: o } = n, s = isUnitSpec(t) || isLayerSpec(t), l = {};
	s ? i == "container" && o == "container" ? (l.type = "fit", l.contains = "padding") : i == "container" ? (l.type = "fit-x", l.contains = "padding") : o == "container" && (l.type = "fit-y", l.contains = "padding") : (i == "container" && (warn(containerSizeNonSingle("width")), i = void 0), o == "container" && (warn(containerSizeNonSingle("height")), o = void 0));
	let u = {
		type: "pad",
		...l,
		...r ? _normalizeAutoSize(r.autosize) : {},
		..._normalizeAutoSize(t.autosize)
	};
	if (u.type === "fit" && !s && (warn(FIT_NON_SINGLE), u.type = "pad"), i == "container" && !(u.type == "fit" || u.type == "fit-x") && warn(containerSizeNotCompatibleWithAutosize("width")), o == "container" && !(u.type == "fit" || u.type == "fit-y") && warn(containerSizeNotCompatibleWithAutosize("height")), !deepEqual(u, { type: "pad" })) return u;
}
function isFitType(t) {
	return [
		"fit",
		"fit-x",
		"fit-y"
	].includes(t);
}
function getFitType(t) {
	return t ? `fit-${getPositionScaleChannel(t)}` : "fit";
}
var TOP_LEVEL_PROPERTIES = ["background", "padding"];
function extractTopLevelProperties(t, n) {
	let r = {};
	for (let n of TOP_LEVEL_PROPERTIES) t && t[n] !== void 0 && (r[n] = signalRefOrValue(t[n]));
	return n && (r.params = t.params), r;
}
var Split = class t {
	explicit;
	implicit;
	constructor(t = {}, n = {}) {
		this.explicit = t, this.implicit = n;
	}
	clone() {
		return new t(duplicate(this.explicit), duplicate(this.implicit));
	}
	combine() {
		return {
			...this.explicit,
			...this.implicit
		};
	}
	get(t) {
		return getFirstDefined(this.explicit[t], this.implicit[t]);
	}
	getWithExplicit(t) {
		return this.explicit[t] === void 0 ? this.implicit[t] === void 0 ? {
			explicit: !1,
			value: void 0
		} : {
			explicit: !1,
			value: this.implicit[t]
		} : {
			explicit: !0,
			value: this.explicit[t]
		};
	}
	setWithExplicit(t, { value: n, explicit: r }) {
		n !== void 0 && this.set(t, n, r);
	}
	set(t, n, r) {
		return delete this[r ? "implicit" : "explicit"][t], this[r ? "explicit" : "implicit"][t] = n, this;
	}
	copyKeyFromSplit(t, { explicit: n, implicit: r }) {
		n[t] === void 0 ? r[t] !== void 0 && this.set(t, r[t], !1) : this.set(t, n[t], !0);
	}
	copyKeyFromObject(t, n) {
		n[t] !== void 0 && this.set(t, n[t], !0);
	}
	copyAll(t) {
		for (let n of keys(t.combine())) {
			let r = t.getWithExplicit(n);
			this.setWithExplicit(n, r);
		}
	}
};
function makeExplicit(t) {
	return {
		explicit: !0,
		value: t
	};
}
function makeImplicit(t) {
	return {
		explicit: !1,
		value: t
	};
}
function tieBreakByComparing(t) {
	return (n, r, i, o) => {
		let s = t(n.value, r.value);
		return s > 0 ? n : s < 0 ? r : defaultTieBreaker(n, r, i, o);
	};
}
function defaultTieBreaker(t, n, r, i) {
	return t.explicit && n.explicit && warn(mergeConflictingProperty(r, i, t.value, n.value)), t;
}
function mergeValuesWithExplicit(t, n, r, i, o = defaultTieBreaker) {
	return t === void 0 || t.value === void 0 ? n : t.explicit && !n.explicit ? t : n.explicit && !t.explicit ? n : deepEqual(t.value, n.value) ? t : o(t, n, r, i);
}
var AncestorParse = class extends Split {
	explicit;
	implicit;
	parseNothing;
	constructor(t = {}, n = {}, r = !1) {
		super(t, n), this.explicit = t, this.implicit = n, this.parseNothing = r;
	}
	clone() {
		let t = super.clone();
		return t.parseNothing = this.parseNothing, t;
	}
};
function isUrlData(t) {
	return hasProperty(t, "url");
}
function isInlineData(t) {
	return hasProperty(t, "values");
}
function isNamedData(t) {
	return hasProperty(t, "name") && !isUrlData(t) && !isInlineData(t) && !isGenerator(t);
}
function isGenerator(t) {
	return t && (isSequenceGenerator(t) || isSphereGenerator(t) || isGraticuleGenerator(t));
}
function isSequenceGenerator(t) {
	return hasProperty(t, "sequence");
}
function isSphereGenerator(t) {
	return hasProperty(t, "sphere");
}
function isGraticuleGenerator(t) {
	return hasProperty(t, "graticule");
}
var DataSourceType;
(function(t) {
	t[t.Raw = 0] = "Raw", t[t.Main = 1] = "Main", t[t.Row = 2] = "Row", t[t.Column = 3] = "Column", t[t.Lookup = 4] = "Lookup", t[t.PreFilterInvalid = 5] = "PreFilterInvalid", t[t.PostFilterInvalid = 6] = "PostFilterInvalid";
})(DataSourceType ||= {});
function getDataSourcesForHandlingInvalidValues({ invalid: t, isPath: n }) {
	switch (normalizeInvalidDataMode(t, { isPath: n })) {
		case "filter": return {
			marks: "exclude-invalid-values",
			scales: "exclude-invalid-values"
		};
		case "break-paths-show-domains": return {
			marks: n ? "include-invalid-values" : "exclude-invalid-values",
			scales: "include-invalid-values"
		};
		case "break-paths-filter-domains": return {
			marks: n ? "include-invalid-values" : "exclude-invalid-values",
			scales: "exclude-invalid-values"
		};
		case "show": return {
			marks: "include-invalid-values",
			scales: "include-invalid-values"
		};
	}
}
function getScaleDataSourceForHandlingInvalidValues(t) {
	let { marks: n, scales: r } = getDataSourcesForHandlingInvalidValues(t);
	return n === r ? DataSourceType.Main : r === "include-invalid-values" ? DataSourceType.PreFilterInvalid : DataSourceType.PostFilterInvalid;
}
var DataFlowNode = class {
	debugName;
	_children = [];
	_parent = null;
	_hash;
	constructor(t, n) {
		this.debugName = n, t && (this.parent = t);
	}
	clone() {
		throw Error("Cannot clone node");
	}
	get parent() {
		return this._parent;
	}
	set parent(t) {
		this._parent = t, t && t.addChild(this);
	}
	get children() {
		return this._children;
	}
	numChildren() {
		return this._children.length;
	}
	addChild(t, n) {
		if (this._children.includes(t)) {
			warn(ADD_SAME_CHILD_TWICE);
			return;
		}
		n === void 0 ? this._children.push(t) : this._children.splice(n, 0, t);
	}
	removeChild(t) {
		let n = this._children.indexOf(t);
		return this._children.splice(n, 1), n;
	}
	remove() {
		let t = this._parent.removeChild(this);
		for (let n of this._children) n._parent = this._parent, this._parent.addChild(n, t++);
	}
	insertAsParentOf(t) {
		let n = t.parent;
		n.removeChild(this), this.parent = n, t.parent = this;
	}
	swapWithParent() {
		let t = this._parent, n = t.parent;
		for (let n of this._children) n.parent = t;
		this._children = [], t.removeChild(this);
		let r = t.parent.removeChild(t);
		this._parent = n, n.addChild(this, r), t.parent = this;
	}
}, OutputNode = class extends DataFlowNode {
	type;
	refCounts;
	_source;
	_name;
	clone() {
		let t = new this.constructor();
		return t.debugName = `clone_${this.debugName}`, t._source = this._source, t._name = `clone_${this._name}`, t.type = this.type, t.refCounts = this.refCounts, t.refCounts[t._name] = 0, t;
	}
	constructor(t, n, r, i) {
		super(t, n), this.type = r, this.refCounts = i, this._source = this._name = n, this.refCounts && !(this._name in this.refCounts) && (this.refCounts[this._name] = 0);
	}
	dependentFields() {
		return /* @__PURE__ */ new Set();
	}
	producedFields() {
		return /* @__PURE__ */ new Set();
	}
	hash() {
		return this._hash === void 0 && (this._hash = `Output ${uniqueId()}`), this._hash;
	}
	getSource() {
		return this.refCounts[this._name]++, this._source;
	}
	isRequired() {
		return !!this.refCounts[this._name];
	}
	setSource(t) {
		this._source = t;
	}
};
function isTimeUnitTransformComponent(t) {
	return t.as !== void 0;
}
function offsetAs(t) {
	return `${t}_end`;
}
var TimeUnitNode = class t extends DataFlowNode {
	timeUnits;
	clone() {
		return new t(null, duplicate(this.timeUnits));
	}
	constructor(t, n) {
		super(t), this.timeUnits = n;
	}
	static makeFromEncoding(n, r) {
		let i = r.reduceFieldDef((t, n, i) => {
			let { field: o, timeUnit: s } = n;
			if (s) {
				let l;
				if (isBinnedTimeUnit(s)) {
					if (isUnitModel(r)) {
						let { mark: t, markDef: i, config: u } = r, d = getBandPosition({
							fieldDef: n,
							markDef: i,
							config: u
						});
						(isRectBasedMark(t) || d) && (l = {
							timeUnit: normalizeTimeUnit(s),
							field: o
						});
					}
				} else l = {
					as: vgField(n, { forAs: !0 }),
					field: o,
					timeUnit: s
				};
				if (isUnitModel(r)) {
					let { mark: t, markDef: o, config: s } = r, u = getBandPosition({
						fieldDef: n,
						markDef: o,
						config: s
					});
					isRectBasedMark(t) && isXorY(i) && u !== .5 && (l.rectBandPosition = u);
				}
				l && (t[hash(l)] = l);
			}
			return t;
		}, {});
		return isEmpty(i) ? null : new t(n, i);
	}
	static makeFromTransform(n, r) {
		let { timeUnit: i,...o } = { ...r }, s = normalizeTimeUnit(i), l = {
			...o,
			timeUnit: s
		};
		return new t(n, { [hash(l)]: l });
	}
	merge(t) {
		for (let n in this.timeUnits = { ...this.timeUnits }, t.timeUnits) this.timeUnits[n] || (this.timeUnits[n] = t.timeUnits[n]);
		for (let n of t.children) t.removeChild(n), n.parent = this;
		t.remove();
	}
	removeFormulas(t) {
		let n = {};
		for (let [r, i] of entries$1(this.timeUnits)) {
			let o = isTimeUnitTransformComponent(i) ? i.as : `${i.field}_end`;
			t.has(o) || (n[r] = i);
		}
		this.timeUnits = n;
	}
	producedFields() {
		return new Set(vals(this.timeUnits).map((t) => isTimeUnitTransformComponent(t) ? t.as : offsetAs(t.field)));
	}
	dependentFields() {
		return new Set(vals(this.timeUnits).map((t) => t.field));
	}
	hash() {
		return `TimeUnit ${hash(this.timeUnits)}`;
	}
	assemble() {
		let t = [];
		for (let n of vals(this.timeUnits)) {
			let { rectBandPosition: r } = n, i = normalizeTimeUnit(n.timeUnit);
			if (isTimeUnitTransformComponent(n)) {
				let { field: o, as: s } = n, { unit: l, utc: u,...d } = i, f = [s, `${s}_end`];
				t.push({
					field: replacePathInField(o),
					type: "timeunit",
					...l ? { units: getTimeUnitParts(l) } : {},
					...u ? { timezone: "utc" } : {},
					...d,
					as: f
				}), t.push(...offsetedRectFormulas(f, r, i));
			} else if (n) {
				let { field: o } = n, s = unescapeSingleQuoteAndPathDot(o), l = offsetExpr({
					timeUnit: i,
					field: s
				}), u = offsetAs(s);
				t.push({
					type: "formula",
					expr: l,
					as: u
				}), t.push(...offsetedRectFormulas([s, u], r, i));
			}
		}
		return t;
	}
}, OFFSETTED_RECT_START_SUFFIX = "offsetted_rect_start", OFFSETTED_RECT_END_SUFFIX = "offsetted_rect_end";
function offsetExpr({ timeUnit: t, field: n, reverse: r }) {
	let { unit: i, utc: o } = t, { part: s, step: l } = getDateTimePartAndStep(getSmallestTimeUnitPart(i), t.step);
	return `${o ? "utcOffset" : "timeOffset"}('${s}', ${accessWithDatumToUnescapedPath(n)}, ${r ? -l : l})`;
}
function offsetedRectFormulas([t, n], r, i) {
	if (r !== void 0 && r !== .5) {
		let o = accessWithDatumToUnescapedPath(t), s = accessWithDatumToUnescapedPath(n);
		return [{
			type: "formula",
			expr: interpolateExpr([offsetExpr({
				timeUnit: i,
				field: t,
				reverse: !0
			}), o], r + .5),
			as: `${t}_${OFFSETTED_RECT_START_SUFFIX}`
		}, {
			type: "formula",
			expr: interpolateExpr([o, s], r + .5),
			as: `${t}_${OFFSETTED_RECT_END_SUFFIX}`
		}];
	}
	return [];
}
function interpolateExpr([t, n], r) {
	return `${1 - r} * ${t} + ${r} * ${n}`;
}
var TUPLE_FIELDS = "_tuple_fields", SelectionProjectionComponent = class {
	hasChannel;
	hasField;
	hasSelectionId;
	timeUnit;
	items;
	constructor(...t) {
		this.items = t, this.hasChannel = {}, this.hasField = {}, this.hasSelectionId = !1;
	}
}, project = {
	defined: () => !0,
	parse: (t, n, r) => {
		let i = n.name, o = n.project ??= new SelectionProjectionComponent(), s = {}, l = {}, u = /* @__PURE__ */ new Set(), d = (t, n) => {
			let r = n === "visual" ? t.channel : t.field, o = varName(`${i}_${r}`);
			for (let t = 1; u.has(o); t++) o = varName(`${i}_${r}_${t}`);
			return u.add(o), { [n]: o };
		}, f = n.type, p = t.config.selection[f], g = r.value === void 0 ? null : array(r.value), { fields: _, encodings: v } = isObject(r.select) ? r.select : {};
		if (!_ && !v && g) {
			for (let t of g) if (isObject(t)) for (let n of keys(t)) isSingleDefUnitChannel(n) ? (v ||= []).push(n) : f === "interval" ? (warn(INTERVAL_INITIALIZED_WITH_POS), v = p.encodings) : (_ ??= []).push(n);
		}
		!_ && !v && (v = p.encodings, "fields" in p && (_ = p.fields));
		for (let n of v ?? []) {
			let r = t.fieldDef(n);
			if (r) {
				let i = r.field;
				if (r.aggregate) {
					warn(cannotProjectAggregate(n, r.aggregate));
					continue;
				} else if (!i) {
					warn(cannotProjectOnChannelWithoutField(n));
					continue;
				}
				if (r.timeUnit && !isBinnedTimeUnit(r.timeUnit)) {
					i = t.vgField(n);
					let o = {
						timeUnit: r.timeUnit,
						as: i,
						field: r.field
					};
					l[hash(o)] = o;
				}
				if (!s[i]) {
					let l = f === "interval" && isScaleChannel(n) && hasContinuousDomain(t.getScaleComponent(n).get("type")) ? "R" : r.bin ? "R-RE" : "E", u = {
						field: i,
						channel: n,
						type: l,
						index: o.items.length
					};
					u.signals = {
						...d(u, "data"),
						...d(u, "visual")
					}, o.items.push(s[i] = u), o.hasField[i] = s[i], o.hasSelectionId = o.hasSelectionId || i === SELECTION_ID, isGeoPositionChannel(n) ? (u.geoChannel = n, u.channel = getPositionChannelFromLatLong(n), o.hasChannel[u.channel] = s[i]) : o.hasChannel[n] = s[i];
				}
			} else warn(cannotProjectOnChannelWithoutField(n));
		}
		for (let t of _ ?? []) {
			if (o.hasField[t]) continue;
			let n = {
				type: "E",
				field: t,
				index: o.items.length
			};
			n.signals = { ...d(n, "data") }, o.items.push(n), o.hasField[t] = n, o.hasSelectionId = o.hasSelectionId || t === SELECTION_ID;
		}
		g && (n.init = g.map((t) => o.items.map((n) => isObject(t) ? t[n.geoChannel || n.channel] === void 0 ? t[n.field] : t[n.geoChannel || n.channel] : t))), isEmpty(l) || (o.timeUnit = new TimeUnitNode(null, l));
	},
	signals: (t, n, r) => {
		let i = n.name + TUPLE_FIELDS;
		return r.filter((t) => t.name === i).length > 0 || n.project.hasSelectionId ? r : r.concat({
			name: i,
			value: n.project.items.map(assembleProjection)
		});
	}
}, CURR = "_curr", ANIM_VALUE = "anim_value", ANIM_CLOCK = "anim_clock", EASED_ANIM_CLOCK = "eased_anim_clock", MIN_EXTENT = "min_extent", MAX_RANGE_EXTENT = "max_range_extent", LAST_TICK = "last_tick_at", IS_PLAYING = "is_playing", THROTTLE = 1 / 60 * 1e3, animationSignals = (t, n) => [
	{
		name: EASED_ANIM_CLOCK,
		update: ANIM_CLOCK
	},
	{
		name: `${t}_domain`,
		init: `domain('${n}')`
	},
	{
		name: MIN_EXTENT,
		init: `extent(${t}_domain)[0]`
	},
	{
		name: MAX_RANGE_EXTENT,
		init: `extent(range('${n}'))[1]`
	},
	{
		name: ANIM_VALUE,
		update: `invert('${n}', ${EASED_ANIM_CLOCK})`
	}
], point$1 = {
	defined: (t) => t.type === "point",
	topLevelSignals: (t, n, r) => (isTimerSelection(n) && (r = r.concat([
		{
			name: ANIM_CLOCK,
			init: "0",
			on: [{
				events: {
					type: "timer",
					throttle: THROTTLE
				},
				update: `${IS_PLAYING} ? (${ANIM_CLOCK} + (now() - ${LAST_TICK}) > ${MAX_RANGE_EXTENT} ? 0 : ${ANIM_CLOCK} + (now() - ${LAST_TICK})) : ${ANIM_CLOCK}`
			}]
		},
		{
			name: LAST_TICK,
			init: "now()",
			on: [{
				events: [{ signal: ANIM_CLOCK }, { signal: IS_PLAYING }],
				update: "now()"
			}]
		},
		{
			name: IS_PLAYING,
			init: "true"
		}
	])), r),
	signals: (t, n, r) => {
		let i = n.name, o = i + TUPLE_FIELDS, s = n.project, l = "(item().isVoronoi ? datum.datum : datum)", u = vals(t.component.selection ?? {}).reduce((t, n) => n.type === "interval" ? t.concat(n.name + BRUSH) : t, []).map((t) => `indexof(item().mark.name, '${t}') < 0`).join(" && "), d = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${u ? ` && ${u}` : ""}`, f = `unit: ${unitName(t)}, `;
		if (n.project.hasSelectionId) f += `${SELECTION_ID}: ${l}[${$(SELECTION_ID)}]`;
		else if (isTimerSelection(n)) f += `fields: ${o}, values: [${ANIM_VALUE} ? ${ANIM_VALUE} : ${MIN_EXTENT}]`;
		else {
			let n = s.items.map((n) => t.fieldDef(n.channel)?.bin ? `[${l}[${$(t.vgField(n.channel, {}))}], ${l}[${$(t.vgField(n.channel, { binSuffix: "end" }))}]]` : `${l}[${$(n.field)}]`).join(", ");
			f += `fields: ${o}, values: [${n}]`;
		}
		if (isTimerSelection(n)) return r.concat(animationSignals(n.name, t.scaleName(TIME)), [{
			name: i + TUPLE,
			on: [{
				events: [{ signal: EASED_ANIM_CLOCK }, { signal: ANIM_VALUE }],
				update: `{${f}}`,
				force: !0
			}]
		}]);
		{
			let t = n.events;
			return r.concat([{
				name: i + TUPLE,
				on: t ? [{
					events: t,
					update: `${d} ? {${f}} : null`,
					force: !0
				}] : []
			}]);
		}
	}
};
function assembleProjection(t) {
	let { signals: n, hasLegend: r, index: i,...o } = t;
	return o.field = replacePathInField(o.field), o;
}
function assembleInit(t, n = !0, r = identity) {
	if (isArray(t)) {
		let i = t.map((t) => assembleInit(t, n, r));
		return n ? `[${i.join(", ")}]` : i;
	} else if (isDateTime(t)) return r(n ? dateTimeToExpr(t) : dateTimeToTimestamp(t));
	return n ? r(stringify$2(t)) : t;
}
function assembleUnitSelectionSignals(t, n) {
	for (let r of vals(t.component.selection ?? {})) {
		let i = r.name, o = `${i}${TUPLE}, ${r.resolve === "global" ? "true" : `{unit: ${unitName(t)}}`}`;
		for (let i of selectionCompilers) i.defined(r) && (i.signals && (n = i.signals(t, r, n)), i.modifyExpr && (o = i.modifyExpr(t, r, o)));
		n.push({
			name: i + MODIFY,
			on: [{
				events: { signal: r.name + TUPLE },
				update: `modify(${$(r.name + STORE)}, ${o})`
			}]
		});
	}
	return cleanupEmptyOnArray(n);
}
function assembleFacetSignals(t, n) {
	if (t.component.selection && keys(t.component.selection).length) {
		let r = $(t.getName("cell"));
		n.unshift({
			name: "facet",
			value: {},
			on: [{
				events: eventSelector("pointermove", "scope"),
				update: `isTuple(facet) ? facet : group(${r}).datum`
			}]
		});
	}
	return cleanupEmptyOnArray(n);
}
function assembleTopLevelSignals(t, n) {
	let r = !1;
	for (let i of vals(t.component.selection ?? {})) {
		let o = i.name, s = $(o + STORE);
		if (n.filter((t) => t.name === o).length === 0) {
			let t = i.resolve === "global" ? "union" : i.resolve, r = i.type === "point" ? ", true, true)" : ")";
			n.push({
				name: i.name,
				update: `${VL_SELECTION_RESOLVE}(${s}, ${$(t)}${r}`
			});
		}
		r = !0;
		for (let r of selectionCompilers) r.defined(i) && r.topLevelSignals && (n = r.topLevelSignals(t, i, n));
	}
	return r && n.filter((t) => t.name === "unit").length === 0 && n.unshift({
		name: "unit",
		value: {},
		on: [{
			events: "pointermove",
			update: "isTuple(group()) ? group() : unit"
		}]
	}), cleanupEmptyOnArray(n);
}
function assembleUnitSelectionData(t, n) {
	let r = [], i = [], o = unitName(t, { escape: !1 });
	for (let s of vals(t.component.selection ?? {})) {
		let l = { name: s.name + STORE };
		if (s.project.hasSelectionId && (l.transform = [{
			type: "collect",
			sort: { field: SELECTION_ID }
		}]), s.init) {
			let t = s.project.items.map(assembleProjection);
			l.values = s.project.hasSelectionId ? s.init.map((t) => ({
				unit: o,
				[SELECTION_ID]: assembleInit(t, !1)[0]
			})) : s.init.map((n) => ({
				unit: o,
				fields: t,
				values: assembleInit(n, !1)
			}));
		}
		if ([...r, ...n].filter((t) => t.name === s.name + STORE).length || r.push(l), isTimerSelection(s) && n.length) {
			let r = t.lookupDataSource(t.getDataName(DataSourceType.Main)), o = n.find((t) => t.name === r), s = o.transform.find((t) => t.type === "filter" && t.expr.includes("vlSelectionTest"));
			if (s) {
				o.transform = o.transform.filter((t) => t !== s);
				let t = {
					name: o.name + CURR,
					source: o.name,
					transform: [s]
				};
				i.push(t);
			}
		}
	}
	return r.concat(n, i);
}
function assembleUnitSelectionMarks(t, n) {
	for (let r of vals(t.component.selection ?? {})) for (let i of selectionCompilers) i.defined(r) && i.marks && (n = i.marks(t, r, n));
	return n;
}
function assembleLayerSelectionMarks(t, n) {
	for (let r of t.children) isUnitModel(r) && (n = assembleUnitSelectionMarks(r, n));
	return n;
}
function assembleSelectionScaleDomain(t, n, r, i) {
	let o = parseSelectionExtent(t, n.param, n);
	return { signal: hasContinuousDomain(r.get("type")) && isArray(i) && i[0] > i[1] ? `isValid(${o}) && reverse(${o})` : o };
}
function cleanupEmptyOnArray(t) {
	return t.map((t) => (t.on && !t.on.length && delete t.on, t));
}
var scaleBindings = {
	defined: (t) => t.type === "interval" && t.resolve === "global" && t.bind && t.bind === "scales",
	parse: (t, n) => {
		let r = n.scales = [];
		for (let i of n.project.items) {
			let o = i.channel;
			if (!isScaleChannel(o)) continue;
			let s = t.getScaleComponent(o), l = s ? s.get("type") : void 0;
			if (l == "sequential" && warn(SEQUENTIAL_SCALE_DEPRECATED), !s || !hasContinuousDomain(l)) {
				warn(SCALE_BINDINGS_CONTINUOUS);
				continue;
			}
			s.set("selectionExtent", {
				param: n.name,
				field: i.field
			}, !0), r.push(i);
		}
	},
	topLevelSignals: (t, n, r) => {
		let i = n.scales.filter((t) => r.filter((n) => n.name === t.signals.data).length === 0);
		if (!t.parent || isTopLevelLayer(t) || i.length === 0) return r;
		let o = r.find((t) => t.name === n.name), s = o.update;
		if (s.includes(VL_SELECTION_RESOLVE)) o.update = `{${i.map((t) => `${$(replacePathInField(t.field))}: ${t.signals.data}`).join(", ")}}`;
		else {
			for (let t of i) {
				let n = `${$(replacePathInField(t.field))}: ${t.signals.data}`;
				s.includes(n) || (s = `${s.substring(0, s.length - 1)}, ${n}}`);
			}
			o.update = s;
		}
		return r.concat(i.map((t) => ({ name: t.signals.data })));
	},
	signals: (t, n, r) => {
		if (t.parent && !isTopLevelLayer(t)) for (let t of n.scales) {
			let n = r.find((n) => n.name === t.signals.data);
			n.push = "outer", delete n.value, delete n.update;
		}
		return r;
	}
};
function domain(t, n) {
	return `domain(${$(t.scaleName(n))})`;
}
function isTopLevelLayer(t) {
	return t.parent && isLayerModel(t.parent) && (!t.parent.parent || isTopLevelLayer(t.parent.parent));
}
var BRUSH = "_brush", SCALE_TRIGGER = "_scale_trigger", GEO_INIT_TICK = "geo_interval_init_tick", INIT = "_init", CENTER = "_center", interval = {
	defined: (t) => t.type === "interval",
	parse: (t, n, r) => {
		if (t.hasProjection) {
			let t = { ...isObject(r.select) ? r.select : {} };
			t.fields = [SELECTION_ID], t.encodings ||= r.value ? keys(r.value) : [LONGITUDE, LATITUDE], r.select = {
				type: "interval",
				...t
			};
		}
		if (n.translate && !scaleBindings.defined(n)) {
			let t = `!event.item || event.item.mark.name !== ${$(n.name + BRUSH)}`;
			for (let r of n.events) {
				if (!r.between) {
					warn(`${r} is not an ordered event stream for interval selections.`);
					continue;
				}
				let n = array(r.between[0].filter ??= []);
				n.includes(t) || n.push(t);
			}
		}
	},
	signals: (t, n, r) => {
		let i = n.name, o = i + TUPLE, s = vals(n.project.hasChannel).filter((t) => t.channel === X || t.channel === Y), l = n.init ? n.init[0] : null;
		if (r.push(...s.reduce((r, i) => r.concat(channelSignals(t, n, i, l?.[i.index])), [])), t.hasProjection) {
			let u = $(t.projectionName()), d = t.projectionName() + CENTER, { x: f, y: p } = n.project.hasChannel, g = f?.signals.visual, _ = p?.signals.visual, v = f ? l?.[f.index] : `${d}[0]`, S = p ? l?.[p.index] : `${d}[1]`, T = (n) => t.getSizeSignalRef(n).signal, E = `[[${g ? `${g}[0]` : "0"}, ${_ ? `${_}[0]` : "0"}],[${g ? `${g}[1]` : T("width")}, ${_ ? `${_}[1]` : T("height")}]]`;
			l && (r.unshift({
				name: i + INIT,
				init: `[scale(${u}, [${f ? v[0] : v}, ${p ? S[0] : S}]), scale(${u}, [${f ? v[1] : v}, ${p ? S[1] : S}])]`
			}), (!f || !p) && (r.find((t) => t.name === d) || r.unshift({
				name: d,
				update: `invert(${u}, [${T("width")}/2, ${T("height")}/2])`
			})));
			let O = `vlSelectionTuples(${`intersect(${E}, {markname: ${$(t.getName("marks"))}}, unit.mark)`}, ${`{unit: ${unitName(t)}}`})`, k = s.map((t) => t.signals.visual);
			return r.concat({
				name: o,
				on: [{
					events: [...k.length ? [{ signal: k.join(" || ") }] : [], ...l ? [{ signal: GEO_INIT_TICK }] : []],
					update: O
				}]
			});
		} else {
			if (!scaleBindings.defined(n)) {
				let n = i + SCALE_TRIGGER, o = s.map((n) => {
					let r = n.channel, { data: i, visual: o } = n.signals, s = $(t.scaleName(r)), l = hasContinuousDomain(t.getScaleComponent(r).get("type")) ? "+" : "";
					return `(!isArray(${i}) || (${l}invert(${s}, ${o})[0] === ${l}${i}[0] && ${l}invert(${s}, ${o})[1] === ${l}${i}[1]))`;
				});
				o.length && r.push({
					name: n,
					value: {},
					on: [{
						events: s.map((n) => ({ scale: t.scaleName(n.channel) })),
						update: `${o.join(" && ")} ? ${n} : {}`
					}]
				});
			}
			let u = s.map((t) => t.signals.data), d = `unit: ${unitName(t)}, fields: ${i + TUPLE_FIELDS}, values`;
			return r.concat({
				name: o,
				...l ? { init: `{${d}: ${assembleInit(l)}}` } : {},
				...u.length ? { on: [{
					events: [{ signal: u.join(" || ") }],
					update: `${u.join(" && ")} ? {${d}: [${u}]} : null`
				}] } : {}
			});
		}
	},
	topLevelSignals: (t, n, r) => (isUnitModel(t) && t.hasProjection && n.init && (r.filter((t) => t.name === GEO_INIT_TICK).length || r.unshift({
		name: GEO_INIT_TICK,
		value: null,
		on: [{
			events: "timer{1}",
			update: `${GEO_INIT_TICK} === null ? {} : ${GEO_INIT_TICK}`
		}]
	})), r),
	marks: (t, n, r) => {
		let i = n.name, { x: o, y: s } = n.project.hasChannel, l = o?.signals.visual, u = s?.signals.visual, d = `data(${$(n.name + STORE)})`;
		if (scaleBindings.defined(n) || !o && !s) return r;
		let f = {
			x: o === void 0 ? { value: 0 } : { signal: `${l}[0]` },
			y: s === void 0 ? { value: 0 } : { signal: `${u}[0]` },
			x2: o === void 0 ? { field: { group: "width" } } : { signal: `${l}[1]` },
			y2: s === void 0 ? { field: { group: "height" } } : { signal: `${u}[1]` }
		};
		if (n.resolve === "global") for (let n of keys(f)) f[n] = [{
			test: `${d}.length && ${d}[0].unit === ${unitName(t)}`,
			...f[n]
		}, { value: 0 }];
		let { fill: p, fillOpacity: g, cursor: _,...v } = n.mark, S = keys(v).reduce((t, n) => (t[n] = [{
			test: [o !== void 0 && `${l}[0] !== ${l}[1]`, s !== void 0 && `${u}[0] !== ${u}[1]`].filter((t) => t).join(" && "),
			value: v[n]
		}, { value: null }], t), {}), T = _ ?? (n.translate ? "move" : null);
		return [
			{
				name: `${i + BRUSH}_bg`,
				type: "rect",
				clip: !0,
				encode: {
					enter: {
						fill: { value: p },
						fillOpacity: { value: g }
					},
					update: f
				}
			},
			...r,
			{
				name: i + BRUSH,
				type: "rect",
				clip: !0,
				encode: {
					enter: {
						...T ? { cursor: { value: T } } : {},
						fill: { value: "transparent" }
					},
					update: {
						...f,
						...S
					}
				}
			}
		];
	}
};
function channelSignals(t, n, r, i) {
	let o = !t.hasProjection, s = r.channel, l = r.signals.visual, u = $(o ? t.scaleName(s) : t.projectionName()), d = (t) => `scale(${u}, ${t})`, f = t.getSizeSignalRef(s === X ? "width" : "height").signal, p = `${s}(unit)`, g = n.events.reduce((t, n) => [
		...t,
		{
			events: n.between[0],
			update: `[${p}, ${p}]`
		},
		{
			events: n,
			update: `[${l}[0], clamp(${p}, 0, ${f})]`
		}
	], []);
	if (o) {
		let o = r.signals.data, f = scaleBindings.defined(n), p = t.getScaleComponent(s), _ = p ? p.get("type") : void 0, v = i ? { init: assembleInit(i, !0, d) } : { value: [] };
		return g.push({
			events: { signal: n.name + SCALE_TRIGGER },
			update: hasContinuousDomain(_) ? `[${d(`${o}[0]`)}, ${d(`${o}[1]`)}]` : "[0, 0]"
		}), f ? [{
			name: o,
			on: []
		}] : [{
			name: l,
			...v,
			on: g
		}, {
			name: o,
			...i ? { init: assembleInit(i) } : {},
			on: [{
				events: { signal: l },
				update: `${l}[0] === ${l}[1] ? null : invert(${u}, ${l})`
			}]
		}];
	} else {
		let t = s === X ? 0 : 1, r = n.name + INIT;
		return [{
			name: l,
			...i ? { init: `[${r}[0][${t}], ${r}[1][${t}]]` } : { value: [] },
			on: g
		}];
	}
}
function wrapCondition({ model: t, channelDef: n, vgChannel: r, invalidValueRef: i, mainRefFn: o }) {
	let s = isConditionalDef(n) && n.condition, l = [];
	s && (l = array(s).map((n) => {
		let r = o(n);
		if (isConditionalParameter(n)) {
			let { param: i, empty: o } = n;
			return {
				test: parseSelectionPredicate(t, {
					param: i,
					empty: o
				}),
				...r
			};
		} else return {
			test: expression$1(t, n.test),
			...r
		};
	})), i !== void 0 && l.push(i);
	let u = o(n);
	return u !== void 0 && l.push(u), l.length > 1 || l.length === 1 && l[0].test ? { [r]: l } : l.length === 1 ? { [r]: l[0] } : {};
}
function text$1(t, n = "text") {
	let r = t.encoding[n];
	return wrapCondition({
		model: t,
		channelDef: r,
		vgChannel: n,
		mainRefFn: (n) => textRef(n, t.config),
		invalidValueRef: void 0
	});
}
function textRef(t, n, r = "datum") {
	if (t) {
		if (isValueDef(t)) return signalOrValueRef(t.value);
		if (isFieldOrDatumDef(t)) {
			let { format: i, formatType: o } = getFormatMixins(t);
			return formatSignalRef({
				fieldOrDatumDef: t,
				format: i,
				formatType: o,
				expr: r,
				config: n
			});
		}
	}
}
function tooltip(t, n = {}) {
	let { encoding: r, markDef: i, config: o, stack: s } = t, l = r.tooltip;
	if (isArray(l)) return { tooltip: tooltipRefForEncoding({ tooltip: l }, s, o, n) };
	{
		let u = n.reactiveGeom ? "datum.datum" : "datum";
		return wrapCondition({
			model: t,
			channelDef: l,
			vgChannel: "tooltip",
			mainRefFn: (t) => {
				let l = addLineBreaksToTooltip(t, o, u);
				if (l) return l;
				if (t === null) return;
				let d = getMarkPropOrConfig("tooltip", i, o);
				if (d === !0 && (d = { content: "encoding" }), isString(d)) return { value: d };
				if (isObject(d)) return isSignalRef(d) ? d : d.content === "encoding" ? tooltipRefForEncoding(r, s, o, n) : { signal: u };
			},
			invalidValueRef: void 0
		});
	}
}
function tooltipData(t, n, r, { reactiveGeom: i } = {}) {
	let o = {
		...r,
		...r.tooltipFormat
	}, s = /* @__PURE__ */ new Set(), l = i ? "datum.datum" : "datum", u = [];
	function d(r, i) {
		let d = getMainRangeChannel(i), f = isTypedFieldDef(r) ? r : {
			...r,
			type: t[d].type
		}, p = array(f.title || defaultTitle(f, o)).join(", ").replaceAll(/"/g, "\\\""), g;
		if (isXorY(i)) {
			let n = i === "x" ? "x2" : "y2", r = getFieldDef(t[n]);
			if (isBinned(f.bin) && r) {
				let t = vgField(f, { expr: l }), i = vgField(r, { expr: l }), { format: u, formatType: d } = getFormatMixins(f);
				g = binFormatExpression(t, i, u, d, o), s.add(n);
			}
		}
		if ((isXorY(i) || i === THETA || i === RADIUS) && n && n.fieldChannel === i && n.offset === "normalize") {
			let { format: t, formatType: n } = getFormatMixins(f);
			g = formatSignalRef({
				fieldOrDatumDef: f,
				format: t,
				formatType: n,
				expr: l,
				config: o,
				normalizeStack: !0
			}).signal;
		}
		g ??= addLineBreaksToTooltip(f, o, l).signal, u.push({
			channel: i,
			key: p,
			value: g
		});
	}
	forEach(t, (t, n) => {
		isFieldDef(t) ? d(t, n) : hasConditionalFieldDef(t) && d(t.condition, n);
	});
	let f = {};
	for (let { channel: t, key: n, value: r } of u) !s.has(t) && !f[n] && (f[n] = r);
	return f;
}
function tooltipRefForEncoding(t, n, r, { reactiveGeom: i } = {}) {
	let o = entries$1(tooltipData(t, n, r, { reactiveGeom: i })).map(([t, n]) => `"${t}": ${n}`);
	return o.length > 0 ? { signal: `{${o.join(", ")}}` } : void 0;
}
function addLineBreaksToTooltip(t, n, r = "datum") {
	if (isFieldDef(t) && isDiscrete$1(t.type) && !hasProperty(t, "format")) {
		let n = `datum["${t.field}"]`;
		return { signal: `isValid(${n}) ? isArray(${n}) ? join(${n}, '\\n') : ${n} : ""+${n}` };
	}
	return textRef(t, n, r);
}
function aria(t) {
	let { markDef: n, config: r } = t, i = getMarkPropOrConfig("aria", n, r);
	return i === !1 ? {} : {
		...i ? { aria: i } : {},
		...ariaRoleDescription(t),
		...description(t)
	};
}
function ariaRoleDescription(t) {
	let { mark: n, markDef: r, config: i } = t;
	if (i.aria === !1) return {};
	let o = getMarkPropOrConfig("ariaRoleDescription", r, i);
	return o == null ? has(VG_MARK_INDEX, n) ? {} : { ariaRoleDescription: { value: n } } : { ariaRoleDescription: { value: o } };
}
function description(t) {
	let { encoding: n, markDef: r, config: i, stack: o } = t, s = n.description;
	if (s) return wrapCondition({
		model: t,
		channelDef: s,
		vgChannel: "description",
		mainRefFn: (n) => textRef(n, t.config),
		invalidValueRef: void 0
	});
	let l = getMarkPropOrConfig("description", r, i);
	if (l != null) return { description: signalOrValueRef(l) };
	if (i.aria === !1) return {};
	let u = tooltipData(n, o, i);
	if (!isEmpty(u)) return { description: { signal: entries$1(u).filter(([t]) => !t.startsWith("_")).map(([t, n]) => [t, n.replaceAll("\\n", " ")]).map(([t, n], r) => `"${r > 0 ? "; " : ""}${t}: " + (${n})`).join(" + ") } };
}
function nonPosition(t, n, r = {}) {
	let { markDef: i, encoding: o, config: s } = n, { vgChannel: l } = r, { defaultRef: u, defaultValue: d } = r, f = o[t];
	u === void 0 && (d ??= getMarkPropOrConfig(t, i, s, {
		vgChannel: l,
		ignoreVgConfig: !isConditionalDef(f)
	}), d !== void 0 && (u = signalOrValueRef(d)));
	let p = {
		markDef: i,
		config: s,
		scaleName: n.scaleName(t),
		scale: n.getScaleComponent(t)
	}, g = getConditionalValueRefForIncludingInvalidValue({
		...p,
		scaleChannel: t,
		channelDef: f
	});
	return wrapCondition({
		model: n,
		channelDef: f,
		vgChannel: l ?? t,
		invalidValueRef: g,
		mainRefFn: (n) => midPoint({
			...p,
			channel: t,
			channelDef: n,
			stack: null,
			defaultRef: u
		})
	});
}
function color(t, n = { filled: void 0 }) {
	let { markDef: r, encoding: i, config: o } = t, { type: s } = r, l = n.filled ?? getMarkPropOrConfig("filled", r, o), u = contains([
		"bar",
		"point",
		"circle",
		"square",
		"geoshape"
	], s) ? "transparent" : void 0, d = getMarkPropOrConfig(l === !0 ? "color" : void 0, r, o, { vgChannel: "fill" }) ?? o.mark[l === !0 && "color"] ?? u, f = getMarkPropOrConfig(l === !1 ? "color" : void 0, r, o, { vgChannel: "stroke" }) ?? o.mark[l === !1 && "color"], p = l ? "fill" : "stroke", g = {
		...d ? { fill: signalOrValueRef(d) } : {},
		...f ? { stroke: signalOrValueRef(f) } : {}
	};
	return r.color && (l ? r.fill : r.stroke) && warn(droppingColor("property", {
		fill: "fill" in r,
		stroke: "stroke" in r
	})), {
		...g,
		...nonPosition("color", t, {
			vgChannel: p,
			defaultValue: l ? d : f
		}),
		...nonPosition("fill", t, { defaultValue: i.fill ? d : void 0 }),
		...nonPosition("stroke", t, { defaultValue: i.stroke ? f : void 0 })
	};
}
function zindex(t) {
	let { encoding: n, mark: r } = t, i = n.order;
	return !isPathMark(r) && isValueDef(i) ? wrapCondition({
		model: t,
		channelDef: i,
		vgChannel: "zindex",
		mainRefFn: (t) => signalOrValueRef(t.value),
		invalidValueRef: void 0
	}) : {};
}
function positionOffset({ channel: t, markDef: n, encoding: r = {}, model: i, bandPosition: o }) {
	let s = `${t}Offset`, l = n[s], u = r[s];
	if ((s === "xOffset" || s === "yOffset") && u) return {
		offsetType: "encoding",
		offset: midPoint({
			channel: s,
			channelDef: u,
			markDef: n,
			config: i?.config,
			scaleName: i.scaleName(s),
			scale: i.getScaleComponent(s),
			stack: null,
			defaultRef: signalOrValueRef(l),
			bandPosition: o
		})
	};
	let d = n[s];
	return d ? {
		offsetType: "visual",
		offset: d
	} : {};
}
function pointPosition(t, n, { defaultPos: r, vgChannel: i }) {
	let { encoding: o, markDef: s, config: l, stack: u } = n, d = o[t], f = o[getSecondaryRangeChannel(t)], p = n.scaleName(t), g = n.getScaleComponent(t), { offset: _, offsetType: v } = positionOffset({
		channel: t,
		markDef: s,
		encoding: o,
		model: n,
		bandPosition: .5
	}), S = pointPositionDefaultRef({
		model: n,
		defaultPos: r,
		channel: t,
		scaleName: p,
		scale: g
	}), T = !d && isXorY(t) && (o.latitude || o.longitude) ? { field: n.getName(t) } : positionRef({
		channel: t,
		channelDef: d,
		channel2Def: f,
		markDef: s,
		config: l,
		scaleName: p,
		scale: g,
		stack: u,
		offset: _,
		defaultRef: S,
		bandPosition: v === "encoding" ? 0 : void 0
	});
	return T ? { [i || t]: T } : void 0;
}
function positionRef(t) {
	let { channel: n, channelDef: r, scaleName: i, stack: o, offset: s, markDef: l } = t;
	if (isFieldOrDatumDef(r) && o && n === o.fieldChannel) {
		if (isFieldDef(r)) {
			let t = r.bandPosition;
			if (t === void 0 && l.type === "text" && (n === "radius" || n === "theta") && (t = .5), t !== void 0) return interpolatedSignalRef({
				scaleName: i,
				fieldOrDatumDef: r,
				startSuffix: "start",
				bandPosition: t,
				offset: s
			});
		}
		return valueRefForFieldOrDatumDef(r, i, { suffix: "end" }, { offset: s });
	}
	return midPointRefWithPositionInvalidTest(t);
}
function pointPositionDefaultRef({ model: t, defaultPos: n, channel: r, scaleName: i, scale: o }) {
	let { markDef: s, config: l } = t;
	return () => {
		let u = getMainRangeChannel(r), d = getMarkPropOrConfig(r, s, l, { vgChannel: getVgPositionChannel(r) });
		if (d !== void 0) return widthHeightValueOrSignalRef(r, d);
		switch (n) {
			case "zeroOrMin": return zeroOrMinOrMaxPosition({
				scaleName: i,
				scale: o,
				mode: "zeroOrMin",
				mainChannel: u,
				config: l
			});
			case "zeroOrMax": return zeroOrMinOrMaxPosition({
				scaleName: i,
				scale: o,
				mode: { zeroOrMax: {
					widthSignal: t.width.signal,
					heightSignal: t.height.signal
				} },
				mainChannel: u,
				config: l
			});
			case "mid": return {
				...t[getSizeChannel(r)],
				mult: .5
			};
		}
	};
}
function zeroOrMinOrMaxPosition({ mainChannel: t, config: n,...r }) {
	let i = scaledZeroOrMinOrMax(r), { mode: o } = r;
	if (i) return i;
	switch (t) {
		case "radius": {
			if (o === "zeroOrMin") return { value: 0 };
			let { widthSignal: t, heightSignal: n } = o.zeroOrMax;
			return { signal: `min(${t},${n})/2` };
		}
		case "theta": return o === "zeroOrMin" ? { value: 0 } : { signal: "2*PI" };
		case "x": return o === "zeroOrMin" ? { value: 0 } : { field: { group: "width" } };
		case "y": return o === "zeroOrMin" ? { field: { group: "height" } } : { value: 0 };
	}
}
var ALIGNED_X_CHANNEL = {
	left: "x",
	center: "xc",
	right: "x2"
}, BASELINED_Y_CHANNEL = {
	top: "y",
	middle: "yc",
	bottom: "y2"
};
function vgAlignedPositionChannel(t, n, r, i = "middle") {
	if (t === "radius" || t === "theta") return getVgPositionChannel(t);
	let o = t === "x" ? "align" : "baseline", s = getMarkPropOrConfig(o, n, r), l;
	return isSignalRef(s) ? (warn(rangeMarkAlignmentCannotBeExpression(o)), l = void 0) : l = s, t === "x" ? ALIGNED_X_CHANNEL[l || (i === "top" ? "left" : "center")] : BASELINED_Y_CHANNEL[l || i];
}
function pointOrRangePosition(t, n, { defaultPos: r, defaultPos2: i, range: o }) {
	return o ? rangePosition(t, n, {
		defaultPos: r,
		defaultPos2: i
	}) : pointPosition(t, n, { defaultPos: r });
}
function rangePosition(t, n, { defaultPos: r, defaultPos2: i }) {
	let { markDef: o, config: s } = n, l = getSecondaryRangeChannel(t), u = getSizeChannel(t), d = pointPosition2OrSize(n, i, l);
	return {
		...pointPosition(t, n, {
			defaultPos: r,
			vgChannel: d[u] ? vgAlignedPositionChannel(t, o, s) : getVgPositionChannel(t)
		}),
		...d
	};
}
function pointPosition2OrSize(t, n, r) {
	let { encoding: i, mark: o, markDef: s, stack: l, config: u } = t, d = getMainRangeChannel(r), f = getSizeChannel(r), p = getVgPositionChannel(r), g = i[d], _ = t.scaleName(d), v = t.getScaleComponent(d), { offset: S } = r in i || r in s ? positionOffset({
		channel: r,
		markDef: s,
		encoding: i,
		model: t
	}) : positionOffset({
		channel: d,
		markDef: s,
		encoding: i,
		model: t
	});
	if (!g && (r === "x2" || r === "y2") && (i.latitude || i.longitude)) {
		let n = getSizeChannel(r), i = t.markDef[n];
		return i == null ? { [p]: { field: t.getName(r) } } : { [n]: { value: i } };
	}
	let T = position2Ref({
		channel: r,
		channelDef: g,
		channel2Def: i[r],
		markDef: s,
		config: u,
		scaleName: _,
		scale: v,
		stack: l,
		offset: S,
		defaultRef: void 0
	});
	return T === void 0 ? position2orSize(r, s) || position2orSize(r, {
		[r]: getMarkStyleConfig(r, s, u.style),
		[f]: getMarkStyleConfig(f, s, u.style)
	}) || position2orSize(r, u[o]) || position2orSize(r, u.mark) || { [p]: pointPositionDefaultRef({
		model: t,
		defaultPos: n,
		channel: r,
		scaleName: _,
		scale: v
	})() } : { [p]: T };
}
function position2Ref({ channel: t, channelDef: n, channel2Def: r, markDef: i, config: o, scaleName: s, scale: l, stack: u, offset: d, defaultRef: f }) {
	return isFieldOrDatumDef(n) && u && t.charAt(0) === u.fieldChannel.charAt(0) ? valueRefForFieldOrDatumDef(n, s, { suffix: "start" }, { offset: d }) : midPointRefWithPositionInvalidTest({
		channel: t,
		channelDef: r,
		scaleName: s,
		scale: l,
		stack: u,
		markDef: i,
		config: o,
		offset: d,
		defaultRef: f
	});
}
function position2orSize(t, n) {
	let r = getSizeChannel(t), i = getVgPositionChannel(t);
	if (n[i] !== void 0) return { [i]: widthHeightValueOrSignalRef(t, n[i]) };
	if (n[t] !== void 0) return { [i]: widthHeightValueOrSignalRef(t, n[t]) };
	if (n[r]) {
		let i = n[r];
		if (isRelativeBandSize(i)) warn(relativeBandSizeNotSupported(r));
		else return { [r]: widthHeightValueOrSignalRef(t, i) };
	}
}
function rectPosition(t, n) {
	let { config: r, encoding: i, markDef: o } = t, s = o.type, l = getSecondaryRangeChannel(n), u = getSizeChannel(n), d = i[n], f = i[l], p = t.getScaleComponent(n), g = p ? p.get("type") : void 0, _ = o.orient, v = i[u] ?? i.size ?? getMarkPropOrConfig("size", o, r, { vgChannel: u }), S = getOffsetChannel(n), T = s === "bar" && (n === "x" ? _ === "vertical" : _ === "horizontal") || s === "tick" && (n === "y" ? _ === "vertical" : _ === "horizontal");
	return isFieldDef(d) && (isBinning(d.bin) || isBinned(d.bin) || d.timeUnit && !f) && !(v && !isRelativeBandSize(v)) && !i[S] && !hasDiscreteDomain(g) ? rectBinPosition({
		fieldDef: d,
		fieldDef2: f,
		channel: n,
		model: t
	}) : (isFieldOrDatumDef(d) && hasDiscreteDomain(g) || T) && !f ? positionAndSize(d, n, t) : rangePosition(n, t, {
		defaultPos: "zeroOrMax",
		defaultPos2: "zeroOrMin"
	});
}
function defaultSizeRef(t, n, r, i, o, s, l) {
	if (isRelativeBandSize(o)) if (r) {
		let t = r.get("type");
		if (t === "band") {
			let t = `bandwidth('${n}')`;
			o.band !== 1 && (t = `${o.band} * ${t}`);
			let r = getMarkConfig("minBandSize", { type: l }, i);
			return { signal: r ? `max(${signalOrStringValue(r)}, ${t})` : t };
		} else o.band !== 1 && (warn(cannotUseRelativeBandSizeWithNonBandScale(t)), o = void 0);
	} else return {
		mult: o.band,
		field: { group: t }
	};
	else if (isSignalRef(o)) return o;
	else if (o) return { value: o };
	if (r) {
		let t = r.get("range");
		if (isVgRangeStep(t) && isNumber(t.step)) return { value: t.step - 2 };
	}
	if (!s) {
		let { bandPaddingInner: n, barBandPaddingInner: r, rectBandPaddingInner: o, tickBandPaddingInner: s } = i.scale, u = getFirstDefined(n, l === "tick" ? s : l === "bar" ? r : o);
		if (isSignalRef(u)) return { signal: `(1 - (${u.signal})) * ${t}` };
		if (isNumber(u)) return { signal: `${1 - u} * ${t}` };
	}
	return { value: getViewConfigDiscreteStep(i.view, t) - 2 };
}
function positionAndSize(t, n, r) {
	let { markDef: i, encoding: o, config: s, stack: l } = r, u = i.orient, d = r.scaleName(n), f = r.getScaleComponent(n), p = getSizeChannel(n), g = getSecondaryRangeChannel(n), _ = getOffsetChannel(n), v = r.scaleName(_), S = r.getScaleComponent(getOffsetScaleChannel(n)), T = i.type === "tick" || u === "horizontal" && n === "y" || u === "vertical" && n === "x", E;
	(o.size || i.size) && (T ? E = nonPosition("size", r, {
		vgChannel: p,
		defaultRef: signalOrValueRef(i.size)
	}) : warn(cannotApplySizeToNonOrientedMark(i.type)));
	let O = !!E, k = getBandSize({
		channel: n,
		fieldDef: t,
		markDef: i,
		config: s,
		scaleType: (f || S)?.get("type"),
		useVlSizeChannel: T
	});
	E ||= { [p]: defaultSizeRef(p, v || d, S || f, s, k, !!t, i.type) };
	let A = vgAlignedPositionChannel(n, i, s, (f || S)?.get("type") === "band" && isRelativeBandSize(k) && !O ? "top" : "middle"), j = A === "xc" || A === "yc", { offset: N, offsetType: P } = positionOffset({
		channel: n,
		markDef: i,
		encoding: o,
		model: r,
		bandPosition: j ? .5 : 0
	}), F = midPointRefWithPositionInvalidTest({
		channel: n,
		channelDef: t,
		markDef: i,
		config: s,
		scaleName: d,
		scale: f,
		stack: l,
		offset: N,
		defaultRef: pointPositionDefaultRef({
			model: r,
			defaultPos: "mid",
			channel: n,
			scaleName: d,
			scale: f
		}),
		bandPosition: j ? P === "encoding" ? 0 : .5 : isSignalRef(k) ? { signal: `(1-${k})/2` } : isRelativeBandSize(k) ? (1 - k.band) / 2 : 0
	});
	if (p) return {
		[A]: F,
		...E
	};
	{
		let t = getVgPositionChannel(g), n = E[p], r = N ? {
			...n,
			offset: N
		} : n;
		return {
			[A]: F,
			[t]: isArray(F) ? [F[0], {
				...F[1],
				offset: r
			}] : {
				...F,
				offset: r
			}
		};
	}
}
function getBinSpacing(t, n, r, i, o, s, l) {
	if (isPolarPositionChannel(t)) return 0;
	let u = t === "x" || t === "y2", d = u ? -n / 2 : n / 2;
	if (isSignalRef(r) || isSignalRef(o) || isSignalRef(i) || s) {
		let t = signalOrStringValue(r), n = signalOrStringValue(o), f = signalOrStringValue(i), p = signalOrStringValue(s), g = s ? `(${l} < ${p} ? ${u ? "" : "-"}0.5 * (${p} - (${l})) : ${d})` : d, _ = f ? `${f} + ` : "", v = t ? `(${t} ? -1 : 1) * ` : "", S = n ? `(${n} + ${g})` : g;
		return { signal: _ + v + S };
	} else return o ||= 0, i + (r ? -o - d : +o + d);
}
function rectBinPosition({ fieldDef: t, fieldDef2: n, channel: r, model: i }) {
	let { config: o, markDef: s, encoding: l } = i, u = i.getScaleComponent(r), d = i.scaleName(r), f = u ? u.get("type") : void 0, p = u.get("reverse"), g = getBandSize({
		channel: r,
		fieldDef: t,
		markDef: s,
		config: o,
		scaleType: f
	}), _ = (i.component.axes[r]?.[0])?.get("translate") ?? .5, v = isXorY(r) ? getMarkPropOrConfig("binSpacing", s, o) ?? 0 : 0, S = getSecondaryRangeChannel(r), T = getVgPositionChannel(r), E = getVgPositionChannel(S), O = getMarkConfig("minBandSize", s, o), { offset: k } = positionOffset({
		channel: r,
		markDef: s,
		encoding: l,
		model: i,
		bandPosition: 0
	}), { offset: A } = positionOffset({
		channel: S,
		markDef: s,
		encoding: l,
		model: i,
		bandPosition: 0
	}), j = binSizeExpr({
		fieldDef: t,
		scaleName: d
	}), N = getBinSpacing(r, v, p, _, k, O, j), P = getBinSpacing(S, v, p, _, A ?? k, O, j), F = isSignalRef(g) ? { signal: `(1-${g.signal})/2` } : isRelativeBandSize(g) ? (1 - g.band) / 2 : .5, I = getBandPosition({
		fieldDef: t,
		fieldDef2: n,
		markDef: s,
		config: o
	});
	if (isBinning(t.bin) || t.timeUnit) {
		let n = t.timeUnit && I !== .5;
		return {
			[E]: rectBinRef({
				fieldDef: t,
				scaleName: d,
				bandPosition: F,
				offset: P,
				useRectOffsetField: n
			}),
			[T]: rectBinRef({
				fieldDef: t,
				scaleName: d,
				bandPosition: isSignalRef(F) ? { signal: `1-${F.signal}` } : 1 - F,
				offset: N,
				useRectOffsetField: n
			})
		};
	} else if (isBinned(t.bin)) {
		let r = valueRefForFieldOrDatumDef(t, d, {}, { offset: P });
		if (isFieldDef(n)) return {
			[E]: r,
			[T]: valueRefForFieldOrDatumDef(n, d, {}, { offset: N })
		};
		if (isBinParams(t.bin) && t.bin.step) return {
			[E]: r,
			[T]: {
				signal: `scale("${d}", ${vgField(t, { expr: "datum" })} + ${t.bin.step})`,
				offset: N
			}
		};
	}
	warn(channelRequiredForBinned(S));
}
function rectBinRef({ fieldDef: t, scaleName: n, bandPosition: r, offset: i, useRectOffsetField: o }) {
	return interpolatedSignalRef({
		scaleName: n,
		fieldOrDatumDef: t,
		bandPosition: r,
		offset: i,
		...o ? {
			startSuffix: OFFSETTED_RECT_START_SUFFIX,
			endSuffix: OFFSETTED_RECT_END_SUFFIX
		} : {}
	});
}
var ALWAYS_IGNORE = new Set([
	"aria",
	"width",
	"height"
]);
function baseEncodeEntry(t, n) {
	let { fill: r = void 0, stroke: i = void 0 } = n.color === "include" ? color(t) : {};
	return {
		...markDefProperties(t.markDef, n),
		...colorRef("fill", r),
		...colorRef("stroke", i),
		...nonPosition("opacity", t),
		...nonPosition("fillOpacity", t),
		...nonPosition("strokeOpacity", t),
		...nonPosition("strokeWidth", t),
		...nonPosition("strokeDash", t),
		...zindex(t),
		...tooltip(t),
		...text$1(t, "href"),
		...aria(t)
	};
}
function colorRef(t, n) {
	return n ? { [t]: n } : {};
}
function markDefProperties(t, n) {
	return VG_MARK_CONFIGS.reduce((r, i) => (!ALWAYS_IGNORE.has(i) && hasProperty(t, i) && n[i] !== "ignore" && (r[i] = signalOrValueRef(t[i])), r), {});
}
function defined(t) {
	let { config: n, markDef: r } = t, i = /* @__PURE__ */ new Set();
	if (t.forEachFieldDef((o, s) => {
		let l;
		if (!isScaleChannel(s) || !(l = t.getScaleType(s))) return;
		let u = isCountingAggregateOp(o.aggregate);
		if (shouldBreakPath(getScaleInvalidDataMode({
			scaleChannel: s,
			markDef: r,
			config: n,
			scaleType: l,
			isCountAggregate: u
		}))) {
			let n = t.vgField(s, {
				expr: "datum",
				binSuffix: t.stack?.impute ? "mid" : void 0
			});
			n && i.add(n);
		}
	}), i.size > 0) return { defined: { signal: [...i].map((t) => fieldValidPredicate(t, !0)).join(" && ") } };
}
function valueIfDefined(t, n) {
	if (n !== void 0) return { [t]: signalOrValueRef(n) };
}
var VORONOI = "voronoi", nearest = {
	defined: (t) => t.type === "point" && t.nearest,
	parse: (t, n) => {
		if (n.events) for (let r of n.events) r.markname = t.getName(VORONOI);
	},
	marks: (t, n, r) => {
		let { x: i, y: o } = n.project.hasChannel, s = t.mark;
		if (isPathMark(s)) return warn(nearestNotSupportForContinuous(s)), r;
		let l = {
			name: t.getName(VORONOI),
			type: "path",
			interactive: !0,
			aria: !1,
			from: { data: t.getName("marks") },
			encode: { update: {
				fill: { value: "transparent" },
				strokeWidth: { value: .35 },
				stroke: { value: "transparent" },
				isVoronoi: { value: !0 },
				...tooltip(t, { reactiveGeom: !0 })
			} },
			transform: [{
				type: "voronoi",
				x: { expr: i || !o ? "datum.datum.x || 0" : "0" },
				y: { expr: o || !i ? "datum.datum.y || 0" : "0" },
				size: [t.getSizeSignalRef("width"), t.getSizeSignalRef("height")]
			}]
		}, u = 0, d = !1;
		return r.forEach((n, r) => {
			let i = n.name ?? "";
			i === t.component.mark[0].name ? u = r : i.includes(VORONOI) && (d = !0);
		}), d || r.splice(u + 1, 0, l), r;
	}
}, inputBindings = {
	defined: (t) => t.type === "point" && t.resolve === "global" && t.bind && t.bind !== "scales" && !isLegendBinding(t.bind),
	parse: (t, n, r) => disableDirectManipulation(n, r),
	topLevelSignals: (t, n, r) => {
		let i = n.name, o = n.project, s = n.bind, l = n.init?.[0], u = nearest.defined(n) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
		return o.items.forEach((t, o) => {
			let d = varName(`${i}_${t.field}`);
			r.filter((t) => t.name === d).length || r.unshift({
				name: d,
				...l ? { init: assembleInit(l[o]) } : { value: null },
				on: n.events ? [{
					events: n.events,
					update: `datum && item().mark.marktype !== 'group' ? ${u}[${$(t.field)}] : null`
				}] : [],
				bind: s[t.field] ?? s[t.channel] ?? s
			});
		}), r;
	},
	signals: (t, n, r) => {
		let i = n.name, o = n.project, s = r.find((t) => t.name === i + TUPLE), l = i + TUPLE_FIELDS, u = o.items.map((t) => varName(`${i}_${t.field}`)), d = u.map((t) => `${t} !== null`).join(" && ");
		return u.length && (s.update = `${d} ? {fields: ${l}, values: [${u.join(", ")}]} : null`), delete s.value, delete s.on, r;
	}
}, TOGGLE = "_toggle", toggle = {
	defined: (t) => t.type === "point" && !isTimerSelection(t) && !!t.toggle,
	signals: (t, n, r) => r.concat({
		name: n.name + TOGGLE,
		value: !1,
		on: [{
			events: n.events,
			update: n.toggle
		}]
	}),
	modifyExpr: (t, n) => {
		let r = n.name + TUPLE, i = n.name + TOGGLE;
		return `${i} ? null : ${r}, ${n.resolve === "global" ? `${i} ? null : true, ` : `${i} ? null : {unit: ${unitName(t)}}, `}${i} ? ${r} : null`;
	}
}, clear = {
	defined: (t) => t.clear !== void 0 && t.clear !== !1 && !isTimerSelection(t),
	parse: (t, n) => {
		n.clear &&= isString(n.clear) ? eventSelector(n.clear, "view") : n.clear;
	},
	topLevelSignals: (t, n, r) => {
		if (inputBindings.defined(n)) for (let t of n.project.items) {
			let i = r.findIndex((r) => r.name === varName(`${n.name}_${t.field}`));
			i !== -1 && r[i].on.push({
				events: n.clear,
				update: "null"
			});
		}
		return r;
	},
	signals: (t, n, r) => {
		function i(t, i) {
			t !== -1 && r[t].on && r[t].on.push({
				events: n.clear,
				update: i
			});
		}
		if (n.type === "interval") for (let t of n.project.items) {
			let n = r.findIndex((n) => n.name === t.signals.visual);
			i(n, "[0, 0]"), n === -1 && i(r.findIndex((n) => n.name === t.signals.data), "null");
		}
		else {
			let t = r.findIndex((t) => t.name === n.name + TUPLE);
			i(t, "null"), toggle.defined(n) && (t = r.findIndex((t) => t.name === n.name + TOGGLE), i(t, "false"));
		}
		return r;
	}
}, legendBindings = {
	defined: (t) => {
		let n = t.resolve === "global" && t.bind && isLegendBinding(t.bind), r = t.project.items.length === 1 && t.project.items[0].field !== SELECTION_ID;
		return n && !r && warn(LEGEND_BINDINGS_MUST_HAVE_PROJECTION), n && r;
	},
	parse: (t, n, r) => {
		let i = duplicate(r);
		if (i.select = isString(i.select) ? {
			type: i.select,
			toggle: n.toggle
		} : {
			...i.select,
			toggle: n.toggle
		}, disableDirectManipulation(n, i), isObject(r.select) && (r.select.on || r.select.clear)) {
			let t = "event.item && indexof(event.item.mark.role, \"legend\") < 0";
			for (let r of n.events) r.filter = array(r.filter ?? []), r.filter.includes(t) || r.filter.push(t);
		}
		let o = isLegendStreamBinding(n.bind) ? n.bind.legend : "click";
		n.bind = { legend: { merge: isString(o) ? eventSelector(o, "view") : array(o) } };
	},
	topLevelSignals: (t, n, r) => {
		let i = n.name, o = isLegendStreamBinding(n.bind) && n.bind.legend, s = (t) => (n) => {
			let r = duplicate(n);
			return r.markname = t, r;
		};
		for (let t of n.project.items) {
			if (!t.hasLegend) continue;
			let l = `${varName(t.field)}_legend`, u = `${i}_${l}`;
			if (r.filter((t) => t.name === u).length === 0) {
				let t = o.merge.map(s(`${l}_symbols`)).concat(o.merge.map(s(`${l}_labels`))).concat(o.merge.map(s(`${l}_entries`)));
				r.unshift({
					name: u,
					...n.init ? {} : { value: null },
					on: [{
						events: t,
						update: "isDefined(datum.value) ? datum.value : item().items[0].items[0].datum.value",
						force: !0
					}, {
						events: o.merge,
						update: `!event.item || !datum ? null : ${u}`,
						force: !0
					}]
				});
			}
		}
		return r;
	},
	signals: (t, n, r) => {
		let i = n.name, o = n.project, s = r.find((t) => t.name === i + TUPLE), l = i + TUPLE_FIELDS, u = o.items.filter((t) => t.hasLegend).map((t) => varName(`${i}_${varName(t.field)}_legend`)), d = `${u.map((t) => `${t} !== null`).join(" && ")} ? {fields: ${l}, values: [${u.join(", ")}]} : null`;
		n.events && u.length > 0 ? s.on.push({
			events: u.map((t) => ({ signal: t })),
			update: d
		}) : u.length > 0 && (s.update = d, delete s.value, delete s.on);
		let f = r.find((t) => t.name === i + TOGGLE), p = isLegendStreamBinding(n.bind) && n.bind.legend;
		return f && (n.events ? f.on.push({
			...f.on[0],
			events: p
		}) : f.on[0].events = p), r;
	}
};
function parseInteractiveLegend(t, n, r) {
	let i = t.fieldDef(n)?.field;
	for (let o of vals(t.component.selection ?? {})) {
		let t = o.project.hasField[i] ?? o.project.hasChannel[n];
		if (t && legendBindings.defined(o)) {
			let n = r.get("selections") ?? [];
			n.push(o.name), r.set("selections", n, !1), t.hasLegend = !0;
		}
	}
}
var ANCHOR$1 = "_translate_anchor", DELTA$1 = "_translate_delta", translate = {
	defined: (t) => t.type === "interval" && t.translate,
	signals: (t, n, r) => {
		let i = n.name, o = scaleBindings.defined(n), s = i + ANCHOR$1, { x: l, y: u } = n.project.hasChannel, d = eventSelector(n.translate, "scope");
		return o || (d = d.map((t) => (t.between[0].markname = i + BRUSH, t))), r.push({
			name: s,
			value: {},
			on: [{
				events: d.map((t) => t.between[0]),
				update: `{x: x(unit), y: y(unit)${l === void 0 ? "" : `, extent_x: ${o ? domain(t, X) : `slice(${l.signals.visual})`}`}${u === void 0 ? "" : `, extent_y: ${o ? domain(t, Y) : `slice(${u.signals.visual})`}`}}`
			}]
		}, {
			name: i + DELTA$1,
			value: {},
			on: [{
				events: d,
				update: `{x: ${s}.x - x(unit), y: ${s}.y - y(unit)}`
			}]
		}), l !== void 0 && onDelta$1(t, n, l, "width", r), u !== void 0 && onDelta$1(t, n, u, "height", r), r;
	}
};
function onDelta$1(t, n, r, i, o) {
	let s = n.name, l = s + ANCHOR$1, u = s + DELTA$1, d = r.channel, f = scaleBindings.defined(n), p = o.find((t) => t.name === r.signals[f ? "data" : "visual"]), g = t.getSizeSignalRef(i).signal, _ = t.getScaleComponent(d), v = _?.get("type"), S = _?.get("reverse"), T = f ? d === X ? S ? "" : "-" : S ? "-" : "" : "", E = `${l}.extent_${d}`, O = `${T}${u}.${d} / ${f ? `${g}` : `span(${E})`}`, k = `${!f || !_ ? "panLinear" : v === "log" ? "panLog" : v === "symlog" ? "panSymlog" : v === "pow" ? "panPow" : "panLinear"}(${E}, ${O}${f ? v === "pow" ? `, ${_.get("exponent") ?? 1}` : v === "symlog" ? `, ${_.get("constant") ?? 1}` : "" : ""})`;
	p.on.push({
		events: { signal: u },
		update: f ? k : `clampRange(${k}, 0, ${g})`
	});
}
var ANCHOR = "_zoom_anchor", DELTA = "_zoom_delta", zoom = {
	defined: (t) => t.type === "interval" && t.zoom,
	signals: (t, n, r) => {
		let i = n.name, o = scaleBindings.defined(n), s = i + DELTA, { x: l, y: u } = n.project.hasChannel, d = $(t.scaleName(X)), f = $(t.scaleName(Y)), p = eventSelector(n.zoom, "scope");
		return o || (p = p.map((t) => (t.markname = i + BRUSH, t))), r.push({
			name: i + ANCHOR,
			on: [{
				events: p,
				update: o ? `{${[d ? `x: invert(${d}, x(unit))` : "", f ? `y: invert(${f}, y(unit))` : ""].filter((t) => t).join(", ")}}` : "{x: x(unit), y: y(unit)}"
			}]
		}, {
			name: s,
			on: [{
				events: p,
				force: !0,
				update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
			}]
		}), l !== void 0 && onDelta(t, n, l, "width", r), u !== void 0 && onDelta(t, n, u, "height", r), r;
	}
};
function onDelta(t, n, r, i, o) {
	let s = n.name, l = r.channel, u = scaleBindings.defined(n), d = o.find((t) => t.name === r.signals[u ? "data" : "visual"]), f = t.getSizeSignalRef(i).signal, p = t.getScaleComponent(l), g = p?.get("type"), _ = u ? domain(t, l) : d.name, v = s + DELTA, S = `${s}${ANCHOR}.${l}`, T = `${!u || !p ? "zoomLinear" : g === "log" ? "zoomLog" : g === "symlog" ? "zoomSymlog" : g === "pow" ? "zoomPow" : "zoomLinear"}(${_}, ${S}, ${v}${u ? g === "pow" ? `, ${p.get("exponent") ?? 1}` : g === "symlog" ? `, ${p.get("constant") ?? 1}` : "" : ""})`;
	d.on.push({
		events: { signal: v },
		update: u ? T : `clampRange(${T}, 0, ${f})`
	});
}
var STORE = "_store", TUPLE = "_tuple", MODIFY = "_modify", VL_SELECTION_RESOLVE = "vlSelectionResolve", selectionCompilers = [
	point$1,
	interval,
	project,
	toggle,
	inputBindings,
	scaleBindings,
	legendBindings,
	clear,
	translate,
	zoom,
	nearest
];
function getFacetModel(t) {
	let n = t.parent;
	for (; n && !isFacetModel(n);) n = n.parent;
	return n;
}
function unitName(t, { escape: n } = { escape: !0 }) {
	let r = n ? $(t.name) : t.name, i = getFacetModel(t);
	if (i) {
		let { facet: t } = i;
		for (let n of FACET_CHANNELS) t[n] && (r += ` + '__facet_${n}_' + (facet[${$(i.vgField(n))}])`);
	}
	return r;
}
function requiresSelectionId(t) {
	return vals(t.component.selection ?? {}).reduce((t, n) => t || n.project.hasSelectionId, !1);
}
function disableDirectManipulation(t, n) {
	(isString(n.select) || !n.select.on) && delete t.events, (isString(n.select) || !n.select.clear) && delete t.clear, (isString(n.select) || !n.select.toggle) && delete t.toggle;
}
function isTimerSelection(t) {
	return t.events?.find((t) => "type" in t && t.type === "timer");
}
function getName(t) {
	let n = [];
	return t.type === "Identifier" ? [t.name] : t.type === "Literal" ? [t.value] : (t.type === "MemberExpression" && (n.push(...getName(t.object)), n.push(...getName(t.property))), n);
}
function startsWithDatum(t) {
	return t.object.type === "MemberExpression" ? startsWithDatum(t.object) : t.object.name === "datum";
}
function getDependentFields(t) {
	let n = parser(t), r = /* @__PURE__ */ new Set();
	return n.visit((t) => {
		t.type === "MemberExpression" && startsWithDatum(t) && r.add(getName(t).slice(1).join("."));
	}), r;
}
var FilterNode = class t extends DataFlowNode {
	model;
	filter;
	expr;
	_dependentFields;
	clone() {
		return new t(null, this.model, duplicate(this.filter));
	}
	constructor(t, n, r) {
		super(t), this.model = n, this.filter = r, this.expr = expression$1(this.model, this.filter, this), this._dependentFields = getDependentFields(this.expr);
	}
	dependentFields() {
		return this._dependentFields;
	}
	producedFields() {
		return /* @__PURE__ */ new Set();
	}
	assemble() {
		return {
			type: "filter",
			expr: this.expr
		};
	}
	hash() {
		return `Filter ${this.expr}`;
	}
};
function parseUnitSelection(t, n) {
	let r = {}, i = t.config.selection;
	if (!n || !n.length) return r;
	let o = 0;
	for (let s of n) {
		let n = varName(s.name), l = s.select, u = isString(l) ? l : l.type, d = isObject(l) ? duplicate(l) : { type: u }, f = i[u];
		for (let t in f) t === "fields" || t === "encodings" || (t === "mark" && (d.mark = {
			...f.mark,
			...d.mark
		}), (d[t] === void 0 || d[t] === !0) && (d[t] = duplicate(f[t] ?? d[t])));
		let p = r[n] = {
			...d,
			name: n,
			type: u,
			init: s.value,
			bind: s.bind,
			events: isString(d.on) ? eventSelector(d.on, "scope") : array(duplicate(d.on))
		};
		if (isTimerSelection(p) && (o++, o > 1)) {
			delete r[n];
			continue;
		}
		let g = duplicate(s);
		for (let n of selectionCompilers) n.defined(p) && n.parse && n.parse(t, p, g);
	}
	return o > 1 && warn(MULTIPLE_TIMER_ANIMATION_SELECTION), r;
}
function parseSelectionPredicate(t, n, r, i = "datum") {
	let o = isString(n) ? n : n.param, s = varName(o), l = $(s + STORE), u;
	try {
		u = t.getSelectionComponent(s, o);
	} catch {
		return `!!${s}`;
	}
	if (u.project.timeUnit) {
		let n = r ?? t.component.data.raw, i = u.project.timeUnit.clone();
		n.parent ? i.insertAsParentOf(n) : n.parent = i;
	}
	let d = `${u.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest("}${l}, ${i}${u.resolve === "global" ? ")" : `, ${$(u.resolve)})`}`, f = `length(data(${l}))`;
	return n.empty === !1 ? `${f} && ${d}` : `!${f} || ${d}`;
}
function parseSelectionExtent(t, n, r) {
	let i = varName(n), o = r.encoding, s = r.field, l;
	try {
		l = t.getSelectionComponent(i, n);
	} catch {
		return i;
	}
	if (!o && !s) s = l.project.items[0].field, l.project.items.length > 1 && warn(selectionAsScaleDomainWithoutField(s));
	else if (o && !s) {
		let t = l.project.items.filter((t) => t.channel === o);
		!t.length || t.length > 1 ? (s = l.project.items[0].field, warn(selectionAsScaleDomainWrongEncodings(t, o, r, s))) : s = t[0].field;
	}
	return `${l.name}[${$(replacePathInField(s))}]`;
}
function materializeSelections(t, n) {
	for (let [r, i] of entries$1(t.component.selection ?? {})) {
		let o = t.getName(`lookup_${r}`);
		t.component.data.outputNodes[o] = i.materialized = new OutputNode(new FilterNode(n, t, { param: r }), o, DataSourceType.Lookup, t.component.data.outputNodeRefCounts);
	}
}
function expression$1(t, n, r) {
	return logicalExpr(n, (n) => isString(n) ? n : isSelectionPredicate(n) ? parseSelectionPredicate(t, n, r) : fieldFilterExpression(n));
}
function assembleTitle(t, n) {
	if (t) return isArray(t) && !isText(t) ? t.map((t) => defaultTitle(t, n)).join(", ") : t;
}
function setAxisEncode(t, n, r, i) {
	t.encode ??= {}, t.encode[n] ??= {}, t.encode[n].update ??= {}, t.encode[n].update[r] = i;
}
function assembleAxis(t, n, r, i = { header: !1 }) {
	let { disable: o, orient: s, scale: l, labelExpr: u, title: d, zindex: f,...p } = t.combine();
	if (!o) {
		for (let t in p) {
			let r = t, i = AXIS_PROPERTY_TYPE[r], o = p[r];
			if (i && i !== n && i !== "both") delete p[r];
			else if (isConditionalAxisValue(o)) {
				let { condition: t,...n } = o, i = array(t), s = CONDITIONAL_AXIS_PROP_INDEX[r];
				if (s) {
					let { vgProp: t, part: o } = s;
					setAxisEncode(p, o, t, [...i.map((t) => {
						let { test: n,...r } = t;
						return {
							test: expression$1(null, n),
							...r
						};
					}), n]), delete p[r];
				} else s === null && (p[r] = { signal: i.map((t) => {
					let { test: n,...r } = t;
					return `${expression$1(null, n)} ? ${exprFromValueRefOrSignalRef(r)} : `;
				}).join("") + exprFromValueRefOrSignalRef(n) });
			} else if (isSignalRef(o)) {
				let t = CONDITIONAL_AXIS_PROP_INDEX[r];
				if (t) {
					let { vgProp: n, part: i } = t;
					setAxisEncode(p, i, n, o), delete p[r];
				}
			}
			contains(["labelAlign", "labelBaseline"], r) && p[r] === null && delete p[r];
		}
		if (n === "grid") {
			if (!p.grid) return;
			if (p.encode) {
				let { grid: t } = p.encode;
				p.encode = { ...t ? { grid: t } : {} }, isEmpty(p.encode) && delete p.encode;
			}
			return {
				scale: l,
				orient: s,
				...p,
				domain: !1,
				labels: !1,
				aria: !1,
				maxExtent: 0,
				minExtent: 0,
				ticks: !1,
				zindex: getFirstDefined(f, 0)
			};
		} else {
			if (!i.header && t.mainExtracted) return;
			if (u !== void 0) {
				let t = u;
				p.encode?.labels?.update && isSignalRef(p.encode.labels.update.text) && (t = replaceAll(u, "datum.label", p.encode.labels.update.text.signal)), setAxisEncode(p, "labels", "text", { signal: t });
			}
			if (p.labelAlign === null && delete p.labelAlign, p.encode) {
				for (let n of AXIS_PARTS) t.hasAxisPart(n) || delete p.encode[n];
				isEmpty(p.encode) && delete p.encode;
			}
			let n = assembleTitle(d, r);
			return {
				scale: l,
				orient: s,
				grid: !1,
				...n ? { title: n } : {},
				...p,
				...r.aria === !1 ? { aria: !1 } : {},
				zindex: getFirstDefined(f, 0)
			};
		}
	}
}
function assembleAxisSignals(t) {
	let { axes: n } = t.component, r = [];
	for (let i of POSITION_SCALE_CHANNELS) if (n[i]) {
		for (let o of n[i]) if (!o.get("disable") && !o.get("gridScale")) {
			let n = i === "x" ? "height" : "width", o = t.getSizeSignalRef(n).signal;
			n !== o && r.push({
				name: n,
				update: o
			});
		}
	}
	return r;
}
function assembleAxes(t, n) {
	let { x: r = [], y: i = [] } = t;
	return [
		...r.map((t) => assembleAxis(t, "grid", n)),
		...i.map((t) => assembleAxis(t, "grid", n)),
		...r.map((t) => assembleAxis(t, "main", n)),
		...i.map((t) => assembleAxis(t, "main", n))
	].filter((t) => t);
}
function getAxisConfigFromConfigTypes(t, n, r, i) {
	return Object.assign.apply(null, [{}, ...t.map((t) => {
		if (t === "axisOrient") {
			let t = r === "x" ? "bottom" : "left", o = n[r === "x" ? "axisBottom" : "axisLeft"] || {}, s = n[r === "x" ? "axisTop" : "axisRight"] || {}, l = new Set([...keys(o), ...keys(s)]), u = {};
			for (let n of l.values()) u[n] = { signal: `${i.signal} === "${t}" ? ${signalOrStringValue(o[n])} : ${signalOrStringValue(s[n])}` };
			return u;
		}
		return n[t];
	})]);
}
function getAxisConfigs(t, n, r, i) {
	let o = n === "band" ? ["axisDiscrete", "axisBand"] : n === "point" ? ["axisDiscrete", "axisPoint"] : isQuantitative(n) ? ["axisQuantitative"] : n === "time" || n === "utc" ? ["axisTemporal"] : [], s = t === "x" ? "axisX" : "axisY", l = isSignalRef(r) ? "axisOrient" : `axis${titleCase(r)}`, u = [...o, ...o.map((t) => s + t.substr(4))], d = [
		"axis",
		l,
		s
	];
	return {
		vlOnlyAxisConfig: getAxisConfigFromConfigTypes(u, i, t, r),
		vgAxisConfig: getAxisConfigFromConfigTypes(d, i, t, r),
		axisConfigStyle: getAxisConfigStyle([...d, ...u], i)
	};
}
function getAxisConfigStyle(t, n) {
	let r = [{}];
	for (let i of t) {
		let t = n[i]?.style;
		if (t) {
			t = array(t);
			for (let i of t) r.push(n.style[i]);
		}
	}
	return Object.assign.apply(null, r);
}
function getAxisConfig(t, n, r, i = {}) {
	let o = getStyleConfig(t, r, n);
	if (o !== void 0) return {
		configFrom: "style",
		configValue: o
	};
	for (let n of [
		"vlOnlyAxisConfig",
		"vgAxisConfig",
		"axisConfigStyle"
	]) if (i[n]?.[t] !== void 0) return {
		configFrom: n,
		configValue: i[n][t]
	};
	return {};
}
var axisRules = {
	scale: ({ model: t, channel: n }) => t.scaleName(n),
	format: ({ format: t }) => t,
	formatType: ({ formatType: t }) => t,
	grid: ({ fieldOrDatumDef: t, axis: n, scaleType: r }) => n.grid ?? defaultGrid(r, t),
	gridScale: ({ model: t, channel: n }) => gridScale(t, n),
	labelAlign: ({ axis: t, labelAngle: n, orient: r, channel: i }) => t.labelAlign || defaultLabelAlign(n, r, i),
	labelAngle: ({ labelAngle: t }) => t,
	labelBaseline: ({ axis: t, labelAngle: n, orient: r, channel: i }) => t.labelBaseline || defaultLabelBaseline(n, r, i),
	labelFlush: ({ axis: t, fieldOrDatumDef: n, channel: r }) => t.labelFlush ?? defaultLabelFlush(n.type, r),
	labelOverlap: ({ axis: t, fieldOrDatumDef: n, scaleType: r }) => t.labelOverlap ?? defaultLabelOverlap$1(n.type, r, isFieldDef(n) && !!n.timeUnit, isFieldDef(n) ? n.sort : void 0),
	orient: ({ orient: t }) => t,
	tickCount: ({ channel: t, model: n, axis: r, fieldOrDatumDef: i, scaleType: o }) => {
		let s = t === "x" ? "width" : t === "y" ? "height" : void 0, l = s ? n.getSizeSignalRef(s) : void 0;
		return r.tickCount ?? defaultTickCount({
			fieldOrDatumDef: i,
			scaleType: o,
			size: l,
			values: r.values
		});
	},
	tickMinStep: ({ axis: t, format: n, fieldOrDatumDef: r }) => t.tickMinStep ?? defaultTickMinStep({
		format: n,
		fieldOrDatumDef: r
	}),
	title: ({ axis: t, model: n, channel: r }) => {
		if (t.title !== void 0) return t.title;
		let i = getFieldDefTitle(n, r);
		if (i !== void 0) return i;
		let o = n.typedFieldDef(r), s = r === "x" ? "x2" : "y2", l = n.fieldDef(s);
		return mergeTitleFieldDefs(o ? [toFieldDefBase(o)] : [], isFieldDef(l) ? [toFieldDefBase(l)] : []);
	},
	values: ({ axis: t, fieldOrDatumDef: n }) => values$1(t, n),
	zindex: ({ axis: t, fieldOrDatumDef: n, mark: r }) => t.zindex ?? defaultZindex(r, n)
};
function defaultGrid(t, n) {
	return !hasDiscreteDomain(t) && isFieldDef(n) && !isBinning(n?.bin) && !isBinned(n?.bin);
}
function gridScale(t, n) {
	let r = n === "x" ? "y" : "x";
	if (t.getScaleComponent(r)) return t.scaleName(r);
}
function getLabelAngle(t, n, r, i, o) {
	let s = n?.labelAngle;
	if (s !== void 0) return isSignalRef(s) ? s : normalizeAngle(s);
	{
		let { configValue: s } = getAxisConfig("labelAngle", i, n?.style, o);
		return s === void 0 ? r === X && contains([NOMINAL, ORDINAL], t.type) && !(isFieldDef(t) && t.timeUnit) ? 270 : void 0 : normalizeAngle(s);
	}
}
function normalizeAngleExpr(t) {
	return `(((${t.signal} % 360) + 360) % 360)`;
}
function defaultLabelBaseline(t, n, r, i) {
	if (t !== void 0) if (r === "x") {
		if (isSignalRef(t)) {
			let r = normalizeAngleExpr(t);
			return { signal: `(45 < ${r} && ${r} < 135) || (225 < ${r} && ${r} < 315) ? "middle" :(${r} <= 45 || 315 <= ${r}) === ${isSignalRef(n) ? `(${n.signal} === "top")` : n === "top"} ? "bottom" : "top"` };
		}
		if (45 < t && t < 135 || 225 < t && t < 315) return "middle";
		if (isSignalRef(n)) {
			let r = t <= 45 || 315 <= t ? "===" : "!==";
			return { signal: `${n.signal} ${r} "top" ? "bottom" : "top"` };
		}
		return (t <= 45 || 315 <= t) == (n === "top") ? "bottom" : "top";
	} else {
		if (isSignalRef(t)) {
			let r = normalizeAngleExpr(t), o = isSignalRef(n) ? `(${n.signal} === "left")` : n === "left";
			return { signal: `${r} <= 45 || 315 <= ${r} || (135 <= ${r} && ${r} <= 225) ? ${i ? "\"middle\"" : "null"} : (45 <= ${r} && ${r} <= 135) === ${o} ? "top" : "bottom"` };
		}
		if (t <= 45 || 315 <= t || 135 <= t && t <= 225) return i ? "middle" : null;
		if (isSignalRef(n)) {
			let r = 45 <= t && t <= 135 ? "===" : "!==";
			return { signal: `${n.signal} ${r} "left" ? "top" : "bottom"` };
		}
		return (45 <= t && t <= 135) == (n === "left") ? "top" : "bottom";
	}
}
function defaultLabelAlign(t, n, r) {
	if (t === void 0) return;
	let i = r === "x", o = i ? 0 : 90, s = i ? "bottom" : "left";
	if (isSignalRef(t)) {
		let r = normalizeAngleExpr(t), l = isSignalRef(n) ? `(${n.signal} === "${s}")` : n === s;
		return { signal: `(${o ? `(${r} + 90)` : r} % 180 === 0) ? ${i ? null : "\"center\""} :(${o} < ${r} && ${r} < ${180 + o}) === ${l} ? "left" : "right"` };
	}
	if ((t + o) % 180 == 0) return i ? null : "center";
	if (isSignalRef(n)) {
		let r = o < t && t < 180 + o ? "===" : "!==";
		return { signal: `${`${n.signal} ${r} "${s}"`} ? "left" : "right"` };
	}
	return (o < t && t < 180 + o) == (n === s) ? "left" : "right";
}
function defaultLabelFlush(t, n) {
	if (n === "x" && contains(["quantitative", "temporal"], t)) return !0;
}
function defaultLabelOverlap$1(t, n, r, i) {
	if (r && !isObject(i) || t !== "nominal" && t !== "ordinal") return n === "log" || n === "symlog" ? "greedy" : !0;
}
function defaultOrient(t) {
	return t === "x" ? "bottom" : "left";
}
function defaultTickCount({ fieldOrDatumDef: t, scaleType: n, size: r, values: i }) {
	if (!i && !hasDiscreteDomain(n) && n !== "log") {
		if (isFieldDef(t)) {
			if (isBinning(t.bin)) return { signal: `ceil(${r.signal}/10)` };
			if (t.timeUnit && contains([
				"month",
				"hours",
				"day",
				"quarter"
			], normalizeTimeUnit(t.timeUnit)?.unit)) return;
		}
		return { signal: `ceil(${r.signal}/40)` };
	}
}
function defaultTickMinStep({ format: t, fieldOrDatumDef: n }) {
	if (t === "d") return 1;
	if (isFieldDef(n)) {
		let { timeUnit: t } = n;
		if (t) {
			let n = durationExpr(t);
			if (n) return { signal: n };
		}
	}
}
function getFieldDefTitle(t, n) {
	let r = n === "x" ? "x2" : "y2", i = t.fieldDef(n), o = t.fieldDef(r), s = i ? i.title : void 0, l = o ? o.title : void 0;
	if (s && l) return mergeTitle(s, l);
	if (s) return s;
	if (l) return l;
	if (s !== void 0) return s;
	if (l !== void 0) return l;
}
function values$1(t, n) {
	let r = t.values;
	if (isArray(r)) return valueArray(n, r);
	if (isSignalRef(r)) return r;
}
function defaultZindex(t, n) {
	return t === "rect" && isDiscrete(n) ? 1 : 0;
}
var CalculateNode = class t extends DataFlowNode {
	transform;
	_dependentFields;
	clone() {
		return new t(null, duplicate(this.transform));
	}
	constructor(t, n) {
		super(t), this.transform = n, this._dependentFields = getDependentFields(this.transform.calculate);
	}
	static parseAllForSortIndex(n, r) {
		return r.forEachFieldDef((r, i) => {
			if (isScaleFieldDef(r) && isSortArray(r.sort)) {
				let { field: o, timeUnit: s } = r, l = r.sort, u = l.map((t, n) => `${fieldFilterExpression({
					field: o,
					timeUnit: s,
					equal: t
				})} ? ${n} : `).join("") + l.length;
				n = new t(n, {
					calculate: u,
					as: sortArrayIndexField(r, i, { forAs: !0 })
				});
			}
		}), n;
	}
	producedFields() {
		return new Set([this.transform.as]);
	}
	dependentFields() {
		return this._dependentFields;
	}
	assemble() {
		return {
			type: "formula",
			expr: this.transform.calculate,
			as: this.transform.as
		};
	}
	hash() {
		return `Calculate ${hash(this.transform)}`;
	}
};
function sortArrayIndexField(t, n, r) {
	return vgField(t, {
		prefix: n,
		suffix: "sort_index",
		...r
	});
}
function getHeaderChannel(t, n) {
	return contains(["top", "bottom"], n) ? "column" : contains(["left", "right"], n) || t === "row" ? "row" : "column";
}
function getHeaderProperty(t, n, r, i) {
	let o = i === "row" ? r.headerRow : i === "column" ? r.headerColumn : r.headerFacet;
	return getFirstDefined((n || {})[t], o[t], r.header[t]);
}
function getHeaderProperties(t, n, r, i) {
	let o = {};
	for (let s of t) {
		let t = getHeaderProperty(s, n || {}, r, i);
		t !== void 0 && (o[s] = t);
	}
	return o;
}
var HEADER_CHANNELS = ["row", "column"], HEADER_TYPES = ["header", "footer"];
function assembleTitleGroup(t, n) {
	let r = t.component.layoutHeaders[n].title, i = t.config ? t.config : void 0, o = t.component.layoutHeaders[n].facetFieldDef ? t.component.layoutHeaders[n].facetFieldDef : void 0, { titleAnchor: s, titleAngle: l, titleOrient: u } = getHeaderProperties([
		"titleAnchor",
		"titleAngle",
		"titleOrient"
	], o.header, i, n), d = getHeaderChannel(n, u), f = normalizeAngle(l);
	return {
		name: `${n}-title`,
		type: "group",
		role: `${d}-title`,
		title: {
			text: r,
			...n === "row" ? { orient: "left" } : {},
			style: "guide-title",
			...defaultHeaderGuideBaseline(f, d),
			...defaultHeaderGuideAlign(d, f, s),
			...assembleHeaderProperties(i, o, n, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP)
		}
	};
}
function defaultHeaderGuideAlign(t, n, r = "middle") {
	switch (r) {
		case "start": return { align: "left" };
		case "end": return { align: "right" };
	}
	let i = defaultLabelAlign(n, t === "row" ? "left" : "top", t === "row" ? "y" : "x");
	return i ? { align: i } : {};
}
function defaultHeaderGuideBaseline(t, n) {
	let r = defaultLabelBaseline(t, n === "row" ? "left" : "top", n === "row" ? "y" : "x", !0);
	return r ? { baseline: r } : {};
}
function assembleHeaderGroups(t, n) {
	let r = t.component.layoutHeaders[n], i = [];
	for (let o of HEADER_TYPES) if (r[o]) for (let s of r[o]) {
		let l = assembleHeaderGroup(t, n, o, r, s);
		l != null && i.push(l);
	}
	return i;
}
function getSort$1(t, n) {
	let { sort: r } = t;
	return isSortField(r) ? {
		field: vgField(r, { expr: "datum" }),
		order: r.order ?? "ascending"
	} : isArray(r) ? {
		field: sortArrayIndexField(t, n, { expr: "datum" }),
		order: "ascending"
	} : {
		field: vgField(t, { expr: "datum" }),
		order: r ?? "ascending"
	};
}
function assembleLabelTitle(t, n, r) {
	let { format: i, formatType: o, labelAngle: s, labelAnchor: l, labelOrient: u, labelExpr: d } = getHeaderProperties([
		"format",
		"formatType",
		"labelAngle",
		"labelAnchor",
		"labelOrient",
		"labelExpr"
	], t.header, r, n), f = formatSignalRef({
		fieldOrDatumDef: t,
		format: i,
		formatType: o,
		expr: "parent",
		config: r
	}).signal, p = getHeaderChannel(n, u);
	return {
		text: { signal: d ? replaceAll(replaceAll(d, "datum.label", f), "datum.value", vgField(t, { expr: "parent" })) : f },
		...n === "row" ? { orient: "left" } : {},
		style: "guide-label",
		frame: "group",
		...defaultHeaderGuideBaseline(s, p),
		...defaultHeaderGuideAlign(p, s, l),
		...assembleHeaderProperties(r, t, n, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP)
	};
}
function assembleHeaderGroup(t, n, r, i, o) {
	if (o) {
		let s = null, { facetFieldDef: l } = i, u = t.config ? t.config : void 0;
		if (l && o.labels) {
			let { labelOrient: t } = getHeaderProperties(["labelOrient"], l.header, u, n);
			(n === "row" && !contains(["top", "bottom"], t) || n === "column" && !contains(["left", "right"], t)) && (s = assembleLabelTitle(l, n, u));
		}
		let d = isFacetModel(t) && !isFacetMapping(t.facet), f = o.axes, p = f?.length > 0;
		if (s || p) {
			let u = n === "row" ? "height" : "width";
			return {
				name: t.getName(`${n}_${r}`),
				type: "group",
				role: `${n}-${r}`,
				...i.facetFieldDef ? {
					from: { data: t.getName(`${n}_domain`) },
					sort: getSort$1(l, n)
				} : {},
				...p && d ? { from: { data: t.getName(`facet_domain_${n}`) } } : {},
				...s ? { title: s } : {},
				...o.sizeSignal ? { encode: { update: { [u]: o.sizeSignal } } } : {},
				...p ? { axes: f } : {}
			};
		}
	}
	return null;
}
var LAYOUT_TITLE_BAND = {
	column: {
		start: 0,
		end: 1
	},
	row: {
		start: 1,
		end: 0
	}
};
function getLayoutTitleBand(t, n) {
	return LAYOUT_TITLE_BAND[n][t];
}
function assembleLayoutTitleBand(t, n) {
	let r = {};
	for (let i of FACET_CHANNELS) {
		let o = t[i];
		if (o?.facetFieldDef) {
			let { titleAnchor: t, titleOrient: s } = getHeaderProperties(["titleAnchor", "titleOrient"], o.facetFieldDef.header, n, i), l = getHeaderChannel(i, s), u = getLayoutTitleBand(t, l);
			u !== void 0 && (r[l] = u);
		}
	}
	return isEmpty(r) ? void 0 : r;
}
function assembleHeaderProperties(t, n, r, i, o) {
	let s = {};
	for (let l of i) {
		if (!o[l]) continue;
		let i = getHeaderProperty(l, n?.header, t, r);
		i !== void 0 && (s[o[l]] = i);
	}
	return s;
}
function assembleLayoutSignals(t) {
	return [
		...sizeSignals(t, "width"),
		...sizeSignals(t, "height"),
		...sizeSignals(t, "childWidth"),
		...sizeSignals(t, "childHeight")
	];
}
function sizeSignals(t, n) {
	let r = n === "width" ? "x" : "y", i = t.component.layoutSize.get(n);
	if (i == null || i === "merged") return [];
	let o = t.getSizeSignalRef(n).signal;
	if (i === "step") {
		let n = t.getScaleComponent(r);
		if (n) {
			let i = n.get("type"), s = n.get("range");
			if (hasDiscreteDomain(i) && isVgRangeStep(s)) {
				let i = t.scaleName(r);
				return isFacetModel(t.parent) && t.parent.component.resolve.scale[r] === "independent" ? [stepSignal(i, s)] : [stepSignal(i, s), {
					name: o,
					update: sizeExpr(i, n, `domain('${i}').length`)
				}];
			}
		}
		/* istanbul ignore next: Condition should not happen -- only for warning in development. */
		throw Error("layout size is step although width/height is not step.");
	} else if (i == "container") {
		let n = o.endsWith("width"), r = n ? "containerSize()[0]" : "containerSize()[1]", i = `isFinite(${r}) ? ${r} : ${getViewConfigContinuousSize(t.config.view, n ? "width" : "height")}`;
		return [{
			name: o,
			init: i,
			on: [{
				update: i,
				events: "window:resize"
			}]
		}];
	} else return [{
		name: o,
		value: i
	}];
}
function stepSignal(t, n) {
	let r = `${t}_step`;
	return isSignalRef(n.step) ? {
		name: r,
		update: n.step.signal
	} : {
		name: r,
		value: n.step
	};
}
function sizeExpr(t, n, r) {
	let i = n.get("type"), o = n.get("padding"), s = getFirstDefined(n.get("paddingOuter"), o), l = n.get("paddingInner");
	return l = i === "band" ? l === void 0 ? o : l : 1, `bandspace(${r}, ${signalOrStringValue(l)}, ${signalOrStringValue(s)}) * ${t}_step`;
}
function getSizeTypeFromLayoutSizeType(t) {
	return t === "childWidth" ? "width" : t === "childHeight" ? "height" : t;
}
function guideEncodeEntry(t, n) {
	return keys(t).reduce((r, i) => ({
		...r,
		...wrapCondition({
			model: n,
			channelDef: t[i],
			vgChannel: i,
			mainRefFn: (t) => signalOrValueRef(t.value),
			invalidValueRef: void 0
		})
	}), {});
}
function defaultScaleResolve(t, n) {
	if (isFacetModel(n)) return t === "theta" ? "independent" : "shared";
	if (isLayerModel(n)) return "shared";
	if (isConcatModel(n)) return isXorY(t) || t === "theta" || t === "radius" ? "independent" : "shared";
	/* istanbul ignore next: should never reach here. */
	throw Error("invalid model type for resolve");
}
function parseGuideResolve(t, n) {
	let r = t.scale[n], i = isXorY(n) ? "axis" : "legend";
	return r === "independent" ? (t[i][n] === "shared" && warn(independentScaleMeansIndependentGuide(n)), "independent") : t[i][n] || "shared";
}
var LEGEND_COMPONENT_PROPERTIES = keys({
	...COMMON_LEGEND_PROPERTY_INDEX,
	disable: 1,
	labelExpr: 1,
	selections: 1,
	opacity: 1,
	shape: 1,
	stroke: 1,
	fill: 1,
	size: 1,
	strokeWidth: 1,
	strokeDash: 1,
	encode: 1
}), LegendComponent = class extends Split {}, legendEncodeRules = {
	symbols,
	gradient,
	labels: labels$1,
	entries
};
function symbols(t, { fieldOrDatumDef: n, model: r, channel: i, legendCmpt: o, legendType: s }) {
	if (s !== "symbol") return;
	let { markDef: l, encoding: u, config: d, mark: f } = r, p = l.filled && f !== "trail", g = {
		...applyMarkConfig({}, r, FILL_STROKE_CONFIG),
		...color(r, { filled: p })
	}, _ = o.get("symbolOpacity") ?? d.legend.symbolOpacity, v = o.get("symbolFillColor") ?? d.legend.symbolFillColor, S = o.get("symbolStrokeColor") ?? d.legend.symbolStrokeColor, T = _ === void 0 ? getMaxValue(u.opacity) ?? l.opacity : void 0;
	if (g.fill) {
		if (i === "fill" || p && i === COLOR) delete g.fill;
		else if (hasProperty(g.fill, "field")) v ? delete g.fill : (g.fill = signalOrValueRef(d.legend.symbolBaseFillColor ?? "black"), g.fillOpacity = signalOrValueRef(T ?? 1));
		else if (isArray(g.fill)) {
			let t = getFirstConditionValue(u.fill ?? u.color) ?? l.fill ?? (p && l.color);
			t && (g.fill = signalOrValueRef(t));
		}
	}
	if (g.stroke) {
		if (i === "stroke" || !p && i === COLOR) delete g.stroke;
		else if (hasProperty(g.stroke, "field") || S) delete g.stroke;
		else if (isArray(g.stroke)) {
			let t = getFirstDefined(getFirstConditionValue(u.stroke || u.color), l.stroke, p ? l.color : void 0);
			t && (g.stroke = { value: t });
		}
	}
	if (i !== OPACITY) {
		let t = isFieldDef(n) && selectedCondition(r, o, n);
		t ? g.opacity = [{
			test: t,
			...signalOrValueRef(T ?? 1)
		}, signalOrValueRef(d.legend.unselectedOpacity)] : T && (g.opacity = signalOrValueRef(T));
	}
	return g = {
		...g,
		...t
	}, isEmpty(g) ? void 0 : g;
}
function gradient(t, { model: n, legendType: r, legendCmpt: i }) {
	if (r !== "gradient") return;
	let { config: o, markDef: s, encoding: l } = n, u = {}, d = (i.get("gradientOpacity") ?? o.legend.gradientOpacity) === void 0 ? getMaxValue(l.opacity) || s.opacity : void 0;
	return d && (u.opacity = signalOrValueRef(d)), u = {
		...u,
		...t
	}, isEmpty(u) ? void 0 : u;
}
function labels$1(t, { fieldOrDatumDef: n, model: r, channel: i, legendCmpt: o }) {
	let s = r.legend(i) || {}, l = r.config, u = isFieldDef(n) ? selectedCondition(r, o, n) : void 0, d = u ? [{
		test: u,
		value: 1
	}, { value: l.legend.unselectedOpacity }] : void 0, { format: f, formatType: p } = s, g;
	isCustomFormatType(p) ? g = formatCustomType({
		fieldOrDatumDef: n,
		field: "datum.value",
		format: f,
		formatType: p,
		config: l
	}) : f === void 0 && p === void 0 && l.customFormatTypes && (n.type === "quantitative" && l.numberFormatType ? g = formatCustomType({
		fieldOrDatumDef: n,
		field: "datum.value",
		format: l.numberFormat,
		formatType: l.numberFormatType,
		config: l
	}) : n.type === "temporal" && l.timeFormatType && isFieldDef(n) && n.timeUnit === void 0 && (g = formatCustomType({
		fieldOrDatumDef: n,
		field: "datum.value",
		format: l.timeFormat,
		formatType: l.timeFormatType,
		config: l
	})));
	let _ = {
		...d ? { opacity: d } : {},
		...g ? { text: g } : {},
		...t
	};
	return isEmpty(_) ? void 0 : _;
}
function entries(t, { legendCmpt: n }) {
	return n.get("selections")?.length ? {
		...t,
		fill: { value: "transparent" }
	} : t;
}
function getMaxValue(t) {
	return getConditionValue(t, (t, n) => Math.max(t, n.value));
}
function getFirstConditionValue(t) {
	return getConditionValue(t, (t, n) => getFirstDefined(t, n.value));
}
function getConditionValue(t, n) {
	if (hasConditionalValueDef(t)) return array(t.condition).reduce(n, t.value);
	if (isValueDef(t)) return t.value;
}
function selectedCondition(t, n, r) {
	let i = n.get("selections");
	if (!i?.length) return;
	let o = $(r.field);
	return i.map((t) => `(!length(data(${$(varName(t) + STORE)})) || (${t}[${o}] && indexof(${t}[${o}], datum.value) >= 0))`).join(" || ");
}
var legendRules = {
	direction: ({ direction: t }) => t,
	format: ({ fieldOrDatumDef: t, legend: n, config: r }) => {
		let { format: i, formatType: o } = n;
		return guideFormat(t, t.type, i, o, r, !1);
	},
	formatType: ({ legend: t, fieldOrDatumDef: n, scaleType: r }) => {
		let { formatType: i } = t;
		return guideFormatType(i, n, r);
	},
	gradientLength: (t) => {
		let { legend: n, legendConfig: r } = t;
		return n.gradientLength ?? r.gradientLength ?? defaultGradientLength(t);
	},
	labelOverlap: ({ legend: t, legendConfig: n, scaleType: r }) => t.labelOverlap ?? n.labelOverlap ?? defaultLabelOverlap(r),
	symbolType: ({ legend: t, markDef: n, channel: r, encoding: i }) => t.symbolType ?? defaultSymbolType(n.type, r, i.shape, n.shape),
	title: ({ fieldOrDatumDef: t, config: n }) => title(t, n, { allowDisabling: !0 }),
	type: ({ legendType: t, scaleType: n, channel: r }) => {
		if (isColorChannel(r) && isContinuousToContinuous(n)) {
			if (t === "gradient") return;
		} else if (t === "symbol") return;
		return t;
	},
	values: ({ fieldOrDatumDef: t, legend: n }) => values(n, t)
};
function values(t, n) {
	let r = t.values;
	if (isArray(r)) return valueArray(n, r);
	if (isSignalRef(r)) return r;
}
function defaultSymbolType(t, n, r, i) {
	if (n !== "shape") {
		let t = getFirstConditionValue(r) ?? i;
		if (t) return t;
	}
	switch (t) {
		case "bar":
		case "rect":
		case "image":
		case "square": return "square";
		case "line":
		case "trail":
		case "rule": return "stroke";
		case "arc":
		case "point":
		case "circle":
		case "tick":
		case "geoshape":
		case "area":
		case "text": return "circle";
	}
}
function getLegendType(t) {
	let { legend: n } = t;
	return getFirstDefined(n.type, defaultType$1(t));
}
function defaultType$1({ channel: t, timeUnit: n, scaleType: r }) {
	if (isColorChannel(t)) {
		if (contains([
			"quarter",
			"month",
			"day"
		], n)) return "symbol";
		if (isContinuousToContinuous(r)) return "gradient";
	}
	return "symbol";
}
function getDirection({ legendConfig: t, legendType: n, orient: r, legend: i }) {
	return i.direction ?? t[n ? "gradientDirection" : "symbolDirection"] ?? defaultDirection(r, n);
}
function defaultDirection(t, n) {
	switch (t) {
		case "top":
		case "bottom": return "horizontal";
		case "left":
		case "right":
		case "none":
		case void 0: return;
		default: return n === "gradient" ? "horizontal" : void 0;
	}
}
function defaultGradientLength({ legendConfig: t, model: n, direction: r, orient: i, scaleType: o }) {
	let { gradientHorizontalMaxLength: s, gradientHorizontalMinLength: l, gradientVerticalMaxLength: u, gradientVerticalMinLength: d } = t;
	if (isContinuousToContinuous(o)) return r === "horizontal" ? i === "top" || i === "bottom" ? gradientLengthSignal(n, "width", l, s) : l : gradientLengthSignal(n, "height", d, u);
}
function gradientLengthSignal(t, n, r, i) {
	return { signal: `clamp(${t.getSizeSignalRef(n).signal}, ${r}, ${i})` };
}
function defaultLabelOverlap(t) {
	if (contains([
		"quantile",
		"threshold",
		"log",
		"symlog"
	], t)) return "greedy";
}
function parseLegend(t) {
	let n = isUnitModel(t) ? parseUnitLegend(t) : parseNonUnitLegend(t);
	return t.component.legends = n, n;
}
function parseUnitLegend(t) {
	let { encoding: n } = t, r = {};
	for (let i of [COLOR, ...LEGEND_SCALE_CHANNELS]) {
		let o = getFieldOrDatumDef(n[i]);
		!o || !t.getScaleComponent(i) || i === SHAPE && isFieldDef(o) && o.type === GEOJSON || (r[i] = parseLegendForChannel(t, i));
	}
	return r;
}
function getLegendDefWithScale(t, n) {
	let r = t.scaleName(n);
	if (t.mark === "trail") {
		if (n === "color") return { stroke: r };
		if (n === "size") return { strokeWidth: r };
	}
	return n === "color" ? t.markDef.filled ? { fill: r } : { stroke: r } : { [n]: r };
}
function isExplicit$1(t, n, r, i) {
	switch (n) {
		case "disable": return r !== void 0;
		case "values": return !!r?.values;
		case "title": if (n === "title" && t === i?.title) return !0;
	}
	return t === (r || {})[n];
}
function parseLegendForChannel(t, n) {
	let r = t.legend(n), { markDef: i, encoding: o, config: s } = t, l = s.legend, u = new LegendComponent({}, getLegendDefWithScale(t, n));
	parseInteractiveLegend(t, n, u);
	let d = r === void 0 ? l.disable : !r;
	if (u.set("disable", d, r !== void 0), d) return u;
	r ||= {};
	let f = t.getScaleComponent(n).get("type"), p = getFieldOrDatumDef(o[n]), g = isFieldDef(p) ? normalizeTimeUnit(p.timeUnit)?.unit : void 0, _ = r.orient || s.legend.orient || "right", v = getLegendType({
		legend: r,
		channel: n,
		timeUnit: g,
		scaleType: f
	}), S = getDirection({
		legend: r,
		legendType: v,
		orient: _,
		legendConfig: l
	}), T = {
		legend: r,
		channel: n,
		model: t,
		markDef: i,
		encoding: o,
		fieldOrDatumDef: p,
		legendConfig: l,
		config: s,
		scaleType: f,
		orient: _,
		legendType: v,
		direction: S
	};
	for (let i of LEGEND_COMPONENT_PROPERTIES) {
		if (v === "gradient" && i.startsWith("symbol") || v === "symbol" && i.startsWith("gradient")) continue;
		let o = i in legendRules ? legendRules[i](T) : r[i];
		if (o !== void 0) {
			let l = isExplicit$1(o, i, r, t.fieldDef(n));
			(l || s.legend[i] === void 0) && u.set(i, o, l);
		}
	}
	let E = r?.encoding ?? {}, O = u.get("selections"), k = {}, A = {
		fieldOrDatumDef: p,
		model: t,
		channel: n,
		legendCmpt: u,
		legendType: v
	};
	for (let n of [
		"labels",
		"legend",
		"title",
		"symbols",
		"gradient",
		"entries"
	]) {
		let r = guideEncodeEntry(E[n] ?? {}, t), i = n in legendEncodeRules ? legendEncodeRules[n](r, A) : r;
		i !== void 0 && !isEmpty(i) && (k[n] = {
			...O?.length && isFieldDef(p) ? { name: `${varName(p.field)}_legend_${n}` } : {},
			...O?.length ? { interactive: !0 } : {},
			update: O?.length ? {
				...i,
				cursor: { value: "pointer" }
			} : i
		});
	}
	return isEmpty(k) || u.set("encode", k, !!r?.encoding), u;
}
function parseNonUnitLegend(t) {
	let { legends: n, resolve: r } = t.component;
	for (let i of t.children) {
		parseLegend(i);
		for (let o of keys(i.component.legends)) r.legend[o] = parseGuideResolve(t.component.resolve, o), r.legend[o] === "shared" && (n[o] = mergeLegendComponent(n[o], i.component.legends[o]), n[o] || (r.legend[o] = "independent", delete n[o]));
	}
	for (let i of keys(n)) for (let n of t.children) n.component.legends[i] && r.legend[i] === "shared" && delete n.component.legends[i];
	return n;
}
function mergeLegendComponent(t, n) {
	if (!t) return n.clone();
	let r = t.getWithExplicit("orient"), i = n.getWithExplicit("orient");
	if (r.explicit && i.explicit && r.value !== i.value) return;
	let o = !1;
	for (let r of LEGEND_COMPONENT_PROPERTIES) {
		let i = mergeValuesWithExplicit(t.getWithExplicit(r), n.getWithExplicit(r), r, "legend", (t, n) => {
			switch (r) {
				case "symbolType": return mergeSymbolType(t, n);
				case "title": return mergeTitleComponent(t, n);
				case "type": return o = !0, makeImplicit("symbol");
			}
			return defaultTieBreaker(t, n, r, "legend");
		});
		t.setWithExplicit(r, i);
	}
	return o && (t.implicit?.encode?.gradient && deleteNestedProperty(t.implicit, ["encode", "gradient"]), t.explicit?.encode?.gradient && deleteNestedProperty(t.explicit, ["encode", "gradient"])), t;
}
function mergeSymbolType(t, n) {
	return n.value === "circle" ? n : t;
}
function setLegendEncode(t, n, r, i) {
	t.encode ??= {}, t.encode[n] ??= {}, t.encode[n].update ??= {}, t.encode[n].update[r] = i;
}
function assembleLegends(t) {
	let n = t.component.legends, r = {};
	for (let i of keys(n)) {
		let o = stringify$2(t.getScaleComponent(i).get("domains"));
		if (r[o]) for (let t of r[o]) mergeLegendComponent(t, n[i]) || r[o].push(n[i]);
		else r[o] = [n[i].clone()];
	}
	return vals(r).flat().map((n) => assembleLegend(n, t.config)).filter((t) => t !== void 0);
}
function assembleLegend(t, n) {
	let { disable: r, labelExpr: i, selections: o,...s } = t.combine();
	if (!r) {
		if (n.aria === !1 && s.aria == null && (s.aria = !1), s.encode?.symbols) {
			let t = s.encode.symbols.update;
			t.fill && t.fill.value !== "transparent" && !t.stroke && !s.stroke && (t.stroke = { value: "transparent" });
			for (let n of LEGEND_SCALE_CHANNELS) s[n] && delete t[n];
		}
		if (s.title || delete s.title, i !== void 0) {
			let t = i;
			s.encode?.labels?.update && isSignalRef(s.encode.labels.update.text) && (t = replaceAll(i, "datum.label", s.encode.labels.update.text.signal)), setLegendEncode(s, "labels", "text", { signal: t });
		}
		return s;
	}
}
function assembleProjections(t) {
	return isLayerModel(t) || isConcatModel(t) ? assembleProjectionsForModelAndChildren(t) : assembleProjectionForModel(t);
}
function assembleProjectionsForModelAndChildren(t) {
	return t.children.reduce((t, n) => t.concat(n.assembleProjections()), assembleProjectionForModel(t));
}
function assembleProjectionForModel(t) {
	let n = t.component.projection;
	if (!n || n.merged) return [];
	let r = n.combine(), { name: i } = r;
	if (n.data) {
		let o = { signal: `[${n.size.map((t) => t.signal).join(", ")}]` }, s = n.data.reduce((n, r) => {
			let i = isSignalRef(r) ? r.signal : `data('${t.lookupDataSource(r)}')`;
			return contains(n, i) || n.push(i), n;
		}, []);
		if (s.length <= 0) throw Error("Projection's fit didn't find any data sources");
		return [{
			name: i,
			size: o,
			fit: { signal: s.length > 1 ? `[${s.join(", ")}]` : s[0] },
			...r
		}];
	} else return [{
		name: i,
		translate: { signal: "[width / 2, height / 2]" },
		...r
	}];
}
var PROJECTION_PROPERTIES = [
	"type",
	"clipAngle",
	"clipExtent",
	"center",
	"rotate",
	"precision",
	"reflectX",
	"reflectY",
	"coefficient",
	"distance",
	"fraction",
	"lobes",
	"parallel",
	"radius",
	"ratio",
	"spacing",
	"tilt"
], ProjectionComponent = class extends Split {
	specifiedProjection;
	size;
	data;
	merged = !1;
	constructor(t, n, r, i) {
		super({ ...n }, { name: t }), this.specifiedProjection = n, this.size = r, this.data = i;
	}
	get isFit() {
		return !!this.data;
	}
};
function parseProjection(t) {
	t.component.projection = isUnitModel(t) ? parseUnitProjection(t) : parseNonUnitProjections(t);
}
function parseUnitProjection(t) {
	if (t.hasProjection) {
		let n = replaceExprRef(t.specifiedProjection), r = !(n && (n.scale != null || n.translate != null)), i = r ? [t.getSizeSignalRef("width"), t.getSizeSignalRef("height")] : void 0, o = r ? gatherFitData(t) : void 0, s = new ProjectionComponent(t.projectionName(!0), {
			...replaceExprRef(t.config.projection),
			...n
		}, i, o);
		return s.get("type") || s.set("type", "equalEarth", !1), s;
	}
}
function gatherFitData(t) {
	let n = [], { encoding: r } = t;
	for (let i of [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]) (getFieldOrDatumDef(r[i[0]]) || getFieldOrDatumDef(r[i[1]])) && n.push({ signal: t.getName(`geojson_${n.length}`) });
	return t.channelHasField(SHAPE) && t.typedFieldDef(SHAPE).type === GEOJSON && n.push({ signal: t.getName(`geojson_${n.length}`) }), n.length === 0 && n.push(t.requestDataName(DataSourceType.Main)), n;
}
function mergeIfNoConflict(t, n) {
	let r = every(PROJECTION_PROPERTIES, (r) => !!(!has(t.explicit, r) && !has(n.explicit, r) || has(t.explicit, r) && has(n.explicit, r) && deepEqual(t.get(r), n.get(r))));
	if (deepEqual(t.size, n.size)) {
		if (r) return t;
		if (deepEqual(t.explicit, {})) return n;
		if (deepEqual(n.explicit, {})) return t;
	}
	return null;
}
function parseNonUnitProjections(t) {
	if (t.children.length === 0) return;
	let n;
	for (let n of t.children) parseProjection(n);
	let r = every(t.children, (t) => {
		let r = t.component.projection;
		if (r) if (n) {
			let t = mergeIfNoConflict(n, r);
			return t && (n = t), !!t;
		} else return n = r, !0;
		else return !0;
	});
	if (n && r) {
		let r = t.projectionName(!0), i = new ProjectionComponent(r, n.specifiedProjection, n.size, duplicate(n.data));
		for (let n of t.children) {
			let t = n.component.projection;
			t && (t.isFit && i.data.push(...n.component.projection.data), n.renameProjection(t.get("name"), r), t.merged = !0);
		}
		return i;
	}
}
function rangeFormula(t, n, r, i) {
	if (binRequiresRange(n, r)) {
		let o = isUnitModel(t) ? t.axis(r) ?? t.legend(r) ?? {} : {}, s = vgField(n, { expr: "datum" }), l = vgField(n, {
			expr: "datum",
			binSuffix: "end"
		});
		return {
			formulaAs: vgField(n, {
				binSuffix: "range",
				forAs: !0
			}),
			formula: binFormatExpression(s, l, o.format, o.formatType, i)
		};
	}
	return {};
}
function binKey(t, n) {
	return `${binToString(t)}_${n}`;
}
function getSignalsFromModel(t, n) {
	return {
		signal: t.getName(`${n}_bins`),
		extentSignal: t.getName(`${n}_extent`)
	};
}
function getBinSignalName(t, n, r) {
	let i = binKey(normalizeBin(r, void 0) ?? {}, n);
	return t.getName(`${i}_bins`);
}
function isBinTransform(t) {
	return "as" in t;
}
function createBinComponent(t, n, r) {
	let i, o;
	i = isBinTransform(t) ? isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]] : [vgField(t, { forAs: !0 }), vgField(t, {
		binSuffix: "end",
		forAs: !0
	})];
	let s = { ...normalizeBin(n, void 0) }, l = binKey(s, t.field), { signal: u, extentSignal: d } = getSignalsFromModel(r, l);
	if (isParameterExtent(s.extent)) {
		let t = s.extent;
		o = parseSelectionExtent(r, t.param, t), delete s.extent;
	}
	return {
		key: l,
		binComponent: {
			bin: s,
			field: t.field,
			as: [i],
			...u ? { signal: u } : {},
			...d ? { extentSignal: d } : {},
			...o ? { span: o } : {}
		}
	};
}
var BinNode = class t extends DataFlowNode {
	bins;
	clone() {
		return new t(null, duplicate(this.bins));
	}
	constructor(t, n) {
		super(t), this.bins = n;
	}
	static makeFromEncoding(n, r) {
		let i = r.reduceFieldDef((t, n, i) => {
			if (isTypedFieldDef(n) && isBinning(n.bin)) {
				let { key: o, binComponent: s } = createBinComponent(n, n.bin, r);
				t[o] = {
					...s,
					...t[o],
					...rangeFormula(r, n, i, r.config)
				};
			}
			return t;
		}, {});
		return isEmpty(i) ? null : new t(n, i);
	}
	static makeFromTransform(n, r, i) {
		let { key: o, binComponent: s } = createBinComponent(r, r.bin, i);
		return new t(n, { [o]: s });
	}
	merge(t, n) {
		for (let r of keys(t.bins)) r in this.bins ? (n(t.bins[r].signal, this.bins[r].signal), this.bins[r].as = unique([...this.bins[r].as, ...t.bins[r].as], hash)) : this.bins[r] = t.bins[r];
		for (let n of t.children) t.removeChild(n), n.parent = this;
		t.remove();
	}
	producedFields() {
		return new Set(vals(this.bins).map((t) => t.as).flat(2));
	}
	dependentFields() {
		return new Set(vals(this.bins).map((t) => t.field));
	}
	hash() {
		return `Bin ${hash(this.bins)}`;
	}
	assemble() {
		return vals(this.bins).flatMap((t) => {
			let n = [], [r, ...i] = t.as, { extent: o,...s } = t.bin, l = {
				type: "bin",
				field: replacePathInField(t.field),
				as: r,
				signal: t.signal,
				...isParameterExtent(o) ? { extent: null } : { extent: o },
				...t.span ? { span: { signal: `span(${t.span})` } } : {},
				...s
			};
			!o && t.extentSignal && (n.push({
				type: "extent",
				field: replacePathInField(t.field),
				signal: t.extentSignal
			}), l.extent = { signal: t.extentSignal }), n.push(l);
			for (let t of i) for (let i = 0; i < 2; i++) n.push({
				type: "formula",
				expr: vgField({ field: r[i] }, { expr: "datum" }),
				as: t[i]
			});
			return t.formula && n.push({
				type: "formula",
				expr: t.formula,
				as: t.formulaAs
			}), n;
		});
	}
};
function addDimension(t, n, r, i) {
	let o = isUnitModel(i) ? i.encoding[getSecondaryRangeChannel(n)] : void 0;
	if (isTypedFieldDef(r) && isUnitModel(i) && hasBandEnd(r, o, i.markDef, i.config)) {
		t.add(vgField(r, {})), t.add(vgField(r, { suffix: "end" }));
		let { mark: o, markDef: s, config: l } = i, u = getBandPosition({
			fieldDef: r,
			markDef: s,
			config: l
		});
		isRectBasedMark(o) && u !== .5 && isXorY(n) && (t.add(vgField(r, { suffix: OFFSETTED_RECT_START_SUFFIX })), t.add(vgField(r, { suffix: OFFSETTED_RECT_END_SUFFIX }))), r.bin && binRequiresRange(r, n) && t.add(vgField(r, { binSuffix: "range" }));
	} else if (isGeoPositionChannel(n)) {
		let r = getPositionChannelFromLatLong(n);
		t.add(i.getName(r));
	} else t.add(vgField(r));
	return isScaleFieldDef(r) && isFieldRange(r.scale?.range) && t.add(r.scale.range.field), t;
}
function mergeMeasures(t, n) {
	for (let r of keys(n)) {
		let i = n[r];
		for (let n of keys(i)) r in t ? t[r][n] = new Set([...t[r][n] ?? [], ...i[n]]) : t[r] = { [n]: i[n] };
	}
}
var AggregateNode = class t extends DataFlowNode {
	dimensions;
	measures;
	clone() {
		return new t(null, new Set(this.dimensions), duplicate(this.measures));
	}
	constructor(t, n, r) {
		super(t), this.dimensions = n, this.measures = r;
	}
	get groupBy() {
		return this.dimensions;
	}
	static makeFromEncoding(n, r) {
		let i = !1;
		r.forEachFieldDef((t) => {
			t.aggregate && (i = !0);
		});
		let o = {}, s = /* @__PURE__ */ new Set();
		return !i || (r.forEachFieldDef((t, n) => {
			let { aggregate: i, field: l } = t;
			if (i) if (i === "count") o["*"] ??= {}, o["*"].count = new Set([vgField(t, { forAs: !0 })]);
			else {
				if (isArgminDef(i) || isArgmaxDef(i)) {
					let t = isArgminDef(i) ? "argmin" : "argmax", n = i[t];
					o[n] ??= {}, o[n][t] = new Set([vgField({
						op: t,
						field: n
					}, { forAs: !0 })]);
				} else o[l] ??= {}, o[l][i] = new Set([vgField(t, { forAs: !0 })]);
				isScaleChannel(n) && r.scaleDomain(n) === "unaggregated" && (o[l] ??= {}, o[l].min = new Set([vgField({
					field: l,
					aggregate: "min"
				}, { forAs: !0 })]), o[l].max = new Set([vgField({
					field: l,
					aggregate: "max"
				}, { forAs: !0 })]));
			}
			else addDimension(s, n, t, r);
		}), s.size + keys(o).length === 0) ? null : new t(n, s, o);
	}
	static makeFromTransform(n, r) {
		let i = /* @__PURE__ */ new Set(), o = {};
		for (let t of r.aggregate) {
			let { op: n, field: r, as: i } = t;
			n && (n === "count" ? (o["*"] ??= {}, o["*"].count = new Set([i || vgField(t, { forAs: !0 })])) : (o[r] ??= {}, o[r][n] ??= /* @__PURE__ */ new Set(), o[r][n].add(i || vgField(t, { forAs: !0 }))));
		}
		for (let t of r.groupby ?? []) i.add(t);
		return i.size + keys(o).length === 0 ? null : new t(n, i, o);
	}
	merge(t) {
		return setEqual(this.dimensions, t.dimensions) ? (mergeMeasures(this.measures, t.measures), !0) : (debug("different dimensions, cannot merge"), !1);
	}
	addDimensions(t) {
		t.forEach(this.dimensions.add, this.dimensions);
	}
	dependentFields() {
		return new Set([...this.dimensions, ...keys(this.measures)]);
	}
	producedFields() {
		let t = /* @__PURE__ */ new Set();
		for (let n of keys(this.measures)) for (let r of keys(this.measures[n])) {
			let i = this.measures[n][r];
			i.size === 0 ? t.add(`${r}_${n}`) : i.forEach(t.add, t);
		}
		return t;
	}
	hash() {
		return `Aggregate ${hash({
			dimensions: this.dimensions,
			measures: this.measures
		})}`;
	}
	assemble() {
		let t = [], n = [], r = [];
		for (let i of keys(this.measures)) for (let o of keys(this.measures[i])) for (let s of this.measures[i][o]) r.push(s), t.push(o), n.push(i === "*" ? null : replacePathInField(i));
		return {
			type: "aggregate",
			groupby: [...this.dimensions].map(replacePathInField),
			ops: t,
			fields: n,
			as: r
		};
	}
}, FacetNode = class extends DataFlowNode {
	model;
	name;
	data;
	column;
	row;
	facet;
	childModel;
	constructor(t, n, r, i) {
		super(t), this.model = n, this.name = r, this.data = i;
		for (let t of FACET_CHANNELS) {
			let r = n.facet[t];
			if (r) {
				let { bin: i, sort: o } = r;
				this[t] = {
					name: n.getName(`${t}_domain`),
					fields: [vgField(r), ...isBinning(i) ? [vgField(r, { binSuffix: "end" })] : []],
					...isSortField(o) ? { sortField: o } : isArray(o) ? { sortIndexField: sortArrayIndexField(r, t) } : {}
				};
			}
		}
		this.childModel = n.child;
	}
	hash() {
		let t = "Facet";
		for (let n of FACET_CHANNELS) this[n] && (t += ` ${n.charAt(0)}:${hash(this[n])}`);
		return t;
	}
	get fields() {
		let t = [];
		for (let n of FACET_CHANNELS) this[n]?.fields && t.push(...this[n].fields);
		return t;
	}
	dependentFields() {
		let t = new Set(this.fields);
		for (let n of FACET_CHANNELS) this[n] && (this[n].sortField && t.add(this[n].sortField.field), this[n].sortIndexField && t.add(this[n].sortIndexField));
		return t;
	}
	producedFields() {
		return /* @__PURE__ */ new Set();
	}
	getSource() {
		return this.name;
	}
	getChildIndependentFieldsWithStep() {
		let t = {};
		for (let n of POSITION_SCALE_CHANNELS) {
			let r = this.childModel.component.scales[n];
			if (r && !r.merged) {
				let i = r.get("type"), o = r.get("range");
				if (hasDiscreteDomain(i) && isVgRangeStep(o)) {
					let r = getFieldFromDomain(assembleDomain(this.childModel, n));
					r ? t[n] = r : warn(unknownField(n));
				}
			}
		}
		return t;
	}
	assembleRowColumnHeaderData(t, n, r) {
		let i = {
			row: "y",
			column: "x",
			facet: void 0
		}[t], o = [], s = [], l = [];
		i && r && r[i] && (n ? (o.push(`distinct_${r[i]}`), s.push("max")) : (o.push(r[i]), s.push("distinct")), l.push(`distinct_${r[i]}`));
		let { sortField: u, sortIndexField: d } = this[t];
		if (u) {
			let { op: t = DEFAULT_SORT_OP, field: n } = u;
			o.push(n), s.push(t), l.push(vgField(u, { forAs: !0 }));
		} else d && (o.push(d), s.push("max"), l.push(d));
		return {
			name: this[t].name,
			source: n ?? this.data,
			transform: [{
				type: "aggregate",
				groupby: this[t].fields,
				...o.length ? {
					fields: o,
					ops: s,
					as: l
				} : {}
			}]
		};
	}
	assembleFacetHeaderData(t) {
		let { columns: n } = this.model.layout, { layoutHeaders: r } = this.model.component, i = [], o = {};
		for (let t of HEADER_CHANNELS) {
			for (let n of HEADER_TYPES) {
				let i = r[t]?.[n] ?? [];
				for (let n of i) if (n.axes?.length > 0) {
					o[t] = !0;
					break;
				}
			}
			if (o[t]) {
				let r = `length(data("${this.facet.name}"))`, o = t === "row" ? n ? { signal: `ceil(${r} / ${n})` } : 1 : n ? { signal: `min(${r}, ${n})` } : { signal: r };
				i.push({
					name: `${this.facet.name}_${t}`,
					transform: [{
						type: "sequence",
						start: 0,
						stop: o
					}]
				});
			}
		}
		let { row: s, column: l } = o;
		return (s || l) && i.unshift(this.assembleRowColumnHeaderData("facet", null, t)), i;
	}
	assemble() {
		let t = [], n = null, r = this.getChildIndependentFieldsWithStep(), { column: i, row: o, facet: s } = this;
		if (i && o && (r.x || r.y)) {
			n = `cross_${this.column.name}_${this.row.name}`;
			let i = [].concat(r.x ?? [], r.y ?? []), o = i.map(() => "distinct");
			t.push({
				name: n,
				source: this.data,
				transform: [{
					type: "aggregate",
					groupby: this.fields,
					fields: i,
					ops: o
				}]
			});
		}
		for (let i of [COLUMN, ROW]) this[i] && t.push(this.assembleRowColumnHeaderData(i, n, r));
		if (s) {
			let n = this.assembleFacetHeaderData(r);
			n && t.push(...n);
		}
		return t;
	}
};
function unquote(t) {
	return t.startsWith("'") && t.endsWith("'") || t.startsWith("\"") && t.endsWith("\"") ? t.slice(1, -1) : t;
}
function parseExpression(t, n) {
	let r = accessPathWithDatum(t);
	return n === "number" ? `toNumber(${r})` : n === "boolean" ? `toBoolean(${r})` : n === "string" ? `toString(${r})` : n === "date" ? `toDate(${r})` : n === "flatten" ? r : n.startsWith("date:") ? `timeParse(${r},'${unquote(n.slice(5, n.length))}')` : n.startsWith("utc:") ? `utcParse(${r},'${unquote(n.slice(4, n.length))}')` : (warn(unrecognizedParse(n)), null);
}
function getImplicitFromFilterTransform(t) {
	let n = {};
	return forEachLeaf(t.filter, (t) => {
		if (isFieldPredicate(t)) {
			let r = null;
			isFieldEqualPredicate(t) ? r = signalRefOrValue(t.equal) : isFieldLTEPredicate(t) ? r = signalRefOrValue(t.lte) : isFieldLTPredicate(t) ? r = signalRefOrValue(t.lt) : isFieldGTPredicate(t) ? r = signalRefOrValue(t.gt) : isFieldGTEPredicate(t) ? r = signalRefOrValue(t.gte) : isFieldRangePredicate(t) ? r = t.range[0] : isFieldOneOfPredicate(t) && (r = (t.oneOf ?? t.in)[0]), r && (isDateTime(r) ? n[t.field] = "date" : isNumber(r) ? n[t.field] = "number" : isString(r) && (n[t.field] = "string")), t.timeUnit && (n[t.field] = "date");
		}
	}), n;
}
function getImplicitFromEncoding(t) {
	let n = {};
	function r(t) {
		isFieldOrDatumDefForTimeFormat(t) ? n[t.field] = "date" : t.type === "quantitative" && isMinMaxOp(t.aggregate) ? n[t.field] = "number" : accessPathDepth(t.field) > 1 ? t.field in n || (n[t.field] = "flatten") : isScaleFieldDef(t) && isSortField(t.sort) && accessPathDepth(t.sort.field) > 1 && (t.sort.field in n || (n[t.sort.field] = "flatten"));
	}
	if ((isUnitModel(t) || isFacetModel(t)) && t.forEachFieldDef((n, i) => {
		if (isTypedFieldDef(n)) r(n);
		else {
			let o = getMainRangeChannel(i), s = t.fieldDef(o);
			r({
				...n,
				type: s.type
			});
		}
	}), isUnitModel(t)) {
		let { mark: r, markDef: i, encoding: o } = t;
		if (isPathMark(r) && !t.encoding.order) {
			let t = o[i.orient === "horizontal" ? "y" : "x"];
			isFieldDef(t) && t.type === "quantitative" && !(t.field in n) && (n[t.field] = "number");
		}
	}
	return n;
}
function getImplicitFromSelection(t) {
	let n = {};
	if (isUnitModel(t) && t.component.selection) for (let r of keys(t.component.selection)) {
		let i = t.component.selection[r];
		for (let t of i.project.items) !t.channel && accessPathDepth(t.field) > 1 && (n[t.field] = "flatten");
	}
	return n;
}
var ParseNode = class t extends DataFlowNode {
	_parse;
	clone() {
		return new t(null, duplicate(this._parse));
	}
	constructor(t, n) {
		super(t), this._parse = n;
	}
	hash() {
		return `Parse ${hash(this._parse)}`;
	}
	static makeExplicit(t, n, r) {
		let i = {}, o = n.data;
		return !isGenerator(o) && o?.format?.parse && (i = o.format.parse), this.makeWithAncestors(t, i, {}, r);
	}
	static makeWithAncestors(n, r, i, o) {
		for (let t of keys(i)) {
			let n = o.getWithExplicit(t);
			n.value !== void 0 && (n.explicit || n.value === i[t] || n.value === "derived" || i[t] === "flatten" ? delete i[t] : warn(differentParse(t, i[t], n.value)));
		}
		for (let t of keys(r)) {
			let n = o.get(t);
			n !== void 0 && (n === r[t] ? delete r[t] : warn(differentParse(t, r[t], n)));
		}
		let s = new Split(r, i);
		o.copyAll(s);
		let l = {};
		for (let t of keys(s.combine())) {
			let n = s.get(t);
			n !== null && (l[t] = n);
		}
		return keys(l).length === 0 || o.parseNothing ? null : new t(n, l);
	}
	get parse() {
		return this._parse;
	}
	merge(t) {
		this._parse = {
			...this._parse,
			...t.parse
		}, t.remove();
	}
	assembleFormatParse() {
		let t = {};
		for (let n of keys(this._parse)) {
			let r = this._parse[n];
			accessPathDepth(n) === 1 && (t[n] = r);
		}
		return t;
	}
	producedFields() {
		return new Set(keys(this._parse));
	}
	dependentFields() {
		return new Set(keys(this._parse));
	}
	assembleTransforms(t = !1) {
		return keys(this._parse).filter((n) => t ? accessPathDepth(n) > 1 : !0).map((t) => {
			let n = parseExpression(t, this._parse[t]);
			return n ? {
				type: "formula",
				expr: n,
				as: removePathFromField(t)
			} : null;
		}).filter((t) => t !== null);
	}
}, IdentifierNode = class t extends DataFlowNode {
	clone() {
		return new t(null);
	}
	constructor(t) {
		super(t);
	}
	dependentFields() {
		return /* @__PURE__ */ new Set();
	}
	producedFields() {
		return new Set([SELECTION_ID]);
	}
	hash() {
		return "Identifier";
	}
	assemble() {
		return {
			type: "identifier",
			as: SELECTION_ID
		};
	}
}, GraticuleNode = class t extends DataFlowNode {
	params;
	clone() {
		return new t(null, this.params);
	}
	constructor(t, n) {
		super(t), this.params = n;
	}
	dependentFields() {
		return /* @__PURE__ */ new Set();
	}
	producedFields() {}
	hash() {
		return `Graticule ${hash(this.params)}`;
	}
	assemble() {
		return {
			type: "graticule",
			...this.params === !0 ? {} : this.params
		};
	}
}, SequenceNode = class t extends DataFlowNode {
	params;
	clone() {
		return new t(null, this.params);
	}
	constructor(t, n) {
		super(t), this.params = n;
	}
	dependentFields() {
		return /* @__PURE__ */ new Set();
	}
	producedFields() {
		return new Set([this.params.as ?? "data"]);
	}
	hash() {
		return `Hash ${hash(this.params)}`;
	}
	assemble() {
		return {
			type: "sequence",
			...this.params
		};
	}
}, SourceNode = class extends DataFlowNode {
	_data;
	_name;
	_generator;
	constructor(t) {
		super(null), t ??= { name: "source" };
		let n;
		if (isGenerator(t) || (n = t.format ? { ...omit(t.format, ["parse"]) } : {}), isInlineData(t)) this._data = { values: t.values };
		else if (isUrlData(t)) {
			if (this._data = { url: t.url }, !n.type) {
				let r = /(?:\.([^.]+))?$/.exec(t.url)[1];
				contains([
					"json",
					"csv",
					"tsv",
					"dsv",
					"topojson"
				], r) || (r = "json"), n.type = r;
			}
		} else isSphereGenerator(t) ? this._data = { values: [{ type: "Sphere" }] } : (isNamedData(t) || isGenerator(t)) && (this._data = {});
		this._generator = isGenerator(t), t.name && (this._name = t.name), n && !isEmpty(n) && (this._data.format = n);
	}
	dependentFields() {
		return /* @__PURE__ */ new Set();
	}
	producedFields() {}
	get data() {
		return this._data;
	}
	hasName() {
		return !!this._name;
	}
	get isGenerator() {
		return this._generator;
	}
	get dataName() {
		return this._name;
	}
	set dataName(t) {
		this._name = t;
	}
	set parent(t) {
		throw Error("Source nodes have to be roots.");
	}
	remove() {
		throw Error("Source nodes are roots and cannot be removed.");
	}
	hash() {
		throw Error("Cannot hash sources");
	}
	assemble() {
		return {
			name: this._name,
			...this._data,
			transform: []
		};
	}
};
function isDataSourceNode(t) {
	return t instanceof SourceNode || t instanceof GraticuleNode || t instanceof SequenceNode;
}
var Optimizer = class {
	#modified;
	constructor() {
		this.#modified = !1;
	}
	setModified() {
		this.#modified = !0;
	}
	get modifiedFlag() {
		return this.#modified;
	}
}, BottomUpOptimizer = class extends Optimizer {
	getNodeDepths(t, n, r) {
		r.set(t, n);
		for (let i of t.children) this.getNodeDepths(i, n + 1, r);
		return r;
	}
	optimize(t) {
		let n = [...this.getNodeDepths(t, 0, /* @__PURE__ */ new Map()).entries()].sort((t, n) => n[1] - t[1]);
		for (let t of n) this.run(t[0]);
		return this.modifiedFlag;
	}
}, TopDownOptimizer = class extends Optimizer {
	optimize(t) {
		this.run(t);
		for (let n of t.children) this.optimize(n);
		return this.modifiedFlag;
	}
}, MergeIdenticalNodes = class extends TopDownOptimizer {
	mergeNodes(t, n) {
		let r = n.shift();
		for (let i of n) t.removeChild(i), i.parent = r, i.remove();
	}
	run(t) {
		let n = t.children.map((t) => t.hash()), r = {};
		for (let i = 0; i < n.length; i++) r[n[i]] === void 0 ? r[n[i]] = [t.children[i]] : r[n[i]].push(t.children[i]);
		for (let n of keys(r)) r[n].length > 1 && (this.setModified(), this.mergeNodes(t, r[n]));
	}
}, RemoveUnnecessaryIdentifierNodes = class extends TopDownOptimizer {
	requiresSelectionId;
	constructor(t) {
		super(), this.requiresSelectionId = t && requiresSelectionId(t);
	}
	run(t) {
		t instanceof IdentifierNode && (this.requiresSelectionId && (isDataSourceNode(t.parent) || t.parent instanceof AggregateNode || t.parent instanceof ParseNode) || (this.setModified(), t.remove()));
	}
}, RemoveDuplicateTimeUnits = class extends Optimizer {
	optimize(t) {
		return this.run(t, /* @__PURE__ */ new Set()), this.modifiedFlag;
	}
	run(t, n) {
		let r = /* @__PURE__ */ new Set();
		t instanceof TimeUnitNode && (r = t.producedFields(), hasIntersection(r, n) && (this.setModified(), t.removeFormulas(n), t.producedFields.length === 0 && t.remove()));
		for (let i of t.children) this.run(i, new Set([...n, ...r]));
	}
}, RemoveUnnecessaryOutputNodes = class extends TopDownOptimizer {
	constructor() {
		super();
	}
	run(t) {
		t instanceof OutputNode && !t.isRequired() && (this.setModified(), t.remove());
	}
}, MoveParseUp = class extends BottomUpOptimizer {
	run(t) {
		if (!isDataSourceNode(t) && !(t.numChildren() > 1)) {
			for (let n of t.children) if (n instanceof ParseNode) if (t instanceof ParseNode) this.setModified(), t.merge(n);
			else {
				if (fieldIntersection(t.producedFields(), n.dependentFields())) continue;
				this.setModified(), n.swapWithParent();
			}
		}
	}
}, MergeParse = class extends BottomUpOptimizer {
	run(t) {
		let n = [...t.children], r = t.children.filter((t) => t instanceof ParseNode);
		if (t.numChildren() > 1 && r.length >= 1) {
			let i = {}, o = /* @__PURE__ */ new Set();
			for (let t of r) {
				let n = t.parse;
				for (let t of keys(n)) t in i ? i[t] !== n[t] && o.add(t) : i[t] = n[t];
			}
			for (let t of o) delete i[t];
			if (!isEmpty(i)) {
				this.setModified();
				let r = new ParseNode(t, i);
				for (let o of n) {
					if (o instanceof ParseNode) for (let t of keys(i)) delete o.parse[t];
					t.removeChild(o), o.parent = r, o instanceof ParseNode && keys(o.parse).length === 0 && o.remove();
				}
			}
		}
	}
}, RemoveUnusedSubtrees = class extends BottomUpOptimizer {
	run(t) {
		t instanceof OutputNode || t.numChildren() > 0 || t instanceof FacetNode || t instanceof SourceNode || (this.setModified(), t.remove());
	}
}, MergeTimeUnits = class extends BottomUpOptimizer {
	run(t) {
		let n = t.children.filter((t) => t instanceof TimeUnitNode), r = n.pop();
		for (let t of n) this.setModified(), r.merge(t);
	}
}, MergeAggregates = class extends BottomUpOptimizer {
	run(t) {
		let n = t.children.filter((t) => t instanceof AggregateNode), r = {};
		for (let t of n) {
			let n = hash(t.groupBy);
			n in r || (r[n] = []), r[n].push(t);
		}
		for (let n of keys(r)) {
			let i = r[n];
			if (i.length > 1) {
				let n = i.pop();
				for (let r of i) n.merge(r) && (t.removeChild(r), r.parent = n, r.remove(), this.setModified());
			}
		}
	}
}, MergeBins = class extends BottomUpOptimizer {
	model;
	constructor(t) {
		super(), this.model = t;
	}
	run(t) {
		let n = !(isDataSourceNode(t) || t instanceof FilterNode || t instanceof ParseNode || t instanceof IdentifierNode), r = [], i = [];
		for (let o of t.children) o instanceof BinNode && (n && !fieldIntersection(t.producedFields(), o.dependentFields()) ? r.push(o) : i.push(o));
		if (r.length > 0) {
			let n = r.pop();
			for (let t of r) n.merge(t, this.model.renameSignal.bind(this.model));
			this.setModified(), t instanceof BinNode ? t.merge(n, this.model.renameSignal.bind(this.model)) : n.swapWithParent();
		}
		if (i.length > 1) {
			let t = i.pop();
			for (let n of i) t.merge(n, this.model.renameSignal.bind(this.model));
			this.setModified();
		}
	}
}, MergeOutputs = class extends BottomUpOptimizer {
	run(t) {
		let n = [...t.children];
		if (!some(n, (t) => t instanceof OutputNode) || t.numChildren() <= 1) return;
		let r = [], i;
		for (let o of n) if (o instanceof OutputNode) {
			let n = o;
			for (; n.numChildren() === 1;) {
				let [t] = n.children;
				if (t instanceof OutputNode) n = t;
				else break;
			}
			r.push(...n.children), i ? (t.removeChild(o), o.parent = i.parent, i.parent.removeChild(i), i.parent = n, this.setModified()) : i = n;
		} else r.push(o);
		if (r.length) {
			this.setModified();
			for (let t of r) t.parent.removeChild(t), t.parent = i;
		}
	}
}, JoinAggregateTransformNode = class t extends DataFlowNode {
	transform;
	clone() {
		return new t(null, duplicate(this.transform));
	}
	constructor(t, n) {
		super(t), this.transform = n;
	}
	addDimensions(t) {
		this.transform.groupby = unique(this.transform.groupby.concat(t), (t) => t);
	}
	dependentFields() {
		let t = /* @__PURE__ */ new Set();
		return this.transform.groupby && this.transform.groupby.forEach(t.add, t), this.transform.joinaggregate.map((t) => t.field).filter((t) => t !== void 0).forEach(t.add, t), t;
	}
	producedFields() {
		return new Set(this.transform.joinaggregate.map(this.getDefaultName));
	}
	getDefaultName(t) {
		return t.as ?? vgField(t);
	}
	hash() {
		return `JoinAggregateTransform ${hash(this.transform)}`;
	}
	assemble() {
		let t = [], n = [], r = [];
		for (let i of this.transform.joinaggregate) n.push(i.op), r.push(this.getDefaultName(i)), t.push(i.field === void 0 ? null : i.field);
		let i = this.transform.groupby;
		return {
			type: "joinaggregate",
			as: r,
			ops: n,
			fields: t,
			...i === void 0 ? {} : { groupby: i }
		};
	}
}, FilterInvalidNode = class t extends DataFlowNode {
	filter;
	clone() {
		return new t(null, { ...this.filter });
	}
	constructor(t, n) {
		super(t), this.filter = n;
	}
	static make(n, r, i) {
		let { config: o, markDef: s } = r, { marks: l, scales: u } = i;
		if (l === "include-invalid-values" && u === "include-invalid-values") return null;
		let d = r.reduceFieldDef((t, n, i) => {
			let l = isScaleChannel(i) && r.getScaleComponent(i);
			if (l) {
				let r = l.get("type"), { aggregate: u } = n, d = getScaleInvalidDataMode({
					scaleChannel: i,
					markDef: s,
					config: o,
					scaleType: r,
					isCountAggregate: isCountingAggregateOp(u)
				});
				d !== "show" && d !== "always-valid" && (t[n.field] = n);
			}
			return t;
		}, {});
		return keys(d).length ? new t(n, d) : null;
	}
	dependentFields() {
		return new Set(keys(this.filter));
	}
	producedFields() {
		return /* @__PURE__ */ new Set();
	}
	hash() {
		return `FilterInvalid ${hash(this.filter)}`;
	}
	assemble() {
		let t = keys(this.filter).reduce((t, n) => {
			let r = this.filter[n], i = vgField(r, { expr: "datum" });
			return r !== null && (r.type === "temporal" ? t.push(`(isDate(${i}) || (${isValidFiniteNumberExpr(i)}))`) : r.type === "quantitative" && t.push(isValidFiniteNumberExpr(i))), t;
		}, []);
		return t.length > 0 ? {
			type: "filter",
			expr: t.join(" && ")
		} : null;
	}
};
function isValidFiniteNumberExpr(t) {
	return `isValid(${t}) && isFinite(+${t})`;
}
function getStackByFields(t) {
	return t.stack.stackBy.reduce((t, n) => {
		let r = n.fieldDef, i = vgField(r);
		return i && t.push(i), t;
	}, []);
}
function isValidAsArray(t) {
	return isArray(t) && t.every((t) => isString(t)) && t.length > 1;
}
var StackNode = class t extends DataFlowNode {
	_stack;
	clone() {
		return new t(null, duplicate(this._stack));
	}
	constructor(t, n) {
		super(t), this._stack = n;
	}
	static makeFromTransform(n, r) {
		let { stack: i, groupby: o, as: s, offset: l = "zero" } = r, u = [], d = [];
		if (r.sort !== void 0) for (let t of r.sort) u.push(t.field), d.push(getFirstDefined(t.order, "ascending"));
		let f = {
			field: u,
			order: d
		}, p;
		return p = isValidAsArray(s) ? s : isString(s) ? [s, `${s}_end`] : [`${r.stack}_start`, `${r.stack}_end`], new t(n, {
			dimensionFieldDefs: [],
			stackField: i,
			groupby: o,
			offset: l,
			sort: f,
			facetby: [],
			as: p
		});
	}
	static makeFromEncoding(n, r) {
		let i = r.stack, { encoding: o } = r;
		if (!i) return null;
		let { groupbyChannels: s, fieldChannel: l, offset: u, impute: d } = i, f = s.map((t) => {
			let n = o[t];
			return getFieldDef(n);
		}).filter((t) => !!t), p = getStackByFields(r), g = r.encoding.order, _;
		if (isArray(g) || isFieldDef(g)) _ = sortParams(g);
		else {
			let t = isOrderOnlyDef(g) ? g.sort : l === "y" ? "descending" : "ascending";
			_ = p.reduce((n, r) => (n.field.includes(r) || (n.field.push(r), n.order.push(t)), n), {
				field: [],
				order: []
			});
		}
		return new t(n, {
			dimensionFieldDefs: f,
			stackField: r.vgField(l),
			facetby: [],
			stackby: p,
			sort: _,
			offset: u,
			impute: d,
			as: [r.vgField(l, {
				suffix: "start",
				forAs: !0
			}), r.vgField(l, {
				suffix: "end",
				forAs: !0
			})]
		});
	}
	get stack() {
		return this._stack;
	}
	addDimensions(t) {
		this._stack.facetby.push(...t);
	}
	dependentFields() {
		let t = /* @__PURE__ */ new Set();
		return t.add(this._stack.stackField), this.getGroupbyFields().forEach(t.add, t), this._stack.facetby.forEach(t.add, t), this._stack.sort.field.forEach(t.add, t), t;
	}
	producedFields() {
		return new Set(this._stack.as);
	}
	hash() {
		return `Stack ${hash(this._stack)}`;
	}
	getGroupbyFields() {
		let { dimensionFieldDefs: t, impute: n, groupby: r } = this._stack;
		return t.length > 0 ? t.map((t) => t.bin ? n ? [vgField(t, { binSuffix: "mid" })] : [vgField(t, {}), vgField(t, { binSuffix: "end" })] : [vgField(t)]).flat() : r ?? [];
	}
	assemble() {
		let t = [], { facetby: n, dimensionFieldDefs: r, stackField: i, stackby: o, sort: s, offset: l, impute: u, as: d } = this._stack;
		if (u) for (let s of r) {
			let { bandPosition: r = .5, bin: l } = s;
			if (l) {
				let n = vgField(s, { expr: "datum" }), i = vgField(s, {
					expr: "datum",
					binSuffix: "end"
				});
				t.push({
					type: "formula",
					expr: `${isValidFiniteNumberExpr(n)} ? ${r}*${n}+${1 - r}*${i} : ${n}`,
					as: vgField(s, {
						binSuffix: "mid",
						forAs: !0
					})
				});
			}
			t.push({
				type: "impute",
				field: i,
				groupby: [...o, ...n],
				key: vgField(s, { binSuffix: "mid" }),
				method: "value",
				value: 0
			});
		}
		return t.push({
			type: "stack",
			groupby: [...this.getGroupbyFields(), ...n],
			field: i,
			sort: s,
			as: d,
			offset: l
		}), t;
	}
}, WindowTransformNode = class t extends DataFlowNode {
	transform;
	clone() {
		return new t(null, duplicate(this.transform));
	}
	constructor(t, n) {
		super(t), this.transform = n;
	}
	addDimensions(t) {
		this.transform.groupby = unique(this.transform.groupby.concat(t), (t) => t);
	}
	dependentFields() {
		let t = /* @__PURE__ */ new Set();
		return (this.transform.groupby ?? []).forEach(t.add, t), (this.transform.sort ?? []).forEach((n) => t.add(n.field)), this.transform.window.map((t) => t.field).filter((t) => t !== void 0).forEach(t.add, t), t;
	}
	producedFields() {
		return new Set(this.transform.window.map(this.getDefaultName));
	}
	getDefaultName(t) {
		return t.as ?? vgField(t);
	}
	hash() {
		return `WindowTransform ${hash(this.transform)}`;
	}
	assemble() {
		let t = [], n = [], r = [], i = [];
		for (let o of this.transform.window) n.push(o.op), r.push(this.getDefaultName(o)), i.push(o.param === void 0 ? null : o.param), t.push(o.field === void 0 ? null : o.field);
		let o = this.transform.frame, s = this.transform.groupby;
		if (o && o[0] === null && o[1] === null && n.every((t) => isAggregateOp(t))) return {
			type: "joinaggregate",
			as: r,
			ops: n,
			fields: t,
			...s === void 0 ? {} : { groupby: s }
		};
		let l = [], u = [];
		if (this.transform.sort !== void 0) for (let t of this.transform.sort) l.push(t.field), u.push(t.order ?? "ascending");
		let d = {
			field: l,
			order: u
		}, f = this.transform.ignorePeers;
		return {
			type: "window",
			params: i,
			as: r,
			ops: n,
			fields: t,
			sort: d,
			...f === void 0 ? {} : { ignorePeers: f },
			...s === void 0 ? {} : { groupby: s },
			...o === void 0 ? {} : { frame: o }
		};
	}
};
function cloneSubtree(t) {
	function n(r) {
		if (!(r instanceof FacetNode)) {
			let i = r.clone();
			if (i instanceof OutputNode) {
				let n = FACET_SCALE_PREFIX + i.getSource();
				i.setSource(n), t.model.component.data.outputNodes[n] = i;
			} else (i instanceof AggregateNode || i instanceof StackNode || i instanceof WindowTransformNode || i instanceof JoinAggregateTransformNode) && i.addDimensions(t.fields);
			for (let t of r.children.flatMap(n)) t.parent = i;
			return [i];
		}
		return r.children.flatMap(n);
	}
	return n;
}
function moveFacetDown(t) {
	if (t instanceof FacetNode) if (t.numChildren() === 1 && !(t.children[0] instanceof OutputNode)) {
		let n = t.children[0];
		(n instanceof AggregateNode || n instanceof StackNode || n instanceof WindowTransformNode || n instanceof JoinAggregateTransformNode) && n.addDimensions(t.fields), n.swapWithParent(), moveFacetDown(t);
	} else {
		let n = t.model.component.data.main;
		moveMainDownToFacet(n);
		let r = cloneSubtree(t), i = t.children.map(r).flat();
		for (let t of i) t.parent = n;
	}
	else t.children.map(moveFacetDown);
}
function moveMainDownToFacet(t) {
	if (t instanceof OutputNode && t.type === DataSourceType.Main && t.numChildren() === 1) {
		let n = t.children[0];
		n instanceof FacetNode || (n.swapWithParent(), moveMainDownToFacet(t));
	}
}
var FACET_SCALE_PREFIX = "scale_", MAX_OPTIMIZATION_RUNS = 5;
function checkLinks(t) {
	for (let n of t) {
		for (let t of n.children) if (t.parent !== n) return !1;
		if (!checkLinks(n.children)) return !1;
	}
	return !0;
}
function runOptimizer(t, n) {
	let r = !1;
	for (let i of n) r = t.optimize(i) || r;
	return r;
}
function optimizationDataflowHelper(t, n, r) {
	let i = t.sources, o = !1;
	return o = runOptimizer(new RemoveUnnecessaryOutputNodes(), i) || o, o = runOptimizer(new RemoveUnnecessaryIdentifierNodes(n), i) || o, i = i.filter((t) => t.numChildren() > 0), o = runOptimizer(new RemoveUnusedSubtrees(), i) || o, i = i.filter((t) => t.numChildren() > 0), r || (o = runOptimizer(new MoveParseUp(), i) || o, o = runOptimizer(new MergeBins(n), i) || o, o = runOptimizer(new RemoveDuplicateTimeUnits(), i) || o, o = runOptimizer(new MergeParse(), i) || o, o = runOptimizer(new MergeAggregates(), i) || o, o = runOptimizer(new MergeTimeUnits(), i) || o, o = runOptimizer(new MergeIdenticalNodes(), i) || o, o = runOptimizer(new MergeOutputs(), i) || o), t.sources = i, o;
}
function optimizeDataflow(t, n) {
	checkLinks(t.sources);
	let r = 0, i = 0;
	for (let i = 0; i < MAX_OPTIMIZATION_RUNS && optimizationDataflowHelper(t, n, !0); i++) r++;
	t.sources.map(moveFacetDown);
	for (let r = 0; r < MAX_OPTIMIZATION_RUNS && optimizationDataflowHelper(t, n, !1); r++) i++;
	checkLinks(t.sources), Math.max(r, i) === MAX_OPTIMIZATION_RUNS && warn(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);
}
var SignalRefWrapper = class t {
	constructor(t) {
		Object.defineProperty(this, "signal", {
			enumerable: !0,
			get: t
		});
	}
	signal;
	static fromName(n, r) {
		return new t(() => n(r));
	}
};
function parseScaleDomain(t) {
	isUnitModel(t) ? parseUnitScaleDomain(t) : parseNonUnitScaleDomain(t);
}
function parseUnitScaleDomain(t) {
	let n = t.component.scales;
	for (let r of keys(n)) {
		let i = parseDomainForChannel(t, r);
		if (n[r].setWithExplicit("domains", i), parseSelectionDomain(t, r), t.component.data.isFaceted) {
			let n = t;
			for (; !isFacetModel(n) && n.parent;) n = n.parent;
			if (n.component.resolve.scale[r] === "shared") for (let t of i.value) isDataRefDomain(t) && (t.data = FACET_SCALE_PREFIX + t.data.replace(FACET_SCALE_PREFIX, ""));
		}
	}
}
function parseNonUnitScaleDomain(t) {
	for (let n of t.children) parseScaleDomain(n);
	let n = t.component.scales;
	for (let r of keys(n)) {
		let i, o = null;
		for (let n of t.children) {
			let t = n.component.scales[r];
			if (t) {
				i = i === void 0 ? t.getWithExplicit("domains") : mergeValuesWithExplicit(i, t.getWithExplicit("domains"), "domains", "scale", domainsTieBreaker);
				let n = t.get("selectionExtent");
				o && n && o.param !== n.param && warn(NEEDS_SAME_SELECTION), o = n;
			}
		}
		n[r].setWithExplicit("domains", i), o && n[r].set("selectionExtent", o, !0);
	}
}
function normalizeUnaggregatedDomain(t, n, r, i) {
	if (t === "unaggregated") {
		let { valid: t, reason: i } = canUseUnaggregatedDomain(n, r);
		if (!t) {
			warn(i);
			return;
		}
	} else if (t === void 0 && i.useUnaggregatedDomain) {
		let { valid: t } = canUseUnaggregatedDomain(n, r);
		if (t) return "unaggregated";
	}
	return t;
}
function parseDomainForChannel(t, n) {
	let r = t.getScaleComponent(n).get("type"), { encoding: i } = t, o = normalizeUnaggregatedDomain(t.scaleDomain(n), t.typedFieldDef(n), r, t.config.scale);
	return o !== t.scaleDomain(n) && (t.specifiedScales[n] = {
		...t.specifiedScales[n],
		domain: o
	}), n === "x" && getFieldOrDatumDef(i.x2) ? getFieldOrDatumDef(i.x) ? mergeValuesWithExplicit(parseSingleChannelDomain(r, o, t, "x"), parseSingleChannelDomain(r, o, t, "x2"), "domain", "scale", domainsTieBreaker) : parseSingleChannelDomain(r, o, t, "x2") : n === "y" && getFieldOrDatumDef(i.y2) ? getFieldOrDatumDef(i.y) ? mergeValuesWithExplicit(parseSingleChannelDomain(r, o, t, "y"), parseSingleChannelDomain(r, o, t, "y2"), "domain", "scale", domainsTieBreaker) : parseSingleChannelDomain(r, o, t, "y2") : parseSingleChannelDomain(r, o, t, n);
}
function mapDomainToDataSignal(t, n, r) {
	return t.map((t) => ({ signal: `{data: ${valueExpr(t, {
		timeUnit: r,
		type: n
	})}}` }));
}
function convertDomainIfItIsDateTime(t, n, r) {
	let i = normalizeTimeUnit(r)?.unit;
	return n === "temporal" || i ? mapDomainToDataSignal(t, n, i) : [t];
}
function parseSingleChannelDomain(t, n, r, i) {
	let { encoding: o, markDef: s, mark: l, config: u, stack: d } = r, f = getFieldOrDatumDef(o[i]), { type: p } = f, g = f.timeUnit, _ = getScaleDataSourceForHandlingInvalidValues({
		invalid: getMarkConfig("invalid", s, u),
		isPath: isPathMark(l)
	});
	if (isDomainUnionWith(n)) {
		let o = parseSingleChannelDomain(t, void 0, r, i);
		return makeExplicit([...convertDomainIfItIsDateTime(n.unionWith, p, g), ...o.value]);
	} else if (isSignalRef(n)) return makeExplicit([n]);
	else if (n && n !== "unaggregated" && !isParameterDomain(n)) return makeExplicit(convertDomainIfItIsDateTime(n, p, g));
	if (d && i === d.fieldChannel) {
		if (d.offset === "normalize") return makeImplicit([[0, 1]]);
		let t = r.requestDataName(_);
		return makeImplicit([{
			data: t,
			field: r.vgField(i, { suffix: "start" })
		}, {
			data: t,
			field: r.vgField(i, { suffix: "end" })
		}]);
	}
	let v = isScaleChannel(i) && isFieldDef(f) ? domainSort(r, i, t) : void 0;
	if (isDatumDef(f)) return makeImplicit(convertDomainIfItIsDateTime([f.datum], p, g));
	let S = f;
	if (n === "unaggregated") {
		let { field: t } = f;
		return makeImplicit([{
			data: r.requestDataName(_),
			field: vgField({
				field: t,
				aggregate: "min"
			})
		}, {
			data: r.requestDataName(_),
			field: vgField({
				field: t,
				aggregate: "max"
			})
		}]);
	} else if (isBinning(S.bin)) {
		if (hasDiscreteDomain(t)) return makeImplicit(t === "bin-ordinal" ? [] : [{
			data: isBoolean$1(v) ? r.requestDataName(_) : r.requestDataName(DataSourceType.Raw),
			field: r.vgField(i, binRequiresRange(S, i) ? { binSuffix: "range" } : {}),
			sort: v === !0 || !isObject(v) ? {
				field: r.vgField(i, {}),
				op: "min"
			} : v
		}]);
		{
			let { bin: t } = S;
			if (isBinning(t)) {
				let n = getBinSignalName(r, S.field, t);
				return makeImplicit([new SignalRefWrapper(() => {
					let t = r.getSignalName(n);
					return `[${t}.start, ${t}.stop]`;
				})]);
			} else return makeImplicit([{
				data: r.requestDataName(_),
				field: r.vgField(i, {})
			}]);
		}
	} else if (S.timeUnit && contains(["time", "utc"], t)) {
		let t = o[getSecondaryRangeChannel(i)];
		if (hasBandEnd(S, t, s, u)) {
			let n = r.requestDataName(_), o = getBandPosition({
				fieldDef: S,
				fieldDef2: t,
				markDef: s,
				config: u
			}), d = isRectBasedMark(l) && o !== .5 && isXorY(i);
			return makeImplicit([{
				data: n,
				field: r.vgField(i, d ? { suffix: OFFSETTED_RECT_START_SUFFIX } : {})
			}, {
				data: n,
				field: r.vgField(i, { suffix: d ? OFFSETTED_RECT_END_SUFFIX : "end" })
			}]);
		}
	}
	return makeImplicit(v ? [{
		data: isBoolean$1(v) ? r.requestDataName(_) : r.requestDataName(DataSourceType.Raw),
		field: r.vgField(i),
		sort: v
	}] : [{
		data: r.requestDataName(_),
		field: r.vgField(i)
	}]);
}
function normalizeSortField(t, n) {
	let { op: r, field: i, order: o } = t;
	return {
		op: r ?? (n ? "sum" : DEFAULT_SORT_OP),
		...i ? { field: replacePathInField(i) } : {},
		...o ? { order: o } : {}
	};
}
function parseSelectionDomain(t, n) {
	let r = t.component.scales[n], i = t.specifiedScales[n].domain, o = t.fieldDef(n)?.bin, s = isParameterDomain(i) ? i : void 0, l = isBinParams(o) && isParameterExtent(o.extent) ? o.extent : void 0;
	(s || l) && r.set("selectionExtent", s ?? l, !0);
}
function domainSort(t, n, r) {
	if (!hasDiscreteDomain(r)) return;
	let i = t.fieldDef(n), o = i.sort;
	if (isSortArray(o)) return {
		op: "min",
		field: sortArrayIndexField(i, n),
		order: "ascending"
	};
	let { stack: s } = t, l = s ? new Set([...s.groupbyFields, ...s.stackBy.map((t) => t.fieldDef.field)]) : void 0;
	if (isSortField(o)) return normalizeSortField(o, s && !l.has(o.field));
	if (isSortByEncoding(o)) {
		let { encoding: n, order: r } = o, i = t.fieldDef(n), { aggregate: u, field: d } = i, f = s && !l.has(d);
		if (isArgminDef(u) || isArgmaxDef(u)) return normalizeSortField({
			field: vgField(i),
			order: r
		}, f);
		if (isAggregateOp(u) || !u) return normalizeSortField({
			op: u,
			field: d,
			order: r
		}, f);
	} else if (o === "descending") return {
		op: "min",
		field: t.vgField(n),
		order: "descending"
	};
	else if (contains(["ascending", void 0], o)) return !0;
}
function canUseUnaggregatedDomain(t, n) {
	let { aggregate: r, type: i } = t;
	return r ? isString(r) && !SHARED_DOMAIN_OPS.has(r) ? {
		valid: !1,
		reason: unaggregateDomainWithNonSharedDomainOp(r)
	} : i === "quantitative" && n === "log" ? {
		valid: !1,
		reason: unaggregatedDomainWithLogScale(t)
	} : { valid: !0 } : {
		valid: !1,
		reason: unaggregateDomainHasNoEffectForRawField(t)
	};
}
function domainsTieBreaker(t, n, r, i) {
	return t.explicit && n.explicit && warn(mergeConflictingDomainProperty(r, i, t.value, n.value)), {
		explicit: t.explicit,
		value: [...t.value, ...n.value]
	};
}
function mergeDomains(t) {
	let n = unique(t.map((t) => {
		if (isDataRefDomain(t)) {
			let { sort: n,...r } = t;
			return r;
		}
		return t;
	}), hash), r = unique(t.map((t) => {
		if (isDataRefDomain(t)) {
			let n = t.sort;
			return n !== void 0 && !isBoolean$1(n) && ("op" in n && n.op === "count" && delete n.field, n.order === "ascending" && delete n.order), n;
		}
	}).filter((t) => t !== void 0), hash);
	if (n.length === 0) return;
	if (n.length === 1) {
		let n = t[0];
		if (isDataRefDomain(n) && r.length > 0) {
			let t = r[0];
			if (r.length > 1) {
				warn(MORE_THAN_ONE_SORT);
				let n = r.filter((t) => isObject(t) && "op" in t && t.op !== "min");
				t = r.every((t) => isObject(t) && "op" in t) && n.length === 1 ? n[0] : !0;
			} else if (isObject(t) && "field" in t) {
				let r = t.field;
				n.field === r && (t = t.order ? { order: t.order } : !0);
			}
			return {
				...n,
				sort: t
			};
		}
		return n;
	}
	let i = unique(r.map((t) => isBoolean$1(t) || !("op" in t) || isString(t.op) && has(MULTIDOMAIN_SORT_OP_INDEX, t.op) ? t : (warn(domainSortDropped(t)), !0)), hash), o;
	i.length === 1 ? o = i[0] : i.length > 1 && (warn(MORE_THAN_ONE_SORT), o = !0);
	let s = unique(t.map((t) => isDataRefDomain(t) ? t.data : null), (t) => t);
	return s.length === 1 && s[0] !== null ? {
		data: s[0],
		fields: n.map((t) => t.field),
		...o ? { sort: o } : {}
	} : {
		fields: n,
		...o ? { sort: o } : {}
	};
}
function getFieldFromDomain(t) {
	if (isDataRefDomain(t) && isString(t.field)) return t.field;
	if (isDataRefUnionedDomain(t)) {
		let n;
		for (let r of t.fields) if (isDataRefDomain(r) && isString(r.field)) {
			if (!n) n = r.field;
			else if (n !== r.field) return warn(FACETED_INDEPENDENT_DIFFERENT_SOURCES), n;
		}
		return warn(FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES), n;
	} else if (isFieldRefUnionDomain(t)) {
		warn(FACETED_INDEPENDENT_SAME_SOURCE);
		let n = t.fields[0];
		return isString(n) ? n : void 0;
	}
}
function assembleDomain(t, n) {
	return mergeDomains(t.component.scales[n].get("domains").map((n) => (isDataRefDomain(n) && (n.data = t.lookupDataSource(n.data)), n)));
}
function assembleScales(t) {
	return isLayerModel(t) || isConcatModel(t) ? t.children.reduce((t, n) => t.concat(assembleScales(n)), assembleScalesForModel(t)) : assembleScalesForModel(t);
}
function assembleScalesForModel(t) {
	return keys(t.component.scales).reduce((n, r) => {
		let i = t.component.scales[r];
		if (i.merged) return n;
		let o = i.combine(), { name: s, type: l, selectionExtent: u, domains: d, range: f, reverse: p,...g } = o, _ = assembleScaleRange(o.range, s, r, t), v = assembleDomain(t, r), S = u ? assembleSelectionScaleDomain(t, u, i, v) : null;
		return n.push({
			name: s,
			type: l,
			...v ? { domain: v } : {},
			...S ? { domainRaw: S } : {},
			range: _,
			...p === void 0 ? {} : { reverse: p },
			...g
		}), n;
	}, []);
}
function assembleScaleRange(t, n, r, i) {
	if (isXorY(r)) {
		if (isVgRangeStep(t)) return { step: { signal: `${n}_step` } };
	} else if (isObject(t) && isDataRefDomain(t)) return {
		...t,
		data: i.lookupDataSource(t.data)
	};
	return t;
}
var ScaleComponent = class extends Split {
	merged = !1;
	constructor(t, n) {
		super({}, { name: t }), this.setWithExplicit("type", n);
	}
	domainHasZero() {
		let t = this.get("type");
		if (contains([
			ScaleType.LOG,
			ScaleType.TIME,
			ScaleType.UTC
		], t)) return "definitely-not";
		let n = this.get("zero");
		if (n === !0 || n === void 0 && contains([
			ScaleType.LINEAR,
			ScaleType.SQRT,
			ScaleType.POW
		], t)) return "definitely";
		let r = this.get("domains");
		if (r.length > 0) {
			let t = !1, n = !1, i = !1;
			for (let o of r) {
				if (isArray(o)) {
					let r = o[0], i = o[o.length - 1];
					if (isNumber(r) && isNumber(i)) if (r <= 0 && i >= 0) {
						t = !0;
						continue;
					} else {
						n = !0;
						continue;
					}
				}
				i = !0;
			}
			if (t) return "definitely";
			if (n && !i) return "definitely-not";
		}
		return "maybe";
	}
}, RANGE_PROPERTIES = ["range", "scheme"];
function parseUnitScaleRange(t) {
	let n = t.component.scales;
	for (let r of SCALE_CHANNELS) {
		let i = n[r];
		if (!i) continue;
		let o = parseRangeForChannel(r, t);
		i.setWithExplicit("range", o);
	}
}
function getBinStepSignal(t, n) {
	let r = t.fieldDef(n);
	if (r?.bin) {
		let { bin: i, field: o } = r, s = getSizeChannel(n), l = t.getName(s);
		if (isObject(i) && i.binned && i.step !== void 0) return new SignalRefWrapper(() => {
			let r = t.scaleName(n), o = `(domain("${r}")[1] - domain("${r}")[0]) / ${i.step}`;
			return `${t.getSignalName(l)} / (${o})`;
		});
		if (isBinning(i)) {
			let n = getBinSignalName(t, o, i);
			return new SignalRefWrapper(() => {
				let r = t.getSignalName(n), i = `(${r}.stop - ${r}.start) / ${r}.step`;
				return `${t.getSignalName(l)} / (${i})`;
			});
		}
	}
}
function parseRangeForChannel(t, n) {
	let r = n.specifiedScales[t], { size: i } = n, o = n.getScaleComponent(t).get("type");
	for (let i of RANGE_PROPERTIES) if (r[i] !== void 0) {
		let s = scaleTypeSupportProperty(o, i), l = channelScalePropertyIncompatability(t, i);
		if (!s) warn(scalePropertyNotWorkWithScaleType(o, i, t));
		else if (l) warn(l);
		else switch (i) {
			case "range": {
				let i = r.range;
				if (isArray(i)) {
					if (isXorY(t)) return makeExplicit(i.map((t) => {
						if (t === "width" || t === "height") {
							let r = n.getName(t), i = n.getSignalName.bind(n);
							return SignalRefWrapper.fromName(i, r);
						}
						return t;
					}));
				} else if (isObject(i)) return makeExplicit({
					data: n.requestDataName(DataSourceType.Main),
					field: i.field,
					sort: {
						op: "min",
						field: n.vgField(t)
					}
				});
				return makeExplicit(i);
			}
			case "scheme": return makeExplicit(parseScheme(r[i]));
		}
	}
	let s = t === X || t === "xOffset" ? "width" : "height", l = i[s];
	if (isStep(l)) {
		if (isXorY(t)) if (hasDiscreteDomain(o)) {
			let r = getPositionStep(l, n, t);
			if (r) return makeExplicit({ step: r });
		} else warn(stepDropped(s));
		else if (isXorYOffset(t)) {
			let r = t === XOFFSET ? "x" : "y";
			if (n.getScaleComponent(r).get("type") === "band") {
				let t = getOffsetStep(l, o);
				if (t) return makeExplicit(t);
			}
		}
	}
	let { rangeMin: u, rangeMax: d } = r, f = defaultRange(t, n);
	return (u !== void 0 || d !== void 0) && scaleTypeSupportProperty(o, "rangeMin") && isArray(f) && f.length === 2 ? makeExplicit([u ?? f[0], d ?? f[1]]) : makeImplicit(f);
}
function parseScheme(t) {
	return isExtendedScheme(t) ? {
		scheme: t.name,
		...omit(t, ["name"])
	} : { scheme: t };
}
function fullWidthOrHeightRange(t, n, r, { center: i } = {}) {
	let o = getSizeChannel(t), s = n.getName(o), l = n.getSignalName.bind(n);
	return t === Y && hasContinuousDomain(r) ? i ? [SignalRefWrapper.fromName((t) => `${l(t)}/2`, s), SignalRefWrapper.fromName((t) => `-${l(t)}/2`, s)] : [SignalRefWrapper.fromName(l, s), 0] : i ? [SignalRefWrapper.fromName((t) => `-${l(t)}/2`, s), SignalRefWrapper.fromName((t) => `${l(t)}/2`, s)] : [0, SignalRefWrapper.fromName(l, s)];
}
function defaultRange(t, n) {
	let { size: r, config: i, mark: o, encoding: s } = n, { type: l } = getFieldOrDatumDef(s[t]), u = n.getScaleComponent(t).get("type"), { domain: d, domainMid: f } = n.specifiedScales[t];
	switch (t) {
		case X:
		case Y:
			if (contains(["point", "band"], u)) {
				let o = getDiscretePositionSize(t, r, i.view);
				if (isStep(o)) return { step: getPositionStep(o, n, t) };
			}
			return fullWidthOrHeightRange(t, n, u);
		case XOFFSET:
		case YOFFSET: return getOffsetRange(t, n, u);
		case SIZE: {
			let s = sizeRangeMin(o, i), l = sizeRangeMax(o, r, n, i);
			return isContinuousToDiscrete(u) ? interpolateRange(s, l, defaultContinuousToDiscreteCount(u, i, d, t)) : [s, l];
		}
		case THETA: return [0, Math.PI * 2];
		case ANGLE: return [0, 360];
		case RADIUS: return [0, new SignalRefWrapper(() => `min(${n.getSignalName(isFacetModel(n.parent) ? "child_width" : "width")},${n.getSignalName(isFacetModel(n.parent) ? "child_height" : "height")})/2`)];
		case TIME: return { step: 1e3 / i.scale.framesPerSecond };
		case STROKEWIDTH: return [i.scale.minStrokeWidth, i.scale.maxStrokeWidth];
		case STROKEDASH: return [
			[1, 0],
			[4, 2],
			[2, 1],
			[1, 1],
			[
				1,
				2,
				4,
				2
			]
		];
		case SHAPE: return "symbol";
		case COLOR:
		case FILL:
		case STROKE: return u === "ordinal" ? l === "nominal" ? "category" : "ordinal" : f === void 0 ? o === "rect" || o === "geoshape" ? "heatmap" : "ramp" : "diverging";
		case OPACITY:
		case FILLOPACITY:
		case STROKEOPACITY: return [i.scale.minOpacity, i.scale.maxOpacity];
	}
}
function getPositionStep(t, n, r) {
	let { encoding: i } = n, o = n.getScaleComponent(r), s = getOffsetScaleChannel(r), l = i[s];
	if (getStepFor({
		step: t,
		offsetIsDiscrete: isFieldOrDatumDef(l) && isDiscrete$1(l.type)
	}) === "offset" && channelHasFieldOrDatum(i, s)) {
		let r = n.getScaleComponent(s), i = `domain('${n.scaleName(s)}').length`;
		if (r.get("type") === "band") {
			let t = r.get("paddingInner") ?? r.get("padding") ?? 0, n = r.get("paddingOuter") ?? r.get("padding") ?? 0;
			i = `bandspace(${i}, ${t}, ${n})`;
		}
		let l = o.get("paddingInner") ?? o.get("padding");
		return { signal: `${t.step} * ${i} / (1-${exprFromSignalRefOrValue(l)})` };
	} else return t.step;
}
function getOffsetStep(t, n) {
	if (getStepFor({
		step: t,
		offsetIsDiscrete: hasDiscreteDomain(n)
	}) === "offset") return { step: t.step };
}
function getOffsetRange(t, n, r) {
	let i = t === XOFFSET ? "x" : "y", o = n.getScaleComponent(i);
	if (!o) return fullWidthOrHeightRange(i, n, r, { center: !0 });
	let s = o.get("type"), l = n.scaleName(i), { markDef: u, config: d } = n;
	if (s === "band") {
		let t = getDiscretePositionSize(i, n.size, n.config.view);
		if (isStep(t)) {
			let n = getOffsetStep(t, r);
			if (n) return n;
		}
		return [0, { signal: `bandwidth('${l}')` }];
	} else {
		let r = n.encoding[i];
		if (isFieldDef(r) && r.timeUnit) {
			let t = durationExpr(r.timeUnit, (t) => `scale('${l}', ${t})`), i = n.config.scale.bandWithNestedOffsetPaddingInner, o = getBandPosition({
				fieldDef: r,
				markDef: u,
				config: d
			}) - .5, s = o === 0 ? "" : ` + ${o}`;
			if (i) {
				let n = isSignalRef(i) ? `${i.signal}/2${s}` : `${i / 2 + o}`, r = isSignalRef(i) ? `(1 - ${i.signal}/2)${s}` : `${1 - i / 2 + o}`;
				return [{ signal: `${n} * (${t})` }, { signal: `${r} * (${t})` }];
			}
			return [0, { signal: t }];
		}
		return never(`Cannot use ${t} scale if ${i} scale is not discrete.`);
	}
}
function getDiscretePositionSize(t, n, r) {
	let i = t === X ? "width" : "height", o = n[i];
	return o === void 0 ? getViewConfigDiscreteSize(r, i) : o;
}
function defaultContinuousToDiscreteCount(t, n, r, i) {
	switch (t) {
		case "quantile": return n.scale.quantileCount;
		case "quantize": return n.scale.quantizeCount;
		case "threshold": return r !== void 0 && isArray(r) ? r.length + 1 : (warn(domainRequiredForThresholdScale(i)), 3);
	}
}
function interpolateRange(t, n, r) {
	let i = () => {
		let i = signalOrStringValue(n), o = signalOrStringValue(t), s = `(${i} - ${o}) / (${r} - 1)`;
		return `sequence(${o}, ${i} + ${s}, ${s})`;
	};
	return isSignalRef(n) ? new SignalRefWrapper(i) : { signal: i() };
}
function sizeRangeMin(t, n) {
	switch (t) {
		case "bar":
		case "tick": return n.scale.minBandSize;
		case "line":
		case "trail":
		case "rule": return n.scale.minStrokeWidth;
		case "text": return n.scale.minFontSize;
		case "point":
		case "square":
		case "circle": return n.scale.minSize;
	}
	/* istanbul ignore next: should never reach here */
	throw Error(incompatibleChannel("size", t));
}
var MAX_SIZE_RANGE_STEP_RATIO = .95;
function sizeRangeMax(t, n, r, i) {
	let o = {
		x: getBinStepSignal(r, "x"),
		y: getBinStepSignal(r, "y")
	};
	switch (t) {
		case "bar":
		case "tick": {
			if (i.scale.maxBandSize !== void 0) return i.scale.maxBandSize;
			let t = minXYStep(n, o, i.view);
			return isNumber(t) ? t - 1 : new SignalRefWrapper(() => `${t.signal} - 1`);
		}
		case "line":
		case "trail":
		case "rule": return i.scale.maxStrokeWidth;
		case "text": return i.scale.maxFontSize;
		case "point":
		case "square":
		case "circle": {
			if (i.scale.maxSize) return i.scale.maxSize;
			let t = minXYStep(n, o, i.view);
			return isNumber(t) ? (MAX_SIZE_RANGE_STEP_RATIO * t) ** 2 : new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${t.signal}, 2)`);
		}
	}
	/* istanbul ignore next: should never reach here */
	throw Error(incompatibleChannel("size", t));
}
function minXYStep(t, n, r) {
	let i = isStep(t.width) ? t.width.step : getViewConfigDiscreteStep(r, "width"), o = isStep(t.height) ? t.height.step : getViewConfigDiscreteStep(r, "height");
	return n.x || n.y ? new SignalRefWrapper(() => `min(${[n.x ? n.x.signal : i, n.y ? n.y.signal : o].join(", ")})`) : Math.min(i, o);
}
function parseScaleProperty(t, n) {
	isUnitModel(t) ? parseUnitScaleProperty(t, n) : parseNonUnitScaleProperty(t, n);
}
function parseUnitScaleProperty(t, n) {
	let r = t.component.scales, { config: i, encoding: o, markDef: s, specifiedScales: l } = t;
	for (let u of keys(r)) {
		let d = l[u], f = r[u], p = t.getScaleComponent(u), g = getFieldOrDatumDef(o[u]), _ = d[n], v = p.get("type"), S = p.get("padding"), T = p.get("paddingInner"), E = scaleTypeSupportProperty(v, n), O = channelScalePropertyIncompatability(u, n);
		if (_ !== void 0 && (E ? O && warn(O) : warn(scalePropertyNotWorkWithScaleType(v, n, u))), E && O === void 0) if (_ !== void 0) {
			let t = g.timeUnit, r = g.type;
			switch (n) {
				case "domainMax":
				case "domainMin":
					isDateTime(d[n]) || r === "temporal" || t ? f.set(n, { signal: valueExpr(d[n], {
						type: r,
						timeUnit: t
					}) }, !0) : f.set(n, d[n], !0);
					break;
				default: f.copyKeyFromObject(n, d);
			}
		} else {
			let r = hasProperty(scaleRules, n) ? scaleRules[n]({
				model: t,
				channel: u,
				fieldOrDatumDef: g,
				scaleType: v,
				scalePadding: S,
				scalePaddingInner: T,
				domain: d.domain,
				domainMin: d.domainMin,
				domainMax: d.domainMax,
				markDef: s,
				config: i,
				hasNestedOffsetScale: channelHasNestedOffsetScale(o, u),
				hasSecondaryRangeChannel: !!o[getSecondaryRangeChannel(u)]
			}) : i.scale[n];
			r !== void 0 && f.set(n, r, !1);
		}
	}
}
var scaleRules = {
	bins: ({ model: t, fieldOrDatumDef: n }) => isFieldDef(n) ? bins(t, n) : void 0,
	interpolate: ({ channel: t, fieldOrDatumDef: n }) => interpolate(t, n.type),
	nice: ({ scaleType: t, channel: n, domain: r, domainMin: i, domainMax: o, fieldOrDatumDef: s }) => nice(t, n, r, i, o, s),
	padding: ({ channel: t, scaleType: n, fieldOrDatumDef: r, markDef: i, config: o }) => padding(t, n, o.scale, r, i, o.bar),
	paddingInner: ({ scalePadding: t, channel: n, markDef: r, scaleType: i, config: o, hasNestedOffsetScale: s }) => paddingInner(t, n, r.type, i, o.scale, s),
	paddingOuter: ({ scalePadding: t, channel: n, scaleType: r, scalePaddingInner: i, config: o, hasNestedOffsetScale: s }) => paddingOuter(t, n, r, i, o.scale, s),
	reverse: ({ fieldOrDatumDef: t, scaleType: n, channel: r, config: i }) => reverse(n, isFieldDef(t) ? t.sort : void 0, r, i.scale),
	zero: ({ channel: t, fieldOrDatumDef: n, domain: r, markDef: i, scaleType: o, config: s, hasSecondaryRangeChannel: l }) => zero(t, n, r, i, o, s.scale, l)
};
function parseScaleRange(t) {
	isUnitModel(t) ? parseUnitScaleRange(t) : parseNonUnitScaleProperty(t, "range");
}
function parseNonUnitScaleProperty(t, n) {
	let r = t.component.scales;
	for (let r of t.children) n === "range" ? parseScaleRange(r) : parseScaleProperty(r, n);
	for (let i of keys(r)) {
		let o;
		for (let r of t.children) {
			let t = r.component.scales[i];
			if (t) {
				let r = t.getWithExplicit(n);
				o = mergeValuesWithExplicit(o, r, n, "scale", tieBreakByComparing((t, r) => {
					switch (n) {
						case "range": return t.step && r.step ? t.step - r.step : 0;
					}
					return 0;
				}));
			}
		}
		r[i].setWithExplicit(n, o);
	}
}
function bins(t, n) {
	let r = n.bin;
	if (isBinning(r)) {
		let i = getBinSignalName(t, n.field, r);
		return new SignalRefWrapper(() => t.getSignalName(i));
	} else if (isBinned(r) && isBinParams(r) && r.step !== void 0) return { step: r.step };
}
function interpolate(t, n) {
	if (contains([
		COLOR,
		FILL,
		STROKE
	], t) && n !== "nominal") return "hcl";
}
function nice(t, n, r, i, o, s) {
	if (!(getFieldDef(s)?.bin || isArray(r) || o != null || i != null || contains([ScaleType.TIME, ScaleType.UTC], t))) return isXorY(n) ? !0 : void 0;
}
function padding(t, n, r, i, o, s) {
	if (isXorY(t)) {
		if (isContinuousToContinuous(n)) {
			if (r.continuousPadding !== void 0) return r.continuousPadding;
			let { type: n, orient: l } = o;
			if (n === "bar" && !(isFieldDef(i) && (i.bin || i.timeUnit)) && (l === "vertical" && t === "x" || l === "horizontal" && t === "y")) return s.continuousBandSize;
		}
		if (n === ScaleType.POINT) return r.pointPadding;
	}
}
function paddingInner(t, n, r, i, o, s = !1) {
	if (t === void 0) {
		if (isXorY(n)) {
			let { bandPaddingInner: t, barBandPaddingInner: n, rectBandPaddingInner: i, tickBandPaddingInner: l, bandWithNestedOffsetPaddingInner: u } = o;
			return s ? u : getFirstDefined(t, r === "bar" ? n : r === "tick" ? l : i);
		} else if (isXorYOffset(n) && i === ScaleType.BAND) return o.offsetBandPaddingInner;
	}
}
function paddingOuter(t, n, r, i, o, s = !1) {
	if (t === void 0) {
		if (isXorY(n)) {
			let { bandPaddingOuter: t, bandWithNestedOffsetPaddingOuter: n } = o;
			if (s) return n;
			if (r === ScaleType.BAND) return getFirstDefined(t, isSignalRef(i) ? { signal: `${i.signal}/2` } : i / 2);
		} else if (isXorYOffset(n)) {
			if (r === ScaleType.POINT) return .5;
			if (r === ScaleType.BAND) return o.offsetBandPaddingOuter;
		}
	}
}
function reverse(t, n, r, i) {
	if (r === "x" && i.xReverse !== void 0) return hasContinuousDomain(t) && n === "descending" ? isSignalRef(i.xReverse) ? { signal: `!${i.xReverse.signal}` } : !i.xReverse : i.xReverse;
	if (hasContinuousDomain(t) && n === "descending") return !0;
}
function zero(t, n, r, i, o, s, l) {
	if (r && r !== "unaggregated" && hasContinuousDomain(o)) {
		if (isArray(r)) {
			let t = r[0], n = r[r.length - 1];
			if (isNumber(t) && t <= 0 && isNumber(n) && n >= 0) return !0;
		}
		return !1;
	}
	if (t === "size" && n.type === "quantitative" && !isContinuousToDiscrete(o)) return !0;
	if (!(isFieldDef(n) && n.bin) && contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], t)) {
		let { orient: n, type: r } = i;
		return contains([
			"bar",
			"area",
			"line",
			"trail"
		], r) && (n === "horizontal" && t === "y" || n === "vertical" && t === "x") ? !1 : contains(["bar", "area"], r) && !l ? !0 : s?.zero;
	}
	return !1;
}
function scaleType(t, n, r, i, o = !1) {
	let s = defaultType(n, r, i, o), { type: l } = t;
	return isScaleChannel(n) ? l === void 0 ? s : channelSupportScaleType(n, l) ? isFieldDef(r) && !scaleTypeSupportDataType(l, r.type) ? (warn(scaleTypeNotWorkWithFieldDef(l, s)), s) : l : (warn(scaleTypeNotWorkWithChannel(n, l, s)), s) : null;
}
function defaultType(t, n, r, i) {
	switch (n.type) {
		case "nominal":
		case "ordinal": {
			if (isColorChannel(t) || rangeType(t) === "discrete") return t === "shape" && n.type === "ordinal" && warn(discreteChannelCannotEncode(t, "ordinal")), "ordinal";
			if (isTime(t)) return "band";
			if (isXorY(t) || isXorYOffset(t)) {
				if (contains([
					"rect",
					"bar",
					"image",
					"rule",
					"tick"
				], r.type) || i) return "band";
			} else if (r.type === "arc" && t in POLAR_POSITION_SCALE_CHANNEL_INDEX) return "band";
			let o = r[getSizeChannel(t)];
			return isRelativeBandSize(o) || isPositionFieldOrDatumDef(n) && n.axis?.tickBand ? "band" : "point";
		}
		case "temporal": return isColorChannel(t) ? "time" : rangeType(t) === "discrete" ? (warn(discreteChannelCannotEncode(t, "temporal")), "ordinal") : isFieldDef(n) && n.timeUnit && normalizeTimeUnit(n.timeUnit).utc ? "utc" : isTime(t) ? "band" : "time";
		case "quantitative": return isColorChannel(t) ? isFieldDef(n) && isBinning(n.bin) ? "bin-ordinal" : "linear" : rangeType(t) === "discrete" ? (warn(discreteChannelCannotEncode(t, "quantitative")), "ordinal") : isTime(t) ? "band" : "linear";
		case "geojson": return;
	}
	/* istanbul ignore next: should never reach this */
	throw Error(invalidFieldType(n.type));
}
function parseScales(t, { ignoreRange: n } = {}) {
	parseScaleCore(t), parseScaleDomain(t);
	for (let n of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) parseScaleProperty(t, n);
	n || parseScaleRange(t);
}
function parseScaleCore(t) {
	isUnitModel(t) ? t.component.scales = parseUnitScaleCore(t) : t.component.scales = parseNonUnitScaleCore(t);
}
function parseUnitScaleCore(t) {
	let { encoding: n, mark: r, markDef: i } = t, o = {};
	for (let s of SCALE_CHANNELS) {
		let l = getFieldOrDatumDef(n[s]);
		if (l && r === GEOSHAPE && s === SHAPE && l.type === GEOJSON) continue;
		let u = l && l.scale;
		if (l && u !== null && u !== !1) {
			u ??= {};
			let r = channelHasNestedOffsetScale(n, s), d = scaleType(u, s, l, i, r);
			o[s] = new ScaleComponent(t.scaleName(`${s}`, !0), {
				value: d,
				explicit: u.type === d
			});
		}
	}
	return o;
}
var scaleTypeTieBreaker = tieBreakByComparing((t, n) => scaleTypePrecedence(t) - scaleTypePrecedence(n));
function parseNonUnitScaleCore(t) {
	let n = t.component.scales = {}, r = {}, i = t.component.resolve;
	for (let n of t.children) {
		parseScaleCore(n);
		for (let o of keys(n.component.scales)) if (i.scale[o] ??= defaultScaleResolve(o, t), i.scale[o] === "shared") {
			let t = r[o], s = n.component.scales[o].getWithExplicit("type");
			t ? scaleCompatible(t.value, s.value) ? r[o] = mergeValuesWithExplicit(t, s, "type", "scale", scaleTypeTieBreaker) : (i.scale[o] = "independent", delete r[o]) : r[o] = s;
		}
	}
	for (let i of keys(r)) {
		let o = t.scaleName(i, !0), s = r[i];
		n[i] = new ScaleComponent(o, s);
		for (let n of t.children) {
			let t = n.component.scales[i];
			t && (n.renameScale(t.get("name"), o), t.merged = !0);
		}
	}
	return n;
}
var NameMap = class {
	nameMap;
	constructor() {
		this.nameMap = {};
	}
	rename(t, n) {
		this.nameMap[t] = n;
	}
	has(t) {
		return this.nameMap[t] !== void 0;
	}
	get(t) {
		for (; this.nameMap[t] && t !== this.nameMap[t];) t = this.nameMap[t];
		return t;
	}
};
function isUnitModel(t) {
	return t?.type === "unit";
}
function isFacetModel(t) {
	return t?.type === "facet";
}
function isConcatModel(t) {
	return t?.type === "concat";
}
function isLayerModel(t) {
	return t?.type === "layer";
}
var Model = class {
	type;
	parent;
	config;
	name;
	size;
	title;
	description;
	data;
	transforms;
	layout;
	scaleNameMap;
	projectionNameMap;
	signalNameMap;
	component;
	view;
	constructor(t, n, r, i, o, s, l) {
		this.type = n, this.parent = r, this.config = o, this.parent = r, this.config = o, this.view = replaceExprRef(l), this.name = t.name ?? i, this.title = isText(t.title) ? { text: t.title } : t.title ? replaceExprRef(t.title) : void 0, this.scaleNameMap = r ? r.scaleNameMap : new NameMap(), this.projectionNameMap = r ? r.projectionNameMap : new NameMap(), this.signalNameMap = r ? r.signalNameMap : new NameMap(), this.data = t.data, this.description = t.description, this.transforms = normalizeTransform(t.transform ?? []), this.layout = n === "layer" || n === "unit" ? {} : extractCompositionLayout(t, n, o), this.component = {
			data: {
				sources: r ? r.component.data.sources : [],
				outputNodes: r ? r.component.data.outputNodes : {},
				outputNodeRefCounts: r ? r.component.data.outputNodeRefCounts : {},
				isFaceted: isFacetSpec(t) || r?.component.data.isFaceted && t.data === void 0
			},
			layoutSize: new Split(),
			layoutHeaders: {
				row: {},
				column: {},
				facet: {}
			},
			mark: null,
			resolve: {
				scale: {},
				axis: {},
				legend: {},
				...s ? duplicate(s) : {}
			},
			selection: null,
			scales: null,
			projection: null,
			axes: {},
			legends: {}
		};
	}
	get width() {
		return this.getSizeSignalRef("width");
	}
	get height() {
		return this.getSizeSignalRef("height");
	}
	parse() {
		this.parseScale(), this.parseLayoutSize(), this.renameTopLevelLayoutSizeSignal(), this.parseSelections(), this.parseProjection(), this.parseData(), this.parseAxesAndHeaders(), this.parseLegends(), this.parseMarkGroup();
	}
	parseScale() {
		parseScales(this);
	}
	parseProjection() {
		parseProjection(this);
	}
	renameTopLevelLayoutSizeSignal() {
		this.getName("width") !== "width" && this.renameSignal(this.getName("width"), "width"), this.getName("height") !== "height" && this.renameSignal(this.getName("height"), "height");
	}
	parseLegends() {
		parseLegend(this);
	}
	assembleEncodeFromView(t) {
		let { style: n,...r } = t, i = {};
		for (let t of keys(r)) {
			let n = r[t];
			n !== void 0 && (i[t] = signalOrValueRef(n));
		}
		return i;
	}
	assembleGroupEncodeEntry(t) {
		let n = {};
		return this.view && (n = this.assembleEncodeFromView(this.view)), !t && (this.description && (n.description = signalOrValueRef(this.description)), this.type === "unit" || this.type === "layer") ? {
			width: this.getSizeSignalRef("width"),
			height: this.getSizeSignalRef("height"),
			...n
		} : isEmpty(n) ? void 0 : n;
	}
	assembleLayout() {
		if (!this.layout) return;
		let { spacing: t,...n } = this.layout, { component: r, config: i } = this, o = assembleLayoutTitleBand(r.layoutHeaders, i);
		return {
			padding: t,
			...this.assembleDefaultLayout(),
			...n,
			...o ? { titleBand: o } : {}
		};
	}
	assembleDefaultLayout() {
		return {};
	}
	assembleHeaderMarks() {
		let { layoutHeaders: t } = this.component, n = [];
		for (let r of FACET_CHANNELS) t[r].title && n.push(assembleTitleGroup(this, r));
		for (let t of HEADER_CHANNELS) n = n.concat(assembleHeaderGroups(this, t));
		return n;
	}
	assembleAxes() {
		return assembleAxes(this.component.axes, this.config);
	}
	assembleLegends() {
		return assembleLegends(this);
	}
	assembleProjections() {
		return assembleProjections(this);
	}
	assembleTitle() {
		let { encoding: t,...n } = this.title ?? {}, r = {
			...extractTitleConfig(this.config.title).nonMarkTitleProperties,
			...n,
			...t ? { encode: { update: t } } : {}
		};
		if (r.text) return contains(["unit", "layer"], this.type) ? contains(["middle", void 0], r.anchor) && (r.frame ??= "group") : r.anchor ??= "start", isEmpty(r) ? void 0 : r;
	}
	assembleGroup(t = []) {
		let n = {};
		t = t.concat(this.assembleSignals()), t.length > 0 && (n.signals = t);
		let r = this.assembleLayout();
		r && (n.layout = r), n.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
		let i = !this.parent || isFacetModel(this.parent) ? assembleScales(this) : [];
		i.length > 0 && (n.scales = i);
		let o = this.assembleAxes();
		o.length > 0 && (n.axes = o);
		let s = this.assembleLegends();
		return s.length > 0 && (n.legends = s), n;
	}
	getName(t) {
		return varName((this.name ? `${this.name}_` : "") + t);
	}
	getDataName(t) {
		return this.getName(DataSourceType[t].toLowerCase());
	}
	requestDataName(t) {
		let n = this.getDataName(t), r = this.component.data.outputNodeRefCounts;
		return r[n] = (r[n] || 0) + 1, n;
	}
	getSizeSignalRef(t) {
		if (isFacetModel(this.parent)) {
			let n = getPositionScaleChannel(getSizeTypeFromLayoutSizeType(t)), r = this.component.scales[n];
			if (r && !r.merged) {
				let t = r.get("type"), i = r.get("range");
				if (hasDiscreteDomain(t) && isVgRangeStep(i)) {
					let t = r.get("name"), i = getFieldFromDomain(assembleDomain(this, n));
					return i ? { signal: sizeExpr(t, r, vgField({
						aggregate: "distinct",
						field: i
					}, { expr: "datum" })) } : (warn(unknownField(n)), null);
				}
			}
		}
		return { signal: this.signalNameMap.get(this.getName(t)) };
	}
	lookupDataSource(t) {
		let n = this.component.data.outputNodes[t];
		return n ? n.getSource() : t;
	}
	getSignalName(t) {
		return this.signalNameMap.get(t);
	}
	renameSignal(t, n) {
		this.signalNameMap.rename(t, n);
	}
	renameScale(t, n) {
		this.scaleNameMap.rename(t, n);
	}
	renameProjection(t, n) {
		this.projectionNameMap.rename(t, n);
	}
	scaleName(t, n) {
		if (n) return this.getName(t);
		if (isChannel(t) && isScaleChannel(t) && this.component.scales[t] || this.scaleNameMap.has(this.getName(t))) return this.scaleNameMap.get(this.getName(t));
	}
	projectionName(t) {
		if (t) return this.getName("projection");
		if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection"))) return this.projectionNameMap.get(this.getName("projection"));
	}
	getScaleComponent(t) {
		/* istanbul ignore next: This is warning for debugging test */
		if (!this.component.scales) throw Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
		let n = this.component.scales[t];
		return n && !n.merged ? n : this.parent ? this.parent.getScaleComponent(t) : void 0;
	}
	getScaleType(t) {
		let n = this.getScaleComponent(t);
		return n ? n.get("type") : void 0;
	}
	getSelectionComponent(t, n) {
		let r = this.component.selection[t];
		if (!r && this.parent && (r = this.parent.getSelectionComponent(t, n)), !r) throw Error(selectionNotFound(n));
		return r;
	}
	hasAxisOrientSignalRef() {
		return this.component.axes.x?.some((t) => t.hasOrientSignalRef()) || this.component.axes.y?.some((t) => t.hasOrientSignalRef());
	}
}, ModelWithField = class extends Model {
	vgField(t, n = {}) {
		let r = this.fieldDef(t);
		if (r) return vgField(r, n);
	}
	reduceFieldDef(t, n) {
		return reduce(this.getMapping(), (n, r, i) => {
			let o = getFieldDef(r);
			return o ? t(n, o, i) : n;
		}, n);
	}
	forEachFieldDef(t, n) {
		forEach(this.getMapping(), (n, r) => {
			let i = getFieldDef(n);
			i && t(i, r);
		}, n);
	}
}, DensityTransformNode = class t extends DataFlowNode {
	transform;
	clone() {
		return new t(null, duplicate(this.transform));
	}
	constructor(t, n) {
		super(t), this.transform = n, this.transform = duplicate(n);
		let r = this.transform.as ?? [void 0, void 0];
		this.transform.as = [r[0] ?? "value", r[1] ?? "density"];
		let i = this.transform.resolve ?? "shared";
		this.transform.resolve = i;
	}
	dependentFields() {
		return new Set([this.transform.density, ...this.transform.groupby ?? []]);
	}
	producedFields() {
		return new Set(this.transform.as);
	}
	hash() {
		return `DensityTransform ${hash(this.transform)}`;
	}
	assemble() {
		let { density: t,...n } = this.transform, r = {
			type: "kde",
			field: t,
			...n
		};
		return r.resolve = this.transform.resolve, r;
	}
}, ExtentTransformNode = class t extends DataFlowNode {
	transform;
	clone() {
		return new t(null, duplicate(this.transform));
	}
	constructor(t, n) {
		super(t), this.transform = n, this.transform = duplicate(n);
	}
	dependentFields() {
		return new Set([this.transform.extent]);
	}
	producedFields() {
		return /* @__PURE__ */ new Set([]);
	}
	hash() {
		return `ExtentTransform ${hash(this.transform)}`;
	}
	assemble() {
		let { extent: t, param: n } = this.transform;
		return {
			type: "extent",
			field: t,
			signal: n
		};
	}
}, FlattenTransformNode = class t extends DataFlowNode {
	transform;
	clone() {
		return new t(this.parent, duplicate(this.transform));
	}
	constructor(t, n) {
		super(t), this.transform = n, this.transform = duplicate(n);
		let { flatten: r, as: i = [] } = this.transform;
		this.transform.as = r.map((t, n) => i[n] ?? t);
	}
	dependentFields() {
		return new Set(this.transform.flatten);
	}
	producedFields() {
		return new Set(this.transform.as);
	}
	hash() {
		return `FlattenTransform ${hash(this.transform)}`;
	}
	assemble() {
		let { flatten: t, as: n } = this.transform;
		return {
			type: "flatten",
			fields: t,
			as: n
		};
	}
}, FoldTransformNode = class t extends DataFlowNode {
	transform;
	clone() {
		return new t(null, duplicate(this.transform));
	}
	constructor(t, n) {
		super(t), this.transform = n, this.transform = duplicate(n);
		let r = this.transform.as ?? [void 0, void 0];
		this.transform.as = [r[0] ?? "key", r[1] ?? "value"];
	}
	dependentFields() {
		return new Set(this.transform.fold);
	}
	producedFields() {
		return new Set(this.transform.as);
	}
	hash() {
		return `FoldTransform ${hash(this.transform)}`;
	}
	assemble() {
		let { fold: t, as: n } = this.transform;
		return {
			type: "fold",
			fields: t,
			as: n
		};
	}
}, GeoJSONNode = class t extends DataFlowNode {
	fields;
	geojson;
	signal;
	clone() {
		return new t(null, duplicate(this.fields), this.geojson, this.signal);
	}
	static parseAll(n, r) {
		if (r.component.projection && !r.component.projection.isFit) return n;
		let i = 0;
		for (let o of [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]) {
			let s = o.map((t) => {
				let n = getFieldOrDatumDef(r.encoding[t]);
				return isFieldDef(n) ? n.field : isDatumDef(n) ? { expr: `${n.datum}` } : isValueDef(n) ? { expr: `${n.value}` } : void 0;
			});
			(s[0] || s[1]) && (n = new t(n, s, null, r.getName(`geojson_${i++}`)));
		}
		if (r.channelHasField(SHAPE)) {
			let o = r.typedFieldDef(SHAPE);
			o.type === GEOJSON && (n = new t(n, null, o.field, r.getName(`geojson_${i++}`)));
		}
		return n;
	}
	constructor(t, n, r, i) {
		super(t), this.fields = n, this.geojson = r, this.signal = i;
	}
	dependentFields() {
		let t = (this.fields ?? []).filter(isString);
		return new Set([...this.geojson ? [this.geojson] : [], ...t]);
	}
	producedFields() {
		return /* @__PURE__ */ new Set();
	}
	hash() {
		return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;
	}
	assemble() {
		return [...this.geojson ? [{
			type: "filter",
			expr: `isValid(datum["${this.geojson}"])`
		}] : [], {
			type: "geojson",
			...this.fields ? { fields: this.fields } : {},
			...this.geojson ? { geojson: this.geojson } : {},
			signal: this.signal
		}];
	}
}, GeoPointNode = class t extends DataFlowNode {
	projection;
	fields;
	as;
	clone() {
		return new t(null, this.projection, duplicate(this.fields), duplicate(this.as));
	}
	constructor(t, n, r, i) {
		super(t), this.projection = n, this.fields = r, this.as = i;
	}
	static parseAll(n, r) {
		if (!r.projectionName()) return n;
		for (let i of [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]) {
			let o = i.map((t) => {
				let n = getFieldOrDatumDef(r.encoding[t]);
				return isFieldDef(n) ? n.field : isDatumDef(n) ? { expr: `${n.datum}` } : isValueDef(n) ? { expr: `${n.value}` } : void 0;
			}), s = i[0] === LONGITUDE2 ? "2" : "";
			(o[0] || o[1]) && (n = new t(n, r.projectionName(), o, [r.getName(`x${s}`), r.getName(`y${s}`)]));
		}
		return n;
	}
	dependentFields() {
		return new Set(this.fields.filter(isString));
	}
	producedFields() {
		return new Set(this.as);
	}
	hash() {
		return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;
	}
	assemble() {
		return {
			type: "geopoint",
			projection: this.projection,
			fields: this.fields,
			as: this.as
		};
	}
}, ImputeNode = class t extends DataFlowNode {
	transform;
	clone() {
		return new t(null, duplicate(this.transform));
	}
	constructor(t, n) {
		super(t), this.transform = n;
	}
	dependentFields() {
		return new Set([
			this.transform.impute,
			this.transform.key,
			...this.transform.groupby ?? []
		]);
	}
	producedFields() {
		return new Set([this.transform.impute]);
	}
	processSequence(t) {
		let { start: n = 0, stop: r, step: i } = t;
		return { signal: `sequence(${[
			n,
			r,
			...i ? [i] : []
		].join(",")})` };
	}
	static makeFromTransform(n, r) {
		return new t(n, r);
	}
	static makeFromEncoding(n, r) {
		let i = r.encoding, o = i.x, s = i.y;
		if (isFieldDef(o) && isFieldDef(s)) {
			let l = o.impute ? o : s.impute ? s : void 0;
			if (l === void 0) return;
			let u = o.impute ? s : s.impute ? o : void 0, { method: d, value: f, frame: p, keyvals: g } = l.impute, _ = pathGroupingFields(r.mark, i);
			return new t(n, {
				impute: l.field,
				key: u.field,
				...d ? { method: d } : {},
				...f === void 0 ? {} : { value: f },
				...p ? { frame: p } : {},
				...g === void 0 ? {} : { keyvals: g },
				..._.length ? { groupby: _ } : {}
			});
		}
		return null;
	}
	hash() {
		return `Impute ${hash(this.transform)}`;
	}
	assemble() {
		let { impute: t, key: n, keyvals: r, method: i, groupby: o, value: s, frame: l = [null, null] } = this.transform, u = {
			type: "impute",
			field: t,
			key: n,
			...r ? { keyvals: isImputeSequence(r) ? this.processSequence(r) : r } : {},
			method: "value",
			...o ? { groupby: o } : {},
			value: !i || i === "value" ? s : null
		};
		return i && i !== "value" ? [
			u,
			{
				type: "window",
				as: [`imputed_${t}_value`],
				ops: [i],
				fields: [t],
				frame: l,
				ignorePeers: !1,
				...o ? { groupby: o } : {}
			},
			{
				type: "formula",
				expr: `datum.${t} === null ? datum.imputed_${t}_value : datum.${t}`,
				as: t
			}
		] : [u];
	}
}, LoessTransformNode = class t extends DataFlowNode {
	transform;
	clone() {
		return new t(null, duplicate(this.transform));
	}
	constructor(t, n) {
		super(t), this.transform = n, this.transform = duplicate(n);
		let r = this.transform.as ?? [void 0, void 0];
		this.transform.as = [r[0] ?? n.on, r[1] ?? n.loess];
	}
	dependentFields() {
		return new Set([
			this.transform.loess,
			this.transform.on,
			...this.transform.groupby ?? []
		]);
	}
	producedFields() {
		return new Set(this.transform.as);
	}
	hash() {
		return `LoessTransform ${hash(this.transform)}`;
	}
	assemble() {
		let { loess: t, on: n,...r } = this.transform;
		return {
			type: "loess",
			x: n,
			y: t,
			...r
		};
	}
}, LookupNode = class t extends DataFlowNode {
	transform;
	secondary;
	clone() {
		return new t(null, duplicate(this.transform), this.secondary);
	}
	constructor(t, n, r) {
		super(t), this.transform = n, this.secondary = r;
	}
	static make(n, r, i, o) {
		let s = r.component.data.sources, { from: l } = i, u = null;
		if (isLookupData(l)) {
			let t = findSource(l.data, s);
			t || (t = new SourceNode(l.data), s.push(t));
			let n = r.getName(`lookup_${o}`);
			u = new OutputNode(t, n, DataSourceType.Lookup, r.component.data.outputNodeRefCounts), r.component.data.outputNodes[n] = u;
		} else if (isLookupSelection(l)) {
			let t = l.param;
			i = {
				as: t,
				...i
			};
			let n;
			try {
				n = r.getSelectionComponent(varName(t), t);
			} catch {
				throw Error(cannotLookupVariableParameter(t));
			}
			if (u = n.materialized, !u) throw Error(noSameUnitLookup(t));
		}
		return new t(n, i, u.getSource());
	}
	dependentFields() {
		return new Set([this.transform.lookup]);
	}
	producedFields() {
		return new Set(this.transform.as ? array(this.transform.as) : this.transform.from.fields);
	}
	hash() {
		return `Lookup ${hash({
			transform: this.transform,
			secondary: this.secondary
		})}`;
	}
	assemble() {
		let t;
		if (this.transform.from.fields) t = {
			values: this.transform.from.fields,
			...this.transform.as ? { as: array(this.transform.as) } : {}
		};
		else {
			let n = this.transform.as;
			isString(n) || (warn(NO_FIELDS_NEEDS_AS), n = "_lookup"), t = { as: [n] };
		}
		return {
			type: "lookup",
			from: this.secondary,
			key: this.transform.from.key,
			fields: [this.transform.lookup],
			...t,
			...this.transform.default ? { default: this.transform.default } : {}
		};
	}
}, QuantileTransformNode = class t extends DataFlowNode {
	transform;
	clone() {
		return new t(null, duplicate(this.transform));
	}
	constructor(t, n) {
		super(t), this.transform = n, this.transform = duplicate(n);
		let r = this.transform.as ?? [void 0, void 0];
		this.transform.as = [r[0] ?? "prob", r[1] ?? "value"];
	}
	dependentFields() {
		return new Set([this.transform.quantile, ...this.transform.groupby ?? []]);
	}
	producedFields() {
		return new Set(this.transform.as);
	}
	hash() {
		return `QuantileTransform ${hash(this.transform)}`;
	}
	assemble() {
		let { quantile: t,...n } = this.transform;
		return {
			type: "quantile",
			field: t,
			...n
		};
	}
}, RegressionTransformNode = class t extends DataFlowNode {
	transform;
	clone() {
		return new t(null, duplicate(this.transform));
	}
	constructor(t, n) {
		super(t), this.transform = n, this.transform = duplicate(n);
		let r = this.transform.as ?? [void 0, void 0];
		this.transform.as = [r[0] ?? n.on, r[1] ?? n.regression];
	}
	dependentFields() {
		return new Set([
			this.transform.regression,
			this.transform.on,
			...this.transform.groupby ?? []
		]);
	}
	producedFields() {
		return new Set(this.transform.as);
	}
	hash() {
		return `RegressionTransform ${hash(this.transform)}`;
	}
	assemble() {
		let { regression: t, on: n,...r } = this.transform;
		return {
			type: "regression",
			x: n,
			y: t,
			...r
		};
	}
}, PivotTransformNode = class t extends DataFlowNode {
	transform;
	clone() {
		return new t(null, duplicate(this.transform));
	}
	constructor(t, n) {
		super(t), this.transform = n;
	}
	addDimensions(t) {
		this.transform.groupby = unique((this.transform.groupby ?? []).concat(t), (t) => t);
	}
	producedFields() {}
	dependentFields() {
		return new Set([
			this.transform.pivot,
			this.transform.value,
			...this.transform.groupby ?? []
		]);
	}
	hash() {
		return `PivotTransform ${hash(this.transform)}`;
	}
	assemble() {
		let { pivot: t, value: n, groupby: r, limit: i, op: o } = this.transform;
		return {
			type: "pivot",
			field: t,
			value: n,
			...i === void 0 ? {} : { limit: i },
			...o === void 0 ? {} : { op: o },
			...r === void 0 ? {} : { groupby: r }
		};
	}
}, SampleTransformNode = class t extends DataFlowNode {
	transform;
	clone() {
		return new t(null, duplicate(this.transform));
	}
	constructor(t, n) {
		super(t), this.transform = n;
	}
	dependentFields() {
		return /* @__PURE__ */ new Set();
	}
	producedFields() {
		return /* @__PURE__ */ new Set();
	}
	hash() {
		return `SampleTransform ${hash(this.transform)}`;
	}
	assemble() {
		return {
			type: "sample",
			size: this.transform.sample
		};
	}
};
function makeWalkTree(t) {
	let n = 0;
	function r(i, o) {
		if (i instanceof SourceNode && !i.isGenerator && !isUrlData(i.data) && (t.push(o), o = {
			name: null,
			source: o.name,
			transform: []
		}), i instanceof ParseNode && (i.parent instanceof SourceNode && !o.source ? (o.format = {
			...o.format,
			parse: i.assembleFormatParse()
		}, o.transform.push(...i.assembleTransforms(!0))) : o.transform.push(...i.assembleTransforms())), i instanceof FacetNode) {
			o.name ||= `data_${n++}`, !o.source || o.transform.length > 0 ? (t.push(o), i.data = o.name) : i.data = o.source, t.push(...i.assemble());
			return;
		}
		switch ((i instanceof GraticuleNode || i instanceof SequenceNode || i instanceof FilterInvalidNode || i instanceof FilterNode || i instanceof CalculateNode || i instanceof GeoPointNode || i instanceof AggregateNode || i instanceof LookupNode || i instanceof WindowTransformNode || i instanceof JoinAggregateTransformNode || i instanceof FoldTransformNode || i instanceof FlattenTransformNode || i instanceof DensityTransformNode || i instanceof LoessTransformNode || i instanceof QuantileTransformNode || i instanceof RegressionTransformNode || i instanceof IdentifierNode || i instanceof SampleTransformNode || i instanceof PivotTransformNode || i instanceof ExtentTransformNode) && o.transform.push(i.assemble()), (i instanceof BinNode || i instanceof TimeUnitNode || i instanceof ImputeNode || i instanceof StackNode || i instanceof GeoJSONNode) && o.transform.push(...i.assemble()), i instanceof OutputNode && (o.source && o.transform.length === 0 ? i.setSource(o.source) : i.parent instanceof OutputNode ? i.setSource(o.name) : (o.name ||= `data_${n++}`, i.setSource(o.name), i.numChildren() === 1 && (t.push(o), o = {
			name: null,
			source: o.name,
			transform: []
		}))), i.numChildren()) {
			case 0:
				i instanceof OutputNode && (!o.source || o.transform.length > 0) && t.push(o);
				break;
			case 1:
				r(i.children[0], o);
				break;
			default: {
				o.name ||= `data_${n++}`;
				let s = o.name;
				!o.source || o.transform.length > 0 ? t.push(o) : s = o.source;
				for (let t of i.children) r(t, {
					name: null,
					source: s,
					transform: []
				});
				break;
			}
		}
	}
	return r;
}
function assembleFacetData(t) {
	let n = [], r = makeWalkTree(n);
	for (let n of t.children) r(n, {
		source: t.name,
		name: null,
		transform: []
	});
	return n;
}
function assembleRootData(t, n) {
	let r = [], i = makeWalkTree(r), o = 0;
	for (let n of t.sources) n.hasName() || (n.dataName = `source_${o++}`), i(n, n.assemble());
	for (let t of r) t.transform.length === 0 && delete t.transform;
	let s = 0;
	for (let [t, n] of r.entries()) (n.transform ?? []).length === 0 && !n.source && r.splice(s++, 0, r.splice(t, 1)[0]);
	for (let n of r) for (let r of n.transform ?? []) r.type === "lookup" && (r.from = t.outputNodes[r.from].getSource());
	for (let t of r) t.name in n && (t.values = n[t.name]);
	return r;
}
function getHeaderType(t) {
	return t === "top" || t === "left" || isSignalRef(t) ? "header" : "footer";
}
function parseFacetHeaders(t) {
	for (let n of FACET_CHANNELS) parseFacetHeader(t, n);
	mergeChildAxis(t, "x"), mergeChildAxis(t, "y");
}
function parseFacetHeader(t, n) {
	let { facet: r, config: i, child: o, component: s } = t;
	if (t.channelHasField(n)) {
		let l = r[n], u = getHeaderProperty("title", null, i, n), d = title(l, i, {
			allowDisabling: !0,
			includeDefault: u === void 0 || !!u
		});
		o.component.layoutHeaders[n].title && (d = isArray(d) ? d.join(", ") : d, d += ` / ${o.component.layoutHeaders[n].title}`, o.component.layoutHeaders[n].title = null);
		let f = getHeaderProperty("labelOrient", l.header, i, n), p = l.header === null ? !1 : getFirstDefined(l.header?.labels, i.header.labels, !0), g = contains(["bottom", "right"], f) ? "footer" : "header";
		s.layoutHeaders[n] = {
			title: l.header === null ? null : d,
			facetFieldDef: l,
			[g]: n === "facet" ? [] : [makeHeaderComponent(t, n, p)]
		};
	}
}
function makeHeaderComponent(t, n, r) {
	let i = n === "row" ? "height" : "width";
	return {
		labels: r,
		sizeSignal: t.child.component.layoutSize.get(i) ? t.child.getSizeSignalRef(i) : void 0,
		axes: []
	};
}
function mergeChildAxis(t, n) {
	let { child: r } = t;
	if (r.component.axes[n]) {
		let { layoutHeaders: i, resolve: o } = t.component;
		if (o.axis[n] = parseGuideResolve(o, n), o.axis[n] === "shared") {
			let o = n === "x" ? "column" : "row", s = i[o];
			for (let i of r.component.axes[n]) {
				let n = getHeaderType(i.get("orient"));
				s[n] ??= [makeHeaderComponent(t, o, !1)];
				let r = assembleAxis(i, "main", t.config, { header: !0 });
				r && s[n][0].axes.push(r), i.mainExtracted = !0;
			}
		}
	}
}
function parseLayerLayoutSize(t) {
	parseChildrenLayoutSize(t), parseNonUnitLayoutSizeForChannel(t, "width"), parseNonUnitLayoutSizeForChannel(t, "height");
}
function parseConcatLayoutSize(t) {
	parseChildrenLayoutSize(t);
	let n = t.layout.columns === 1 ? "width" : "childWidth", r = t.layout.columns === void 0 ? "height" : "childHeight";
	parseNonUnitLayoutSizeForChannel(t, n), parseNonUnitLayoutSizeForChannel(t, r);
}
function parseChildrenLayoutSize(t) {
	for (let n of t.children) n.parseLayoutSize();
}
function parseNonUnitLayoutSizeForChannel(t, n) {
	let r = getSizeTypeFromLayoutSizeType(n), i = getPositionScaleChannel(r), o = t.component.resolve, s = t.component.layoutSize, l;
	for (let n of t.children) {
		let s = n.component.layoutSize.getWithExplicit(r), u = o.scale[i] ?? defaultScaleResolve(i, t);
		if (u === "independent" && s.value === "step") {
			l = void 0;
			break;
		}
		if (l) {
			if (u === "independent" && l.value !== s.value) {
				l = void 0;
				break;
			}
			l = mergeValuesWithExplicit(l, s, r, "");
		} else l = s;
	}
	if (l) {
		for (let i of t.children) t.renameSignal(i.getName(r), t.getName(n)), i.component.layoutSize.set(r, "merged", !1);
		s.setWithExplicit(n, l);
	} else s.setWithExplicit(n, {
		explicit: !1,
		value: void 0
	});
}
function parseUnitLayoutSize(t) {
	let { size: n, component: r } = t;
	for (let i of POSITION_SCALE_CHANNELS) {
		let o = getSizeChannel(i);
		if (n[o] != null && n[o] != null) {
			let t = n[o];
			r.layoutSize.set(o, isStep(t) ? "step" : t, !0);
		} else {
			let n = defaultUnitSize(t, o);
			r.layoutSize.set(o, n, !1);
		}
	}
}
function defaultUnitSize(t, n) {
	let r = n === "width" ? "x" : "y", i = t.config, o = t.getScaleComponent(r);
	if (o) {
		let t = o.get("type"), r = o.get("range");
		if (hasDiscreteDomain(t)) {
			let t = getViewConfigDiscreteSize(i.view, n);
			return isVgRangeStep(r) || isStep(t) ? "step" : t;
		} else return getViewConfigContinuousSize(i.view, n);
	} else if (t.hasProjection || t.mark === "arc") return getViewConfigContinuousSize(i.view, n);
	else {
		let t = getViewConfigDiscreteSize(i.view, n);
		return isStep(t) ? t.step : t;
	}
}
function facetSortFieldName(t, n, r) {
	return vgField(n, {
		suffix: `by_${vgField(t)}`,
		...r
	});
}
var FacetModel = class t extends ModelWithField {
	facet;
	child;
	children;
	constructor(t, n, r, i) {
		super(t, "facet", n, r, i, t.resolve), this.child = buildModel(t.spec, this, this.getName("child"), void 0, i), this.children = [this.child], this.facet = this.initFacet(t.facet);
	}
	initFacet(t) {
		if (!isFacetMapping(t)) return { facet: this.initFacetFieldDef(t, "facet") };
		let n = keys(t), r = {};
		for (let i of n) {
			if (![ROW, COLUMN].includes(i)) {
				warn(incompatibleChannel(i, "facet"));
				break;
			}
			let n = t[i];
			if (n.field === void 0) {
				warn(emptyFieldDef(n, i));
				break;
			}
			r[i] = this.initFacetFieldDef(n, i);
		}
		return r;
	}
	initFacetFieldDef(t, n) {
		let r = initFieldDef(t, n);
		return r.header ? r.header = replaceExprRef(r.header) : r.header === null && (r.header = null), r;
	}
	channelHasField(t) {
		return hasProperty(this.facet, t);
	}
	fieldDef(t) {
		return this.facet[t];
	}
	parseData() {
		this.component.data = parseData(this), this.child.parseData();
	}
	parseLayoutSize() {
		parseChildrenLayoutSize(this);
	}
	parseSelections() {
		this.child.parseSelections(), this.component.selection = this.child.component.selection, vals(this.component.selection).some((t) => isTimerSelection(t)) && error(MULTI_VIEW_ANIMATION_UNSUPPORTED);
	}
	parseMarkGroup() {
		this.child.parseMarkGroup();
	}
	parseAxesAndHeaders() {
		this.child.parseAxesAndHeaders(), parseFacetHeaders(this);
	}
	assembleSelectionTopLevelSignals(t) {
		return this.child.assembleSelectionTopLevelSignals(t);
	}
	assembleSignals() {
		return this.child.assembleSignals(), [];
	}
	assembleSelectionData(t) {
		return this.child.assembleSelectionData(t);
	}
	getHeaderLayoutMixins() {
		let t = {};
		for (let n of FACET_CHANNELS) for (let r of HEADER_TYPES) {
			let i = this.component.layoutHeaders[n], o = i[r], { facetFieldDef: s } = i;
			if (s) {
				let r = getHeaderProperty("titleOrient", s.header, this.config, n);
				if (["right", "bottom"].includes(r)) {
					let i = getHeaderChannel(n, r);
					t.titleAnchor ??= {}, t.titleAnchor[i] = "end";
				}
			}
			if (o?.[0]) {
				let o = n === "row" ? "height" : "width", s = r === "header" ? "headerBand" : "footerBand";
				n !== "facet" && !this.child.component.layoutSize.get(o) && (t[s] ??= {}, t[s][n] = .5), i.title && (t.offset ??= {}, t.offset[n === "row" ? "rowTitle" : "columnTitle"] = 10);
			}
		}
		return t;
	}
	assembleDefaultLayout() {
		let { column: t, row: n } = this.facet, r = t ? this.columnDistinctSignal() : n ? 1 : void 0, i = "all";
		return (!n && this.component.resolve.scale.x === "independent" || !t && this.component.resolve.scale.y === "independent") && (i = "none"), {
			...this.getHeaderLayoutMixins(),
			...r ? { columns: r } : {},
			bounds: "full",
			align: i
		};
	}
	assembleLayoutSignals() {
		return this.child.assembleLayoutSignals();
	}
	columnDistinctSignal() {
		if (!(this.parent && this.parent instanceof t)) return { signal: `length(data('${this.getName("column_domain")}'))` };
	}
	assembleGroupStyle() {}
	assembleGroup(n) {
		return this.parent && this.parent instanceof t ? {
			...this.channelHasField("column") ? { encode: { update: { columns: { field: vgField(this.facet.column, { prefix: "distinct" }) } } } } : {},
			...super.assembleGroup(n)
		} : super.assembleGroup(n);
	}
	getCardinalityAggregateForChild() {
		let n = [], r = [], i = [];
		if (this.child instanceof t) {
			if (this.child.channelHasField("column")) {
				let t = vgField(this.child.facet.column);
				n.push(t), r.push("distinct"), i.push(`distinct_${t}`);
			}
		} else for (let t of POSITION_SCALE_CHANNELS) {
			let o = this.child.component.scales[t];
			if (o && !o.merged) {
				let s = o.get("type"), l = o.get("range");
				if (hasDiscreteDomain(s) && isVgRangeStep(l)) {
					let o = getFieldFromDomain(assembleDomain(this.child, t));
					o ? (n.push(o), r.push("distinct"), i.push(`distinct_${o}`)) : warn(unknownField(t));
				}
			}
		}
		return {
			fields: n,
			ops: r,
			as: i
		};
	}
	assembleFacet() {
		let { name: t, data: n } = this.component.data.facetRoot, { row: r, column: i } = this.facet, { fields: o, ops: s, as: l } = this.getCardinalityAggregateForChild(), u = [];
		for (let t of FACET_CHANNELS) {
			let n = this.facet[t];
			if (n) {
				u.push(vgField(n));
				let { bin: d, sort: f } = n;
				if (isBinning(d) && u.push(vgField(n, { binSuffix: "end" })), isSortField(f)) {
					let { field: t, op: u = DEFAULT_SORT_OP } = f, d = facetSortFieldName(n, f);
					r && i ? (o.push(d), s.push("max"), l.push(d)) : (o.push(t), s.push(u), l.push(d));
				} else if (isArray(f)) {
					let r = sortArrayIndexField(n, t);
					o.push(r), s.push("max"), l.push(r);
				}
			}
		}
		let d = !!r && !!i;
		return {
			name: t,
			data: n,
			groupby: u,
			...d || o.length > 0 ? { aggregate: {
				...d ? { cross: d } : {},
				...o.length ? {
					fields: o,
					ops: s,
					as: l
				} : {}
			} } : {}
		};
	}
	facetSortFields(t) {
		let { facet: n } = this, r = n[t];
		return r ? isSortField(r.sort) ? [facetSortFieldName(r, r.sort, { expr: "datum" })] : isArray(r.sort) ? [sortArrayIndexField(r, t, { expr: "datum" })] : [vgField(r, { expr: "datum" })] : [];
	}
	facetSortOrder(t) {
		let { facet: n } = this, r = n[t];
		if (r) {
			let { sort: t } = r;
			return [(isSortField(t) ? t.order : !isArray(t) && t) || "ascending"];
		}
		return [];
	}
	assembleLabelTitle() {
		let { facet: t, config: n } = this;
		if (t.facet) return assembleLabelTitle(t.facet, "facet", n);
		let r = {
			row: ["top", "bottom"],
			column: ["left", "right"]
		};
		for (let i of HEADER_CHANNELS) if (t[i]) {
			let o = getHeaderProperty("labelOrient", t[i]?.header, n, i);
			if (r[i].includes(o)) return assembleLabelTitle(t[i], i, n);
		}
	}
	assembleMarks() {
		let { child: t } = this, n = this.component.data.facetRoot, r = assembleFacetData(n), i = t.assembleGroupEncodeEntry(!1), o = this.assembleLabelTitle() || t.assembleTitle(), s = t.assembleGroupStyle();
		return [{
			name: this.getName("cell"),
			type: "group",
			...o ? { title: o } : {},
			...s ? { style: s } : {},
			from: { facet: this.assembleFacet() },
			sort: {
				field: FACET_CHANNELS.map((t) => this.facetSortFields(t)).flat(),
				order: FACET_CHANNELS.map((t) => this.facetSortOrder(t)).flat()
			},
			...r.length > 0 ? { data: r } : {},
			...i ? { encode: { update: i } } : {},
			...t.assembleGroup(assembleFacetSignals(this, []))
		}];
	}
	getMapping() {
		return this.facet;
	}
};
function makeJoinAggregateFromFacet(t, n) {
	let { row: r, column: i } = n;
	if (r && i) {
		let n = null;
		for (let o of [r, i]) if (isSortField(o.sort)) {
			let { field: r, op: i = DEFAULT_SORT_OP } = o.sort;
			t = n = new JoinAggregateTransformNode(t, {
				joinaggregate: [{
					op: i,
					field: r,
					as: facetSortFieldName(o, o.sort, { forAs: !0 })
				}],
				groupby: [vgField(o)]
			});
		}
		return n;
	}
	return null;
}
function findSource(t, n) {
	for (let r of n) {
		let n = r.data;
		if (t.name && r.hasName() && t.name !== r.dataName) continue;
		let i = t.format?.mesh, o = n.format?.feature;
		if (i && o) continue;
		let s = t.format?.feature;
		if ((s || o) && s !== o) continue;
		let l = n.format?.mesh;
		if (!((i || l) && i !== l)) {
			if (isInlineData(t) && isInlineData(n)) {
				if (deepEqual(t.values, n.values)) return r;
			} else if (isUrlData(t) && isUrlData(n)) {
				if (t.url === n.url) return r;
			} else if (isNamedData(t) && t.name === r.dataName) return r;
		}
	}
	return null;
}
function parseRoot(t, n) {
	if (t.data || !t.parent) {
		if (t.data === null) {
			let t = new SourceNode({ values: [] });
			return n.push(t), t;
		}
		let r = findSource(t.data, n);
		if (r) return isGenerator(t.data) || (r.data.format = mergeDeep$1({}, t.data.format, r.data.format)), !r.hasName() && t.data.name && (r.dataName = t.data.name), r;
		{
			let r = new SourceNode(t.data);
			return n.push(r), r;
		}
	} else return t.parent.component.data.facetRoot ? t.parent.component.data.facetRoot : t.parent.component.data.main;
}
function parseTransformArray(t, n, r) {
	let i = 0;
	for (let o of n.transforms) {
		let s, l;
		if (isCalculate(o)) l = t = new CalculateNode(t, o), s = "derived";
		else if (isFilter(o)) {
			let i = getImplicitFromFilterTransform(o);
			l = t = ParseNode.makeWithAncestors(t, {}, i, r) ?? t, t = new FilterNode(t, n, o.filter);
		} else if (isBin(o)) l = t = BinNode.makeFromTransform(t, o, n), s = "number";
		else if (isTimeUnit(o)) s = "date", r.getWithExplicit(o.field).value === void 0 && (t = new ParseNode(t, { [o.field]: s }), r.set(o.field, s, !1)), l = t = TimeUnitNode.makeFromTransform(t, o);
		else if (isAggregate(o)) l = t = AggregateNode.makeFromTransform(t, o), s = "number", requiresSelectionId(n) && (t = new IdentifierNode(t));
		else if (isLookup(o)) l = t = LookupNode.make(t, n, o, i++), s = "derived";
		else if (isWindow(o)) l = t = new WindowTransformNode(t, o), s = "number";
		else if (isJoinAggregate(o)) l = t = new JoinAggregateTransformNode(t, o), s = "number";
		else if (isStack(o)) l = t = StackNode.makeFromTransform(t, o), s = "derived";
		else if (isFold(o)) l = t = new FoldTransformNode(t, o), s = "derived";
		else if (isExtent(o)) l = t = new ExtentTransformNode(t, o), s = "derived";
		else if (isFlatten(o)) l = t = new FlattenTransformNode(t, o), s = "derived";
		else if (isPivot(o)) l = t = new PivotTransformNode(t, o), s = "derived";
		else if (isSample(o)) t = new SampleTransformNode(t, o);
		else if (isImpute(o)) l = t = ImputeNode.makeFromTransform(t, o), s = "derived";
		else if (isDensity(o)) l = t = new DensityTransformNode(t, o), s = "derived";
		else if (isQuantile(o)) l = t = new QuantileTransformNode(t, o), s = "derived";
		else if (isRegression(o)) l = t = new RegressionTransformNode(t, o), s = "derived";
		else if (isLoess(o)) l = t = new LoessTransformNode(t, o), s = "derived";
		else {
			warn(invalidTransformIgnored(o));
			continue;
		}
		if (l && s !== void 0) for (let t of l.producedFields() ?? []) r.set(t, s, !1);
	}
	return t;
}
function parseData(t) {
	let n = parseRoot(t, t.component.data.sources), { outputNodes: r, outputNodeRefCounts: i } = t.component.data, o = t.data, s = !(o && (isGenerator(o) || isUrlData(o) || isInlineData(o))) && t.parent ? t.parent.component.data.ancestorParse.clone() : new AncestorParse();
	isGenerator(o) ? (isSequenceGenerator(o) ? n = new SequenceNode(n, o.sequence) : isGraticuleGenerator(o) && (n = new GraticuleNode(n, o.graticule)), s.parseNothing = !0) : o?.format?.parse === null && (s.parseNothing = !0), n = ParseNode.makeExplicit(n, t, s) ?? n, n = new IdentifierNode(n);
	let l = t.parent && isLayerModel(t.parent);
	(isUnitModel(t) || isFacetModel(t)) && l && (n = BinNode.makeFromEncoding(n, t) ?? n), t.transforms.length > 0 && (n = parseTransformArray(n, t, s));
	let u = getImplicitFromSelection(t), d = getImplicitFromEncoding(t);
	n = ParseNode.makeWithAncestors(n, {}, {
		...u,
		...d
	}, s) ?? n, isUnitModel(t) && (n = GeoJSONNode.parseAll(n, t), n = GeoPointNode.parseAll(n, t)), (isUnitModel(t) || isFacetModel(t)) && (l || (n = BinNode.makeFromEncoding(n, t) ?? n), n = TimeUnitNode.makeFromEncoding(n, t) ?? n, n = CalculateNode.parseAllForSortIndex(n, t));
	let f = n = makeOutputNode(DataSourceType.Raw, t, n);
	if (isUnitModel(t)) {
		let r = AggregateNode.makeFromEncoding(n, t);
		r && (n = r, requiresSelectionId(t) && (n = new IdentifierNode(n))), n = ImputeNode.makeFromEncoding(n, t) ?? n, n = StackNode.makeFromEncoding(n, t) ?? n;
	}
	let p, g;
	if (isUnitModel(t)) {
		let { markDef: r, mark: i, config: o } = t, { marks: s, scales: l } = g = getDataSourcesForHandlingInvalidValues({
			invalid: getMarkPropOrConfig("invalid", r, o),
			isPath: isPathMark(i)
		});
		s !== l && l === "include-invalid-values" && (p = n = makeOutputNode(DataSourceType.PreFilterInvalid, t, n)), s === "exclude-invalid-values" && (n = FilterInvalidNode.make(n, t, g) ?? n);
	}
	let _ = n = makeOutputNode(DataSourceType.Main, t, n), v;
	if (isUnitModel(t) && g) {
		let { marks: r, scales: i } = g;
		r === "include-invalid-values" && i === "exclude-invalid-values" && (n = FilterInvalidNode.make(n, t, g) ?? n, v = n = makeOutputNode(DataSourceType.PostFilterInvalid, t, n));
	}
	isUnitModel(t) && materializeSelections(t, _);
	let S = null;
	if (isFacetModel(t)) {
		let i = t.getName("facet");
		n = makeJoinAggregateFromFacet(n, t.facet) ?? n, S = new FacetNode(n, t, i, _.getSource()), r[i] = S;
	}
	return {
		...t.component.data,
		outputNodes: r,
		outputNodeRefCounts: i,
		raw: f,
		main: _,
		facetRoot: S,
		ancestorParse: s,
		preFilterInvalid: p,
		postFilterInvalid: v
	};
}
function makeOutputNode(t, n, r) {
	let { outputNodes: i, outputNodeRefCounts: o } = n.component.data, s = n.getDataName(t), l = new OutputNode(r, s, t, o);
	return i[s] = l, l;
}
var ConcatModel = class extends Model {
	children;
	constructor(t, n, r, i) {
		super(t, "concat", n, r, i, t.resolve), (t.resolve?.axis?.x === "shared" || t.resolve?.axis?.y === "shared") && warn(CONCAT_CANNOT_SHARE_AXIS), this.children = this.getChildren(t).map((t, n) => buildModel(t, this, this.getName(`concat_${n}`), void 0, i));
	}
	parseData() {
		this.component.data = parseData(this);
		for (let t of this.children) t.parseData();
	}
	parseSelections() {
		this.component.selection = {};
		for (let t of this.children) {
			t.parseSelections();
			for (let n of keys(t.component.selection)) this.component.selection[n] = t.component.selection[n];
		}
		vals(this.component.selection).some((t) => isTimerSelection(t)) && error(MULTI_VIEW_ANIMATION_UNSUPPORTED);
	}
	parseMarkGroup() {
		for (let t of this.children) t.parseMarkGroup();
	}
	parseAxesAndHeaders() {
		for (let t of this.children) t.parseAxesAndHeaders();
	}
	getChildren(t) {
		return isVConcatSpec(t) ? t.vconcat : isHConcatSpec(t) ? t.hconcat : t.concat;
	}
	parseLayoutSize() {
		parseConcatLayoutSize(this);
	}
	parseAxisGroup() {
		return null;
	}
	assembleSelectionTopLevelSignals(t) {
		return this.children.reduce((t, n) => n.assembleSelectionTopLevelSignals(t), t);
	}
	assembleSignals() {
		return this.children.forEach((t) => t.assembleSignals()), [];
	}
	assembleLayoutSignals() {
		let t = assembleLayoutSignals(this);
		for (let n of this.children) t.push(...n.assembleLayoutSignals());
		return t;
	}
	assembleSelectionData(t) {
		return this.children.reduce((t, n) => n.assembleSelectionData(t), t);
	}
	assembleMarks() {
		return this.children.map((t) => {
			let n = t.assembleTitle(), r = t.assembleGroupStyle(), i = t.assembleGroupEncodeEntry(!1);
			return {
				type: "group",
				name: t.getName("group"),
				...n ? { title: n } : {},
				...r ? { style: r } : {},
				...i ? { encode: { update: i } } : {},
				...t.assembleGroup()
			};
		});
	}
	assembleGroupStyle() {}
	assembleDefaultLayout() {
		let t = this.layout.columns;
		return {
			...t == null ? {} : { columns: t },
			bounds: "full",
			align: "each"
		};
	}
};
function isFalseOrNull(t) {
	return t === !1 || t === null;
}
var AXIS_COMPONENT_PROPERTIES = keys({
	disable: 1,
	gridScale: 1,
	scale: 1,
	...COMMON_AXIS_PROPERTIES_INDEX,
	labelExpr: 1,
	encode: 1
}), AxisComponent = class t extends Split {
	explicit;
	implicit;
	mainExtracted;
	constructor(t = {}, n = {}, r = !1) {
		super(), this.explicit = t, this.implicit = n, this.mainExtracted = r;
	}
	clone() {
		return new t(duplicate(this.explicit), duplicate(this.implicit), this.mainExtracted);
	}
	hasAxisPart(t) {
		return t === "axis" ? !0 : t === "grid" || t === "title" ? !!this.get(t) : !isFalseOrNull(this.get(t));
	}
	hasOrientSignalRef() {
		return isSignalRef(this.explicit.orient);
	}
};
function labels(t, n, r) {
	let { encoding: i, config: o } = t, s = getFieldOrDatumDef(i[n]) ?? getFieldOrDatumDef(i[getSecondaryRangeChannel(n)]), { format: l, formatType: u } = t.axis(n) || {};
	if (isCustomFormatType(u)) return {
		text: formatCustomType({
			fieldOrDatumDef: s,
			field: "datum.value",
			format: l,
			formatType: u,
			config: o
		}),
		...r
	};
	if (l === void 0 && u === void 0 && o.customFormatTypes) {
		if (channelDefType(s) === "quantitative") {
			if (isPositionFieldOrDatumDef(s) && s.stack === "normalize" && o.normalizedNumberFormatType) return {
				text: formatCustomType({
					fieldOrDatumDef: s,
					field: "datum.value",
					format: o.normalizedNumberFormat,
					formatType: o.normalizedNumberFormatType,
					config: o
				}),
				...r
			};
			if (o.numberFormatType) return {
				text: formatCustomType({
					fieldOrDatumDef: s,
					field: "datum.value",
					format: o.numberFormat,
					formatType: o.numberFormatType,
					config: o
				}),
				...r
			};
		}
		if (channelDefType(s) === "temporal" && o.timeFormatType && isFieldDef(s) && !s.timeUnit) return {
			text: formatCustomType({
				fieldOrDatumDef: s,
				field: "datum.value",
				format: o.timeFormat,
				formatType: o.timeFormatType,
				config: o
			}),
			...r
		};
	}
	return r;
}
function parseUnitAxes(t) {
	return POSITION_SCALE_CHANNELS.reduce((n, r) => (t.component.scales[r] && (n[r] = [parseAxis(r, t)]), n), {});
}
var OPPOSITE_ORIENT = {
	bottom: "top",
	top: "bottom",
	left: "right",
	right: "left"
};
function parseLayerAxes(t) {
	let { axes: n, resolve: r } = t.component, i = {
		top: 0,
		bottom: 0,
		right: 0,
		left: 0
	};
	for (let i of t.children) {
		i.parseAxesAndHeaders();
		for (let o of keys(i.component.axes)) r.axis[o] = parseGuideResolve(t.component.resolve, o), r.axis[o] === "shared" && (n[o] = mergeAxisComponents(n[o], i.component.axes[o]), n[o] || (r.axis[o] = "independent", delete n[o]));
	}
	for (let o of POSITION_SCALE_CHANNELS) {
		for (let s of t.children) if (s.component.axes[o]) {
			if (r.axis[o] === "independent") {
				n[o] = (n[o] ?? []).concat(s.component.axes[o]);
				for (let t of s.component.axes[o]) {
					let { value: n, explicit: r } = t.getWithExplicit("orient");
					if (!isSignalRef(n)) {
						if (i[n] > 0 && !r) {
							let r = OPPOSITE_ORIENT[n];
							i[n] > i[r] && t.set("orient", r, !1);
						}
						i[n]++;
					}
				}
			}
			delete s.component.axes[o];
		}
		if (r.axis[o] === "independent" && n[o] && n[o].length > 1) for (let [t, r] of (n[o] || []).entries()) t > 0 && r.get("grid") && !r.explicit.grid && (r.implicit.grid = !1);
	}
}
function mergeAxisComponents(t, n) {
	if (t) {
		if (t.length !== n.length) return;
		let r = t.length;
		for (let i = 0; i < r; i++) {
			let r = t[i], o = n[i];
			if (!!r != !!o) return;
			if (r && o) {
				let n = r.getWithExplicit("orient"), s = o.getWithExplicit("orient");
				if (n.explicit && s.explicit && n.value !== s.value) return;
				t[i] = mergeAxisComponent(r, o);
			}
		}
	} else return n.map((t) => t.clone());
	return t;
}
function mergeAxisComponent(t, n) {
	for (let r of AXIS_COMPONENT_PROPERTIES) {
		let i = mergeValuesWithExplicit(t.getWithExplicit(r), n.getWithExplicit(r), r, "axis", (t, n) => {
			switch (r) {
				case "title": return mergeTitleComponent(t, n);
				case "gridScale": return {
					explicit: t.explicit,
					value: getFirstDefined(t.value, n.value)
				};
			}
			return defaultTieBreaker(t, n, r, "axis");
		});
		t.setWithExplicit(r, i);
	}
	return t;
}
function isExplicit(t, n, r, i, o) {
	if (n === "disable") return r !== void 0;
	switch (r ||= {}, n) {
		case "titleAngle":
		case "labelAngle": return t === (isSignalRef(r.labelAngle) ? r.labelAngle : normalizeAngle(r.labelAngle));
		case "values": return !!r.values;
		case "encode": return !!r.encoding || !!r.labelAngle;
		case "title": if (t === getFieldDefTitle(i, o)) return !0;
	}
	return t === r[n];
}
var propsToAlwaysIncludeConfig = new Set([
	"grid",
	"translate",
	"format",
	"formatType",
	"orient",
	"labelExpr",
	"tickCount",
	"position",
	"tickMinStep"
]);
function parseAxis(t, n) {
	let r = n.axis(t), i = new AxisComponent(), o = getFieldOrDatumDef(n.encoding[t]), { mark: s, config: l } = n, u = r?.orient || l[t === "x" ? "axisX" : "axisY"]?.orient || l.axis?.orient || defaultOrient(t), d = n.getScaleComponent(t).get("type"), f = getAxisConfigs(t, d, u, n.config), p = r === void 0 ? getAxisConfig("disable", l.style, r?.style, f).configValue : !r;
	if (i.set("disable", p, r !== void 0), p) return i;
	r ||= {};
	let g = getLabelAngle(o, r, t, l.style, f), _ = guideFormatType(r.formatType, o, d), v = guideFormat(o, o.type, r.format, r.formatType, l, !0), S = {
		fieldOrDatumDef: o,
		axis: r,
		channel: t,
		model: n,
		scaleType: d,
		orient: u,
		labelAngle: g,
		format: v,
		formatType: _,
		mark: s,
		config: l
	};
	for (let o of AXIS_COMPONENT_PROPERTIES) {
		let s = o in axisRules ? axisRules[o](S) : isAxisProperty(o) ? r[o] : void 0, u = s !== void 0, d = isExplicit(s, o, r, n, t);
		if (u && d) i.set(o, s, d);
		else {
			let { configValue: t = void 0, configFrom: n = void 0 } = isAxisProperty(o) && o !== "values" ? getAxisConfig(o, l.style, r.style, f) : {}, p = t !== void 0;
			u && !p ? i.set(o, s, d) : (n !== "vgAxisConfig" || propsToAlwaysIncludeConfig.has(o) && p || isConditionalAxisValue(t) || isSignalRef(t)) && i.set(o, t, !1);
		}
	}
	let T = r.encoding ?? {}, E = AXIS_PARTS.reduce((r, o) => {
		if (!i.hasAxisPart(o)) return r;
		let s = guideEncodeEntry(T[o] ?? {}, n), l = o === "labels" ? labels(n, t, s) : s;
		return l !== void 0 && !isEmpty(l) && (r[o] = { update: l }), r;
	}, {});
	return isEmpty(E) || i.set("encode", E, !!r.encoding || r.labelAngle !== void 0), i;
}
function initLayoutSize({ encoding: t, size: n }) {
	for (let r of POSITION_SCALE_CHANNELS) {
		let i = getSizeChannel(r);
		isStep(n[i]) && isContinuousFieldOrDatumDef(t[r]) && (delete n[i], warn(stepDropped(i)));
	}
	return n;
}
var arc = {
	vgMark: "arc",
	encodeEntry: (t) => ({
		...baseEncodeEntry(t, {
			align: "ignore",
			baseline: "ignore",
			color: "include",
			size: "ignore",
			orient: "ignore",
			theta: "ignore"
		}),
		...pointPosition("x", t, { defaultPos: "mid" }),
		...pointPosition("y", t, { defaultPos: "mid" }),
		...rectPosition(t, "radius"),
		...rectPosition(t, "theta")
	})
}, area = {
	vgMark: "area",
	encodeEntry: (t) => ({
		...baseEncodeEntry(t, {
			align: "ignore",
			baseline: "ignore",
			color: "include",
			orient: "include",
			size: "ignore",
			theta: "ignore"
		}),
		...pointOrRangePosition("x", t, {
			defaultPos: "zeroOrMin",
			defaultPos2: "zeroOrMin",
			range: t.markDef.orient === "horizontal"
		}),
		...pointOrRangePosition("y", t, {
			defaultPos: "zeroOrMin",
			defaultPos2: "zeroOrMin",
			range: t.markDef.orient === "vertical"
		}),
		...defined(t)
	})
}, bar = {
	vgMark: "rect",
	encodeEntry: (t) => ({
		...baseEncodeEntry(t, {
			align: "ignore",
			baseline: "ignore",
			color: "include",
			orient: "ignore",
			size: "ignore",
			theta: "ignore"
		}),
		...rectPosition(t, "x"),
		...rectPosition(t, "y")
	})
}, geoshape = {
	vgMark: "shape",
	encodeEntry: (t) => ({ ...baseEncodeEntry(t, {
		align: "ignore",
		baseline: "ignore",
		color: "include",
		size: "ignore",
		orient: "ignore",
		theta: "ignore"
	}) }),
	postEncodingTransform: (t) => {
		let { encoding: n } = t, r = n.shape;
		return [{
			type: "geoshape",
			projection: t.projectionName(),
			...r && isFieldDef(r) && r.type === GEOJSON ? { field: vgField(r, { expr: "datum" }) } : {}
		}];
	}
}, image = {
	vgMark: "image",
	encodeEntry: (t) => ({
		...baseEncodeEntry(t, {
			align: "ignore",
			baseline: "ignore",
			color: "ignore",
			orient: "ignore",
			size: "ignore",
			theta: "ignore"
		}),
		...rectPosition(t, "x"),
		...rectPosition(t, "y"),
		...text$1(t, "url")
	})
}, line = {
	vgMark: "line",
	encodeEntry: (t) => ({
		...baseEncodeEntry(t, {
			align: "ignore",
			baseline: "ignore",
			color: "include",
			size: "ignore",
			orient: "ignore",
			theta: "ignore"
		}),
		...pointPosition("x", t, { defaultPos: "mid" }),
		...pointPosition("y", t, { defaultPos: "mid" }),
		...nonPosition("size", t, { vgChannel: "strokeWidth" }),
		...defined(t)
	})
}, trail = {
	vgMark: "trail",
	encodeEntry: (t) => ({
		...baseEncodeEntry(t, {
			align: "ignore",
			baseline: "ignore",
			color: "include",
			size: "include",
			orient: "ignore",
			theta: "ignore"
		}),
		...pointPosition("x", t, { defaultPos: "mid" }),
		...pointPosition("y", t, { defaultPos: "mid" }),
		...nonPosition("size", t),
		...defined(t)
	})
};
function encodeEntry(t, n) {
	let { config: r } = t;
	return {
		...baseEncodeEntry(t, {
			align: "ignore",
			baseline: "ignore",
			color: "include",
			size: "include",
			orient: "ignore",
			theta: "ignore"
		}),
		...pointPosition("x", t, { defaultPos: "mid" }),
		...pointPosition("y", t, { defaultPos: "mid" }),
		...nonPosition("size", t),
		...nonPosition("angle", t),
		...shapeMixins(t, r, n)
	};
}
function shapeMixins(t, n, r) {
	return r ? { shape: { value: r } } : nonPosition("shape", t);
}
var point = {
	vgMark: "symbol",
	encodeEntry: (t) => encodeEntry(t)
}, circle = {
	vgMark: "symbol",
	encodeEntry: (t) => encodeEntry(t, "circle")
}, square = {
	vgMark: "symbol",
	encodeEntry: (t) => encodeEntry(t, "square")
}, rect = {
	vgMark: "rect",
	encodeEntry: (t) => ({
		...baseEncodeEntry(t, {
			align: "ignore",
			baseline: "ignore",
			color: "include",
			orient: "ignore",
			size: "ignore",
			theta: "ignore"
		}),
		...rectPosition(t, "x"),
		...rectPosition(t, "y")
	})
}, rule = {
	vgMark: "rule",
	encodeEntry: (t) => {
		let { markDef: n } = t, r = n.orient;
		return !t.encoding.x && !t.encoding.y && !t.encoding.latitude && !t.encoding.longitude ? {} : {
			...baseEncodeEntry(t, {
				align: "ignore",
				baseline: "ignore",
				color: "include",
				orient: "ignore",
				size: "ignore",
				theta: "ignore"
			}),
			...pointOrRangePosition("x", t, {
				defaultPos: r === "horizontal" ? "zeroOrMax" : "mid",
				defaultPos2: "zeroOrMin",
				range: r !== "vertical"
			}),
			...pointOrRangePosition("y", t, {
				defaultPos: r === "vertical" ? "zeroOrMax" : "mid",
				defaultPos2: "zeroOrMin",
				range: r !== "horizontal"
			}),
			...nonPosition("size", t, { vgChannel: "strokeWidth" })
		};
	}
}, text = {
	vgMark: "text",
	encodeEntry: (t) => {
		let { config: n, encoding: r } = t;
		return {
			...baseEncodeEntry(t, {
				align: "include",
				baseline: "include",
				color: "include",
				size: "ignore",
				orient: "ignore",
				theta: "include"
			}),
			...pointPosition("x", t, { defaultPos: "mid" }),
			...pointPosition("y", t, { defaultPos: "mid" }),
			...text$1(t),
			...nonPosition("size", t, { vgChannel: "fontSize" }),
			...nonPosition("angle", t),
			...valueIfDefined("align", align(t.markDef, r, n)),
			...valueIfDefined("baseline", baseline(t.markDef, r, n)),
			...pointPosition("radius", t, { defaultPos: null }),
			...pointPosition("theta", t, { defaultPos: null })
		};
	}
};
function align(t, n, r) {
	if (getMarkPropOrConfig("align", t, r) === void 0) return "center";
}
function baseline(t, n, r) {
	if (getMarkPropOrConfig("baseline", t, r) === void 0) return "middle";
}
var markCompiler = {
	arc,
	area,
	bar,
	circle,
	geoshape,
	image,
	line,
	point,
	rect,
	rule,
	square,
	text,
	tick: {
		vgMark: "rect",
		encodeEntry: (t) => {
			let { config: n, markDef: r } = t, i = r.orient, o = i === "horizontal" ? "x" : "y", s = i === "horizontal" ? "y" : "x", l = i === "horizontal" ? "height" : "width";
			return {
				...baseEncodeEntry(t, {
					align: "ignore",
					baseline: "ignore",
					color: "include",
					orient: "ignore",
					size: "ignore",
					theta: "ignore"
				}),
				...rectPosition(t, o),
				...pointPosition(s, t, {
					defaultPos: "mid",
					vgChannel: s === "y" ? "yc" : "xc"
				}),
				[l]: signalOrValueRef(getMarkPropOrConfig("thickness", r, n))
			};
		}
	},
	trail
};
function parseMarkGroups(t) {
	if (contains([
		LINE,
		AREA,
		TRAIL
	], t.mark)) {
		let n = pathGroupingFields(t.mark, t.encoding);
		if (n.length > 0) return getPathGroups(t, n);
	} else if (t.mark === BAR) {
		let n = VG_CORNERRADIUS_CHANNELS.some((n) => getMarkPropOrConfig(n, t.markDef, t.config));
		if (t.stack && !t.fieldDef("size") && n) return getGroupsForStackedBarWithCornerRadius(t);
	}
	return getMarkGroup(t);
}
var FACETED_PATH_PREFIX = "faceted_path_";
function getPathGroups(t, n) {
	return [{
		name: t.getName("pathgroup"),
		type: "group",
		from: { facet: {
			name: FACETED_PATH_PREFIX + t.requestDataName(DataSourceType.Main),
			data: t.requestDataName(DataSourceType.Main),
			groupby: n
		} },
		encode: { update: {
			width: { field: { group: "width" } },
			height: { field: { group: "height" } }
		} },
		marks: getMarkGroup(t, { fromPrefix: FACETED_PATH_PREFIX })
	}];
}
var STACK_GROUP_PREFIX = "stack_group_";
function getGroupsForStackedBarWithCornerRadius(t) {
	let [n] = getMarkGroup(t, { fromPrefix: STACK_GROUP_PREFIX }), r = t.scaleName(t.stack.fieldChannel), i = (n = {}) => t.vgField(t.stack.fieldChannel, n), o = (t, n) => `${t}(${[
		i({
			prefix: "min",
			suffix: "start",
			expr: n
		}),
		i({
			prefix: "max",
			suffix: "start",
			expr: n
		}),
		i({
			prefix: "min",
			suffix: "end",
			expr: n
		}),
		i({
			prefix: "max",
			suffix: "end",
			expr: n
		})
	].map((t) => `scale('${r}',${t})`).join(",")})`, s, l;
	t.stack.fieldChannel === "x" ? (s = {
		...pick(n.encode.update, [
			"y",
			"yc",
			"y2",
			"height",
			...VG_CORNERRADIUS_CHANNELS
		]),
		x: { signal: o("min", "datum") },
		x2: { signal: o("max", "datum") },
		clip: { value: !0 }
	}, l = {
		x: {
			field: { group: "x" },
			mult: -1
		},
		height: { field: { group: "height" } }
	}, n.encode.update = {
		...omit(n.encode.update, [
			"y",
			"yc",
			"y2"
		]),
		height: { field: { group: "height" } }
	}) : (s = {
		...pick(n.encode.update, [
			"x",
			"xc",
			"x2",
			"width"
		]),
		y: { signal: o("min", "datum") },
		y2: { signal: o("max", "datum") },
		clip: { value: !0 }
	}, l = {
		y: {
			field: { group: "y" },
			mult: -1
		},
		width: { field: { group: "width" } }
	}, n.encode.update = {
		...omit(n.encode.update, [
			"x",
			"xc",
			"x2"
		]),
		width: { field: { group: "width" } }
	});
	for (let r of VG_CORNERRADIUS_CHANNELS) {
		let i = getMarkConfig(r, t.markDef, t.config);
		n.encode.update[r] ? (s[r] = n.encode.update[r], delete n.encode.update[r]) : i && (s[r] = signalOrValueRef(i)), i && (n.encode.update[r] = { value: 0 });
	}
	let u = [];
	if (t.stack.groupbyChannels?.length > 0) for (let n of t.stack.groupbyChannels) {
		let r = t.fieldDef(n), i = vgField(r);
		i && u.push(i), (r?.bin || r?.timeUnit) && u.push(vgField(r, { binSuffix: "end" }));
	}
	return s = [
		"stroke",
		"strokeWidth",
		"strokeJoin",
		"strokeCap",
		"strokeDash",
		"strokeDashOffset",
		"strokeMiterLimit",
		"strokeOpacity"
	].reduce((r, i) => {
		if (n.encode.update[i]) return {
			...r,
			[i]: n.encode.update[i]
		};
		{
			let n = getMarkConfig(i, t.markDef, t.config);
			return n === void 0 ? r : {
				...r,
				[i]: signalOrValueRef(n)
			};
		}
	}, s), s.stroke && (s.strokeForeground = { value: !0 }, s.strokeOffset = { value: 0 }), [{
		type: "group",
		from: { facet: {
			data: t.requestDataName(DataSourceType.Main),
			name: STACK_GROUP_PREFIX + t.requestDataName(DataSourceType.Main),
			groupby: u,
			aggregate: {
				fields: [
					i({ suffix: "start" }),
					i({ suffix: "start" }),
					i({ suffix: "end" }),
					i({ suffix: "end" })
				],
				ops: [
					"min",
					"max",
					"min",
					"max"
				]
			}
		} },
		encode: { update: s },
		marks: [{
			type: "group",
			encode: { update: l },
			marks: [n]
		}]
	}];
}
function getSort(t) {
	let { encoding: n, stack: r, mark: i, markDef: o, config: s } = t, l = n.order;
	if (!(!isArray(l) && isValueDef(l) && isNullOrFalse(l.value) || !l && isNullOrFalse(getMarkPropOrConfig("order", o, s)))) {
		if ((isArray(l) || isFieldDef(l)) && !r) return sortParams(l, { expr: "datum" });
		if (isPathMark(i)) {
			let t = o.orient === "horizontal" ? "y" : "x", r = n[t];
			if (isFieldDef(r)) return { field: t };
		}
	}
}
function getMarkGroup(t, n = { fromPrefix: "" }) {
	let { mark: r, markDef: i, encoding: o, config: s } = t, l = getFirstDefined(i.clip, scaleClip(t), projectionClip(t)), u = getStyles(i), d = o.key, f = getSort(t), p = interactiveFlag(t);
	p && Object.values(t.component.selection).some((t) => t.type === "point" && !t.bind && t.on !== "pointerover") && (t.markDef.cursor ??= "pointer");
	let g = getMarkPropOrConfig("aria", i, s), _ = markCompiler[r].postEncodingTransform ? markCompiler[r].postEncodingTransform(t) : null;
	return [{
		name: t.getName("marks"),
		type: markCompiler[r].vgMark,
		...l ? { clip: l } : {},
		...u ? { style: u } : {},
		...d ? { key: d.field } : {},
		...f ? { sort: f } : {},
		...p || {},
		...g === !1 ? { aria: g } : {},
		from: { data: n.fromPrefix + t.requestDataName(DataSourceType.Main) },
		encode: { update: markCompiler[r].encodeEntry(t) },
		..._ ? { transform: _ } : {}
	}];
}
function scaleClip(t) {
	let n = t.getScaleComponent("x"), r = t.getScaleComponent("y");
	return n?.get("selectionExtent") || r?.get("selectionExtent") ? !0 : void 0;
}
function projectionClip(t) {
	let n = t.component.projection;
	return n && !n.isFit ? !0 : void 0;
}
function interactiveFlag(t) {
	if (!t.component.selection) return null;
	let n = keys(t.component.selection).length, r = n, i = t.parent;
	for (; i && r === 0;) r = keys(i.component.selection).length, i = i.parent;
	return r ? { interactive: n > 0 || t.mark === "geoshape" || !!t.encoding.tooltip || !!t.markDef.tooltip } : null;
}
var UnitModel = class extends ModelWithField {
	markDef;
	encoding;
	specifiedScales = {};
	stack;
	specifiedAxes = {};
	specifiedLegends = {};
	specifiedProjection = {};
	selection = [];
	children = [];
	constructor(t, n, r, i = {}, o) {
		super(t, "unit", n, r, o, void 0, isFrameMixins(t) ? t.view : void 0);
		let s = isMarkDef(t.mark) ? { ...t.mark } : { type: t.mark }, l = s.type;
		s.filled === void 0 && (s.filled = defaultFilled(s, o, { graticule: t.data && isGraticuleGenerator(t.data) }));
		let u = this.encoding = initEncoding(t.encoding || {}, l, s.filled, o);
		this.markDef = initMarkdef(s, u, o), this.size = initLayoutSize({
			encoding: u,
			size: isFrameMixins(t) ? {
				...i,
				...t.width === void 0 ? {} : { width: t.width },
				...t.height === void 0 ? {} : { height: t.height }
			} : i
		}), this.stack = stack(this.markDef, u), this.specifiedScales = this.initScales(l, u), this.specifiedAxes = this.initAxes(u), this.specifiedLegends = this.initLegends(u), this.specifiedProjection = t.projection, this.selection = (t.params ?? []).filter((t) => isSelectionParameter(t)), this.alignStackOrderWithColorDomain();
	}
	get hasProjection() {
		let { encoding: t } = this, n = this.mark === GEOSHAPE, r = t && GEOPOSITION_CHANNELS.some((n) => isFieldOrDatumDef(t[n]));
		return n || r;
	}
	scaleDomain(t) {
		let n = this.specifiedScales[t];
		return n ? n.domain : void 0;
	}
	axis(t) {
		return this.specifiedAxes[t];
	}
	legend(t) {
		return this.specifiedLegends[t];
	}
	initScales(t, n) {
		return SCALE_CHANNELS.reduce((t, r) => {
			let i = getFieldOrDatumDef(n[r]);
			return i && (t[r] = this.initScale(i.scale ?? {})), t;
		}, {});
	}
	initScale(t) {
		let { domain: n, range: r } = t, i = replaceExprRef(t);
		return isArray(n) && (i.domain = n.map(signalRefOrValue)), isArray(r) && (i.range = r.map(signalRefOrValue)), i;
	}
	initAxes(t) {
		return POSITION_SCALE_CHANNELS.reduce((n, r) => {
			let i = t[r];
			if (isFieldOrDatumDef(i) || r === X && isFieldOrDatumDef(t.x2) || r === Y && isFieldOrDatumDef(t.y2)) {
				let t = isFieldOrDatumDef(i) ? i.axis : void 0;
				n[r] = t && this.initAxis({ ...t });
			}
			return n;
		}, {});
	}
	initAxis(t) {
		let n = keys(t), r = {};
		for (let i of n) {
			let n = t[i];
			r[i] = isConditionalAxisValue(n) ? signalOrValueRefWithCondition(n) : signalRefOrValue(n);
		}
		return r;
	}
	initLegends(t) {
		return NONPOSITION_SCALE_CHANNELS.reduce((n, r) => {
			let i = getFieldOrDatumDef(t[r]);
			if (i && supportLegend(r)) {
				let t = i.legend;
				n[r] = t && replaceExprRef(t);
			}
			return n;
		}, {});
	}
	alignStackOrderWithColorDomain() {
		let { color: t, fill: n, order: r, xOffset: i, yOffset: o } = this.encoding, s = n || t, l = isFieldDef(s) ? s : void 0, u = l?.field, d = l?.scale, f = l?.type, p = d?.domain, g = i || o, _ = isFieldDef(g) ? g : void 0, v = `_${u}_sort_index`;
		if (!r && Array.isArray(p) && typeof u == "string" && f === "nominal") if (_ && !_.sort) _.sort = p;
		else {
			if (!this.stack) return;
			let t = `indexof(${$(p)}, datum['${u}'])`, n = this.markDef?.orient === "horizontal" ? "ascending" : "descending";
			this.transforms.push({
				calculate: t,
				as: v
			}), this.encoding.order = {
				field: v,
				type: "quantitative",
				sort: n
			};
		}
	}
	parseData() {
		this.component.data = parseData(this);
	}
	parseLayoutSize() {
		parseUnitLayoutSize(this);
	}
	parseSelections() {
		this.component.selection = parseUnitSelection(this, this.selection);
	}
	parseMarkGroup() {
		this.component.mark = parseMarkGroups(this);
	}
	parseAxesAndHeaders() {
		this.component.axes = parseUnitAxes(this);
	}
	assembleSelectionTopLevelSignals(t) {
		return assembleTopLevelSignals(this, t);
	}
	assembleSignals() {
		return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];
	}
	assembleSelectionData(t) {
		return assembleUnitSelectionData(this, t);
	}
	assembleLayout() {
		return null;
	}
	assembleLayoutSignals() {
		return assembleLayoutSignals(this);
	}
	correctDataNames = (t) => (t.from?.data && (t.from.data = this.lookupDataSource(t.from.data), "time" in this.encoding && (t.from.data = t.from.data + CURR)), t.from?.facet?.data && (t.from.facet.data = this.lookupDataSource(t.from.facet.data)), t);
	assembleMarks() {
		let t = this.component.mark ?? [];
		return (!this.parent || !isLayerModel(this.parent)) && (t = assembleUnitSelectionMarks(this, t)), t.map(this.correctDataNames);
	}
	assembleGroupStyle() {
		let { style: t } = this.view || {};
		return t === void 0 ? this.encoding.x || this.encoding.y ? "cell" : "view" : t;
	}
	getMapping() {
		return this.encoding;
	}
	get mark() {
		return this.markDef.type;
	}
	channelHasField(t) {
		return channelHasField(this.encoding, t);
	}
	fieldDef(t) {
		let n = this.encoding[t];
		return getFieldDef(n);
	}
	typedFieldDef(t) {
		let n = this.fieldDef(t);
		return isTypedFieldDef(n) ? n : null;
	}
}, LayerModel = class t extends Model {
	children;
	constructor(n, r, i, o, s) {
		super(n, "layer", r, i, s, n.resolve, n.view);
		let l = {
			...o,
			...n.width ? { width: n.width } : {},
			...n.height ? { height: n.height } : {}
		};
		this.children = n.layer.map((n, r) => {
			if (isLayerSpec(n)) return new t(n, this, this.getName(`layer_${r}`), l, s);
			if (isUnitSpec(n)) return new UnitModel(n, this, this.getName(`layer_${r}`), l, s);
			throw Error(invalidSpec(n));
		});
	}
	parseData() {
		this.component.data = parseData(this);
		for (let t of this.children) t.parseData();
	}
	parseLayoutSize() {
		parseLayerLayoutSize(this);
	}
	parseSelections() {
		this.component.selection = {};
		for (let t of this.children) {
			t.parseSelections();
			for (let n of keys(t.component.selection)) this.component.selection[n] = t.component.selection[n];
		}
		vals(this.component.selection).some((t) => isTimerSelection(t)) && error(MULTI_VIEW_ANIMATION_UNSUPPORTED);
	}
	parseMarkGroup() {
		for (let t of this.children) t.parseMarkGroup();
	}
	parseAxesAndHeaders() {
		parseLayerAxes(this);
	}
	assembleSelectionTopLevelSignals(t) {
		return this.children.reduce((t, n) => n.assembleSelectionTopLevelSignals(t), t);
	}
	assembleSignals() {
		return this.children.reduce((t, n) => t.concat(n.assembleSignals()), assembleAxisSignals(this));
	}
	assembleLayoutSignals() {
		return this.children.reduce((t, n) => t.concat(n.assembleLayoutSignals()), assembleLayoutSignals(this));
	}
	assembleSelectionData(t) {
		return this.children.reduce((t, n) => n.assembleSelectionData(t), t);
	}
	assembleGroupStyle() {
		let t = /* @__PURE__ */ new Set();
		for (let n of this.children) for (let r of array(n.assembleGroupStyle())) t.add(r);
		let n = Array.from(t);
		return n.length > 1 ? n : n.length === 1 ? n[0] : void 0;
	}
	assembleTitle() {
		let t = super.assembleTitle();
		if (t) return t;
		for (let n of this.children) if (t = n.assembleTitle(), t) return t;
	}
	assembleLayout() {
		return null;
	}
	assembleMarks() {
		return assembleLayerSelectionMarks(this, this.children.flatMap((t) => t.assembleMarks()));
	}
	assembleLegends() {
		return this.children.reduce((t, n) => t.concat(n.assembleLegends()), assembleLegends(this));
	}
};
function buildModel(t, n, r, i, o) {
	if (isFacetSpec(t)) return new FacetModel(t, n, r, o);
	if (isLayerSpec(t)) return new LayerModel(t, n, r, i, o);
	if (isUnitSpec(t)) return new UnitModel(t, n, r, i, o);
	if (isAnyConcatSpec(t)) return new ConcatModel(t, n, r, o);
	throw Error(invalidSpec(t));
}
function compile(t, n = {}) {
	n.logger && set(n.logger), n.fieldTitle && setTitleFormatter(n.fieldTitle);
	try {
		let r = initConfig(mergeConfig(n.config, t.config)), i = normalize(t, r), o = buildModel(i, null, "", void 0, r);
		return o.parse(), optimizeDataflow(o.component.data, o), {
			spec: assembleTopLevelModel(o, getTopLevelProperties(t, i.autosize, r, o), t.datasets, t.usermeta),
			normalized: i
		};
	} finally {
		n.logger && reset(), n.fieldTitle && resetTitleFormatter();
	}
}
function getTopLevelProperties(t, n, r, i) {
	let o = i.component.layoutSize.get("width"), s = i.component.layoutSize.get("height");
	if (n === void 0 ? (n = { type: "pad" }, i.hasAxisOrientSignalRef() && (n.resize = !0)) : isString(n) && (n = { type: n }), o && s && isFitType(n.type)) {
		if (o === "step" && s === "step") warn(droppingFit()), n.type = "pad";
		else if (o === "step" || s === "step") {
			let t = o === "step" ? "width" : "height";
			warn(droppingFit(getPositionScaleChannel(t))), n.type = getFitType(t === "width" ? "height" : "width");
		}
	}
	return {
		...keys(n).length === 1 && n.type ? n.type === "pad" ? {} : { autosize: n.type } : { autosize: n },
		...extractTopLevelProperties(r, !1),
		...extractTopLevelProperties(t, !0)
	};
}
function assembleTopLevelModel(t, n, r = {}, i) {
	let o = t.config ? stripAndRedirectConfig(t.config) : void 0, s = assembleRootData(t.component.data, r), l = t.assembleSelectionData(s), u = t.assembleProjections(), d = t.assembleTitle(), f = t.assembleGroupStyle(), p = t.assembleGroupEncodeEntry(!0), g = t.assembleLayoutSignals();
	g = g.filter((t) => (t.name === "width" || t.name === "height") && t.value !== void 0 ? (n[t.name] = +t.value, !1) : !0);
	let { params: _,...v } = n;
	return {
		$schema: "https://vega.github.io/schema/vega/v6.json",
		...t.description ? { description: t.description } : {},
		...v,
		...d ? { title: d } : {},
		...f ? { style: f } : {},
		...p ? { encode: { update: p } } : {},
		data: l,
		...u.length > 0 ? { projections: u } : {},
		...t.assembleGroup([
			...g,
			...t.assembleSelectionTopLevelSignals([]),
			...assembleParameterSignals(_)
		]),
		...o ? { config: o } : {},
		...i ? { usermeta: i } : {}
	};
}
var version$3 = pkg$2.version;
function e(t) {
	let [n, r] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(t).slice(1, 3);
	return {
		library: n,
		version: r
	};
}
var build_exports$1 = /* @__PURE__ */ __export({
	carbong10: () => carbong10,
	carbong100: () => carbong100,
	carbong90: () => carbong90,
	carbonwhite: () => carbonwhite,
	dark: () => darkTheme,
	excel: () => excelTheme,
	fivethirtyeight: () => fiveThirtyEightTheme,
	ggplot2: () => ggplot2Theme,
	googlecharts: () => googlechartsTheme,
	latimes: () => latimesTheme,
	powerbi: () => powerbiTheme,
	quartz: () => quartzTheme,
	urbaninstitute: () => urbanInstituteTheme,
	version: () => version$2,
	vox: () => voxTheme
}), pkg$1 = { version: "3.0.0" }, lightColor = "#fff", medColor = "#888", darkTheme = {
	background: "#333",
	view: { stroke: medColor },
	title: {
		color: lightColor,
		subtitleColor: lightColor
	},
	style: {
		"guide-label": { fill: lightColor },
		"guide-title": { fill: lightColor }
	},
	axis: {
		domainColor: lightColor,
		gridColor: medColor,
		tickColor: lightColor
	}
}, markColor$7 = "#4572a7", excelTheme = {
	background: "#fff",
	arc: { fill: markColor$7 },
	area: { fill: markColor$7 },
	line: {
		stroke: markColor$7,
		strokeWidth: 2
	},
	path: { stroke: markColor$7 },
	rect: { fill: markColor$7 },
	shape: { stroke: markColor$7 },
	symbol: {
		fill: markColor$7,
		strokeWidth: 1.5,
		size: 50
	},
	axis: {
		bandPosition: .5,
		grid: !0,
		gridColor: "#000000",
		gridOpacity: 1,
		gridWidth: .5,
		labelPadding: 10,
		tickSize: 5,
		tickWidth: .5
	},
	axisBand: {
		grid: !1,
		tickExtra: !0
	},
	legend: {
		labelBaseline: "middle",
		labelFontSize: 11,
		symbolSize: 50,
		symbolType: "square"
	},
	range: { category: [
		"#4572a7",
		"#aa4643",
		"#8aa453",
		"#71598e",
		"#4598ae",
		"#d98445",
		"#94aace",
		"#d09393",
		"#b9cc98",
		"#a99cbc"
	] }
}, markColor$6 = "#30a2da", axisColor$2 = "#cbcbcb", guideLabelColor = "#999", guideTitleColor = "#333", backgroundColor$2 = "#f0f0f0", blackTitle = "#333", fiveThirtyEightTheme = {
	arc: { fill: markColor$6 },
	area: { fill: markColor$6 },
	axis: {
		domainColor: axisColor$2,
		grid: !0,
		gridColor: axisColor$2,
		gridWidth: 1,
		labelColor: guideLabelColor,
		labelFontSize: 10,
		titleColor: guideTitleColor,
		tickColor: axisColor$2,
		tickSize: 10,
		titleFontSize: 14,
		titlePadding: 10,
		labelPadding: 4
	},
	axisBand: { grid: !1 },
	background: backgroundColor$2,
	group: { fill: backgroundColor$2 },
	legend: {
		labelColor: blackTitle,
		labelFontSize: 11,
		padding: 1,
		symbolSize: 30,
		symbolType: "square",
		titleColor: blackTitle,
		titleFontSize: 14,
		titlePadding: 10
	},
	line: {
		stroke: markColor$6,
		strokeWidth: 2
	},
	path: {
		stroke: markColor$6,
		strokeWidth: .5
	},
	rect: { fill: markColor$6 },
	range: {
		category: [
			"#30a2da",
			"#fc4f30",
			"#e5ae38",
			"#6d904f",
			"#8b8b8b",
			"#b96db8",
			"#ff9e27",
			"#56cc60",
			"#52d2ca",
			"#52689e",
			"#545454",
			"#9fe4f8"
		],
		diverging: [
			"#cc0020",
			"#e77866",
			"#f6e7e1",
			"#d6e8ed",
			"#91bfd9",
			"#1d78b5"
		],
		heatmap: [
			"#d6e8ed",
			"#cee0e5",
			"#91bfd9",
			"#549cc6",
			"#1d78b5"
		]
	},
	point: {
		filled: !0,
		shape: "circle"
	},
	shape: { stroke: markColor$6 },
	bar: {
		binSpacing: 2,
		fill: markColor$6,
		stroke: null
	},
	title: {
		anchor: "start",
		fontSize: 24,
		fontWeight: 600,
		offset: 20
	}
}, markColor$5 = "#000", ggplot2Theme = {
	group: { fill: "#e5e5e5" },
	arc: { fill: markColor$5 },
	area: { fill: markColor$5 },
	line: { stroke: markColor$5 },
	path: { stroke: markColor$5 },
	rect: { fill: markColor$5 },
	shape: { stroke: markColor$5 },
	symbol: {
		fill: markColor$5,
		size: 40
	},
	axis: {
		domain: !1,
		grid: !0,
		gridColor: "#FFFFFF",
		gridOpacity: 1,
		labelColor: "#7F7F7F",
		labelPadding: 4,
		tickColor: "#7F7F7F",
		tickSize: 5.67,
		titleFontSize: 16,
		titleFontWeight: "normal"
	},
	legend: {
		labelBaseline: "middle",
		labelFontSize: 11,
		symbolSize: 40
	},
	range: { category: [
		"#000000",
		"#7F7F7F",
		"#1A1A1A",
		"#999999",
		"#333333",
		"#B0B0B0",
		"#4D4D4D",
		"#C9C9C9",
		"#666666",
		"#DCDCDC"
	] }
}, headlineFontSize = 22, headlineFontWeight = "normal", labelFont$1 = "Benton Gothic, sans-serif", labelFontSize = 11.5, labelFontWeight = "normal", markColor$4 = "#82c6df", titleFont = "Benton Gothic Bold, sans-serif", titleFontWeight = "normal", titleFontSize$1 = 13, colorSchemes$1 = {
	"category-6": [
		"#ec8431",
		"#829eb1",
		"#c89d29",
		"#3580b1",
		"#adc839",
		"#ab7fb4"
	],
	"fire-7": [
		"#fbf2c7",
		"#f9e39c",
		"#f8d36e",
		"#f4bb6a",
		"#e68a4f",
		"#d15a40",
		"#ab4232"
	],
	"fireandice-6": [
		"#e68a4f",
		"#f4bb6a",
		"#f9e39c",
		"#dadfe2",
		"#a6b7c6",
		"#849eae"
	]
}, latimesTheme = {
	background: "#ffffff",
	title: {
		anchor: "start",
		color: "#000000",
		font: titleFont,
		fontSize: headlineFontSize,
		fontWeight: headlineFontWeight
	},
	arc: { fill: markColor$4 },
	area: { fill: markColor$4 },
	line: {
		stroke: markColor$4,
		strokeWidth: 2
	},
	path: { stroke: markColor$4 },
	rect: { fill: markColor$4 },
	shape: { stroke: markColor$4 },
	symbol: {
		fill: markColor$4,
		size: 30
	},
	axis: {
		labelFont: labelFont$1,
		labelFontSize,
		labelFontWeight,
		titleFont,
		titleFontSize: titleFontSize$1,
		titleFontWeight
	},
	axisX: {
		labelAngle: 0,
		labelPadding: 4,
		tickSize: 3
	},
	axisY: {
		labelBaseline: "middle",
		maxExtent: 45,
		minExtent: 45,
		tickSize: 2,
		titleAlign: "left",
		titleAngle: 0,
		titleX: -45,
		titleY: -11
	},
	legend: {
		labelFont: labelFont$1,
		labelFontSize,
		symbolType: "square",
		titleFont,
		titleFontSize: titleFontSize$1,
		titleFontWeight
	},
	range: {
		category: colorSchemes$1["category-6"],
		diverging: colorSchemes$1["fireandice-6"],
		heatmap: colorSchemes$1["fire-7"],
		ordinal: colorSchemes$1["fire-7"],
		ramp: colorSchemes$1["fire-7"]
	}
}, markColor$3 = "#ab5787", axisColor$1 = "#979797", quartzTheme = {
	background: "#f9f9f9",
	arc: { fill: markColor$3 },
	area: { fill: markColor$3 },
	line: { stroke: markColor$3 },
	path: { stroke: markColor$3 },
	rect: { fill: markColor$3 },
	shape: { stroke: markColor$3 },
	symbol: {
		fill: markColor$3,
		size: 30
	},
	axis: {
		domainColor: axisColor$1,
		domainWidth: .5,
		gridWidth: .2,
		labelColor: axisColor$1,
		tickColor: axisColor$1,
		tickWidth: .2,
		titleColor: axisColor$1
	},
	axisBand: { grid: !1 },
	axisX: {
		grid: !0,
		tickSize: 10
	},
	axisY: {
		domain: !1,
		grid: !0,
		tickSize: 0
	},
	legend: {
		labelFontSize: 11,
		padding: 1,
		symbolSize: 30,
		symbolType: "square"
	},
	range: { category: [
		"#ab5787",
		"#51b2e5",
		"#703c5c",
		"#168dd9",
		"#d190b6",
		"#00609f",
		"#d365ba",
		"#154866",
		"#666666",
		"#c4c4c4"
	] }
}, markColor$2 = "#3e5c69", voxTheme = {
	background: "#fff",
	arc: { fill: markColor$2 },
	area: { fill: markColor$2 },
	line: { stroke: markColor$2 },
	path: { stroke: markColor$2 },
	rect: { fill: markColor$2 },
	shape: { stroke: markColor$2 },
	symbol: { fill: markColor$2 },
	axis: {
		domainWidth: .5,
		grid: !0,
		labelPadding: 2,
		tickSize: 5,
		tickWidth: .5,
		titleFontWeight: "normal"
	},
	axisBand: { grid: !1 },
	axisX: { gridWidth: .2 },
	axisY: {
		gridDash: [3],
		gridWidth: .4
	},
	legend: {
		labelFontSize: 11,
		padding: 1,
		symbolType: "square"
	},
	range: { category: [
		"#3e5c69",
		"#6793a6",
		"#182429",
		"#0570b0",
		"#3690c0",
		"#74a9cf",
		"#a6bddb",
		"#e2ddf2"
	] }
}, markColor$1 = "#1696d2", axisColor = "#000000", backgroundColor$1 = "#FFFFFF", font = "Lato", labelFont = "Lato", sourceFont = "Lato", gridColor$1 = "#DEDDDD", titleFontSize = 18, colorSchemes = {
	"shades-blue": [
		"#CFE8F3",
		"#A2D4EC",
		"#73BFE2",
		"#46ABDB",
		"#1696D2",
		"#12719E",
		"#0A4C6A",
		"#062635"
	],
	"six-groups-cat-1": [
		"#1696d2",
		"#ec008b",
		"#fdbf11",
		"#000000",
		"#d2d2d2",
		"#55b748"
	],
	"six-groups-seq": [
		"#cfe8f3",
		"#a2d4ec",
		"#73bfe2",
		"#46abdb",
		"#1696d2",
		"#12719e"
	],
	"diverging-colors": [
		"#ca5800",
		"#fdbf11",
		"#fdd870",
		"#fff2cf",
		"#cfe8f3",
		"#73bfe2",
		"#1696d2",
		"#0a4c6a"
	]
}, urbanInstituteTheme = {
	background: backgroundColor$1,
	title: {
		anchor: "start",
		fontSize: titleFontSize,
		font
	},
	axisX: {
		domain: !0,
		domainColor: axisColor,
		domainWidth: 1,
		grid: !1,
		labelFontSize: 12,
		labelFont,
		labelAngle: 0,
		tickColor: axisColor,
		tickSize: 5,
		titleFontSize: 12,
		titlePadding: 10,
		titleFont: font
	},
	axisY: {
		domain: !1,
		domainWidth: 1,
		grid: !0,
		gridColor: gridColor$1,
		gridWidth: 1,
		labelFontSize: 12,
		labelFont,
		labelPadding: 8,
		ticks: !1,
		titleFontSize: 12,
		titlePadding: 10,
		titleFont: font,
		titleAngle: 0,
		titleY: -10,
		titleX: 18
	},
	legend: {
		labelFontSize: 12,
		labelFont,
		symbolSize: 100,
		titleFontSize: 12,
		titlePadding: 10,
		titleFont: font,
		orient: "right",
		offset: 10
	},
	view: { stroke: "transparent" },
	range: {
		category: colorSchemes["six-groups-cat-1"],
		diverging: colorSchemes["diverging-colors"],
		heatmap: colorSchemes["diverging-colors"],
		ordinal: colorSchemes["six-groups-seq"],
		ramp: colorSchemes["shades-blue"]
	},
	area: { fill: markColor$1 },
	rect: { fill: markColor$1 },
	line: {
		color: markColor$1,
		stroke: markColor$1,
		strokeWidth: 5
	},
	trail: {
		color: markColor$1,
		stroke: markColor$1,
		strokeWidth: 0,
		size: 1
	},
	path: {
		stroke: markColor$1,
		strokeWidth: .5
	},
	point: { filled: !0 },
	text: {
		font: sourceFont,
		color: markColor$1,
		fontSize: 11,
		align: "center",
		fontWeight: 400,
		size: 11
	},
	style: { bar: {
		fill: markColor$1,
		stroke: null
	} },
	arc: { fill: markColor$1 },
	shape: { stroke: markColor$1 },
	symbol: {
		fill: markColor$1,
		size: 30
	}
}, markColor = "#3366CC", gridColor = "#ccc", defaultFont$1 = "Arial, sans-serif", googlechartsTheme = {
	arc: { fill: markColor },
	area: { fill: markColor },
	path: { stroke: markColor },
	rect: { fill: markColor },
	shape: { stroke: markColor },
	symbol: { stroke: markColor },
	circle: { fill: markColor },
	background: "#fff",
	padding: {
		top: 10,
		right: 10,
		bottom: 10,
		left: 10
	},
	style: {
		"guide-label": {
			font: defaultFont$1,
			fontSize: 12
		},
		"guide-title": {
			font: defaultFont$1,
			fontSize: 12
		},
		"group-title": {
			font: defaultFont$1,
			fontSize: 12
		}
	},
	title: {
		font: defaultFont$1,
		fontSize: 14,
		fontWeight: "bold",
		dy: -3,
		anchor: "start"
	},
	axis: {
		gridColor,
		tickColor: gridColor,
		domain: !1,
		grid: !0
	},
	range: {
		category: [
			"#4285F4",
			"#DB4437",
			"#F4B400",
			"#0F9D58",
			"#AB47BC",
			"#00ACC1",
			"#FF7043",
			"#9E9D24",
			"#5C6BC0",
			"#F06292",
			"#00796B",
			"#C2185B"
		],
		heatmap: [
			"#c6dafc",
			"#5e97f6",
			"#2a56c6"
		]
	}
}, ptToPx = (t) => t * 1.3333333333333333, fontSmallPx = ptToPx(9), legendFontPx = ptToPx(10), fontLargePx = ptToPx(12), fontStandard = "Segoe UI", fontTitle = "wf_standard-font, helvetica, arial, sans-serif", firstLevelElementColor = "#252423", secondLevelElementColor = "#605E5C", backgroundColor = "transparent", backgroundSecondaryColor = "#C8C6C4", paletteColor1 = "#118DFF", paletteColor2 = "#12239E", paletteColor3 = "#E66C37", paletteColor4 = "#6B007B", paletteColor5 = "#E044A7", paletteColor6 = "#744EC2", paletteColor7 = "#D9B300", paletteColor8 = "#D64550", divergentColorMax = paletteColor1, divergentColorMin = "#DEEFFF", divergentPalette = [divergentColorMin, divergentColorMax], powerbiTheme = {
	view: { stroke: backgroundColor },
	background: backgroundColor,
	font: fontStandard,
	header: {
		titleFont: fontTitle,
		titleFontSize: fontLargePx,
		titleColor: firstLevelElementColor,
		labelFont: fontStandard,
		labelFontSize: legendFontPx,
		labelColor: secondLevelElementColor
	},
	axis: {
		ticks: !1,
		grid: !1,
		domain: !1,
		labelColor: secondLevelElementColor,
		labelFontSize: fontSmallPx,
		titleFont: fontTitle,
		titleColor: firstLevelElementColor,
		titleFontSize: fontLargePx,
		titleFontWeight: "normal"
	},
	axisQuantitative: {
		tickCount: 3,
		grid: !0,
		gridColor: backgroundSecondaryColor,
		gridDash: [1, 5],
		labelFlush: !1
	},
	axisBand: { tickExtra: !0 },
	axisX: { labelPadding: 5 },
	axisY: { labelPadding: 10 },
	bar: { fill: paletteColor1 },
	line: {
		stroke: paletteColor1,
		strokeWidth: 3,
		strokeCap: "round",
		strokeJoin: "round"
	},
	text: {
		font: fontStandard,
		fontSize: fontSmallPx,
		fill: secondLevelElementColor
	},
	arc: { fill: paletteColor1 },
	area: {
		fill: paletteColor1,
		line: !0,
		opacity: .6
	},
	path: { stroke: paletteColor1 },
	rect: { fill: paletteColor1 },
	point: {
		fill: paletteColor1,
		filled: !0,
		size: 75
	},
	shape: { stroke: paletteColor1 },
	symbol: {
		fill: paletteColor1,
		strokeWidth: 1.5,
		size: 50
	},
	legend: {
		titleFont: fontStandard,
		titleFontWeight: "bold",
		titleColor: secondLevelElementColor,
		labelFont: fontStandard,
		labelFontSize: legendFontPx,
		labelColor: secondLevelElementColor,
		symbolType: "circle",
		symbolSize: 75
	},
	range: {
		category: [
			paletteColor1,
			paletteColor2,
			paletteColor3,
			paletteColor4,
			paletteColor5,
			paletteColor6,
			paletteColor7,
			paletteColor8
		],
		diverging: divergentPalette,
		heatmap: divergentPalette,
		ordinal: [
			divergentColorMin,
			"#c7e4ff",
			"#b0d9ff",
			"#9aceff",
			"#83c3ff",
			"#6cb9ff",
			"#55aeff",
			"#3fa3ff",
			"#2898ff",
			divergentColorMax
		]
	}
}, defaultFont = "IBM Plex Sans,system-ui,-apple-system,BlinkMacSystemFont,\".sfnstext-regular\",sans-serif", condensedFont = "IBM Plex Sans Condensed, system-ui, -apple-system, BlinkMacSystemFont, \".SFNSText-Regular\", sans-serif", fontWeight = 400, TOKENS = {
	textPrimary: {
		g90: "#f4f4f4",
		g100: "#f4f4f4",
		white: "#161616",
		g10: "#161616"
	},
	textSecondary: {
		g90: "#c6c6c6",
		g100: "#c6c6c6",
		white: "#525252",
		g10: "#525252"
	},
	layerAccent01: {
		white: "#e0e0e0",
		g10: "#e0e0e0",
		g90: "#525252",
		g100: "#393939"
	},
	gridBg: {
		white: "#ffffff",
		g10: "#ffffff",
		g90: "#161616",
		g100: "#161616"
	}
}, darkCategories = [
	"#8a3ffc",
	"#33b1ff",
	"#007d79",
	"#ff7eb6",
	"#fa4d56",
	"#fff1f1",
	"#6fdc8c",
	"#4589ff",
	"#d12771",
	"#d2a106",
	"#08bdba",
	"#bae6ff",
	"#ba4e00",
	"#d4bbff"
], lightCategories = [
	"#6929c4",
	"#1192e8",
	"#005d5d",
	"#9f1853",
	"#fa4d56",
	"#570408",
	"#198038",
	"#002d9c",
	"#ee538b",
	"#b28600",
	"#009d9a",
	"#012749",
	"#8a3800",
	"#a56eff"
];
function genCarbonConfig({ theme: t, background: n }) {
	let r = ["white", "g10"].includes(t) ? "light" : "dark", i = TOKENS.gridBg[t], o = TOKENS.textPrimary[t], s = TOKENS.textSecondary[t], l = r === "dark" ? darkCategories : lightCategories, u = r === "dark" ? "#d4bbff" : "#6929c4";
	return {
		background: n,
		arc: { fill: u },
		area: { fill: u },
		path: { stroke: u },
		rect: { fill: u },
		shape: { stroke: u },
		symbol: { stroke: u },
		circle: { fill: u },
		view: {
			fill: i,
			stroke: i
		},
		group: { fill: i },
		title: {
			color: o,
			anchor: "start",
			dy: -15,
			fontSize: 16,
			font: defaultFont,
			fontWeight: 600
		},
		axis: {
			labelColor: s,
			labelFontSize: 12,
			labelFont: condensedFont,
			labelFontWeight: fontWeight,
			titleColor: o,
			titleFontWeight: 600,
			titleFontSize: 12,
			grid: !0,
			gridColor: TOKENS.layerAccent01[t],
			labelAngle: 0
		},
		axisX: { titlePadding: 10 },
		axisY: { titlePadding: 2.5 },
		style: {
			"guide-label": {
				font: defaultFont,
				fill: s,
				fontWeight
			},
			"guide-title": {
				font: defaultFont,
				fill: s,
				fontWeight
			}
		},
		range: {
			category: l,
			diverging: [
				"#750e13",
				"#a2191f",
				"#da1e28",
				"#fa4d56",
				"#ff8389",
				"#ffb3b8",
				"#ffd7d9",
				"#fff1f1",
				"#e5f6ff",
				"#bae6ff",
				"#82cfff",
				"#33b1ff",
				"#1192e8",
				"#0072c3",
				"#00539a",
				"#003a6d"
			],
			heatmap: [
				"#f6f2ff",
				"#e8daff",
				"#d4bbff",
				"#be95ff",
				"#a56eff",
				"#8a3ffc",
				"#6929c4",
				"#491d8b",
				"#31135e",
				"#1c0f30"
			]
		}
	};
}
var carbonwhite = genCarbonConfig({
	theme: "white",
	background: "#ffffff"
}), carbong10 = genCarbonConfig({
	theme: "g10",
	background: "#f4f4f4"
}), carbong90 = genCarbonConfig({
	theme: "g90",
	background: "#262626"
}), carbong100 = genCarbonConfig({
	theme: "g100",
	background: "#161616"
}), version$2 = pkg$1.version, pkg = { version: "1.0.0" };
function formatValue(t, n, r, i) {
	if (isArray(t)) return `[${t.map((t) => n(isString(t) ? t : stringify$1(t, r))).join(", ")}]`;
	if (isObject(t)) {
		let o = "", { title: s, image: l,...u } = t;
		s && (o += `<h2>${n(s)}</h2>`), l && (o += `<img src="${new URL(n(l), i || location.href).href}">`);
		let d = Object.keys(u);
		if (d.length > 0) {
			o += "<table>";
			for (let t of d) {
				let i = u[t];
				i !== void 0 && (isObject(i) && (i = stringify$1(i, r)), o += `<tr><td class="key">${n(t)}</td><td class="value">${n(i)}</td></tr>`);
			}
			o += "</table>";
		}
		return o || "{}";
	}
	return n(t);
}
function replacer(t) {
	let n = [];
	return function(r, i) {
		return typeof i != "object" || !i ? i : (n.length = n.indexOf(this) + 1, n.length > t ? "[Object]" : n.indexOf(i) >= 0 ? "[Circular]" : (n.push(i), i));
	};
}
function stringify$1(t, n) {
	return JSON.stringify(t, replacer(n));
}
var defaultStyle = "#vg-tooltip-element {\n  visibility: hidden;\n  padding: 8px;\n  position: fixed;\n  z-index: 1000;\n  font-family: sans-serif;\n  font-size: 11px;\n  border-radius: 3px;\n  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);\n  /* The default theme is the light theme. */\n  background-color: rgba(255, 255, 255, 0.95);\n  border: 1px solid #d9d9d9;\n  color: black;\n}\n#vg-tooltip-element.visible {\n  visibility: visible;\n}\n#vg-tooltip-element h2 {\n  margin-top: 0;\n  margin-bottom: 10px;\n  font-size: 13px;\n}\n#vg-tooltip-element table {\n  border-spacing: 0;\n}\n#vg-tooltip-element table tr {\n  border: none;\n}\n#vg-tooltip-element table tr td {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n#vg-tooltip-element table tr td.key {\n  color: #808080;\n  max-width: 150px;\n  text-align: right;\n  padding-right: 4px;\n}\n#vg-tooltip-element table tr td.value {\n  display: block;\n  max-width: 300px;\n  max-height: 7em;\n  text-align: left;\n}\n#vg-tooltip-element.dark-theme {\n  background-color: rgba(32, 32, 32, 0.9);\n  border: 1px solid #f5f5f5;\n  color: white;\n}\n#vg-tooltip-element.dark-theme td.key {\n  color: #bfbfbf;\n}\n", EL_ID = "vg-tooltip-element", DEFAULT_OPTIONS = {
	offsetX: 10,
	offsetY: 10,
	id: EL_ID,
	styleId: "vega-tooltip-style",
	theme: "light",
	disableDefaultStyle: !1,
	sanitize: escapeHTML,
	maxDepth: 2,
	formatTooltip: formatValue,
	baseURL: "",
	anchor: "cursor",
	position: [
		"top",
		"bottom",
		"left",
		"right",
		"top-left",
		"top-right",
		"bottom-left",
		"bottom-right"
	]
};
function escapeHTML(t) {
	return String(t).replace(/&/g, "&amp;").replace(/</g, "&lt;");
}
function createDefaultStyle(t) {
	if (!/^[A-Za-z]+[-:.\w]*$/.test(t)) throw Error("Invalid HTML ID");
	return defaultStyle.toString().replaceAll(EL_ID, t);
}
function calculatePositionRelativeToCursor(t, n, { offsetX: r, offsetY: i }) {
	let o = getPositions({
		x1: t.clientX,
		x2: t.clientX,
		y1: t.clientY,
		y2: t.clientY
	}, n, r, i);
	for (let t of [
		"bottom-right",
		"bottom-left",
		"top-right",
		"top-left"
	]) if (tooltipIsInViewport(o[t], n)) return o[t];
	return o["top-left"];
}
function calculatePositionRelativeToMark(t, n, r, i, o) {
	let { position: s, offsetX: l, offsetY: u } = o, d = t._el.getBoundingClientRect(), f = t._origin, p = getPositions(getMarkBounds(d, f, r), i, l, u), g = Array.isArray(s) ? s : [s];
	for (let t of g) if (tooltipIsInViewport(p[t], i) && !mouseIsOnTooltip(n, p[t], i)) return p[t];
	return calculatePositionRelativeToCursor(n, i, o);
}
function getMarkBounds(t, n, r) {
	let i = r.isVoronoi ? r.datum.bounds : r.bounds, o = t.left + n[0] + i.x1, s = t.top + n[1] + i.y1, l = r;
	for (; l.mark.group;) l = l.mark.group, o += l.x ?? 0, s += l.y ?? 0;
	let u = i.x2 - i.x1, d = i.y2 - i.y1;
	return {
		x1: o,
		x2: o + u,
		y1: s,
		y2: s + d
	};
}
function getPositions(t, n, r, i) {
	let o = (t.x1 + t.x2) / 2, s = (t.y1 + t.y2) / 2, l = t.x1 - n.width - r, u = o - n.width / 2, d = t.x2 + r, f = t.y1 - n.height - i, p = s - n.height / 2, g = t.y2 + i;
	return {
		top: {
			x: u,
			y: f
		},
		bottom: {
			x: u,
			y: g
		},
		left: {
			x: l,
			y: p
		},
		right: {
			x: d,
			y: p
		},
		"top-left": {
			x: l,
			y: f
		},
		"top-right": {
			x: d,
			y: f
		},
		"bottom-left": {
			x: l,
			y: g
		},
		"bottom-right": {
			x: d,
			y: g
		}
	};
}
function tooltipIsInViewport(t, n) {
	return t.x >= 0 && t.y >= 0 && t.x + n.width <= window.innerWidth && t.y + n.height <= window.innerHeight;
}
function mouseIsOnTooltip(t, n, r) {
	return t.clientX >= n.x && t.clientX <= n.x + r.width && t.clientY >= n.y && t.clientY <= n.y + r.height;
}
var Handler = class {
	call;
	options;
	el;
	constructor(t) {
		this.options = {
			...DEFAULT_OPTIONS,
			...t
		};
		let n = this.options.id;
		if (this.el = null, this.call = this.tooltipHandler.bind(this), !this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
			let t = document.createElement("style");
			t.setAttribute("id", this.options.styleId), t.innerHTML = createDefaultStyle(n);
			let r = document.head;
			r.childNodes.length > 0 ? r.insertBefore(t, r.childNodes[0]) : r.appendChild(t);
		}
	}
	tooltipHandler(t, n, r, i) {
		if (this.el = document.getElementById(this.options.id), this.el || (this.el = document.createElement("div"), this.el.setAttribute("id", this.options.id), this.el.classList.add("vg-tooltip"), (document.fullscreenElement ?? document.body).appendChild(this.el)), i == null || i === "") {
			this.el.classList.remove("visible", `${this.options.theme}-theme`);
			return;
		}
		this.el.innerHTML = this.options.formatTooltip(i, this.options.sanitize, this.options.maxDepth, this.options.baseURL), this.el.classList.add("visible", `${this.options.theme}-theme`);
		let { x: o, y: s } = this.options.anchor === "mark" ? calculatePositionRelativeToMark(t, n, r, this.el.getBoundingClientRect(), this.options) : calculatePositionRelativeToCursor(n, this.el.getBoundingClientRect(), this.options);
		this.el.style.top = `${s}px`, this.el.style.left = `${o}px`;
	}
};
pkg.version;
/*!
* https://github.com/Starcounter-Jack/JSON-Patch
* (c) 2017-2022 Joachim Wester
* MIT licensed
*/
var __extends = (function() {
	var t = function(n, r) {
		return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
			t.__proto__ = n;
		} || function(t, n) {
			for (var r in n) n.hasOwnProperty(r) && (t[r] = n[r]);
		}, t(n, r);
	};
	return function(n, r) {
		t(n, r);
		function i() {
			this.constructor = n;
		}
		n.prototype = r === null ? Object.create(r) : (i.prototype = r.prototype, new i());
	};
})(), _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(t, n) {
	return _hasOwnProperty.call(t, n);
}
function _objectKeys(t) {
	if (Array.isArray(t)) {
		for (var n = Array(t.length), r = 0; r < n.length; r++) n[r] = "" + r;
		return n;
	}
	if (Object.keys) return Object.keys(t);
	var i = [];
	for (var o in t) hasOwnProperty(t, o) && i.push(o);
	return i;
}
function _deepClone(t) {
	switch (typeof t) {
		case "object": return JSON.parse(JSON.stringify(t));
		case "undefined": return null;
		default: return t;
	}
}
function isInteger(t) {
	for (var n = 0, r = t.length, i; n < r;) {
		if (i = t.charCodeAt(n), i >= 48 && i <= 57) {
			n++;
			continue;
		}
		return !1;
	}
	return !0;
}
function escapePathComponent(t) {
	return t.indexOf("/") === -1 && t.indexOf("~") === -1 ? t : t.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(t) {
	return t.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(t) {
	if (t === void 0) return !0;
	if (t) {
		if (Array.isArray(t)) {
			for (var n = 0, r = t.length; n < r; n++) if (hasUndefined(t[n])) return !0;
		} else if (typeof t == "object") {
			for (var i = _objectKeys(t), o = i.length, s = 0; s < o; s++) if (hasUndefined(t[i[s]])) return !0;
		}
	}
	return !1;
}
function patchErrorMessageFormatter(t, n) {
	var r = [t];
	for (var i in n) {
		var o = typeof n[i] == "object" ? JSON.stringify(n[i], null, 2) : n[i];
		o !== void 0 && r.push(i + ": " + o);
	}
	return r.join("\n");
}
var PatchError = function(t) {
	__extends(n, t);
	function n(n, r, i, o, s) {
		var l = this.constructor, u = t.call(this, patchErrorMessageFormatter(n, {
			name: r,
			index: i,
			operation: o,
			tree: s
		})) || this;
		return u.name = r, u.index = i, u.operation = o, u.tree = s, Object.setPrototypeOf(u, l.prototype), u.message = patchErrorMessageFormatter(n, {
			name: r,
			index: i,
			operation: o,
			tree: s
		}), u;
	}
	return n;
}(Error), JsonPatchError = PatchError, deepClone = _deepClone, objOps = {
	add: function(t, n, r) {
		return t[n] = this.value, { newDocument: r };
	},
	remove: function(t, n, r) {
		var i = t[n];
		return delete t[n], {
			newDocument: r,
			removed: i
		};
	},
	replace: function(t, n, r) {
		var i = t[n];
		return t[n] = this.value, {
			newDocument: r,
			removed: i
		};
	},
	move: function(t, n, r) {
		var i = getValueByPointer(r, this.path);
		i &&= _deepClone(i);
		var o = applyOperation(r, {
			op: "remove",
			path: this.from
		}).removed;
		return applyOperation(r, {
			op: "add",
			path: this.path,
			value: o
		}), {
			newDocument: r,
			removed: i
		};
	},
	copy: function(t, n, r) {
		var i = getValueByPointer(r, this.from);
		return applyOperation(r, {
			op: "add",
			path: this.path,
			value: _deepClone(i)
		}), { newDocument: r };
	},
	test: function(t, n, r) {
		return {
			newDocument: r,
			test: _areEquals(t[n], this.value)
		};
	},
	_get: function(t, n, r) {
		return this.value = t[n], { newDocument: r };
	}
}, arrOps = {
	add: function(t, n, r) {
		return isInteger(n) ? t.splice(n, 0, this.value) : t[n] = this.value, {
			newDocument: r,
			index: n
		};
	},
	remove: function(t, n, r) {
		return {
			newDocument: r,
			removed: t.splice(n, 1)[0]
		};
	},
	replace: function(t, n, r) {
		var i = t[n];
		return t[n] = this.value, {
			newDocument: r,
			removed: i
		};
	},
	move: objOps.move,
	copy: objOps.copy,
	test: objOps.test,
	_get: objOps._get
};
function getValueByPointer(t, n) {
	if (n == "") return t;
	var r = {
		op: "_get",
		path: n
	};
	return applyOperation(t, r), r.value;
}
function applyOperation(t, n, r, i, o, s) {
	if (r === void 0 && (r = !1), i === void 0 && (i = !0), o === void 0 && (o = !0), s === void 0 && (s = 0), r && (typeof r == "function" ? r(n, 0, t, n.path) : validator(n, 0)), n.path === "") {
		var l = { newDocument: t };
		if (n.op === "add") return l.newDocument = n.value, l;
		if (n.op === "replace") return l.newDocument = n.value, l.removed = t, l;
		if (n.op === "move" || n.op === "copy") return l.newDocument = getValueByPointer(t, n.from), n.op === "move" && (l.removed = t), l;
		if (n.op === "test") {
			if (l.test = _areEquals(t, n.value), l.test === !1) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", s, n, t);
			return l.newDocument = t, l;
		} else if (n.op === "remove") return l.removed = t, l.newDocument = null, l;
		else if (n.op === "_get") return n.value = t, l;
		else if (r) throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", s, n, t);
		else return l;
	} else {
		i || (t = _deepClone(t));
		var u = (n.path || "").split("/"), d = t, f = 1, p = u.length, g = void 0, _ = void 0, v = void 0;
		for (v = typeof r == "function" ? r : validator;;) {
			if (_ = u[f], _ && _.indexOf("~") != -1 && (_ = unescapePathComponent(_)), o && (_ == "__proto__" || _ == "prototype" && f > 0 && u[f - 1] == "constructor")) throw TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
			if (r && g === void 0 && (d[_] === void 0 ? g = u.slice(0, f).join("/") : f == p - 1 && (g = n.path), g !== void 0 && v(n, 0, t, g)), f++, Array.isArray(d)) {
				if (_ === "-") _ = d.length;
				else if (r && !isInteger(_)) throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", s, n, t);
				else isInteger(_) && (_ = ~~_);
				if (f >= p) {
					if (r && n.op === "add" && _ > d.length) throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", s, n, t);
					var l = arrOps[n.op].call(n, d, _, t);
					if (l.test === !1) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", s, n, t);
					return l;
				}
			} else if (f >= p) {
				var l = objOps[n.op].call(n, d, _, t);
				if (l.test === !1) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", s, n, t);
				return l;
			}
			if (d = d[_], r && f < p && (!d || typeof d != "object")) throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", s, n, t);
		}
	}
}
function applyPatch(t, n, r, i, o) {
	if (i === void 0 && (i = !0), o === void 0 && (o = !0), r && !Array.isArray(n)) throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
	i || (t = _deepClone(t));
	for (var s = Array(n.length), l = 0, u = n.length; l < u; l++) s[l] = applyOperation(t, n[l], r, !0, o, l), t = s[l].newDocument;
	return s.newDocument = t, s;
}
function applyReducer(t, n, r) {
	var i = applyOperation(t, n);
	if (i.test === !1) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", r, n, t);
	return i.newDocument;
}
function validator(t, n, r, i) {
	if (typeof t != "object" || !t || Array.isArray(t)) throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", n, t, r);
	if (objOps[t.op]) {
		if (typeof t.path != "string") throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", n, t, r);
		if (t.path.indexOf("/") !== 0 && t.path.length > 0) throw new JsonPatchError("Operation `path` property must start with \"/\"", "OPERATION_PATH_INVALID", n, t, r);
		if ((t.op === "move" || t.op === "copy") && typeof t.from != "string") throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", n, t, r);
		if ((t.op === "add" || t.op === "replace" || t.op === "test") && t.value === void 0) throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", n, t, r);
		if ((t.op === "add" || t.op === "replace" || t.op === "test") && hasUndefined(t.value)) throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", n, t, r);
		if (r) {
			if (t.op == "add") {
				var o = t.path.split("/").length, s = i.split("/").length;
				if (o !== s + 1 && o !== s) throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", n, t, r);
			} else if (t.op === "replace" || t.op === "remove" || t.op === "_get") {
				if (t.path !== i) throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", n, t, r);
			} else if (t.op === "move" || t.op === "copy") {
				var l = validate([{
					op: "_get",
					path: t.from,
					value: void 0
				}], r);
				if (l && l.name === "OPERATION_PATH_UNRESOLVABLE") throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", n, t, r);
			}
		}
	} else throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", n, t, r);
}
function validate(t, n, r) {
	try {
		if (!Array.isArray(t)) throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
		if (n) applyPatch(_deepClone(n), _deepClone(t), r || !0);
		else {
			r ||= validator;
			for (var i = 0; i < t.length; i++) r(t[i], i, n, void 0);
		}
	} catch (t) {
		if (t instanceof JsonPatchError) return t;
		throw t;
	}
}
function _areEquals(t, n) {
	if (t === n) return !0;
	if (t && n && typeof t == "object" && typeof n == "object") {
		var r = Array.isArray(t), i = Array.isArray(n), o, s, l;
		if (r && i) {
			if (s = t.length, s != n.length) return !1;
			for (o = s; o-- !== 0;) if (!_areEquals(t[o], n[o])) return !1;
			return !0;
		}
		if (r != i) return !1;
		var u = Object.keys(t);
		if (s = u.length, s !== Object.keys(n).length) return !1;
		for (o = s; o-- !== 0;) if (!n.hasOwnProperty(u[o])) return !1;
		for (o = s; o-- !== 0;) if (l = u[o], !_areEquals(t[l], n[l])) return !1;
		return !0;
	}
	return t !== t && n !== n;
}
var core = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	JsonPatchError,
	_areEquals,
	applyOperation,
	applyPatch,
	applyReducer,
	deepClone,
	getValueByPointer,
	validate,
	validator
}), beforeDict = /* @__PURE__ */ new WeakMap(), Mirror = function() {
	function t(t) {
		this.observers = /* @__PURE__ */ new Map(), this.obj = t;
	}
	return t;
}(), ObserverInfo = function() {
	function t(t, n) {
		this.callback = t, this.observer = n;
	}
	return t;
}();
function getMirror(t) {
	return beforeDict.get(t);
}
function getObserverFromMirror(t, n) {
	return t.observers.get(n);
}
function removeObserverFromMirror(t, n) {
	t.observers.delete(n.callback);
}
function unobserve(t, n) {
	n.unobserve();
}
function observe(t, n) {
	var r = [], i, o = getMirror(t);
	if (!o) o = new Mirror(t), beforeDict.set(t, o);
	else {
		var s = getObserverFromMirror(o, n);
		i = s && s.observer;
	}
	if (i) return i;
	if (i = {}, o.value = _deepClone(t), n) {
		i.callback = n, i.next = null;
		var l = function() {
			generate(i);
		}, u = function() {
			clearTimeout(i.next), i.next = setTimeout(l);
		};
		typeof window < "u" && (window.addEventListener("mouseup", u), window.addEventListener("keyup", u), window.addEventListener("mousedown", u), window.addEventListener("keydown", u), window.addEventListener("change", u));
	}
	return i.patches = r, i.object = t, i.unobserve = function() {
		generate(i), clearTimeout(i.next), removeObserverFromMirror(o, i), typeof window < "u" && (window.removeEventListener("mouseup", u), window.removeEventListener("keyup", u), window.removeEventListener("mousedown", u), window.removeEventListener("keydown", u), window.removeEventListener("change", u));
	}, o.observers.set(n, new ObserverInfo(n, i)), i;
}
function generate(t, n) {
	n === void 0 && (n = !1);
	var r = beforeDict.get(t.object);
	_generate(r.value, t.object, t.patches, "", n), t.patches.length && applyPatch(r.value, t.patches);
	var i = t.patches;
	return i.length > 0 && (t.patches = [], t.callback && t.callback(i)), i;
}
function _generate(t, n, r, i, o) {
	if (n !== t) {
		typeof n.toJSON == "function" && (n = n.toJSON());
		for (var s = _objectKeys(n), l = _objectKeys(t), u = !1, d = l.length - 1; d >= 0; d--) {
			var f = l[d], p = t[f];
			if (hasOwnProperty(n, f) && !(n[f] === void 0 && p !== void 0 && Array.isArray(n) === !1)) {
				var g = n[f];
				typeof p == "object" && p && typeof g == "object" && g && Array.isArray(p) === Array.isArray(g) ? _generate(p, g, r, i + "/" + escapePathComponent(f), o) : p !== g && (o && r.push({
					op: "test",
					path: i + "/" + escapePathComponent(f),
					value: _deepClone(p)
				}), r.push({
					op: "replace",
					path: i + "/" + escapePathComponent(f),
					value: _deepClone(g)
				}));
			} else Array.isArray(t) === Array.isArray(n) ? (o && r.push({
				op: "test",
				path: i + "/" + escapePathComponent(f),
				value: _deepClone(p)
			}), r.push({
				op: "remove",
				path: i + "/" + escapePathComponent(f)
			}), u = !0) : (o && r.push({
				op: "test",
				path: i,
				value: t
			}), r.push({
				op: "replace",
				path: i,
				value: n
			}));
		}
		if (!(!u && s.length == l.length)) for (var d = 0; d < s.length; d++) {
			var f = s[d];
			!hasOwnProperty(t, f) && n[f] !== void 0 && r.push({
				op: "add",
				path: i + "/" + escapePathComponent(f),
				value: _deepClone(n[f])
			});
		}
	}
}
function compare(t, n, r) {
	r === void 0 && (r = !1);
	var i = [];
	return _generate(t, n, i, "", r), i;
}
var duplex = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	compare,
	generate,
	observe,
	unobserve
});
Object.assign({}, core, duplex, {
	JsonPatchError: PatchError,
	deepClone: _deepClone,
	escapePathComponent,
	unescapePathComponent
});
function getDefaultExportFromCjs(t) {
	return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var lrucache, hasRequiredLrucache;
function requireLrucache() {
	if (hasRequiredLrucache) return lrucache;
	hasRequiredLrucache = 1;
	class t {
		constructor() {
			this.max = 1e3, this.map = /* @__PURE__ */ new Map();
		}
		get(t) {
			let n = this.map.get(t);
			if (n !== void 0) return this.map.delete(t), this.map.set(t, n), n;
		}
		delete(t) {
			return this.map.delete(t);
		}
		set(t, n) {
			if (!this.delete(t) && n !== void 0) {
				if (this.map.size >= this.max) {
					let t = this.map.keys().next().value;
					this.delete(t);
				}
				this.map.set(t, n);
			}
			return this;
		}
	}
	return lrucache = t, lrucache;
}
var parseOptions_1, hasRequiredParseOptions;
function requireParseOptions() {
	if (hasRequiredParseOptions) return parseOptions_1;
	hasRequiredParseOptions = 1;
	let t = Object.freeze({ loose: !0 }), n = Object.freeze({});
	return parseOptions_1 = (r) => r ? typeof r == "object" ? r : t : n, parseOptions_1;
}
var re = { exports: {} }, constants, hasRequiredConstants;
function requireConstants() {
	return hasRequiredConstants ? constants : (hasRequiredConstants = 1, constants = {
		MAX_LENGTH: 256,
		MAX_SAFE_COMPONENT_LENGTH: 16,
		MAX_SAFE_BUILD_LENGTH: 250,
		MAX_SAFE_INTEGER: 2 ** 53 - 1 || 9007199254740991,
		RELEASE_TYPES: [
			"major",
			"premajor",
			"minor",
			"preminor",
			"patch",
			"prepatch",
			"prerelease"
		],
		SEMVER_SPEC_VERSION: "2.0.0",
		FLAG_INCLUDE_PRERELEASE: 1,
		FLAG_LOOSE: 2
	}, constants);
}
var debug_1, hasRequiredDebug;
function requireDebug() {
	return hasRequiredDebug ? debug_1 : (hasRequiredDebug = 1, debug_1 = typeof process$1 == "object" && process$1.env && process$1.env.NODE_DEBUG && /\bsemver\b/i.test(process$1.env.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {}, debug_1);
}
var hasRequiredRe;
function requireRe() {
	return hasRequiredRe ? re.exports : (hasRequiredRe = 1, (function(t, n) {
		let { MAX_SAFE_COMPONENT_LENGTH: r, MAX_SAFE_BUILD_LENGTH: i, MAX_LENGTH: o } = requireConstants(), s = requireDebug();
		n = t.exports = {};
		let l = n.re = [], u = n.safeRe = [], d = n.src = [], f = n.safeSrc = [], p = n.t = {}, g = 0, _ = "[a-zA-Z0-9-]", v = [
			["\\s", 1],
			["\\d", o],
			[_, i]
		], S = (t) => {
			for (let [n, r] of v) t = t.split(`${n}*`).join(`${n}{0,${r}}`).split(`${n}+`).join(`${n}{1,${r}}`);
			return t;
		}, T = (t, n, r) => {
			let i = S(n), o = g++;
			s(t, o, n), p[t] = o, d[o] = n, f[o] = i, l[o] = new RegExp(n, r ? "g" : void 0), u[o] = new RegExp(i, r ? "g" : void 0);
		};
		T("NUMERICIDENTIFIER", "0|[1-9]\\d*"), T("NUMERICIDENTIFIERLOOSE", "\\d+"), T("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${_}*`), T("MAINVERSION", `(${d[p.NUMERICIDENTIFIER]})\\.(${d[p.NUMERICIDENTIFIER]})\\.(${d[p.NUMERICIDENTIFIER]})`), T("MAINVERSIONLOOSE", `(${d[p.NUMERICIDENTIFIERLOOSE]})\\.(${d[p.NUMERICIDENTIFIERLOOSE]})\\.(${d[p.NUMERICIDENTIFIERLOOSE]})`), T("PRERELEASEIDENTIFIER", `(?:${d[p.NONNUMERICIDENTIFIER]}|${d[p.NUMERICIDENTIFIER]})`), T("PRERELEASEIDENTIFIERLOOSE", `(?:${d[p.NONNUMERICIDENTIFIER]}|${d[p.NUMERICIDENTIFIERLOOSE]})`), T("PRERELEASE", `(?:-(${d[p.PRERELEASEIDENTIFIER]}(?:\\.${d[p.PRERELEASEIDENTIFIER]})*))`), T("PRERELEASELOOSE", `(?:-?(${d[p.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${d[p.PRERELEASEIDENTIFIERLOOSE]})*))`), T("BUILDIDENTIFIER", `${_}+`), T("BUILD", `(?:\\+(${d[p.BUILDIDENTIFIER]}(?:\\.${d[p.BUILDIDENTIFIER]})*))`), T("FULLPLAIN", `v?${d[p.MAINVERSION]}${d[p.PRERELEASE]}?${d[p.BUILD]}?`), T("FULL", `^${d[p.FULLPLAIN]}$`), T("LOOSEPLAIN", `[v=\\s]*${d[p.MAINVERSIONLOOSE]}${d[p.PRERELEASELOOSE]}?${d[p.BUILD]}?`), T("LOOSE", `^${d[p.LOOSEPLAIN]}$`), T("GTLT", "((?:<|>)?=?)"), T("XRANGEIDENTIFIERLOOSE", `${d[p.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), T("XRANGEIDENTIFIER", `${d[p.NUMERICIDENTIFIER]}|x|X|\\*`), T("XRANGEPLAIN", `[v=\\s]*(${d[p.XRANGEIDENTIFIER]})(?:\\.(${d[p.XRANGEIDENTIFIER]})(?:\\.(${d[p.XRANGEIDENTIFIER]})(?:${d[p.PRERELEASE]})?${d[p.BUILD]}?)?)?`), T("XRANGEPLAINLOOSE", `[v=\\s]*(${d[p.XRANGEIDENTIFIERLOOSE]})(?:\\.(${d[p.XRANGEIDENTIFIERLOOSE]})(?:\\.(${d[p.XRANGEIDENTIFIERLOOSE]})(?:${d[p.PRERELEASELOOSE]})?${d[p.BUILD]}?)?)?`), T("XRANGE", `^${d[p.GTLT]}\\s*${d[p.XRANGEPLAIN]}$`), T("XRANGELOOSE", `^${d[p.GTLT]}\\s*${d[p.XRANGEPLAINLOOSE]}$`), T("COERCEPLAIN", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`), T("COERCE", `${d[p.COERCEPLAIN]}(?:$|[^\\d])`), T("COERCEFULL", d[p.COERCEPLAIN] + `(?:${d[p.PRERELEASE]})?(?:${d[p.BUILD]})?(?:$|[^\\d])`), T("COERCERTL", d[p.COERCE], !0), T("COERCERTLFULL", d[p.COERCEFULL], !0), T("LONETILDE", "(?:~>?)"), T("TILDETRIM", `(\\s*)${d[p.LONETILDE]}\\s+`, !0), n.tildeTrimReplace = "$1~", T("TILDE", `^${d[p.LONETILDE]}${d[p.XRANGEPLAIN]}$`), T("TILDELOOSE", `^${d[p.LONETILDE]}${d[p.XRANGEPLAINLOOSE]}$`), T("LONECARET", "(?:\\^)"), T("CARETTRIM", `(\\s*)${d[p.LONECARET]}\\s+`, !0), n.caretTrimReplace = "$1^", T("CARET", `^${d[p.LONECARET]}${d[p.XRANGEPLAIN]}$`), T("CARETLOOSE", `^${d[p.LONECARET]}${d[p.XRANGEPLAINLOOSE]}$`), T("COMPARATORLOOSE", `^${d[p.GTLT]}\\s*(${d[p.LOOSEPLAIN]})$|^$`), T("COMPARATOR", `^${d[p.GTLT]}\\s*(${d[p.FULLPLAIN]})$|^$`), T("COMPARATORTRIM", `(\\s*)${d[p.GTLT]}\\s*(${d[p.LOOSEPLAIN]}|${d[p.XRANGEPLAIN]})`, !0), n.comparatorTrimReplace = "$1$2$3", T("HYPHENRANGE", `^\\s*(${d[p.XRANGEPLAIN]})\\s+-\\s+(${d[p.XRANGEPLAIN]})\\s*$`), T("HYPHENRANGELOOSE", `^\\s*(${d[p.XRANGEPLAINLOOSE]})\\s+-\\s+(${d[p.XRANGEPLAINLOOSE]})\\s*$`), T("STAR", "(<|>)?=?\\s*\\*"), T("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), T("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
	})(re, re.exports), re.exports);
}
var identifiers, hasRequiredIdentifiers;
function requireIdentifiers() {
	if (hasRequiredIdentifiers) return identifiers;
	hasRequiredIdentifiers = 1;
	let t = /^[0-9]+$/, n = (n, r) => {
		let i = t.test(n), o = t.test(r);
		return i && o && (n = +n, r = +r), n === r ? 0 : i && !o ? -1 : o && !i ? 1 : n < r ? -1 : 1;
	};
	return identifiers = {
		compareIdentifiers: n,
		rcompareIdentifiers: (t, r) => n(r, t)
	}, identifiers;
}
var semver, hasRequiredSemver;
function requireSemver() {
	if (hasRequiredSemver) return semver;
	hasRequiredSemver = 1;
	let t = requireDebug(), { MAX_LENGTH: n, MAX_SAFE_INTEGER: r } = requireConstants(), { safeRe: i, t: o } = requireRe(), s = requireParseOptions(), { compareIdentifiers: l } = requireIdentifiers();
	class u {
		constructor(l, d) {
			if (d = s(d), l instanceof u) {
				if (l.loose === !!d.loose && l.includePrerelease === !!d.includePrerelease) return l;
				l = l.version;
			} else if (typeof l != "string") throw TypeError(`Invalid version. Must be a string. Got type "${typeof l}".`);
			if (l.length > n) throw TypeError(`version is longer than ${n} characters`);
			t("SemVer", l, d), this.options = d, this.loose = !!d.loose, this.includePrerelease = !!d.includePrerelease;
			let f = l.trim().match(d.loose ? i[o.LOOSE] : i[o.FULL]);
			if (!f) throw TypeError(`Invalid Version: ${l}`);
			if (this.raw = l, this.major = +f[1], this.minor = +f[2], this.patch = +f[3], this.major > r || this.major < 0) throw TypeError("Invalid major version");
			if (this.minor > r || this.minor < 0) throw TypeError("Invalid minor version");
			if (this.patch > r || this.patch < 0) throw TypeError("Invalid patch version");
			f[4] ? this.prerelease = f[4].split(".").map((t) => {
				if (/^[0-9]+$/.test(t)) {
					let n = +t;
					if (n >= 0 && n < r) return n;
				}
				return t;
			}) : this.prerelease = [], this.build = f[5] ? f[5].split(".") : [], this.format();
		}
		format() {
			return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
		}
		toString() {
			return this.version;
		}
		compare(n) {
			if (t("SemVer.compare", this.version, this.options, n), !(n instanceof u)) {
				if (typeof n == "string" && n === this.version) return 0;
				n = new u(n, this.options);
			}
			return n.version === this.version ? 0 : this.compareMain(n) || this.comparePre(n);
		}
		compareMain(t) {
			return t instanceof u || (t = new u(t, this.options)), l(this.major, t.major) || l(this.minor, t.minor) || l(this.patch, t.patch);
		}
		comparePre(n) {
			if (n instanceof u || (n = new u(n, this.options)), this.prerelease.length && !n.prerelease.length) return -1;
			if (!this.prerelease.length && n.prerelease.length) return 1;
			if (!this.prerelease.length && !n.prerelease.length) return 0;
			let r = 0;
			do {
				let i = this.prerelease[r], o = n.prerelease[r];
				if (t("prerelease compare", r, i, o), i === void 0 && o === void 0) return 0;
				if (o === void 0) return 1;
				if (i === void 0) return -1;
				if (i === o) continue;
				return l(i, o);
			} while (++r);
		}
		compareBuild(n) {
			n instanceof u || (n = new u(n, this.options));
			let r = 0;
			do {
				let i = this.build[r], o = n.build[r];
				if (t("build compare", r, i, o), i === void 0 && o === void 0) return 0;
				if (o === void 0) return 1;
				if (i === void 0) return -1;
				if (i === o) continue;
				return l(i, o);
			} while (++r);
		}
		inc(t, n, r) {
			if (t.startsWith("pre")) {
				if (!n && r === !1) throw Error("invalid increment argument: identifier is empty");
				if (n) {
					let t = `-${n}`.match(this.options.loose ? i[o.PRERELEASELOOSE] : i[o.PRERELEASE]);
					if (!t || t[1] !== n) throw Error(`invalid identifier: ${n}`);
				}
			}
			switch (t) {
				case "premajor":
					this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n, r);
					break;
				case "preminor":
					this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n, r);
					break;
				case "prepatch":
					this.prerelease.length = 0, this.inc("patch", n, r), this.inc("pre", n, r);
					break;
				case "prerelease":
					this.prerelease.length === 0 && this.inc("patch", n, r), this.inc("pre", n, r);
					break;
				case "release":
					if (this.prerelease.length === 0) throw Error(`version ${this.raw} is not a prerelease`);
					this.prerelease.length = 0;
					break;
				case "major":
					(this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
					break;
				case "minor":
					(this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
					break;
				case "patch":
					this.prerelease.length === 0 && this.patch++, this.prerelease = [];
					break;
				case "pre": {
					let t = Number(r) ? 1 : 0;
					if (this.prerelease.length === 0) this.prerelease = [t];
					else {
						let i = this.prerelease.length;
						for (; --i >= 0;) typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
						if (i === -1) {
							if (n === this.prerelease.join(".") && r === !1) throw Error("invalid increment argument: identifier already exists");
							this.prerelease.push(t);
						}
					}
					if (n) {
						let i = [n, t];
						r === !1 && (i = [n]), l(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = i) : this.prerelease = i;
					}
					break;
				}
				default: throw Error(`invalid increment argument: ${t}`);
			}
			return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
		}
	}
	return semver = u, semver;
}
var compare_1, hasRequiredCompare;
function requireCompare() {
	if (hasRequiredCompare) return compare_1;
	hasRequiredCompare = 1;
	let t = requireSemver();
	return compare_1 = (n, r, i) => new t(n, i).compare(new t(r, i)), compare_1;
}
var eq_1, hasRequiredEq;
function requireEq() {
	if (hasRequiredEq) return eq_1;
	hasRequiredEq = 1;
	let t = requireCompare();
	return eq_1 = (n, r, i) => t(n, r, i) === 0, eq_1;
}
var neq_1, hasRequiredNeq;
function requireNeq() {
	if (hasRequiredNeq) return neq_1;
	hasRequiredNeq = 1;
	let t = requireCompare();
	return neq_1 = (n, r, i) => t(n, r, i) !== 0, neq_1;
}
var gt_1, hasRequiredGt;
function requireGt() {
	if (hasRequiredGt) return gt_1;
	hasRequiredGt = 1;
	let t = requireCompare();
	return gt_1 = (n, r, i) => t(n, r, i) > 0, gt_1;
}
var gte_1, hasRequiredGte;
function requireGte() {
	if (hasRequiredGte) return gte_1;
	hasRequiredGte = 1;
	let t = requireCompare();
	return gte_1 = (n, r, i) => t(n, r, i) >= 0, gte_1;
}
var lt_1, hasRequiredLt;
function requireLt() {
	if (hasRequiredLt) return lt_1;
	hasRequiredLt = 1;
	let t = requireCompare();
	return lt_1 = (n, r, i) => t(n, r, i) < 0, lt_1;
}
var lte_1, hasRequiredLte;
function requireLte() {
	if (hasRequiredLte) return lte_1;
	hasRequiredLte = 1;
	let t = requireCompare();
	return lte_1 = (n, r, i) => t(n, r, i) <= 0, lte_1;
}
var cmp_1, hasRequiredCmp;
function requireCmp() {
	if (hasRequiredCmp) return cmp_1;
	hasRequiredCmp = 1;
	let t = requireEq(), n = requireNeq(), r = requireGt(), i = requireGte(), o = requireLt(), s = requireLte();
	return cmp_1 = (l, u, d, f) => {
		switch (u) {
			case "===": return typeof l == "object" && (l = l.version), typeof d == "object" && (d = d.version), l === d;
			case "!==": return typeof l == "object" && (l = l.version), typeof d == "object" && (d = d.version), l !== d;
			case "":
			case "=":
			case "==": return t(l, d, f);
			case "!=": return n(l, d, f);
			case ">": return r(l, d, f);
			case ">=": return i(l, d, f);
			case "<": return o(l, d, f);
			case "<=": return s(l, d, f);
			default: throw TypeError(`Invalid operator: ${u}`);
		}
	}, cmp_1;
}
var comparator, hasRequiredComparator;
function requireComparator() {
	if (hasRequiredComparator) return comparator;
	hasRequiredComparator = 1;
	let t = Symbol("SemVer ANY");
	class n {
		static get ANY() {
			return t;
		}
		constructor(i, o) {
			if (o = r(o), i instanceof n) {
				if (i.loose === !!o.loose) return i;
				i = i.value;
			}
			i = i.trim().split(/\s+/).join(" "), l("comparator", i, o), this.options = o, this.loose = !!o.loose, this.parse(i), this.semver === t ? this.value = "" : this.value = this.operator + this.semver.version, l("comp", this);
		}
		parse(n) {
			let r = this.options.loose ? i[o.COMPARATORLOOSE] : i[o.COMPARATOR], s = n.match(r);
			if (!s) throw TypeError(`Invalid comparator: ${n}`);
			this.operator = s[1] === void 0 ? "" : s[1], this.operator === "=" && (this.operator = ""), s[2] ? this.semver = new u(s[2], this.options.loose) : this.semver = t;
		}
		toString() {
			return this.value;
		}
		test(n) {
			if (l("Comparator.test", n, this.options.loose), this.semver === t || n === t) return !0;
			if (typeof n == "string") try {
				n = new u(n, this.options);
			} catch {
				return !1;
			}
			return s(n, this.operator, this.semver, this.options);
		}
		intersects(t, i) {
			if (!(t instanceof n)) throw TypeError("a Comparator is required");
			return this.operator === "" ? this.value === "" ? !0 : new d(t.value, i).test(this.value) : t.operator === "" ? t.value === "" ? !0 : new d(this.value, i).test(t.semver) : (i = r(i), i.includePrerelease && (this.value === "<0.0.0-0" || t.value === "<0.0.0-0") || !i.includePrerelease && (this.value.startsWith("<0.0.0") || t.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && t.operator.startsWith(">") || this.operator.startsWith("<") && t.operator.startsWith("<") || this.semver.version === t.semver.version && this.operator.includes("=") && t.operator.includes("=") || s(this.semver, "<", t.semver, i) && this.operator.startsWith(">") && t.operator.startsWith("<") || s(this.semver, ">", t.semver, i) && this.operator.startsWith("<") && t.operator.startsWith(">")));
		}
	}
	comparator = n;
	let r = requireParseOptions(), { safeRe: i, t: o } = requireRe(), s = requireCmp(), l = requireDebug(), u = requireSemver(), d = requireRange();
	return comparator;
}
var range, hasRequiredRange;
function requireRange() {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;
	let t = /\s+/g;
	class n {
		constructor(r, s) {
			if (s = i(s), r instanceof n) return r.loose === !!s.loose && r.includePrerelease === !!s.includePrerelease ? r : new n(r.raw, s);
			if (r instanceof o) return this.raw = r.value, this.set = [[r]], this.formatted = void 0, this;
			if (this.options = s, this.loose = !!s.loose, this.includePrerelease = !!s.includePrerelease, this.raw = r.trim().replace(t, " "), this.set = this.raw.split("||").map((t) => this.parseRange(t.trim())).filter((t) => t.length), !this.set.length) throw TypeError(`Invalid SemVer Range: ${this.raw}`);
			if (this.set.length > 1) {
				let t = this.set[0];
				if (this.set = this.set.filter((t) => !S(t[0])), this.set.length === 0) this.set = [t];
				else if (this.set.length > 1) {
					for (let t of this.set) if (t.length === 1 && T(t[0])) {
						this.set = [t];
						break;
					}
				}
			}
			this.formatted = void 0;
		}
		get range() {
			if (this.formatted === void 0) {
				this.formatted = "";
				for (let t = 0; t < this.set.length; t++) {
					t > 0 && (this.formatted += "||");
					let n = this.set[t];
					for (let t = 0; t < n.length; t++) t > 0 && (this.formatted += " "), this.formatted += n[t].toString().trim();
				}
			}
			return this.formatted;
		}
		format() {
			return this.range;
		}
		toString() {
			return this.range;
		}
		parseRange(t) {
			let n = ((this.options.includePrerelease && _) | (this.options.loose && v)) + ":" + t, i = r.get(n);
			if (i) return i;
			let l = this.options.loose, T = l ? u[d.HYPHENRANGELOOSE] : u[d.HYPHENRANGE];
			t = t.replace(T, z(this.options.includePrerelease)), s("hyphen replace", t), t = t.replace(u[d.COMPARATORTRIM], f), s("comparator trim", t), t = t.replace(u[d.TILDETRIM], p), s("tilde trim", t), t = t.replace(u[d.CARETTRIM], g), s("caret trim", t);
			let E = t.split(" ").map((t) => O(t, this.options)).join(" ").split(/\s+/).map((t) => R(t, this.options));
			l && (E = E.filter((t) => (s("loose invalid filter", t, this.options), !!t.match(u[d.COMPARATORLOOSE])))), s("range list", E);
			let k = /* @__PURE__ */ new Map(), A = E.map((t) => new o(t, this.options));
			for (let t of A) {
				if (S(t)) return [t];
				k.set(t.value, t);
			}
			k.size > 1 && k.has("") && k.delete("");
			let j = [...k.values()];
			return r.set(n, j), j;
		}
		intersects(t, r) {
			if (!(t instanceof n)) throw TypeError("a Range is required");
			return this.set.some((n) => E(n, r) && t.set.some((t) => E(t, r) && n.every((n) => t.every((t) => n.intersects(t, r)))));
		}
		test(t) {
			if (!t) return !1;
			if (typeof t == "string") try {
				t = new l(t, this.options);
			} catch {
				return !1;
			}
			for (let n = 0; n < this.set.length; n++) if (V(this.set[n], t, this.options)) return !0;
			return !1;
		}
	}
	range = n;
	let r = new (requireLrucache())(), i = requireParseOptions(), o = requireComparator(), s = requireDebug(), l = requireSemver(), { safeRe: u, t: d, comparatorTrimReplace: f, tildeTrimReplace: p, caretTrimReplace: g } = requireRe(), { FLAG_INCLUDE_PRERELEASE: _, FLAG_LOOSE: v } = requireConstants(), S = (t) => t.value === "<0.0.0-0", T = (t) => t.value === "", E = (t, n) => {
		let r = !0, i = t.slice(), o = i.pop();
		for (; r && i.length;) r = i.every((t) => o.intersects(t, n)), o = i.pop();
		return r;
	}, O = (t, n) => (s("comp", t, n), t = N(t, n), s("caret", t), t = A(t, n), s("tildes", t), t = F(t, n), s("xrange", t), t = L(t, n), s("stars", t), t), k = (t) => !t || t.toLowerCase() === "x" || t === "*", A = (t, n) => t.trim().split(/\s+/).map((t) => j(t, n)).join(" "), j = (t, n) => {
		let r = n.loose ? u[d.TILDELOOSE] : u[d.TILDE];
		return t.replace(r, (n, r, i, o, l) => {
			s("tilde", t, n, r, i, o, l);
			let u;
			return k(r) ? u = "" : k(i) ? u = `>=${r}.0.0 <${+r + 1}.0.0-0` : k(o) ? u = `>=${r}.${i}.0 <${r}.${+i + 1}.0-0` : l ? (s("replaceTilde pr", l), u = `>=${r}.${i}.${o}-${l} <${r}.${+i + 1}.0-0`) : u = `>=${r}.${i}.${o} <${r}.${+i + 1}.0-0`, s("tilde return", u), u;
		});
	}, N = (t, n) => t.trim().split(/\s+/).map((t) => P(t, n)).join(" "), P = (t, n) => {
		s("caret", t, n);
		let r = n.loose ? u[d.CARETLOOSE] : u[d.CARET], i = n.includePrerelease ? "-0" : "";
		return t.replace(r, (n, r, o, l, u) => {
			s("caret", t, n, r, o, l, u);
			let d;
			return k(r) ? d = "" : k(o) ? d = `>=${r}.0.0${i} <${+r + 1}.0.0-0` : k(l) ? d = r === "0" ? `>=${r}.${o}.0${i} <${r}.${+o + 1}.0-0` : `>=${r}.${o}.0${i} <${+r + 1}.0.0-0` : u ? (s("replaceCaret pr", u), d = r === "0" ? o === "0" ? `>=${r}.${o}.${l}-${u} <${r}.${o}.${+l + 1}-0` : `>=${r}.${o}.${l}-${u} <${r}.${+o + 1}.0-0` : `>=${r}.${o}.${l}-${u} <${+r + 1}.0.0-0`) : (s("no pr"), d = r === "0" ? o === "0" ? `>=${r}.${o}.${l}${i} <${r}.${o}.${+l + 1}-0` : `>=${r}.${o}.${l}${i} <${r}.${+o + 1}.0-0` : `>=${r}.${o}.${l} <${+r + 1}.0.0-0`), s("caret return", d), d;
		});
	}, F = (t, n) => (s("replaceXRanges", t, n), t.split(/\s+/).map((t) => I(t, n)).join(" ")), I = (t, n) => {
		t = t.trim();
		let r = n.loose ? u[d.XRANGELOOSE] : u[d.XRANGE];
		return t.replace(r, (r, i, o, l, u, d) => {
			s("xRange", t, r, i, o, l, u, d);
			let f = k(o), p = f || k(l), g = p || k(u), _ = g;
			return i === "=" && _ && (i = ""), d = n.includePrerelease ? "-0" : "", f ? r = i === ">" || i === "<" ? "<0.0.0-0" : "*" : i && _ ? (p && (l = 0), u = 0, i === ">" ? (i = ">=", p ? (o = +o + 1, l = 0, u = 0) : (l = +l + 1, u = 0)) : i === "<=" && (i = "<", p ? o = +o + 1 : l = +l + 1), i === "<" && (d = "-0"), r = `${i + o}.${l}.${u}${d}`) : p ? r = `>=${o}.0.0${d} <${+o + 1}.0.0-0` : g && (r = `>=${o}.${l}.0${d} <${o}.${+l + 1}.0-0`), s("xRange return", r), r;
		});
	}, L = (t, n) => (s("replaceStars", t, n), t.trim().replace(u[d.STAR], "")), R = (t, n) => (s("replaceGTE0", t, n), t.trim().replace(u[n.includePrerelease ? d.GTE0PRE : d.GTE0], "")), z = (t) => (n, r, i, o, s, l, u, d, f, p, g, _) => (r = k(i) ? "" : k(o) ? `>=${i}.0.0${t ? "-0" : ""}` : k(s) ? `>=${i}.${o}.0${t ? "-0" : ""}` : l ? `>=${r}` : `>=${r}${t ? "-0" : ""}`, d = k(f) ? "" : k(p) ? `<${+f + 1}.0.0-0` : k(g) ? `<${f}.${+p + 1}.0-0` : _ ? `<=${f}.${p}.${g}-${_}` : t ? `<${f}.${p}.${+g + 1}-0` : `<=${d}`, `${r} ${d}`.trim()), V = (t, n, r) => {
		for (let r = 0; r < t.length; r++) if (!t[r].test(n)) return !1;
		if (n.prerelease.length && !r.includePrerelease) {
			for (let r = 0; r < t.length; r++) if (s(t[r].semver), t[r].semver !== o.ANY && t[r].semver.prerelease.length > 0) {
				let i = t[r].semver;
				if (i.major === n.major && i.minor === n.minor && i.patch === n.patch) return !0;
			}
			return !1;
		}
		return !0;
	};
	return range;
}
var satisfies_1, hasRequiredSatisfies;
function requireSatisfies() {
	if (hasRequiredSatisfies) return satisfies_1;
	hasRequiredSatisfies = 1;
	let t = requireRange();
	return satisfies_1 = (n, r, i) => {
		try {
			r = new t(r, i);
		} catch {
			return !1;
		}
		return r.test(n);
	}, satisfies_1;
}
var satisfies = /* @__PURE__ */ getDefaultExportFromCjs(requireSatisfies());
function post(t, n, r) {
	let i = t.open(n), { origin: o } = new URL(n), s = 40;
	function l(n) {
		n.source === i && (s = 0, t.removeEventListener("message", l, !1));
	}
	t.addEventListener("message", l, !1);
	function u() {
		s <= 0 || (i.postMessage(r, o), setTimeout(u, 250), --s);
	}
	setTimeout(u, 250);
}
var embedStyle = ".vega-embed {\n  position: relative;\n  display: inline-block;\n  box-sizing: border-box;\n}\n.vega-embed.has-actions {\n  padding-right: 38px;\n}\n.vega-embed details:not([open]) > :not(summary) {\n  display: none !important;\n}\n.vega-embed summary {\n  list-style: none;\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 6px;\n  z-index: 1000;\n  background: white;\n  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);\n  color: #1b1e23;\n  border: 1px solid #aaa;\n  border-radius: 999px;\n  opacity: 0.2;\n  transition: opacity 0.4s ease-in;\n  cursor: pointer;\n  line-height: 0px;\n}\n.vega-embed summary::-webkit-details-marker {\n  display: none;\n}\n.vega-embed summary:active {\n  box-shadow: #aaa 0px 0px 0px 1px inset;\n}\n.vega-embed summary svg {\n  width: 14px;\n  height: 14px;\n}\n.vega-embed details[open] summary {\n  opacity: 0.7;\n}\n.vega-embed:hover summary, .vega-embed:focus-within summary {\n  opacity: 1 !important;\n  transition: opacity 0.2s ease;\n}\n.vega-embed .vega-actions {\n  position: absolute;\n  z-index: 1001;\n  top: 35px;\n  right: -9px;\n  display: flex;\n  flex-direction: column;\n  padding-bottom: 8px;\n  padding-top: 8px;\n  border-radius: 4px;\n  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);\n  border: 1px solid #d9d9d9;\n  background: white;\n  animation-duration: 0.15s;\n  animation-name: scale-in;\n  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);\n  text-align: left;\n}\n.vega-embed .vega-actions a {\n  padding: 8px 16px;\n  font-family: sans-serif;\n  font-size: 14px;\n  font-weight: 600;\n  white-space: nowrap;\n  color: #434a56;\n  text-decoration: none;\n}\n.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {\n  background-color: #f7f7f9;\n  color: black;\n}\n.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {\n  content: \"\";\n  display: inline-block;\n  position: absolute;\n}\n.vega-embed .vega-actions::before {\n  left: auto;\n  right: 14px;\n  top: -16px;\n  border: 8px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #d9d9d9;\n}\n.vega-embed .vega-actions::after {\n  left: auto;\n  right: 15px;\n  top: -14px;\n  border: 7px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #fff;\n}\n.vega-embed .chart-wrapper.fit-x {\n  width: 100%;\n}\n.vega-embed .chart-wrapper.fit-y {\n  height: 100%;\n}\n\n.vega-embed-wrapper {\n  max-width: 100%;\n  overflow: auto;\n  padding-right: 14px;\n}\n\n@keyframes scale-in {\n  from {\n    opacity: 0;\n    transform: scale(0.6);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n";
function mergeDeep(t, ...n) {
	for (let r of n) deepMerge_(t, r);
	return t;
}
function deepMerge_(t, n) {
	for (let r of Object.keys(n)) writeConfig(t, r, n[r], !0);
}
({ version: "7.1.0" }).version;
var vega = vega_module_exports, vegaLite = build_exports, w = typeof window < "u" ? window : void 0;
vegaLite === void 0 && w?.vl?.compile && (vegaLite = w.vl);
var DEFAULT_ACTIONS = {
	export: {
		svg: !0,
		png: !0
	},
	source: !0,
	compiled: !0,
	editor: !0
}, I18N = {
	CLICK_TO_VIEW_ACTIONS: "Click to view actions",
	COMPILED_ACTION: "View Compiled Vega",
	EDITOR_ACTION: "Open in Vega Editor",
	PNG_ACTION: "Save as PNG",
	SOURCE_ACTION: "View Source",
	SVG_ACTION: "Save as SVG"
}, NAMES = {
	vega: "Vega",
	"vega-lite": "Vega-Lite"
}, VERSION = {
	vega: vega.version,
	"vega-lite": vegaLite ? vegaLite.version : "not available"
}, PREPROCESSOR = {
	vega: (t) => t,
	"vega-lite": (t, n, r) => vegaLite.compile(t, {
		config: r,
		logger: n
	}).spec
}, SVG_CIRCLES = "\n<svg viewBox=\"0 0 16 16\" fill=\"currentColor\" stroke=\"none\" stroke-width=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <circle r=\"2\" cy=\"8\" cx=\"2\"></circle>\n  <circle r=\"2\" cy=\"8\" cx=\"8\"></circle>\n  <circle r=\"2\" cy=\"8\" cx=\"14\"></circle>\n</svg>", CHART_WRAPPER_CLASS = "chart-wrapper";
function isTooltipHandler(t) {
	return typeof t == "function";
}
function viewSource(t, n, r, i) {
	let o = `<html><head>${n}</head><body><pre><code class="json">`, s = `</code></pre>${r}</body></html>`, l = window.open("");
	l.document.write(o + t + s), l.document.title = `${NAMES[i]} JSON Source`;
}
function guessMode(t, n, r) {
	if (t.$schema) {
		let i = e(t.$schema);
		r && r !== i.library && n.warn(`The given visualization spec is written in ${NAMES[i.library]}, but mode argument sets ${NAMES[r] ?? r}.`);
		let o = i.library;
		return satisfies(VERSION[o], `^${i.version.slice(1)}`) || n.warn(`The input spec uses ${NAMES[o]} ${i.version}, but the current version of ${NAMES[o]} is v${VERSION[o]}.`), o;
	}
	return "mark" in t || "encoding" in t || "layer" in t || "hconcat" in t || "vconcat" in t || "facet" in t || "repeat" in t ? "vega-lite" : "marks" in t || "signals" in t || "scales" in t || "axes" in t ? "vega" : r ?? "vega";
}
function isLoader(t) {
	return !!(t && "load" in t);
}
function createLoader(t) {
	return isLoader(t) ? t : vega.loader(t);
}
function embedOptionsFromUsermeta(t) {
	let n = t.usermeta?.embedOptions ?? {};
	return isString(n.defaultStyle) && (n.defaultStyle = !1), n;
}
async function embed(t, n, r = {}) {
	let i, o;
	isString(n) ? (o = createLoader(r.loader), i = JSON.parse(await o.load(n))) : i = n;
	let s = embedOptionsFromUsermeta(i), l = s.loader;
	(!o || l) && (o = createLoader(r.loader ?? l));
	let u = await loadOpts(s, o), d = await loadOpts(r, o), f = {
		...mergeDeep(d, u),
		config: mergeConfig(d.config ?? {}, u.config ?? {})
	};
	return await _embed(t, i, f, o);
}
async function loadOpts(t, n) {
	let r = isString(t.config) ? JSON.parse(await n.load(t.config)) : t.config ?? {}, i = isString(t.patch) ? JSON.parse(await n.load(t.patch)) : t.patch;
	return {
		...t,
		...i ? { patch: i } : {},
		...r ? { config: r } : {}
	};
}
function getRoot(t) {
	let n = t.getRootNode ? t.getRootNode() : document;
	return n instanceof ShadowRoot ? {
		root: n,
		rootContainer: n
	} : {
		root: document,
		rootContainer: document.head ?? document.body
	};
}
async function _embed(t, n, r = {}, i) {
	let o = r.theme ? mergeConfig(build_exports$1[r.theme], r.config ?? {}) : r.config, s = isBoolean(r.actions) ? r.actions : mergeDeep({}, DEFAULT_ACTIONS, r.actions ?? {}), l = {
		...I18N,
		...r.i18n
	}, u = r.renderer ?? "svg", d = r.logger ?? logger(vega.Warn);
	r.logLevel !== void 0 && d.level(r.logLevel);
	let f = r.downloadFileName ?? "visualization", p = typeof t == "string" ? document.querySelector(t) : t;
	if (!p) throw Error(`${t} does not exist`);
	if (r.defaultStyle !== !1) {
		let t = "vega-embed-style", { root: n, rootContainer: i } = getRoot(p);
		if (!n.getElementById(t)) {
			let n = document.createElement("style");
			n.id = t, n.innerHTML = r.defaultStyle === void 0 || r.defaultStyle === !0 ? embedStyle.toString() : r.defaultStyle, i.appendChild(n);
		}
	}
	let g = guessMode(n, d, r.mode), _ = PREPROCESSOR[g](n, d, o);
	if (g === "vega-lite" && _.$schema) {
		let t = e(_.$schema);
		satisfies(VERSION.vega, `^${t.version.slice(1)}`) || d.warn(`The compiled spec uses Vega ${t.version}, but current version is v${VERSION.vega}.`);
	}
	p.classList.add("vega-embed"), s && p.classList.add("has-actions"), p.innerHTML = "";
	let v = p;
	if (s) {
		let t = document.createElement("div");
		t.classList.add(CHART_WRAPPER_CLASS), p.appendChild(t), v = t;
	}
	let S = r.patch;
	if (S && (_ = S instanceof Function ? S(_) : applyPatch(_, S, !0, !1).newDocument), r.formatLocale && vega.formatLocale(r.formatLocale), r.timeFormatLocale && vega.timeFormatLocale(r.timeFormatLocale), r.expressionFunctions) for (let t in r.expressionFunctions) {
		let n = r.expressionFunctions[t];
		"fn" in n ? vega.expressionFunction(t, n.fn, n.visitor) : n instanceof Function && vega.expressionFunction(t, n);
	}
	let { ast: T } = r, E = vega.parse(_, g === "vega-lite" ? {} : o, { ast: T }), O = new (r.viewClass || vega.View)(E, {
		loader: i,
		logger: d,
		renderer: u,
		...T ? { expr: vega.expressionInterpreter ?? r.expr ?? expression } : {}
	});
	if (O.addSignalListener("autosize", (t, n) => {
		let { type: r } = n;
		r == "fit-x" ? (v.classList.add("fit-x"), v.classList.remove("fit-y")) : r == "fit-y" ? (v.classList.remove("fit-x"), v.classList.add("fit-y")) : r == "fit" ? v.classList.add("fit-x", "fit-y") : v.classList.remove("fit-x", "fit-y");
	}), r.tooltip !== !1) {
		let { loader: t, tooltip: n } = r, i = t && !isLoader(t) ? t?.baseURL : void 0, o = isTooltipHandler(n) ? n : new Handler({
			baseURL: i,
			...n === !0 ? {} : n
		}).call;
		O.tooltip(o);
	}
	let { hover: k } = r;
	if (k === void 0 && (k = g === "vega"), k) {
		let { hoverSet: t, updateSet: n } = typeof k == "boolean" ? {} : k;
		O.hover(t, n);
	}
	r && (r.width != null && O.width(r.width), r.height != null && O.height(r.height), r.padding != null && O.padding(r.padding)), await O.initialize(v, r.bind).runAsync();
	let A;
	if (s !== !1) {
		let t = p;
		if (r.defaultStyle !== !1 || r.forceActionsMenu) {
			let n = document.createElement("details");
			n.title = l.CLICK_TO_VIEW_ACTIONS, p.append(n), t = n;
			let r = document.createElement("summary");
			r.innerHTML = SVG_CIRCLES, n.append(r), A = (t) => {
				n.contains(t.target) || n.removeAttribute("open");
			}, document.addEventListener("click", A);
		}
		let i = document.createElement("div");
		if (t.append(i), i.classList.add("vega-actions"), s === !0 || s.export !== !1) {
			for (let t of ["svg", "png"]) if (s === !0 || s.export === !0 || s.export[t]) {
				let n = l[`${t.toUpperCase()}_ACTION`], o = document.createElement("a"), s = isObject(r.scaleFactor) ? r.scaleFactor[t] : r.scaleFactor;
				o.text = n, o.href = "#", o.target = "_blank", o.download = `${f}.${t}`, o.addEventListener("mousedown", async function(n) {
					n.preventDefault(), this.href = await O.toImageURL(t, s);
				}), i.append(o);
			}
		}
		if (s === !0 || s.source !== !1) {
			let t = document.createElement("a");
			t.text = l.SOURCE_ACTION, t.href = "#", t.addEventListener("click", function(t) {
				viewSource(stringify(n), r.sourceHeader ?? "", r.sourceFooter ?? "", g), t.preventDefault();
			}), i.append(t);
		}
		if (g === "vega-lite" && (s === !0 || s.compiled !== !1)) {
			let t = document.createElement("a");
			t.text = l.COMPILED_ACTION, t.href = "#", t.addEventListener("click", function(t) {
				viewSource(stringify(_), r.sourceHeader ?? "", r.sourceFooter ?? "", "vega"), t.preventDefault();
			}), i.append(t);
		}
		if (s === !0 || s.editor !== !1) {
			let t = r.editorUrl ?? "https://vega.github.io/editor/", s = document.createElement("a");
			s.text = l.EDITOR_ACTION, s.href = "#", s.addEventListener("click", function(r) {
				post(window, t, {
					config: o,
					mode: S ? "vega" : g,
					renderer: u,
					spec: stringify(S ? _ : n)
				}), r.preventDefault();
			}), i.append(s);
		}
	}
	function j() {
		A && document.removeEventListener("click", A), O.finalize();
	}
	return {
		view: O,
		spec: n,
		vgSpec: _,
		finalize: j,
		embedOptions: r
	};
}
export { DEFAULT_ACTIONS, embed as default, guessMode, vega, vegaLite };
