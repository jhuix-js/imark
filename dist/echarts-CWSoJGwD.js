import { r as __export } from "./chunk-DgPTj83v.js";
import { n as init_dist, t as global } from "./dist-CoGdlYHY.js";
import { n as init_dist$1, t as Buffer } from "./dist-B_PGMnbI.js";
import { n as process$1, t as init_dist$2 } from "./dist-Dmaes8r4.js";
init_dist$2(), init_dist();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(t, n) {
	return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
		t.__proto__ = n;
	} || function(t, n) {
		for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
	}, extendStatics(t, n);
};
function __extends(t, n) {
	if (typeof n != "function" && n !== null) throw TypeError("Class extends value " + String(n) + " is not a constructor or null");
	extendStatics(t, n);
	function r() {
		this.constructor = t;
	}
	t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
}
var Browser = function() {
	function t() {
		this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
	}
	return t;
}(), env = new (function() {
	function t() {
		this.browser = new Browser(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
	}
	return t;
}())();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (env.wxa = !0, env.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? env.worker = !0 : !env.hasGlobalWindow || "Deno" in window ? (env.node = !0, env.svgSupported = !0) : detect(navigator.userAgent, env);
function detect(t, n) {
	var r = n.browser, a = t.match(/Firefox\/([\d.]+)/), o = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/), s = t.match(/Edge?\/([\d.]+)/), c = /micromessenger/i.test(t);
	a && (r.firefox = !0, r.version = a[1]), o && (r.ie = !0, r.version = o[1]), s && (r.edge = !0, r.version = s[1], r.newEdge = +s[1].split(".")[0] > 18), c && (r.weChat = !0), n.svgSupported = typeof SVGRect < "u", n.touchEventsSupported = "ontouchstart" in window && !r.ie && !r.edge, n.pointerEventsSupported = "onpointerdown" in window && (r.edge || r.ie && +r.version >= 11), n.domSupported = typeof document < "u";
	var l = document.documentElement.style;
	n.transform3dSupported = (r.ie && "transition" in l || r.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in l) && !("OTransition" in l), n.transformSupported = n.transform3dSupported || r.ie && +r.version >= 9;
}
var env_default = env, DEFAULT_FONT = "12px sans-serif", OFFSET = 20, SCALE = 100, defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function getTextWidthMap(t) {
	var n = {};
	if (typeof JSON > "u") return n;
	for (var r = 0; r < t.length; r++) {
		var a = String.fromCharCode(r + 32);
		n[a] = (t.charCodeAt(r) - OFFSET) / SCALE;
	}
	return n;
}
var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr), platformApi = {
	createCanvas: function() {
		return typeof document < "u" && document.createElement("canvas");
	},
	measureText: (function() {
		var t, n;
		return function(r, a) {
			if (!t) {
				var o = platformApi.createCanvas();
				t = o && o.getContext("2d");
			}
			if (t) return n !== a && (n = t.font = a || "12px sans-serif"), t.measureText(r);
			r ||= "", a ||= "12px sans-serif";
			var s = /((?:\d+)?\.?\d*)px/.exec(a), c = s && +s[1] || 12, l = 0;
			if (a.indexOf("mono") >= 0) l = c * r.length;
			else for (var u = 0; u < r.length; u++) {
				var d = DEFAULT_TEXT_WIDTH_MAP[r[u]];
				l += d == null ? c : d * c;
			}
			return { width: l };
		};
	})(),
	loadImage: function(t, n, r) {
		var a = new Image();
		return a.onload = n, a.onerror = r, a.src = t, a;
	}
};
function setPlatformAPI(t) {
	for (var n in platformApi) t[n] && (platformApi[n] = t[n]);
}
var util_exports$1 = /* @__PURE__ */ __export({
	HashMap: () => HashMap,
	RADIAN_TO_DEGREE: () => RADIAN_TO_DEGREE,
	assert: () => assert,
	bind: () => bind,
	clone: () => clone$1,
	concatArray: () => concatArray,
	createCanvas: () => createCanvas,
	createHashMap: () => createHashMap,
	createObject: () => createObject,
	curry: () => curry,
	defaults: () => defaults,
	disableUserSelect: () => disableUserSelect,
	each: () => each,
	eqNaN: () => eqNaN,
	extend: () => extend,
	filter: () => filter,
	find: () => find,
	guid: () => guid,
	hasOwn: () => hasOwn,
	indexOf: () => indexOf,
	inherits: () => inherits,
	isArray: () => isArray,
	isArrayLike: () => isArrayLike,
	isBuiltInObject: () => isBuiltInObject,
	isDom: () => isDom,
	isFunction: () => isFunction,
	isGradientObject: () => isGradientObject,
	isImagePatternObject: () => isImagePatternObject,
	isNumber: () => isNumber,
	isObject: () => isObject,
	isPrimitive: () => isPrimitive,
	isRegExp: () => isRegExp,
	isString: () => isString,
	isStringSafe: () => isStringSafe,
	isTypedArray: () => isTypedArray,
	keys: () => keys,
	logError: () => logError,
	map: () => map,
	merge: () => merge,
	mergeAll: () => mergeAll,
	mixin: () => mixin,
	noop: () => noop,
	normalizeCssArray: () => normalizeCssArray$1,
	reduce: () => reduce,
	retrieve: () => retrieve,
	retrieve2: () => retrieve2,
	retrieve3: () => retrieve3,
	setAsPrimitive: () => setAsPrimitive,
	slice: () => slice,
	trim: () => trim
}), BUILTIN_OBJECT = reduce([
	"Function",
	"RegExp",
	"Date",
	"Error",
	"CanvasGradient",
	"CanvasPattern",
	"Image",
	"Canvas"
], function(t, n) {
	return t["[object " + n + "]"] = !0, t;
}, {}), TYPED_ARRAY = reduce([
	"Int8",
	"Uint8",
	"Uint8Clamped",
	"Int16",
	"Uint16",
	"Int32",
	"Uint32",
	"Float32",
	"Float64"
], function(t, n) {
	return t["[object " + n + "Array]"] = !0, t;
}, {}), objToString = Object.prototype.toString, arrayProto = Array.prototype, nativeForEach = arrayProto.forEach, nativeFilter = arrayProto.filter, nativeSlice = arrayProto.slice, nativeMap = arrayProto.map, ctorFunction = function() {}.constructor, protoFunction = ctorFunction ? ctorFunction.prototype : null, protoKey = "__proto__", idStart = 2311;
function guid() {
	return idStart++;
}
function logError() {
	var t = [...arguments];
	typeof console < "u" && console.error.apply(console, t);
}
function clone$1(t) {
	if (typeof t != "object" || !t) return t;
	var n = t, r = objToString.call(t);
	if (r === "[object Array]") {
		if (!isPrimitive(t)) {
			n = [];
			for (var a = 0, o = t.length; a < o; a++) n[a] = clone$1(t[a]);
		}
	} else if (TYPED_ARRAY[r]) {
		if (!isPrimitive(t)) {
			var s = t.constructor;
			if (s.from) n = s.from(t);
			else {
				n = new s(t.length);
				for (var a = 0, o = t.length; a < o; a++) n[a] = t[a];
			}
		}
	} else if (!BUILTIN_OBJECT[r] && !isPrimitive(t) && !isDom(t)) for (var c in n = {}, t) t.hasOwnProperty(c) && c !== protoKey && (n[c] = clone$1(t[c]));
	return n;
}
function merge(t, n, r) {
	if (!isObject(n) || !isObject(t)) return r ? clone$1(n) : t;
	for (var a in n) if (n.hasOwnProperty(a) && a !== protoKey) {
		var o = t[a], s = n[a];
		isObject(s) && isObject(o) && !isArray(s) && !isArray(o) && !isDom(s) && !isDom(o) && !isBuiltInObject(s) && !isBuiltInObject(o) && !isPrimitive(s) && !isPrimitive(o) ? merge(o, s, r) : (r || !(a in t)) && (t[a] = clone$1(n[a]));
	}
	return t;
}
function mergeAll(t, n) {
	for (var r = t[0], a = 1, o = t.length; a < o; a++) r = merge(r, t[a], n);
	return r;
}
function extend(t, n) {
	if (Object.assign) Object.assign(t, n);
	else for (var r in n) n.hasOwnProperty(r) && r !== protoKey && (t[r] = n[r]);
	return t;
}
function defaults(t, n, r) {
	for (var a = keys(n), o = 0, s = a.length; o < s; o++) {
		var c = a[o];
		(r ? n[c] != null : t[c] == null) && (t[c] = n[c]);
	}
	return t;
}
var createCanvas = platformApi.createCanvas;
function indexOf(t, n) {
	if (t) {
		if (t.indexOf) return t.indexOf(n);
		for (var r = 0, a = t.length; r < a; r++) if (t[r] === n) return r;
	}
	return -1;
}
function inherits(t, n) {
	var r = t.prototype;
	function a() {}
	for (var o in a.prototype = n.prototype, t.prototype = new a(), r) r.hasOwnProperty(o) && (t.prototype[o] = r[o]);
	t.prototype.constructor = t, t.superClass = n;
}
function mixin(t, n, r) {
	if (t = "prototype" in t ? t.prototype : t, n = "prototype" in n ? n.prototype : n, Object.getOwnPropertyNames) for (var a = Object.getOwnPropertyNames(n), o = 0; o < a.length; o++) {
		var s = a[o];
		s !== "constructor" && (r ? n[s] != null : t[s] == null) && (t[s] = n[s]);
	}
	else defaults(t, n, r);
}
function isArrayLike(t) {
	return !t || typeof t == "string" ? !1 : typeof t.length == "number";
}
function each(t, n, r) {
	if (t && n) if (t.forEach && t.forEach === nativeForEach) t.forEach(n, r);
	else if (t.length === +t.length) for (var a = 0, o = t.length; a < o; a++) n.call(r, t[a], a, t);
	else for (var s in t) t.hasOwnProperty(s) && n.call(r, t[s], s, t);
}
function map(t, n, r) {
	if (!t) return [];
	if (!n) return slice(t);
	if (t.map && t.map === nativeMap) return t.map(n, r);
	for (var a = [], o = 0, s = t.length; o < s; o++) a.push(n.call(r, t[o], o, t));
	return a;
}
function reduce(t, n, r, a) {
	if (t && n) {
		for (var o = 0, s = t.length; o < s; o++) r = n.call(a, r, t[o], o, t);
		return r;
	}
}
function filter(t, n, r) {
	if (!t) return [];
	if (!n) return slice(t);
	if (t.filter && t.filter === nativeFilter) return t.filter(n, r);
	for (var a = [], o = 0, s = t.length; o < s; o++) n.call(r, t[o], o, t) && a.push(t[o]);
	return a;
}
function find(t, n, r) {
	if (t && n) {
		for (var a = 0, o = t.length; a < o; a++) if (n.call(r, t[a], a, t)) return t[a];
	}
}
function keys(t) {
	if (!t) return [];
	if (Object.keys) return Object.keys(t);
	var n = [];
	for (var r in t) t.hasOwnProperty(r) && n.push(r);
	return n;
}
function bindPolyfill(t, n) {
	var r = [...arguments].slice(2);
	return function() {
		return t.apply(n, r.concat(nativeSlice.call(arguments)));
	};
}
var bind = protoFunction && isFunction(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
function curry(t) {
	var n = [...arguments].slice(1);
	return function() {
		return t.apply(this, n.concat(nativeSlice.call(arguments)));
	};
}
function isArray(t) {
	return Array.isArray ? Array.isArray(t) : objToString.call(t) === "[object Array]";
}
function isFunction(t) {
	return typeof t == "function";
}
function isString(t) {
	return typeof t == "string";
}
function isStringSafe(t) {
	return objToString.call(t) === "[object String]";
}
function isNumber(t) {
	return typeof t == "number";
}
function isObject(t) {
	var n = typeof t;
	return n === "function" || !!t && n === "object";
}
function isBuiltInObject(t) {
	return !!BUILTIN_OBJECT[objToString.call(t)];
}
function isTypedArray(t) {
	return !!TYPED_ARRAY[objToString.call(t)];
}
function isDom(t) {
	return typeof t == "object" && typeof t.nodeType == "number" && typeof t.ownerDocument == "object";
}
function isGradientObject(t) {
	return t.colorStops != null;
}
function isImagePatternObject(t) {
	return t.image != null;
}
function isRegExp(t) {
	return objToString.call(t) === "[object RegExp]";
}
function eqNaN(t) {
	return t !== t;
}
function retrieve() {
	for (var t = [...arguments], n = 0, r = t.length; n < r; n++) if (t[n] != null) return t[n];
}
function retrieve2(t, n) {
	return t ?? n;
}
function retrieve3(t, n, r) {
	return t ?? n ?? r;
}
function slice(t) {
	var n = [...arguments].slice(1);
	return nativeSlice.apply(t, n);
}
function normalizeCssArray$1(t) {
	if (typeof t == "number") return [
		t,
		t,
		t,
		t
	];
	var n = t.length;
	return n === 2 ? [
		t[0],
		t[1],
		t[0],
		t[1]
	] : n === 3 ? [
		t[0],
		t[1],
		t[2],
		t[1]
	] : t;
}
function assert(t, n) {
	if (!t) throw Error(n);
}
function trim(t) {
	return t == null ? null : typeof t.trim == "function" ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var primitiveKey = "__ec_primitive__";
function setAsPrimitive(t) {
	t[primitiveKey] = !0;
}
function isPrimitive(t) {
	return t[primitiveKey];
}
var MapPolyfill = function() {
	function t() {
		this.data = {};
	}
	return t.prototype.delete = function(t) {
		var n = this.has(t);
		return n && delete this.data[t], n;
	}, t.prototype.has = function(t) {
		return this.data.hasOwnProperty(t);
	}, t.prototype.get = function(t) {
		return this.data[t];
	}, t.prototype.set = function(t, n) {
		return this.data[t] = n, this;
	}, t.prototype.keys = function() {
		return keys(this.data);
	}, t.prototype.forEach = function(t) {
		var n = this.data;
		for (var r in n) n.hasOwnProperty(r) && t(n[r], r);
	}, t;
}(), isNativeMapSupported = typeof Map == "function";
function maybeNativeMap() {
	return isNativeMapSupported ? /* @__PURE__ */ new Map() : new MapPolyfill();
}
var HashMap = function() {
	function t(n) {
		var r = isArray(n);
		this.data = maybeNativeMap();
		var a = this;
		n instanceof t ? n.each(o) : n && each(n, o);
		function o(t, n) {
			r ? a.set(t, n) : a.set(n, t);
		}
	}
	return t.prototype.hasKey = function(t) {
		return this.data.has(t);
	}, t.prototype.get = function(t) {
		return this.data.get(t);
	}, t.prototype.set = function(t, n) {
		return this.data.set(t, n), n;
	}, t.prototype.each = function(t, n) {
		this.data.forEach(function(r, a) {
			t.call(n, r, a);
		});
	}, t.prototype.keys = function() {
		var t = this.data.keys();
		return isNativeMapSupported ? Array.from(t) : t;
	}, t.prototype.removeKey = function(t) {
		this.data.delete(t);
	}, t;
}();
function createHashMap(t) {
	return new HashMap(t);
}
function concatArray(t, n) {
	for (var r = new t.constructor(t.length + n.length), a = 0; a < t.length; a++) r[a] = t[a];
	for (var o = t.length, a = 0; a < n.length; a++) r[a + o] = n[a];
	return r;
}
function createObject(t, n) {
	var r;
	if (Object.create) r = Object.create(t);
	else {
		var a = function() {};
		a.prototype = t, r = new a();
	}
	return n && extend(r, n), r;
}
function disableUserSelect(t) {
	var n = t.style;
	n.webkitUserSelect = "none", n.userSelect = "none", n.webkitTapHighlightColor = "rgba(0,0,0,0)", n["-webkit-touch-callout"] = "none";
}
function hasOwn(t, n) {
	return t.hasOwnProperty(n);
}
function noop() {}
var RADIAN_TO_DEGREE = 180 / Math.PI, vector_exports = /* @__PURE__ */ __export({
	add: () => add,
	applyTransform: () => applyTransform,
	clone: () => clone$3,
	copy: () => copy$1,
	create: () => create$1,
	dist: () => dist$1,
	distSquare: () => distSquare,
	distance: () => distance,
	distanceSquare: () => distanceSquare,
	div: () => div,
	dot: () => dot,
	len: () => len,
	lenSquare: () => lenSquare,
	length: () => length,
	lengthSquare: () => lengthSquare,
	lerp: () => lerp,
	max: () => max,
	min: () => min,
	mul: () => mul$1,
	negate: () => negate,
	normalize: () => normalize$3,
	scale: () => scale$1,
	scaleAndAdd: () => scaleAndAdd$1,
	set: () => set$1,
	sub: () => sub
});
function create$1(t, n) {
	return t ??= 0, n ??= 0, [t, n];
}
function copy$1(t, n) {
	return t[0] = n[0], t[1] = n[1], t;
}
function clone$3(t) {
	return [t[0], t[1]];
}
function set$1(t, n, r) {
	return t[0] = n, t[1] = r, t;
}
function add(t, n, r) {
	return t[0] = n[0] + r[0], t[1] = n[1] + r[1], t;
}
function scaleAndAdd$1(t, n, r, a) {
	return t[0] = n[0] + r[0] * a, t[1] = n[1] + r[1] * a, t;
}
function sub(t, n, r) {
	return t[0] = n[0] - r[0], t[1] = n[1] - r[1], t;
}
function len(t) {
	return Math.sqrt(lenSquare(t));
}
var length = len;
function lenSquare(t) {
	return t[0] * t[0] + t[1] * t[1];
}
var lengthSquare = lenSquare;
function mul$1(t, n, r) {
	return t[0] = n[0] * r[0], t[1] = n[1] * r[1], t;
}
function div(t, n, r) {
	return t[0] = n[0] / r[0], t[1] = n[1] / r[1], t;
}
function dot(t, n) {
	return t[0] * n[0] + t[1] * n[1];
}
function scale$1(t, n, r) {
	return t[0] = n[0] * r, t[1] = n[1] * r, t;
}
function normalize$3(t, n) {
	var r = len(n);
	return r === 0 ? (t[0] = 0, t[1] = 0) : (t[0] = n[0] / r, t[1] = n[1] / r), t;
}
function distance(t, n) {
	return Math.sqrt((t[0] - n[0]) * (t[0] - n[0]) + (t[1] - n[1]) * (t[1] - n[1]));
}
var dist$1 = distance;
function distanceSquare(t, n) {
	return (t[0] - n[0]) * (t[0] - n[0]) + (t[1] - n[1]) * (t[1] - n[1]);
}
var distSquare = distanceSquare;
function negate(t, n) {
	return t[0] = -n[0], t[1] = -n[1], t;
}
function lerp(t, n, r, a) {
	return t[0] = n[0] + a * (r[0] - n[0]), t[1] = n[1] + a * (r[1] - n[1]), t;
}
function applyTransform(t, n, r) {
	var a = n[0], o = n[1];
	return t[0] = r[0] * a + r[2] * o + r[4], t[1] = r[1] * a + r[3] * o + r[5], t;
}
function min(t, n, r) {
	return t[0] = Math.min(n[0], r[0]), t[1] = Math.min(n[1], r[1]), t;
}
function max(t, n, r) {
	return t[0] = Math.max(n[0], r[0]), t[1] = Math.max(n[1], r[1]), t;
}
var Param = function() {
	function t(t, n) {
		this.target = t, this.topTarget = n && n.topTarget;
	}
	return t;
}(), Draggable_default = function() {
	function t(t) {
		this.handler = t, t.on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on("mouseup", this._dragEnd, this);
	}
	return t.prototype._dragStart = function(t) {
		for (var n = t.target; n && !n.draggable;) n = n.parent || n.__hostTarget;
		n && (this._draggingTarget = n, n.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new Param(n, t), "dragstart", t.event));
	}, t.prototype._drag = function(t) {
		var n = this._draggingTarget;
		if (n) {
			var r = t.offsetX, a = t.offsetY, o = r - this._x, s = a - this._y;
			this._x = r, this._y = a, n.drift(o, s, t), this.handler.dispatchToElement(new Param(n, t), "drag", t.event);
			var c = this.handler.findHover(r, a, n).target, l = this._dropTarget;
			this._dropTarget = c, n !== c && (l && c !== l && this.handler.dispatchToElement(new Param(l, t), "dragleave", t.event), c && c !== l && this.handler.dispatchToElement(new Param(c, t), "dragenter", t.event));
		}
	}, t.prototype._dragEnd = function(t) {
		var n = this._draggingTarget;
		n && (n.dragging = !1), this.handler.dispatchToElement(new Param(n, t), "dragend", t.event), this._dropTarget && this.handler.dispatchToElement(new Param(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
	}, t;
}(), Eventful_default = function() {
	function t(t) {
		t && (this._$eventProcessor = t);
	}
	return t.prototype.on = function(t, n, r, a) {
		this._$handlers ||= {};
		var o = this._$handlers;
		if (typeof n == "function" && (a = r, r = n, n = null), !r || !t) return this;
		var s = this._$eventProcessor;
		n != null && s && s.normalizeQuery && (n = s.normalizeQuery(n)), o[t] || (o[t] = []);
		for (var c = 0; c < o[t].length; c++) if (o[t][c].h === r) return this;
		var l = {
			h: r,
			query: n,
			ctx: a || this,
			callAtLast: r.zrEventfulCallAtLast
		}, u = o[t].length - 1, d = o[t][u];
		return d && d.callAtLast ? o[t].splice(u, 0, l) : o[t].push(l), this;
	}, t.prototype.isSilent = function(t) {
		var n = this._$handlers;
		return !n || !n[t] || !n[t].length;
	}, t.prototype.off = function(t, n) {
		var r = this._$handlers;
		if (!r) return this;
		if (!t) return this._$handlers = {}, this;
		if (n) {
			if (r[t]) {
				for (var a = [], o = 0, s = r[t].length; o < s; o++) r[t][o].h !== n && a.push(r[t][o]);
				r[t] = a;
			}
			r[t] && r[t].length === 0 && delete r[t];
		} else delete r[t];
		return this;
	}, t.prototype.trigger = function(t) {
		var n = [...arguments].slice(1);
		if (!this._$handlers) return this;
		var r = this._$handlers[t], a = this._$eventProcessor;
		if (r) for (var o = n.length, s = r.length, c = 0; c < s; c++) {
			var l = r[c];
			if (!(a && a.filter && l.query != null && !a.filter(t, l.query))) switch (o) {
				case 0:
					l.h.call(l.ctx);
					break;
				case 1:
					l.h.call(l.ctx, n[0]);
					break;
				case 2:
					l.h.call(l.ctx, n[0], n[1]);
					break;
				default:
					l.h.apply(l.ctx, n);
					break;
			}
		}
		return a && a.afterTrigger && a.afterTrigger(t), this;
	}, t.prototype.triggerWithContext = function(t) {
		var n = [...arguments].slice(1);
		if (!this._$handlers) return this;
		var r = this._$handlers[t], a = this._$eventProcessor;
		if (r) for (var o = n.length, s = n[o - 1], c = r.length, l = 0; l < c; l++) {
			var u = r[l];
			if (!(a && a.filter && u.query != null && !a.filter(t, u.query))) switch (o) {
				case 0:
					u.h.call(s);
					break;
				case 1:
					u.h.call(s, n[0]);
					break;
				case 2:
					u.h.call(s, n[0], n[1]);
					break;
				default:
					u.h.apply(s, n.slice(1, o - 1));
					break;
			}
		}
		return a && a.afterTrigger && a.afterTrigger(t), this;
	}, t;
}(), LN2 = Math.log(2);
function determinant(t, n, r, a, o, s) {
	var c = a + "-" + o, l = t.length;
	if (s.hasOwnProperty(c)) return s[c];
	if (n === 1) {
		var u = Math.round(Math.log((1 << l) - 1 & ~o) / LN2);
		return t[r][u];
	}
	for (var d = a | 1 << r, f = r + 1; a & 1 << f;) f++;
	for (var p = 0, h = 0, g = 0; h < l; h++) {
		var _ = 1 << h;
		_ & o || (p += (g % 2 ? -1 : 1) * t[r][h] * determinant(t, n - 1, f, d, o | _, s), g++);
	}
	return s[c] = p, p;
}
function buildTransformer(t, n) {
	var r = [
		[
			t[0],
			t[1],
			1,
			0,
			0,
			0,
			-n[0] * t[0],
			-n[0] * t[1]
		],
		[
			0,
			0,
			0,
			t[0],
			t[1],
			1,
			-n[1] * t[0],
			-n[1] * t[1]
		],
		[
			t[2],
			t[3],
			1,
			0,
			0,
			0,
			-n[2] * t[2],
			-n[2] * t[3]
		],
		[
			0,
			0,
			0,
			t[2],
			t[3],
			1,
			-n[3] * t[2],
			-n[3] * t[3]
		],
		[
			t[4],
			t[5],
			1,
			0,
			0,
			0,
			-n[4] * t[4],
			-n[4] * t[5]
		],
		[
			0,
			0,
			0,
			t[4],
			t[5],
			1,
			-n[5] * t[4],
			-n[5] * t[5]
		],
		[
			t[6],
			t[7],
			1,
			0,
			0,
			0,
			-n[6] * t[6],
			-n[6] * t[7]
		],
		[
			0,
			0,
			0,
			t[6],
			t[7],
			1,
			-n[7] * t[6],
			-n[7] * t[7]
		]
	], a = {}, o = determinant(r, 8, 0, 0, 0, a);
	if (o !== 0) {
		for (var s = [], c = 0; c < 8; c++) for (var l = 0; l < 8; l++) s[l] ?? (s[l] = 0), s[l] += ((c + l) % 2 ? -1 : 1) * determinant(r, 7, c === 0 ? 1 : 0, 1 << c, 1 << l, a) / o * n[c];
		return function(t, n, r) {
			var a = n * s[6] + r * s[7] + 1;
			t[0] = (n * s[0] + r * s[1] + s[2]) / a, t[1] = (n * s[3] + r * s[4] + s[5]) / a;
		};
	}
}
var EVENT_SAVED_PROP = "___zrEVENTSAVED", _calcOut$1 = [];
function transformLocalCoord(t, n, r, a, o) {
	return transformCoordWithViewport(_calcOut$1, n, a, o, !0) && transformCoordWithViewport(t, r, _calcOut$1[0], _calcOut$1[1]);
}
function transformCoordWithViewport(t, n, r, a, o) {
	if (n.getBoundingClientRect && env_default.domSupported && !isCanvasEl(n)) {
		var s = n[EVENT_SAVED_PROP] || (n[EVENT_SAVED_PROP] = {}), c = preparePointerTransformer(prepareCoordMarkers(n, s), s, o);
		if (c) return c(t, r, a), !0;
	}
	return !1;
}
function prepareCoordMarkers(t, n) {
	var r = n.markers;
	if (r) return r;
	r = n.markers = [];
	for (var a = ["left", "right"], o = ["top", "bottom"], s = 0; s < 4; s++) {
		var c = document.createElement("div"), l = c.style, u = s % 2, d = (s >> 1) % 2;
		l.cssText = [
			"position: absolute",
			"visibility: hidden",
			"padding: 0",
			"margin: 0",
			"border-width: 0",
			"user-select: none",
			"width:0",
			"height:0",
			a[u] + ":0",
			o[d] + ":0",
			a[1 - u] + ":auto",
			o[1 - d] + ":auto",
			""
		].join("!important;"), t.appendChild(c), r.push(c);
	}
	return r;
}
function preparePointerTransformer(t, n, r) {
	for (var a = r ? "invTrans" : "trans", o = n[a], s = n.srcCoords, c = [], l = [], u = !0, d = 0; d < 4; d++) {
		var f = t[d].getBoundingClientRect(), p = 2 * d, h = f.left, g = f.top;
		c.push(h, g), u = u && s && h === s[p] && g === s[p + 1], l.push(t[d].offsetLeft, t[d].offsetTop);
	}
	return u && o ? o : (n.srcCoords = c, n[a] = r ? buildTransformer(l, c) : buildTransformer(c, l));
}
function isCanvasEl(t) {
	return t.nodeName.toUpperCase() === "CANVAS";
}
var replaceReg = /([&<>"'])/g, replaceMap = {
	"&": "&amp;",
	"<": "&lt;",
	">": "&gt;",
	"\"": "&quot;",
	"'": "&#39;"
};
function encodeHTML(t) {
	return t == null ? "" : (t + "").replace(replaceReg, function(t, n) {
		return replaceMap[n];
	});
}
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, _calcOut = [], firefoxNotSupportOffsetXY = env_default.browser.firefox && +env_default.browser.version.split(".")[0] < 39;
function clientToLocal(t, n, r, a) {
	return r ||= {}, a ? calculateZrXY(t, n, r) : firefoxNotSupportOffsetXY && n.layerX != null && n.layerX !== n.offsetX ? (r.zrX = n.layerX, r.zrY = n.layerY) : n.offsetX == null ? calculateZrXY(t, n, r) : (r.zrX = n.offsetX, r.zrY = n.offsetY), r;
}
function calculateZrXY(t, n, r) {
	if (env_default.domSupported && t.getBoundingClientRect) {
		var a = n.clientX, o = n.clientY;
		if (isCanvasEl(t)) {
			var s = t.getBoundingClientRect();
			r.zrX = a - s.left, r.zrY = o - s.top;
			return;
		} else if (transformCoordWithViewport(_calcOut, t, a, o)) {
			r.zrX = _calcOut[0], r.zrY = _calcOut[1];
			return;
		}
	}
	r.zrX = r.zrY = 0;
}
function getNativeEvent(t) {
	return t || window.event;
}
function normalizeEvent(t, n, r) {
	if (n = getNativeEvent(n), n.zrX != null) return n;
	var a = n.type;
	if (a && a.indexOf("touch") >= 0) {
		var o = a === "touchend" ? n.changedTouches[0] : n.targetTouches[0];
		o && clientToLocal(t, o, n, r);
	} else {
		clientToLocal(t, n, n, r);
		var s = getWheelDeltaMayPolyfill(n);
		n.zrDelta = s ? s / 120 : -(n.detail || 0) / 3;
	}
	var c = n.button;
	return n.which == null && c !== void 0 && MOUSE_EVENT_REG.test(n.type) && (n.which = c & 1 ? 1 : c & 2 ? 3 : c & 4 ? 2 : 0), n;
}
function getWheelDeltaMayPolyfill(t) {
	var n = t.wheelDelta;
	if (n) return n;
	var r = t.deltaX, a = t.deltaY;
	if (r == null || a == null) return n;
	var o = a === 0 ? Math.abs(r) : Math.abs(a), s = a > 0 ? -1 : a < 0 ? 1 : r > 0 ? -1 : 1;
	return 3 * o * s;
}
function addEventListener(t, n, r, a) {
	t.addEventListener(n, r, a);
}
function removeEventListener(t, n, r, a) {
	t.removeEventListener(n, r, a);
}
var stop = function(t) {
	t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0;
};
function isMiddleOrRightButtonOnMouseUpDown(t) {
	return t.which === 2 || t.which === 3;
}
var GestureMgr = function() {
	function t() {
		this._track = [];
	}
	return t.prototype.recognize = function(t, n, r) {
		return this._doTrack(t, n, r), this._recognize(t);
	}, t.prototype.clear = function() {
		return this._track.length = 0, this;
	}, t.prototype._doTrack = function(t, n, r) {
		var a = t.touches;
		if (a) {
			for (var o = {
				points: [],
				touches: [],
				target: n,
				event: t
			}, s = 0, c = a.length; s < c; s++) {
				var l = a[s], u = clientToLocal(r, l, {});
				o.points.push([u.zrX, u.zrY]), o.touches.push(l);
			}
			this._track.push(o);
		}
	}, t.prototype._recognize = function(t) {
		for (var n in recognizers) if (recognizers.hasOwnProperty(n)) {
			var r = recognizers[n](this._track, t);
			if (r) return r;
		}
	}, t;
}();
function dist(t) {
	var n = t[1][0] - t[0][0], r = t[1][1] - t[0][1];
	return Math.sqrt(n * n + r * r);
}
function center$1(t) {
	return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2];
}
var recognizers = { pinch: function(t, n) {
	var r = t.length;
	if (r) {
		var a = (t[r - 1] || {}).points, o = (t[r - 2] || {}).points || a;
		if (o && o.length > 1 && a && a.length > 1) {
			var s = dist(a) / dist(o);
			!isFinite(s) && (s = 1), n.pinchScale = s;
			var c = center$1(a);
			return n.pinchX = c[0], n.pinchY = c[1], {
				type: "pinch",
				target: t[0].target,
				event: n
			};
		}
	}
} }, matrix_exports = /* @__PURE__ */ __export({
	clone: () => clone$4,
	copy: () => copy,
	create: () => create$2,
	identity: () => identity,
	invert: () => invert,
	mul: () => mul,
	rotate: () => rotate,
	scale: () => scale$2,
	translate: () => translate
});
function create$2() {
	return [
		1,
		0,
		0,
		1,
		0,
		0
	];
}
function identity(t) {
	return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;
}
function copy(t, n) {
	return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t;
}
function mul(t, n, r) {
	var a = n[0] * r[0] + n[2] * r[1], o = n[1] * r[0] + n[3] * r[1], s = n[0] * r[2] + n[2] * r[3], c = n[1] * r[2] + n[3] * r[3], l = n[0] * r[4] + n[2] * r[5] + n[4], u = n[1] * r[4] + n[3] * r[5] + n[5];
	return t[0] = a, t[1] = o, t[2] = s, t[3] = c, t[4] = l, t[5] = u, t;
}
function translate(t, n, r) {
	return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4] + r[0], t[5] = n[5] + r[1], t;
}
function rotate(t, n, r, a) {
	a === void 0 && (a = [0, 0]);
	var o = n[0], s = n[2], c = n[4], l = n[1], u = n[3], d = n[5], f = Math.sin(r), p = Math.cos(r);
	return t[0] = o * p + l * f, t[1] = -o * f + l * p, t[2] = s * p + u * f, t[3] = -s * f + p * u, t[4] = p * (c - a[0]) + f * (d - a[1]) + a[0], t[5] = p * (d - a[1]) - f * (c - a[0]) + a[1], t;
}
function scale$2(t, n, r) {
	var a = r[0], o = r[1];
	return t[0] = n[0] * a, t[1] = n[1] * o, t[2] = n[2] * a, t[3] = n[3] * o, t[4] = n[4] * a, t[5] = n[5] * o, t;
}
function invert(t, n) {
	var r = n[0], a = n[2], o = n[4], s = n[1], c = n[3], l = n[5], u = r * c - s * a;
	return u ? (u = 1 / u, t[0] = c * u, t[1] = -s * u, t[2] = -a * u, t[3] = r * u, t[4] = (a * l - c * o) * u, t[5] = (s * o - r * l) * u, t) : null;
}
function clone$4(t) {
	var n = create$2();
	return copy(n, t), n;
}
var Point_default = function() {
	function t(t, n) {
		this.x = t || 0, this.y = n || 0;
	}
	return t.prototype.copy = function(t) {
		return this.x = t.x, this.y = t.y, this;
	}, t.prototype.clone = function() {
		return new t(this.x, this.y);
	}, t.prototype.set = function(t, n) {
		return this.x = t, this.y = n, this;
	}, t.prototype.equal = function(t) {
		return t.x === this.x && t.y === this.y;
	}, t.prototype.add = function(t) {
		return this.x += t.x, this.y += t.y, this;
	}, t.prototype.scale = function(t) {
		this.x *= t, this.y *= t;
	}, t.prototype.scaleAndAdd = function(t, n) {
		this.x += t.x * n, this.y += t.y * n;
	}, t.prototype.sub = function(t) {
		return this.x -= t.x, this.y -= t.y, this;
	}, t.prototype.dot = function(t) {
		return this.x * t.x + this.y * t.y;
	}, t.prototype.len = function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}, t.prototype.lenSquare = function() {
		return this.x * this.x + this.y * this.y;
	}, t.prototype.normalize = function() {
		var t = this.len();
		return this.x /= t, this.y /= t, this;
	}, t.prototype.distance = function(t) {
		var n = this.x - t.x, r = this.y - t.y;
		return Math.sqrt(n * n + r * r);
	}, t.prototype.distanceSquare = function(t) {
		var n = this.x - t.x, r = this.y - t.y;
		return n * n + r * r;
	}, t.prototype.negate = function() {
		return this.x = -this.x, this.y = -this.y, this;
	}, t.prototype.transform = function(t) {
		if (t) {
			var n = this.x, r = this.y;
			return this.x = t[0] * n + t[2] * r + t[4], this.y = t[1] * n + t[3] * r + t[5], this;
		}
	}, t.prototype.toArray = function(t) {
		return t[0] = this.x, t[1] = this.y, t;
	}, t.prototype.fromArray = function(t) {
		this.x = t[0], this.y = t[1];
	}, t.set = function(t, n, r) {
		t.x = n, t.y = r;
	}, t.copy = function(t, n) {
		t.x = n.x, t.y = n.y;
	}, t.len = function(t) {
		return Math.sqrt(t.x * t.x + t.y * t.y);
	}, t.lenSquare = function(t) {
		return t.x * t.x + t.y * t.y;
	}, t.dot = function(t, n) {
		return t.x * n.x + t.y * n.y;
	}, t.add = function(t, n, r) {
		t.x = n.x + r.x, t.y = n.y + r.y;
	}, t.sub = function(t, n, r) {
		t.x = n.x - r.x, t.y = n.y - r.y;
	}, t.scale = function(t, n, r) {
		t.x = n.x * r, t.y = n.y * r;
	}, t.scaleAndAdd = function(t, n, r, a) {
		t.x = n.x + r.x * a, t.y = n.y + r.y * a;
	}, t.lerp = function(t, n, r, a) {
		var o = 1 - a;
		t.x = o * n.x + a * r.x, t.y = o * n.y + a * r.y;
	}, t;
}(), mathMin$10 = Math.min, mathMax$10 = Math.max, lt = new Point_default(), rb = new Point_default(), lb = new Point_default(), rt = new Point_default(), minTv$1 = new Point_default(), maxTv$1 = new Point_default(), BoundingRect_default = function() {
	function t(t, n, r, a) {
		r < 0 && (t += r, r = -r), a < 0 && (n += a, a = -a), this.x = t, this.y = n, this.width = r, this.height = a;
	}
	return t.prototype.union = function(t) {
		var n = mathMin$10(t.x, this.x), r = mathMin$10(t.y, this.y);
		isFinite(this.x) && isFinite(this.width) ? this.width = mathMax$10(t.x + t.width, this.x + this.width) - n : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = mathMax$10(t.y + t.height, this.y + this.height) - r : this.height = t.height, this.x = n, this.y = r;
	}, t.prototype.applyTransform = function(n) {
		t.applyTransform(this, this, n);
	}, t.prototype.calculateTransform = function(t) {
		var n = this, r = t.width / n.width, a = t.height / n.height, o = create$2();
		return translate(o, o, [-n.x, -n.y]), scale$2(o, o, [r, a]), translate(o, o, [t.x, t.y]), o;
	}, t.prototype.intersect = function(n, r) {
		if (!n) return !1;
		n instanceof t || (n = t.create(n));
		var a = this, o = a.x, s = a.x + a.width, c = a.y, l = a.y + a.height, u = n.x, d = n.x + n.width, f = n.y, p = n.y + n.height, h = !(s < u || d < o || l < f || p < c);
		if (r) {
			var g = Infinity, _ = 0, v = Math.abs(s - u), y = Math.abs(d - o), b = Math.abs(l - f), x = Math.abs(p - c), S = Math.min(v, y), C = Math.min(b, x);
			s < u || d < o ? S > _ && (_ = S, v < y ? Point_default.set(maxTv$1, -v, 0) : Point_default.set(maxTv$1, y, 0)) : S < g && (g = S, v < y ? Point_default.set(minTv$1, v, 0) : Point_default.set(minTv$1, -y, 0)), l < f || p < c ? C > _ && (_ = C, b < x ? Point_default.set(maxTv$1, 0, -b) : Point_default.set(maxTv$1, 0, x)) : S < g && (g = S, b < x ? Point_default.set(minTv$1, 0, b) : Point_default.set(minTv$1, 0, -x));
		}
		return r && Point_default.copy(r, h ? minTv$1 : maxTv$1), h;
	}, t.prototype.contain = function(t, n) {
		var r = this;
		return t >= r.x && t <= r.x + r.width && n >= r.y && n <= r.y + r.height;
	}, t.prototype.clone = function() {
		return new t(this.x, this.y, this.width, this.height);
	}, t.prototype.copy = function(n) {
		t.copy(this, n);
	}, t.prototype.plain = function() {
		return {
			x: this.x,
			y: this.y,
			width: this.width,
			height: this.height
		};
	}, t.prototype.isFinite = function() {
		return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
	}, t.prototype.isZero = function() {
		return this.width === 0 || this.height === 0;
	}, t.create = function(n) {
		return new t(n.x, n.y, n.width, n.height);
	}, t.copy = function(t, n) {
		t.x = n.x, t.y = n.y, t.width = n.width, t.height = n.height;
	}, t.applyTransform = function(n, r, a) {
		if (!a) {
			n !== r && t.copy(n, r);
			return;
		}
		if (a[1] < 1e-5 && a[1] > -1e-5 && a[2] < 1e-5 && a[2] > -1e-5) {
			var o = a[0], s = a[3], c = a[4], l = a[5];
			n.x = r.x * o + c, n.y = r.y * s + l, n.width = r.width * o, n.height = r.height * s, n.width < 0 && (n.x += n.width, n.width = -n.width), n.height < 0 && (n.y += n.height, n.height = -n.height);
			return;
		}
		lt.x = lb.x = r.x, lt.y = rt.y = r.y, rb.x = rt.x = r.x + r.width, rb.y = lb.y = r.y + r.height, lt.transform(a), rt.transform(a), rb.transform(a), lb.transform(a), n.x = mathMin$10(lt.x, rb.x, lb.x, rt.x), n.y = mathMin$10(lt.y, rb.y, lb.y, rt.y);
		var u = mathMax$10(lt.x, rb.x, lb.x, rt.x), d = mathMax$10(lt.y, rb.y, lb.y, rt.y);
		n.width = u - n.x, n.height = d - n.y;
	}, t;
}(), SILENT = "silent";
function makeEventPacket(t, n, r) {
	return {
		type: t,
		event: r,
		target: n.target,
		topTarget: n.topTarget,
		cancelBubble: !1,
		offsetX: r.zrX,
		offsetY: r.zrY,
		gestureEvent: r.gestureEvent,
		pinchX: r.pinchX,
		pinchY: r.pinchY,
		pinchScale: r.pinchScale,
		wheelDelta: r.zrDelta,
		zrByTouch: r.zrByTouch,
		which: r.which,
		stop: stopEvent
	};
}
function stopEvent() {
	stop(this.event);
}
var EmptyProxy = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n.handler = null, n;
	}
	return n.prototype.dispose = function() {}, n.prototype.setCursor = function() {}, n;
}(Eventful_default), HoveredResult = function() {
	function t(t, n) {
		this.x = t, this.y = n;
	}
	return t;
}(), handlerNames = [
	"click",
	"dblclick",
	"mousewheel",
	"mouseout",
	"mouseup",
	"mousedown",
	"mousemove",
	"contextmenu"
], tmpRect$1 = new BoundingRect_default(0, 0, 0, 0), Handler = function(t) {
	__extends(n, t);
	function n(n, r, a, o, s) {
		var c = t.call(this) || this;
		return c._hovered = new HoveredResult(0, 0), c.storage = n, c.painter = r, c.painterRoot = o, c._pointerSize = s, a ||= new EmptyProxy(), c.proxy = null, c.setHandlerProxy(a), c._draggingMgr = new Draggable_default(c), c;
	}
	return n.prototype.setHandlerProxy = function(t) {
		this.proxy && this.proxy.dispose(), t && (each(handlerNames, function(n) {
			t.on && t.on(n, this[n], this);
		}, this), t.handler = this), this.proxy = t;
	}, n.prototype.mousemove = function(t) {
		var n = t.zrX, r = t.zrY, a = isOutsideBoundary(this, n, r), o = this._hovered, s = o.target;
		s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target);
		var c = this._hovered = a ? new HoveredResult(n, r) : this.findHover(n, r), l = c.target, u = this.proxy;
		u.setCursor && u.setCursor(l ? l.cursor : "default"), s && l !== s && this.dispatchToElement(o, "mouseout", t), this.dispatchToElement(c, "mousemove", t), l && l !== s && this.dispatchToElement(c, "mouseover", t);
	}, n.prototype.mouseout = function(t) {
		var n = t.zrEventControl;
		n !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", t), n !== "no_globalout" && this.trigger("globalout", {
			type: "globalout",
			event: t
		});
	}, n.prototype.resize = function() {
		this._hovered = new HoveredResult(0, 0);
	}, n.prototype.dispatch = function(t, n) {
		var r = this[t];
		r && r.call(this, n);
	}, n.prototype.dispose = function() {
		this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
	}, n.prototype.setCursorStyle = function(t) {
		var n = this.proxy;
		n.setCursor && n.setCursor(t);
	}, n.prototype.dispatchToElement = function(t, n, r) {
		t ||= {};
		var a = t.target;
		if (!(a && a.silent)) {
			for (var o = "on" + n, s = makeEventPacket(n, t, r); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(n, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble););
			s.cancelBubble || (this.trigger(n, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(t) {
				typeof t[o] == "function" && t[o].call(t, s), t.trigger && t.trigger(n, s);
			}));
		}
	}, n.prototype.findHover = function(t, n, r) {
		var a = this.storage.getDisplayList(), o = new HoveredResult(t, n);
		if (setHoverTarget(a, o, t, n, r), this._pointerSize && !o.target) {
			for (var s = [], c = this._pointerSize, l = c / 2, u = new BoundingRect_default(t - l, n - l, c, c), d = a.length - 1; d >= 0; d--) {
				var f = a[d];
				f !== r && !f.ignore && !f.ignoreCoarsePointer && (!f.parent || !f.parent.ignoreCoarsePointer) && (tmpRect$1.copy(f.getBoundingRect()), f.transform && tmpRect$1.applyTransform(f.transform), tmpRect$1.intersect(u) && s.push(f));
			}
			if (s.length) {
				for (var p = 4, h = Math.PI / 12, g = Math.PI * 2, _ = 0; _ < l; _ += p) for (var v = 0; v < g; v += h) if (setHoverTarget(s, o, t + _ * Math.cos(v), n + _ * Math.sin(v), r), o.target) return o;
			}
		}
		return o;
	}, n.prototype.processGesture = function(t, n) {
		this._gestureMgr ||= new GestureMgr();
		var r = this._gestureMgr;
		n === "start" && r.clear();
		var a = r.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom);
		if (n === "end" && r.clear(), a) {
			var o = a.type;
			t.gestureEvent = o;
			var s = new HoveredResult();
			s.target = a.target, this.dispatchToElement(s, o, a.event);
		}
	}, n;
}(Eventful_default);
each([
	"click",
	"mousedown",
	"mouseup",
	"mousewheel",
	"dblclick",
	"contextmenu"
], function(t) {
	Handler.prototype[t] = function(n) {
		var r = n.zrX, a = n.zrY, o = isOutsideBoundary(this, r, a), s, c;
		if ((t !== "mouseup" || !o) && (s = this.findHover(r, a), c = s.target), t === "mousedown") this._downEl = c, this._downPoint = [n.zrX, n.zrY], this._upEl = c;
		else if (t === "mouseup") this._upEl = c;
		else if (t === "click") {
			if (this._downEl !== this._upEl || !this._downPoint || dist$1(this._downPoint, [n.zrX, n.zrY]) > 4) return;
			this._downPoint = null;
		}
		this.dispatchToElement(s, t, n);
	};
});
function isHover(t, n, r) {
	if (t[t.rectHover ? "rectContain" : "contain"](n, r)) {
		for (var a = t, o = void 0, s = !1; a;) {
			if (a.ignoreClip && (s = !0), !s) {
				var c = a.getClipPath();
				if (c && !c.contain(n, r)) return !1;
			}
			a.silent && (o = !0), a = a.__hostTarget || a.parent;
		}
		return o ? SILENT : !0;
	}
	return !1;
}
function setHoverTarget(t, n, r, a, o) {
	for (var s = t.length - 1; s >= 0; s--) {
		var c = t[s], l = void 0;
		if (c !== o && !c.ignore && (l = isHover(c, r, a)) && (!n.topTarget && (n.topTarget = c), l !== SILENT)) {
			n.target = c;
			break;
		}
	}
}
function isOutsideBoundary(t, n, r) {
	var a = t.painter;
	return n < 0 || n > a.getWidth() || r < 0 || r > a.getHeight();
}
var Handler_default = Handler, DEFAULT_MIN_MERGE = 32, DEFAULT_MIN_GALLOPING = 7;
function minRunLength(t) {
	for (var n = 0; t >= DEFAULT_MIN_MERGE;) n |= t & 1, t >>= 1;
	return t + n;
}
function makeAscendingRun(t, n, r, a) {
	var o = n + 1;
	if (o === r) return 1;
	if (a(t[o++], t[n]) < 0) {
		for (; o < r && a(t[o], t[o - 1]) < 0;) o++;
		reverseRun(t, n, o);
	} else for (; o < r && a(t[o], t[o - 1]) >= 0;) o++;
	return o - n;
}
function reverseRun(t, n, r) {
	for (r--; n < r;) {
		var a = t[n];
		t[n++] = t[r], t[r--] = a;
	}
}
function binaryInsertionSort(t, n, r, a, o) {
	for (a === n && a++; a < r; a++) {
		for (var s = t[a], c = n, l = a, u; c < l;) u = c + l >>> 1, o(s, t[u]) < 0 ? l = u : c = u + 1;
		var d = a - c;
		switch (d) {
			case 3: t[c + 3] = t[c + 2];
			case 2: t[c + 2] = t[c + 1];
			case 1:
				t[c + 1] = t[c];
				break;
			default: for (; d > 0;) t[c + d] = t[c + d - 1], d--;
		}
		t[c] = s;
	}
}
function gallopLeft(t, n, r, a, o, s) {
	var c = 0, l = 0, u = 1;
	if (s(t, n[r + o]) > 0) {
		for (l = a - o; u < l && s(t, n[r + o + u]) > 0;) c = u, u = (u << 1) + 1, u <= 0 && (u = l);
		u > l && (u = l), c += o, u += o;
	} else {
		for (l = o + 1; u < l && s(t, n[r + o - u]) <= 0;) c = u, u = (u << 1) + 1, u <= 0 && (u = l);
		u > l && (u = l);
		var d = c;
		c = o - u, u = o - d;
	}
	for (c++; c < u;) {
		var f = c + (u - c >>> 1);
		s(t, n[r + f]) > 0 ? c = f + 1 : u = f;
	}
	return u;
}
function gallopRight(t, n, r, a, o, s) {
	var c = 0, l = 0, u = 1;
	if (s(t, n[r + o]) < 0) {
		for (l = o + 1; u < l && s(t, n[r + o - u]) < 0;) c = u, u = (u << 1) + 1, u <= 0 && (u = l);
		u > l && (u = l);
		var d = c;
		c = o - u, u = o - d;
	} else {
		for (l = a - o; u < l && s(t, n[r + o + u]) >= 0;) c = u, u = (u << 1) + 1, u <= 0 && (u = l);
		u > l && (u = l), c += o, u += o;
	}
	for (c++; c < u;) {
		var f = c + (u - c >>> 1);
		s(t, n[r + f]) < 0 ? u = f : c = f + 1;
	}
	return u;
}
function TimSort(t, n) {
	var r = DEFAULT_MIN_GALLOPING, a, o, s = 0, c = [];
	a = [], o = [];
	function l(t, n) {
		a[s] = t, o[s] = n, s += 1;
	}
	function u() {
		for (; s > 1;) {
			var t = s - 2;
			if (t >= 1 && o[t - 1] <= o[t] + o[t + 1] || t >= 2 && o[t - 2] <= o[t] + o[t - 1]) o[t - 1] < o[t + 1] && t--;
			else if (o[t] > o[t + 1]) break;
			f(t);
		}
	}
	function d() {
		for (; s > 1;) {
			var t = s - 2;
			t > 0 && o[t - 1] < o[t + 1] && t--, f(t);
		}
	}
	function f(r) {
		var c = a[r], l = o[r], u = a[r + 1], d = o[r + 1];
		o[r] = l + d, r === s - 3 && (a[r + 1] = a[r + 2], o[r + 1] = o[r + 2]), s--;
		var f = gallopRight(t[u], t, c, l, 0, n);
		c += f, l -= f, l !== 0 && (d = gallopLeft(t[c + l - 1], t, u, d, d - 1, n), d !== 0 && (l <= d ? p(c, l, u, d) : h(c, l, u, d)));
	}
	function p(a, o, s, l) {
		var u = 0;
		for (u = 0; u < o; u++) c[u] = t[a + u];
		var d = 0, f = s, p = a;
		if (t[p++] = t[f++], --l === 0) {
			for (u = 0; u < o; u++) t[p + u] = c[d + u];
			return;
		}
		if (o === 1) {
			for (u = 0; u < l; u++) t[p + u] = t[f + u];
			t[p + l] = c[d];
			return;
		}
		for (var h = r, g, _, v;;) {
			g = 0, _ = 0, v = !1;
			do
				if (n(t[f], c[d]) < 0) {
					if (t[p++] = t[f++], _++, g = 0, --l === 0) {
						v = !0;
						break;
					}
				} else if (t[p++] = c[d++], g++, _ = 0, --o === 1) {
					v = !0;
					break;
				}
			while ((g | _) < h);
			if (v) break;
			do {
				if (g = gallopRight(t[f], c, d, o, 0, n), g !== 0) {
					for (u = 0; u < g; u++) t[p + u] = c[d + u];
					if (p += g, d += g, o -= g, o <= 1) {
						v = !0;
						break;
					}
				}
				if (t[p++] = t[f++], --l === 0) {
					v = !0;
					break;
				}
				if (_ = gallopLeft(c[d], t, f, l, 0, n), _ !== 0) {
					for (u = 0; u < _; u++) t[p + u] = t[f + u];
					if (p += _, f += _, l -= _, l === 0) {
						v = !0;
						break;
					}
				}
				if (t[p++] = c[d++], --o === 1) {
					v = !0;
					break;
				}
				h--;
			} while (g >= DEFAULT_MIN_GALLOPING || _ >= DEFAULT_MIN_GALLOPING);
			if (v) break;
			h < 0 && (h = 0), h += 2;
		}
		if (r = h, r < 1 && (r = 1), o === 1) {
			for (u = 0; u < l; u++) t[p + u] = t[f + u];
			t[p + l] = c[d];
		} else if (o === 0) throw Error();
		else for (u = 0; u < o; u++) t[p + u] = c[d + u];
	}
	function h(a, o, s, l) {
		var u = 0;
		for (u = 0; u < l; u++) c[u] = t[s + u];
		var d = a + o - 1, f = l - 1, p = s + l - 1, h = 0, g = 0;
		if (t[p--] = t[d--], --o === 0) {
			for (h = p - (l - 1), u = 0; u < l; u++) t[h + u] = c[u];
			return;
		}
		if (l === 1) {
			for (p -= o, d -= o, g = p + 1, h = d + 1, u = o - 1; u >= 0; u--) t[g + u] = t[h + u];
			t[p] = c[f];
			return;
		}
		for (var _ = r;;) {
			var v = 0, y = 0, b = !1;
			do
				if (n(c[f], t[d]) < 0) {
					if (t[p--] = t[d--], v++, y = 0, --o === 0) {
						b = !0;
						break;
					}
				} else if (t[p--] = c[f--], y++, v = 0, --l === 1) {
					b = !0;
					break;
				}
			while ((v | y) < _);
			if (b) break;
			do {
				if (v = o - gallopRight(c[f], t, a, o, o - 1, n), v !== 0) {
					for (p -= v, d -= v, o -= v, g = p + 1, h = d + 1, u = v - 1; u >= 0; u--) t[g + u] = t[h + u];
					if (o === 0) {
						b = !0;
						break;
					}
				}
				if (t[p--] = c[f--], --l === 1) {
					b = !0;
					break;
				}
				if (y = l - gallopLeft(t[d], c, 0, l, l - 1, n), y !== 0) {
					for (p -= y, f -= y, l -= y, g = p + 1, h = f + 1, u = 0; u < y; u++) t[g + u] = c[h + u];
					if (l <= 1) {
						b = !0;
						break;
					}
				}
				if (t[p--] = t[d--], --o === 0) {
					b = !0;
					break;
				}
				_--;
			} while (v >= DEFAULT_MIN_GALLOPING || y >= DEFAULT_MIN_GALLOPING);
			if (b) break;
			_ < 0 && (_ = 0), _ += 2;
		}
		if (r = _, r < 1 && (r = 1), l === 1) {
			for (p -= o, d -= o, g = p + 1, h = d + 1, u = o - 1; u >= 0; u--) t[g + u] = t[h + u];
			t[p] = c[f];
		} else if (l === 0) throw Error();
		else for (h = p - (l - 1), u = 0; u < l; u++) t[h + u] = c[u];
	}
	return {
		mergeRuns: u,
		forceMergeRuns: d,
		pushRun: l
	};
}
function sort$2(t, n, r, a) {
	r ||= 0, a ||= t.length;
	var o = a - r;
	if (!(o < 2)) {
		var s = 0;
		if (o < DEFAULT_MIN_MERGE) {
			s = makeAscendingRun(t, r, a, n), binaryInsertionSort(t, r, a, r + s, n);
			return;
		}
		var c = TimSort(t, n), l = minRunLength(o);
		do {
			if (s = makeAscendingRun(t, r, a, n), s < l) {
				var u = o;
				u > l && (u = l), binaryInsertionSort(t, r, r + u, r + s, n), s = u;
			}
			c.pushRun(r, s), c.mergeRuns(), o -= s, r += s;
		} while (o !== 0);
		c.forceMergeRuns();
	}
}
var invalidZErrorLogged = !1;
function logInvalidZError() {
	invalidZErrorLogged || (invalidZErrorLogged = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function shapeCompareFunc(t, n) {
	return t.zlevel === n.zlevel ? t.z === n.z ? t.z2 - n.z2 : t.z - n.z : t.zlevel - n.zlevel;
}
var Storage_default = function() {
	function t() {
		this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = shapeCompareFunc;
	}
	return t.prototype.traverse = function(t, n) {
		for (var r = 0; r < this._roots.length; r++) this._roots[r].traverse(t, n);
	}, t.prototype.getDisplayList = function(t, n) {
		n ||= !1;
		var r = this._displayList;
		return (t || !r.length) && this.updateDisplayList(n), r;
	}, t.prototype.updateDisplayList = function(t) {
		this._displayListLen = 0;
		for (var n = this._roots, r = this._displayList, a = 0, o = n.length; a < o; a++) this._updateAndAddDisplayable(n[a], null, t);
		r.length = this._displayListLen, sort$2(r, shapeCompareFunc);
	}, t.prototype._updateAndAddDisplayable = function(t, n, r) {
		if (!(t.ignore && !r)) {
			t.beforeUpdate(), t.update(), t.afterUpdate();
			var a = t.getClipPath();
			if (t.ignoreClip) n = null;
			else if (a) {
				n = n ? n.slice() : [];
				for (var o = a, s = t; o;) o.parent = s, o.updateTransform(), n.push(o), s = o, o = o.getClipPath();
			}
			if (t.childrenRef) {
				for (var c = t.childrenRef(), l = 0; l < c.length; l++) {
					var u = c[l];
					t.__dirty && (u.__dirty |= 1), this._updateAndAddDisplayable(u, n, r);
				}
				t.__dirty = 0;
			} else {
				var d = t;
				n && n.length ? d.__clipPaths = n : d.__clipPaths && d.__clipPaths.length > 0 && (d.__clipPaths = []), isNaN(d.z) && (logInvalidZError(), d.z = 0), isNaN(d.z2) && (logInvalidZError(), d.z2 = 0), isNaN(d.zlevel) && (logInvalidZError(), d.zlevel = 0), this._displayList[this._displayListLen++] = d;
			}
			var f = t.getDecalElement && t.getDecalElement();
			f && this._updateAndAddDisplayable(f, n, r);
			var p = t.getTextGuideLine();
			p && this._updateAndAddDisplayable(p, n, r);
			var h = t.getTextContent();
			h && this._updateAndAddDisplayable(h, n, r);
		}
	}, t.prototype.addRoot = function(t) {
		t.__zr && t.__zr.storage === this || this._roots.push(t);
	}, t.prototype.delRoot = function(t) {
		if (t instanceof Array) {
			for (var n = 0, r = t.length; n < r; n++) this.delRoot(t[n]);
			return;
		}
		var a = indexOf(this._roots, t);
		a >= 0 && this._roots.splice(a, 1);
	}, t.prototype.delAllRoots = function() {
		this._roots = [], this._displayList = [], this._displayListLen = 0;
	}, t.prototype.getRoots = function() {
		return this._roots;
	}, t.prototype.dispose = function() {
		this._displayList = null, this._roots = null;
	}, t;
}(), requestAnimationFrame_default = env_default.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(t) {
	return setTimeout(t, 16);
}, easingFuncs = {
	linear: function(t) {
		return t;
	},
	quadraticIn: function(t) {
		return t * t;
	},
	quadraticOut: function(t) {
		return t * (2 - t);
	},
	quadraticInOut: function(t) {
		return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1);
	},
	cubicIn: function(t) {
		return t * t * t;
	},
	cubicOut: function(t) {
		return --t * t * t + 1;
	},
	cubicInOut: function(t) {
		return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2);
	},
	quarticIn: function(t) {
		return t * t * t * t;
	},
	quarticOut: function(t) {
		return 1 - --t * t * t * t;
	},
	quarticInOut: function(t) {
		return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2);
	},
	quinticIn: function(t) {
		return t * t * t * t * t;
	},
	quinticOut: function(t) {
		return --t * t * t * t * t + 1;
	},
	quinticInOut: function(t) {
		return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2);
	},
	sinusoidalIn: function(t) {
		return 1 - Math.cos(t * Math.PI / 2);
	},
	sinusoidalOut: function(t) {
		return Math.sin(t * Math.PI / 2);
	},
	sinusoidalInOut: function(t) {
		return .5 * (1 - Math.cos(Math.PI * t));
	},
	exponentialIn: function(t) {
		return t === 0 ? 0 : 1024 ** (t - 1);
	},
	exponentialOut: function(t) {
		return t === 1 ? 1 : 1 - 2 ** (-10 * t);
	},
	exponentialInOut: function(t) {
		return t === 0 ? 0 : t === 1 ? 1 : (t *= 2) < 1 ? .5 * 1024 ** (t - 1) : .5 * (-(2 ** (-10 * (t - 1))) + 2);
	},
	circularIn: function(t) {
		return 1 - Math.sqrt(1 - t * t);
	},
	circularOut: function(t) {
		return Math.sqrt(1 - --t * t);
	},
	circularInOut: function(t) {
		return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
	},
	elasticIn: function(t) {
		var n, r = .1, a = .4;
		return t === 0 ? 0 : t === 1 ? 1 : (!r || r < 1 ? (r = 1, n = a / 4) : n = a * Math.asin(1 / r) / (2 * Math.PI), -(r * 2 ** (10 * --t) * Math.sin((t - n) * (2 * Math.PI) / a)));
	},
	elasticOut: function(t) {
		var n, r = .1, a = .4;
		return t === 0 ? 0 : t === 1 ? 1 : (!r || r < 1 ? (r = 1, n = a / 4) : n = a * Math.asin(1 / r) / (2 * Math.PI), r * 2 ** (-10 * t) * Math.sin((t - n) * (2 * Math.PI) / a) + 1);
	},
	elasticInOut: function(t) {
		var n, r = .1, a = .4;
		return t === 0 ? 0 : t === 1 ? 1 : (!r || r < 1 ? (r = 1, n = a / 4) : n = a * Math.asin(1 / r) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * (r * 2 ** (10 * --t) * Math.sin((t - n) * (2 * Math.PI) / a)) : r * 2 ** (-10 * --t) * Math.sin((t - n) * (2 * Math.PI) / a) * .5 + 1);
	},
	backIn: function(t) {
		var n = 1.70158;
		return t * t * ((n + 1) * t - n);
	},
	backOut: function(t) {
		var n = 1.70158;
		return --t * t * ((n + 1) * t + n) + 1;
	},
	backInOut: function(t) {
		var n = 1.70158 * 1.525;
		return (t *= 2) < 1 ? .5 * (t * t * ((n + 1) * t - n)) : .5 * ((t -= 2) * t * ((n + 1) * t + n) + 2);
	},
	bounceIn: function(t) {
		return 1 - easingFuncs.bounceOut(1 - t);
	},
	bounceOut: function(t) {
		return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
	},
	bounceInOut: function(t) {
		return t < .5 ? easingFuncs.bounceIn(t * 2) * .5 : easingFuncs.bounceOut(t * 2 - 1) * .5 + .5;
	}
}, easing_default = easingFuncs, mathPow$2 = Math.pow, mathSqrt$3 = Math.sqrt, EPSILON$4 = 1e-8, EPSILON_NUMERIC = 1e-4, THREE_SQRT = mathSqrt$3(3), ONE_THIRD = 1 / 3, _v0 = create$1(), _v1 = create$1(), _v2 = create$1();
function isAroundZero$1(t) {
	return t > -EPSILON$4 && t < EPSILON$4;
}
function isNotAroundZero$1(t) {
	return t > EPSILON$4 || t < -EPSILON$4;
}
function cubicAt(t, n, r, a, o) {
	var s = 1 - o;
	return s * s * (s * t + 3 * o * n) + o * o * (o * a + 3 * s * r);
}
function cubicDerivativeAt(t, n, r, a, o) {
	var s = 1 - o;
	return 3 * (((n - t) * s + 2 * (r - n) * o) * s + (a - r) * o * o);
}
function cubicRootAt(t, n, r, a, o, s) {
	var c = a + 3 * (n - r) - t, l = 3 * (r - n * 2 + t), u = 3 * (n - t), d = t - o, f = l * l - 3 * c * u, p = l * u - 9 * c * d, h = u * u - 3 * l * d, g = 0;
	if (isAroundZero$1(f) && isAroundZero$1(p)) if (isAroundZero$1(l)) s[0] = 0;
	else {
		var _ = -u / l;
		_ >= 0 && _ <= 1 && (s[g++] = _);
	}
	else {
		var v = p * p - 4 * f * h;
		if (isAroundZero$1(v)) {
			var y = p / f, _ = -l / c + y, b = -y / 2;
			_ >= 0 && _ <= 1 && (s[g++] = _), b >= 0 && b <= 1 && (s[g++] = b);
		} else if (v > 0) {
			var x = mathSqrt$3(v), S = f * l + 1.5 * c * (-p + x), C = f * l + 1.5 * c * (-p - x);
			S = S < 0 ? -mathPow$2(-S, ONE_THIRD) : mathPow$2(S, ONE_THIRD), C = C < 0 ? -mathPow$2(-C, ONE_THIRD) : mathPow$2(C, ONE_THIRD);
			var _ = (-l - (S + C)) / (3 * c);
			_ >= 0 && _ <= 1 && (s[g++] = _);
		} else {
			var w = (2 * f * l - 3 * c * p) / (2 * mathSqrt$3(f * f * f)), T = Math.acos(w) / 3, E = mathSqrt$3(f), D = Math.cos(T), _ = (-l - 2 * E * D) / (3 * c), b = (-l + E * (D + THREE_SQRT * Math.sin(T))) / (3 * c), O = (-l + E * (D - THREE_SQRT * Math.sin(T))) / (3 * c);
			_ >= 0 && _ <= 1 && (s[g++] = _), b >= 0 && b <= 1 && (s[g++] = b), O >= 0 && O <= 1 && (s[g++] = O);
		}
	}
	return g;
}
function cubicExtrema(t, n, r, a, o) {
	var s = 6 * r - 12 * n + 6 * t, c = 9 * n + 3 * a - 3 * t - 9 * r, l = 3 * n - 3 * t, u = 0;
	if (isAroundZero$1(c)) {
		if (isNotAroundZero$1(s)) {
			var d = -l / s;
			d >= 0 && d <= 1 && (o[u++] = d);
		}
	} else {
		var f = s * s - 4 * c * l;
		if (isAroundZero$1(f)) o[0] = -s / (2 * c);
		else if (f > 0) {
			var p = mathSqrt$3(f), d = (-s + p) / (2 * c), h = (-s - p) / (2 * c);
			d >= 0 && d <= 1 && (o[u++] = d), h >= 0 && h <= 1 && (o[u++] = h);
		}
	}
	return u;
}
function cubicSubdivide(t, n, r, a, o, s) {
	var c = (n - t) * o + t, l = (r - n) * o + n, u = (a - r) * o + r, d = (l - c) * o + c, f = (u - l) * o + l, p = (f - d) * o + d;
	s[0] = t, s[1] = c, s[2] = d, s[3] = p, s[4] = p, s[5] = f, s[6] = u, s[7] = a;
}
function cubicProjectPoint(t, n, r, a, o, s, c, l, u, d, f) {
	var p, h = .005, g = Infinity, _, v, y, b;
	_v0[0] = u, _v0[1] = d;
	for (var x = 0; x < 1; x += .05) _v1[0] = cubicAt(t, r, o, c, x), _v1[1] = cubicAt(n, a, s, l, x), y = distSquare(_v0, _v1), y < g && (p = x, g = y);
	g = Infinity;
	for (var S = 0; S < 32 && !(h < EPSILON_NUMERIC); S++) _ = p - h, v = p + h, _v1[0] = cubicAt(t, r, o, c, _), _v1[1] = cubicAt(n, a, s, l, _), y = distSquare(_v1, _v0), _ >= 0 && y < g ? (p = _, g = y) : (_v2[0] = cubicAt(t, r, o, c, v), _v2[1] = cubicAt(n, a, s, l, v), b = distSquare(_v2, _v0), v <= 1 && b < g ? (p = v, g = b) : h *= .5);
	return f && (f[0] = cubicAt(t, r, o, c, p), f[1] = cubicAt(n, a, s, l, p)), mathSqrt$3(g);
}
function cubicLength(t, n, r, a, o, s, c, l, u) {
	for (var d = t, f = n, p = 0, h = 1 / u, g = 1; g <= u; g++) {
		var _ = g * h, v = cubicAt(t, r, o, c, _), y = cubicAt(n, a, s, l, _), b = v - d, x = y - f;
		p += Math.sqrt(b * b + x * x), d = v, f = y;
	}
	return p;
}
function quadraticAt$1(t, n, r, a) {
	var o = 1 - a;
	return o * (o * t + 2 * a * n) + a * a * r;
}
function quadraticDerivativeAt(t, n, r, a) {
	return 2 * ((1 - a) * (n - t) + a * (r - n));
}
function quadraticRootAt(t, n, r, a, o) {
	var s = t - 2 * n + r, c = 2 * (n - t), l = t - a, u = 0;
	if (isAroundZero$1(s)) {
		if (isNotAroundZero$1(c)) {
			var d = -l / c;
			d >= 0 && d <= 1 && (o[u++] = d);
		}
	} else {
		var f = c * c - 4 * s * l;
		if (isAroundZero$1(f)) {
			var d = -c / (2 * s);
			d >= 0 && d <= 1 && (o[u++] = d);
		} else if (f > 0) {
			var p = mathSqrt$3(f), d = (-c + p) / (2 * s), h = (-c - p) / (2 * s);
			d >= 0 && d <= 1 && (o[u++] = d), h >= 0 && h <= 1 && (o[u++] = h);
		}
	}
	return u;
}
function quadraticExtremum(t, n, r) {
	var a = t + r - 2 * n;
	return a === 0 ? .5 : (t - n) / a;
}
function quadraticSubdivide(t, n, r, a, o) {
	var s = (n - t) * a + t, c = (r - n) * a + n, l = (c - s) * a + s;
	o[0] = t, o[1] = s, o[2] = l, o[3] = l, o[4] = c, o[5] = r;
}
function quadraticProjectPoint(t, n, r, a, o, s, c, l, u) {
	var d, f = .005, p = Infinity;
	_v0[0] = c, _v0[1] = l;
	for (var h = 0; h < 1; h += .05) {
		_v1[0] = quadraticAt$1(t, r, o, h), _v1[1] = quadraticAt$1(n, a, s, h);
		var g = distSquare(_v0, _v1);
		g < p && (d = h, p = g);
	}
	p = Infinity;
	for (var _ = 0; _ < 32 && !(f < EPSILON_NUMERIC); _++) {
		var v = d - f, y = d + f;
		_v1[0] = quadraticAt$1(t, r, o, v), _v1[1] = quadraticAt$1(n, a, s, v);
		var g = distSquare(_v1, _v0);
		if (v >= 0 && g < p) d = v, p = g;
		else {
			_v2[0] = quadraticAt$1(t, r, o, y), _v2[1] = quadraticAt$1(n, a, s, y);
			var b = distSquare(_v2, _v0);
			y <= 1 && b < p ? (d = y, p = b) : f *= .5;
		}
	}
	return u && (u[0] = quadraticAt$1(t, r, o, d), u[1] = quadraticAt$1(n, a, s, d)), mathSqrt$3(p);
}
function quadraticLength(t, n, r, a, o, s, c) {
	for (var l = t, u = n, d = 0, f = 1 / c, p = 1; p <= c; p++) {
		var h = p * f, g = quadraticAt$1(t, r, o, h), _ = quadraticAt$1(n, a, s, h), v = g - l, y = _ - u;
		d += Math.sqrt(v * v + y * y), l = g, u = _;
	}
	return d;
}
var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
function createCubicEasingFunc(t) {
	var n = t && regexp.exec(t);
	if (n) {
		var r = n[1].split(","), a = +trim(r[0]), o = +trim(r[1]), s = +trim(r[2]), c = +trim(r[3]);
		if (isNaN(a + o + s + c)) return;
		var l = [];
		return function(t) {
			return t <= 0 ? 0 : t >= 1 ? 1 : cubicRootAt(0, a, s, 1, t, l) && cubicAt(0, o, c, 1, l[0]);
		};
	}
}
var Clip_default = function() {
	function t(t) {
		this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || !1, this.onframe = t.onframe || noop, this.ondestroy = t.ondestroy || noop, this.onrestart = t.onrestart || noop, t.easing && this.setEasing(t.easing);
	}
	return t.prototype.step = function(t, n) {
		if (this._inited ||= (this._startTime = t + this._delay, !0), this._paused) {
			this._pausedTime += n;
			return;
		}
		var r = this._life, a = t - this._startTime - this._pausedTime, o = a / r;
		o < 0 && (o = 0), o = Math.min(o, 1);
		var s = this.easingFunc, c = s ? s(o) : o;
		if (this.onframe(c), o === 1) if (this.loop) this._startTime = t - a % r, this._pausedTime = 0, this.onrestart();
		else return !0;
		return !1;
	}, t.prototype.pause = function() {
		this._paused = !0;
	}, t.prototype.resume = function() {
		this._paused = !1;
	}, t.prototype.setEasing = function(t) {
		this.easing = t, this.easingFunc = isFunction(t) ? t : easing_default[t] || createCubicEasingFunc(t);
	}, t;
}(), Entry = function() {
	function t(t) {
		this.value = t;
	}
	return t;
}(), LinkedList = function() {
	function t() {
		this._len = 0;
	}
	return t.prototype.insert = function(t) {
		var n = new Entry(t);
		return this.insertEntry(n), n;
	}, t.prototype.insertEntry = function(t) {
		this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
	}, t.prototype.remove = function(t) {
		var n = t.prev, r = t.next;
		n ? n.next = r : this.head = r, r ? r.prev = n : this.tail = n, t.next = t.prev = null, this._len--;
	}, t.prototype.len = function() {
		return this._len;
	}, t.prototype.clear = function() {
		this.head = this.tail = null, this._len = 0;
	}, t;
}(), LRU_default = function() {
	function t(t) {
		this._list = new LinkedList(), this._maxSize = 10, this._map = {}, this._maxSize = t;
	}
	return t.prototype.put = function(t, n) {
		var r = this._list, a = this._map, o = null;
		if (a[t] == null) {
			var s = r.len(), c = this._lastRemovedEntry;
			if (s >= this._maxSize && s > 0) {
				var l = r.head;
				r.remove(l), delete a[l.key], o = l.value, this._lastRemovedEntry = l;
			}
			c ? c.value = n : c = new Entry(n), c.key = t, r.insertEntry(c), a[t] = c;
		}
		return o;
	}, t.prototype.get = function(t) {
		var n = this._map[t], r = this._list;
		if (n != null) return n !== r.tail && (r.remove(n), r.insertEntry(n)), n.value;
	}, t.prototype.clear = function() {
		this._list.clear(), this._map = {};
	}, t.prototype.len = function() {
		return this._list.len();
	}, t;
}(), color_exports = /* @__PURE__ */ __export({
	fastLerp: () => fastLerp,
	fastMapToColor: () => fastMapToColor,
	lerp: () => lerp$1,
	lift: () => lift,
	liftColor: () => liftColor,
	lum: () => lum,
	mapToColor: () => mapToColor,
	modifyAlpha: () => modifyAlpha,
	modifyHSL: () => modifyHSL,
	parse: () => parse,
	random: () => random,
	stringify: () => stringify,
	toHex: () => toHex
}), kCSSColorTable = {
	transparent: [
		0,
		0,
		0,
		0
	],
	aliceblue: [
		240,
		248,
		255,
		1
	],
	antiquewhite: [
		250,
		235,
		215,
		1
	],
	aqua: [
		0,
		255,
		255,
		1
	],
	aquamarine: [
		127,
		255,
		212,
		1
	],
	azure: [
		240,
		255,
		255,
		1
	],
	beige: [
		245,
		245,
		220,
		1
	],
	bisque: [
		255,
		228,
		196,
		1
	],
	black: [
		0,
		0,
		0,
		1
	],
	blanchedalmond: [
		255,
		235,
		205,
		1
	],
	blue: [
		0,
		0,
		255,
		1
	],
	blueviolet: [
		138,
		43,
		226,
		1
	],
	brown: [
		165,
		42,
		42,
		1
	],
	burlywood: [
		222,
		184,
		135,
		1
	],
	cadetblue: [
		95,
		158,
		160,
		1
	],
	chartreuse: [
		127,
		255,
		0,
		1
	],
	chocolate: [
		210,
		105,
		30,
		1
	],
	coral: [
		255,
		127,
		80,
		1
	],
	cornflowerblue: [
		100,
		149,
		237,
		1
	],
	cornsilk: [
		255,
		248,
		220,
		1
	],
	crimson: [
		220,
		20,
		60,
		1
	],
	cyan: [
		0,
		255,
		255,
		1
	],
	darkblue: [
		0,
		0,
		139,
		1
	],
	darkcyan: [
		0,
		139,
		139,
		1
	],
	darkgoldenrod: [
		184,
		134,
		11,
		1
	],
	darkgray: [
		169,
		169,
		169,
		1
	],
	darkgreen: [
		0,
		100,
		0,
		1
	],
	darkgrey: [
		169,
		169,
		169,
		1
	],
	darkkhaki: [
		189,
		183,
		107,
		1
	],
	darkmagenta: [
		139,
		0,
		139,
		1
	],
	darkolivegreen: [
		85,
		107,
		47,
		1
	],
	darkorange: [
		255,
		140,
		0,
		1
	],
	darkorchid: [
		153,
		50,
		204,
		1
	],
	darkred: [
		139,
		0,
		0,
		1
	],
	darksalmon: [
		233,
		150,
		122,
		1
	],
	darkseagreen: [
		143,
		188,
		143,
		1
	],
	darkslateblue: [
		72,
		61,
		139,
		1
	],
	darkslategray: [
		47,
		79,
		79,
		1
	],
	darkslategrey: [
		47,
		79,
		79,
		1
	],
	darkturquoise: [
		0,
		206,
		209,
		1
	],
	darkviolet: [
		148,
		0,
		211,
		1
	],
	deeppink: [
		255,
		20,
		147,
		1
	],
	deepskyblue: [
		0,
		191,
		255,
		1
	],
	dimgray: [
		105,
		105,
		105,
		1
	],
	dimgrey: [
		105,
		105,
		105,
		1
	],
	dodgerblue: [
		30,
		144,
		255,
		1
	],
	firebrick: [
		178,
		34,
		34,
		1
	],
	floralwhite: [
		255,
		250,
		240,
		1
	],
	forestgreen: [
		34,
		139,
		34,
		1
	],
	fuchsia: [
		255,
		0,
		255,
		1
	],
	gainsboro: [
		220,
		220,
		220,
		1
	],
	ghostwhite: [
		248,
		248,
		255,
		1
	],
	gold: [
		255,
		215,
		0,
		1
	],
	goldenrod: [
		218,
		165,
		32,
		1
	],
	gray: [
		128,
		128,
		128,
		1
	],
	green: [
		0,
		128,
		0,
		1
	],
	greenyellow: [
		173,
		255,
		47,
		1
	],
	grey: [
		128,
		128,
		128,
		1
	],
	honeydew: [
		240,
		255,
		240,
		1
	],
	hotpink: [
		255,
		105,
		180,
		1
	],
	indianred: [
		205,
		92,
		92,
		1
	],
	indigo: [
		75,
		0,
		130,
		1
	],
	ivory: [
		255,
		255,
		240,
		1
	],
	khaki: [
		240,
		230,
		140,
		1
	],
	lavender: [
		230,
		230,
		250,
		1
	],
	lavenderblush: [
		255,
		240,
		245,
		1
	],
	lawngreen: [
		124,
		252,
		0,
		1
	],
	lemonchiffon: [
		255,
		250,
		205,
		1
	],
	lightblue: [
		173,
		216,
		230,
		1
	],
	lightcoral: [
		240,
		128,
		128,
		1
	],
	lightcyan: [
		224,
		255,
		255,
		1
	],
	lightgoldenrodyellow: [
		250,
		250,
		210,
		1
	],
	lightgray: [
		211,
		211,
		211,
		1
	],
	lightgreen: [
		144,
		238,
		144,
		1
	],
	lightgrey: [
		211,
		211,
		211,
		1
	],
	lightpink: [
		255,
		182,
		193,
		1
	],
	lightsalmon: [
		255,
		160,
		122,
		1
	],
	lightseagreen: [
		32,
		178,
		170,
		1
	],
	lightskyblue: [
		135,
		206,
		250,
		1
	],
	lightslategray: [
		119,
		136,
		153,
		1
	],
	lightslategrey: [
		119,
		136,
		153,
		1
	],
	lightsteelblue: [
		176,
		196,
		222,
		1
	],
	lightyellow: [
		255,
		255,
		224,
		1
	],
	lime: [
		0,
		255,
		0,
		1
	],
	limegreen: [
		50,
		205,
		50,
		1
	],
	linen: [
		250,
		240,
		230,
		1
	],
	magenta: [
		255,
		0,
		255,
		1
	],
	maroon: [
		128,
		0,
		0,
		1
	],
	mediumaquamarine: [
		102,
		205,
		170,
		1
	],
	mediumblue: [
		0,
		0,
		205,
		1
	],
	mediumorchid: [
		186,
		85,
		211,
		1
	],
	mediumpurple: [
		147,
		112,
		219,
		1
	],
	mediumseagreen: [
		60,
		179,
		113,
		1
	],
	mediumslateblue: [
		123,
		104,
		238,
		1
	],
	mediumspringgreen: [
		0,
		250,
		154,
		1
	],
	mediumturquoise: [
		72,
		209,
		204,
		1
	],
	mediumvioletred: [
		199,
		21,
		133,
		1
	],
	midnightblue: [
		25,
		25,
		112,
		1
	],
	mintcream: [
		245,
		255,
		250,
		1
	],
	mistyrose: [
		255,
		228,
		225,
		1
	],
	moccasin: [
		255,
		228,
		181,
		1
	],
	navajowhite: [
		255,
		222,
		173,
		1
	],
	navy: [
		0,
		0,
		128,
		1
	],
	oldlace: [
		253,
		245,
		230,
		1
	],
	olive: [
		128,
		128,
		0,
		1
	],
	olivedrab: [
		107,
		142,
		35,
		1
	],
	orange: [
		255,
		165,
		0,
		1
	],
	orangered: [
		255,
		69,
		0,
		1
	],
	orchid: [
		218,
		112,
		214,
		1
	],
	palegoldenrod: [
		238,
		232,
		170,
		1
	],
	palegreen: [
		152,
		251,
		152,
		1
	],
	paleturquoise: [
		175,
		238,
		238,
		1
	],
	palevioletred: [
		219,
		112,
		147,
		1
	],
	papayawhip: [
		255,
		239,
		213,
		1
	],
	peachpuff: [
		255,
		218,
		185,
		1
	],
	peru: [
		205,
		133,
		63,
		1
	],
	pink: [
		255,
		192,
		203,
		1
	],
	plum: [
		221,
		160,
		221,
		1
	],
	powderblue: [
		176,
		224,
		230,
		1
	],
	purple: [
		128,
		0,
		128,
		1
	],
	red: [
		255,
		0,
		0,
		1
	],
	rosybrown: [
		188,
		143,
		143,
		1
	],
	royalblue: [
		65,
		105,
		225,
		1
	],
	saddlebrown: [
		139,
		69,
		19,
		1
	],
	salmon: [
		250,
		128,
		114,
		1
	],
	sandybrown: [
		244,
		164,
		96,
		1
	],
	seagreen: [
		46,
		139,
		87,
		1
	],
	seashell: [
		255,
		245,
		238,
		1
	],
	sienna: [
		160,
		82,
		45,
		1
	],
	silver: [
		192,
		192,
		192,
		1
	],
	skyblue: [
		135,
		206,
		235,
		1
	],
	slateblue: [
		106,
		90,
		205,
		1
	],
	slategray: [
		112,
		128,
		144,
		1
	],
	slategrey: [
		112,
		128,
		144,
		1
	],
	snow: [
		255,
		250,
		250,
		1
	],
	springgreen: [
		0,
		255,
		127,
		1
	],
	steelblue: [
		70,
		130,
		180,
		1
	],
	tan: [
		210,
		180,
		140,
		1
	],
	teal: [
		0,
		128,
		128,
		1
	],
	thistle: [
		216,
		191,
		216,
		1
	],
	tomato: [
		255,
		99,
		71,
		1
	],
	turquoise: [
		64,
		224,
		208,
		1
	],
	violet: [
		238,
		130,
		238,
		1
	],
	wheat: [
		245,
		222,
		179,
		1
	],
	white: [
		255,
		255,
		255,
		1
	],
	whitesmoke: [
		245,
		245,
		245,
		1
	],
	yellow: [
		255,
		255,
		0,
		1
	],
	yellowgreen: [
		154,
		205,
		50,
		1
	]
};
function clampCssByte(t) {
	return t = Math.round(t), t < 0 ? 0 : t > 255 ? 255 : t;
}
function clampCssAngle(t) {
	return t = Math.round(t), t < 0 ? 0 : t > 360 ? 360 : t;
}
function clampCssFloat(t) {
	return t < 0 ? 0 : t > 1 ? 1 : t;
}
function parseCssInt(t) {
	var n = t;
	return n.length && n.charAt(n.length - 1) === "%" ? clampCssByte(parseFloat(n) / 100 * 255) : clampCssByte(parseInt(n, 10));
}
function parseCssFloat(t) {
	var n = t;
	return n.length && n.charAt(n.length - 1) === "%" ? clampCssFloat(parseFloat(n) / 100) : clampCssFloat(parseFloat(n));
}
function cssHueToRgb(t, n, r) {
	return r < 0 ? r += 1 : r > 1 && --r, r * 6 < 1 ? t + (n - t) * r * 6 : r * 2 < 1 ? n : r * 3 < 2 ? t + (n - t) * (2 / 3 - r) * 6 : t;
}
function lerpNumber(t, n, r) {
	return t + (n - t) * r;
}
function setRgba(t, n, r, a, o) {
	return t[0] = n, t[1] = r, t[2] = a, t[3] = o, t;
}
function copyRgba(t, n) {
	return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t;
}
var colorCache = new LRU_default(20), lastRemovedArr = null;
function putToCache(t, n) {
	lastRemovedArr && copyRgba(lastRemovedArr, n), lastRemovedArr = colorCache.put(t, lastRemovedArr || n.slice());
}
function parse(t, n) {
	if (t) {
		n ||= [];
		var r = colorCache.get(t);
		if (r) return copyRgba(n, r);
		t += "";
		var a = t.replace(/ /g, "").toLowerCase();
		if (a in kCSSColorTable) return copyRgba(n, kCSSColorTable[a]), putToCache(t, n), n;
		var o = a.length;
		if (a.charAt(0) === "#") {
			if (o === 4 || o === 5) {
				var s = parseInt(a.slice(1, 4), 16);
				if (!(s >= 0 && s <= 4095)) {
					setRgba(n, 0, 0, 0, 1);
					return;
				}
				return setRgba(n, (s & 3840) >> 4 | (s & 3840) >> 8, s & 240 | (s & 240) >> 4, s & 15 | (s & 15) << 4, o === 5 ? parseInt(a.slice(4), 16) / 15 : 1), putToCache(t, n), n;
			} else if (o === 7 || o === 9) {
				var s = parseInt(a.slice(1, 7), 16);
				if (!(s >= 0 && s <= 16777215)) {
					setRgba(n, 0, 0, 0, 1);
					return;
				}
				return setRgba(n, (s & 16711680) >> 16, (s & 65280) >> 8, s & 255, o === 9 ? parseInt(a.slice(7), 16) / 255 : 1), putToCache(t, n), n;
			}
			return;
		}
		var c = a.indexOf("("), l = a.indexOf(")");
		if (c !== -1 && l + 1 === o) {
			var u = a.substr(0, c), d = a.substr(c + 1, l - (c + 1)).split(","), f = 1;
			switch (u) {
				case "rgba":
					if (d.length !== 4) return d.length === 3 ? setRgba(n, +d[0], +d[1], +d[2], 1) : setRgba(n, 0, 0, 0, 1);
					f = parseCssFloat(d.pop());
				case "rgb":
					if (d.length >= 3) return setRgba(n, parseCssInt(d[0]), parseCssInt(d[1]), parseCssInt(d[2]), d.length === 3 ? f : parseCssFloat(d[3])), putToCache(t, n), n;
					setRgba(n, 0, 0, 0, 1);
					return;
				case "hsla":
					if (d.length !== 4) {
						setRgba(n, 0, 0, 0, 1);
						return;
					}
					return d[3] = parseCssFloat(d[3]), hsla2rgba(d, n), putToCache(t, n), n;
				case "hsl":
					if (d.length !== 3) {
						setRgba(n, 0, 0, 0, 1);
						return;
					}
					return hsla2rgba(d, n), putToCache(t, n), n;
				default: return;
			}
		}
		setRgba(n, 0, 0, 0, 1);
	}
}
function hsla2rgba(t, n) {
	var r = (parseFloat(t[0]) % 360 + 360) % 360 / 360, a = parseCssFloat(t[1]), o = parseCssFloat(t[2]), s = o <= .5 ? o * (a + 1) : o + a - o * a, c = o * 2 - s;
	return n ||= [], setRgba(n, clampCssByte(cssHueToRgb(c, s, r + 1 / 3) * 255), clampCssByte(cssHueToRgb(c, s, r) * 255), clampCssByte(cssHueToRgb(c, s, r - 1 / 3) * 255), 1), t.length === 4 && (n[3] = t[3]), n;
}
function rgba2hsla(t) {
	if (t) {
		var n = t[0] / 255, r = t[1] / 255, a = t[2] / 255, o = Math.min(n, r, a), s = Math.max(n, r, a), c = s - o, l = (s + o) / 2, u, d;
		if (c === 0) u = 0, d = 0;
		else {
			d = l < .5 ? c / (s + o) : c / (2 - s - o);
			var f = ((s - n) / 6 + c / 2) / c, p = ((s - r) / 6 + c / 2) / c, h = ((s - a) / 6 + c / 2) / c;
			n === s ? u = h - p : r === s ? u = 1 / 3 + f - h : a === s && (u = 2 / 3 + p - f), u < 0 && (u += 1), u > 1 && --u;
		}
		var g = [
			u * 360,
			d,
			l
		];
		return t[3] != null && g.push(t[3]), g;
	}
}
function lift(t, n) {
	var r = parse(t);
	if (r) {
		for (var a = 0; a < 3; a++) n < 0 ? r[a] = r[a] * (1 - n) | 0 : r[a] = (255 - r[a]) * n + r[a] | 0, r[a] > 255 ? r[a] = 255 : r[a] < 0 && (r[a] = 0);
		return stringify(r, r.length === 4 ? "rgba" : "rgb");
	}
}
function toHex(t) {
	var n = parse(t);
	if (n) return ((1 << 24) + (n[0] << 16) + (n[1] << 8) + +n[2]).toString(16).slice(1);
}
function fastLerp(t, n, r) {
	if (!(!(n && n.length) || !(t >= 0 && t <= 1))) {
		r ||= [];
		var a = t * (n.length - 1), o = Math.floor(a), s = Math.ceil(a), c = n[o], l = n[s], u = a - o;
		return r[0] = clampCssByte(lerpNumber(c[0], l[0], u)), r[1] = clampCssByte(lerpNumber(c[1], l[1], u)), r[2] = clampCssByte(lerpNumber(c[2], l[2], u)), r[3] = clampCssFloat(lerpNumber(c[3], l[3], u)), r;
	}
}
var fastMapToColor = fastLerp;
function lerp$1(t, n, r) {
	if (!(!(n && n.length) || !(t >= 0 && t <= 1))) {
		var a = t * (n.length - 1), o = Math.floor(a), s = Math.ceil(a), c = parse(n[o]), l = parse(n[s]), u = a - o, d = stringify([
			clampCssByte(lerpNumber(c[0], l[0], u)),
			clampCssByte(lerpNumber(c[1], l[1], u)),
			clampCssByte(lerpNumber(c[2], l[2], u)),
			clampCssFloat(lerpNumber(c[3], l[3], u))
		], "rgba");
		return r ? {
			color: d,
			leftIndex: o,
			rightIndex: s,
			value: a
		} : d;
	}
}
var mapToColor = lerp$1;
function modifyHSL(t, n, r, a) {
	var o = parse(t);
	if (t) return o = rgba2hsla(o), n != null && (o[0] = clampCssAngle(n)), r != null && (o[1] = parseCssFloat(r)), a != null && (o[2] = parseCssFloat(a)), stringify(hsla2rgba(o), "rgba");
}
function modifyAlpha(t, n) {
	var r = parse(t);
	if (r && n != null) return r[3] = clampCssFloat(n), stringify(r, "rgba");
}
function stringify(t, n) {
	if (!(!t || !t.length)) {
		var r = t[0] + "," + t[1] + "," + t[2];
		return (n === "rgba" || n === "hsva" || n === "hsla") && (r += "," + t[3]), n + "(" + r + ")";
	}
}
function lum(t, n) {
	var r = parse(t);
	return r ? (.299 * r[0] + .587 * r[1] + .114 * r[2]) * r[3] / 255 + (1 - r[3]) * n : 0;
}
function random() {
	return stringify([
		Math.round(Math.random() * 255),
		Math.round(Math.random() * 255),
		Math.round(Math.random() * 255)
	], "rgb");
}
var liftedColorCache = new LRU_default(100);
function liftColor(t) {
	if (isString(t)) {
		var n = liftedColorCache.get(t);
		return n || (n = lift(t, -.1), liftedColorCache.put(t, n)), n;
	} else if (isGradientObject(t)) {
		var r = extend({}, t);
		return r.colorStops = map(t.colorStops, function(t) {
			return {
				offset: t.offset,
				color: lift(t.color, -.1)
			};
		}), r;
	}
	return t;
}
init_dist$1();
var mathRound$1 = Math.round;
function normalizeColor(t) {
	var n;
	if (!t || t === "transparent") t = "none";
	else if (typeof t == "string" && t.indexOf("rgba") > -1) {
		var r = parse(t);
		r && (t = "rgb(" + r[0] + "," + r[1] + "," + r[2] + ")", n = r[3]);
	}
	return {
		color: t,
		opacity: n ?? 1
	};
}
var EPSILON$3 = 1e-4;
function isAroundZero(t) {
	return t < EPSILON$3 && t > -EPSILON$3;
}
function round3(t) {
	return mathRound$1(t * 1e3) / 1e3;
}
function round4(t) {
	return mathRound$1(t * 1e4) / 1e4;
}
function getMatrixStr(t) {
	return "matrix(" + round3(t[0]) + "," + round3(t[1]) + "," + round3(t[2]) + "," + round3(t[3]) + "," + round4(t[4]) + "," + round4(t[5]) + ")";
}
var TEXT_ALIGN_TO_ANCHOR = {
	left: "start",
	right: "end",
	center: "middle",
	middle: "middle"
};
function adjustTextY(t, n, r) {
	return r === "top" ? t += n / 2 : r === "bottom" && (t -= n / 2), t;
}
function hasShadow(t) {
	return t && (t.shadowBlur || t.shadowOffsetX || t.shadowOffsetY);
}
function getShadowKey(t) {
	var n = t.style, r = t.getGlobalScale();
	return [
		n.shadowColor,
		(n.shadowBlur || 0).toFixed(2),
		(n.shadowOffsetX || 0).toFixed(2),
		(n.shadowOffsetY || 0).toFixed(2),
		r[0],
		r[1]
	].join(",");
}
function isImagePattern(t) {
	return t && !!t.image;
}
function isSVGPattern(t) {
	return t && !!t.svgElement;
}
function isPattern(t) {
	return isImagePattern(t) || isSVGPattern(t);
}
function isLinearGradient(t) {
	return t.type === "linear";
}
function isRadialGradient(t) {
	return t.type === "radial";
}
function isGradient(t) {
	return t && (t.type === "linear" || t.type === "radial");
}
function getIdURL(t) {
	return "url(#" + t + ")";
}
function getPathPrecision(t) {
	var n = t.getGlobalScale(), r = Math.max(n[0], n[1]);
	return Math.max(Math.ceil(Math.log(r) / Math.log(10)), 1);
}
function getSRTTransformString(t) {
	var n = t.x || 0, r = t.y || 0, a = (t.rotation || 0) * RADIAN_TO_DEGREE, o = retrieve2(t.scaleX, 1), s = retrieve2(t.scaleY, 1), c = t.skewX || 0, l = t.skewY || 0, u = [];
	return (n || r) && u.push("translate(" + n + "px," + r + "px)"), a && u.push("rotate(" + a + ")"), (o !== 1 || s !== 1) && u.push("scale(" + o + "," + s + ")"), (c || l) && u.push("skew(" + mathRound$1(c * RADIAN_TO_DEGREE) + "deg, " + mathRound$1(l * RADIAN_TO_DEGREE) + "deg)"), u.join(" ");
}
var encodeBase64 = (function() {
	return env_default.hasGlobalWindow && isFunction(window.btoa) ? function(t) {
		return window.btoa(unescape(encodeURIComponent(t)));
	} : Buffer === void 0 ? function(t) {
		return process$1.env.NODE_ENV !== "production" && logError("Base64 isn't natively supported in the current environment."), null;
	} : function(t) {
		return Buffer.from(t).toString("base64");
	};
})(), arraySlice = Array.prototype.slice;
function interpolateNumber$1(t, n, r) {
	return (n - t) * r + t;
}
function interpolate1DArray(t, n, r, a) {
	for (var o = n.length, s = 0; s < o; s++) t[s] = interpolateNumber$1(n[s], r[s], a);
	return t;
}
function interpolate2DArray(t, n, r, a) {
	for (var o = n.length, s = o && n[0].length, c = 0; c < o; c++) {
		t[c] || (t[c] = []);
		for (var l = 0; l < s; l++) t[c][l] = interpolateNumber$1(n[c][l], r[c][l], a);
	}
	return t;
}
function add1DArray(t, n, r, a) {
	for (var o = n.length, s = 0; s < o; s++) t[s] = n[s] + r[s] * a;
	return t;
}
function add2DArray(t, n, r, a) {
	for (var o = n.length, s = o && n[0].length, c = 0; c < o; c++) {
		t[c] || (t[c] = []);
		for (var l = 0; l < s; l++) t[c][l] = n[c][l] + r[c][l] * a;
	}
	return t;
}
function fillColorStops(t, n) {
	for (var r = t.length, a = n.length, o = r > a ? n : t, s = Math.min(r, a), c = o[s - 1] || {
		color: [
			0,
			0,
			0,
			0
		],
		offset: 0
	}, l = s; l < Math.max(r, a); l++) o.push({
		offset: c.offset,
		color: c.color.slice()
	});
}
function fillArray(t, n, r) {
	var a = t, o = n;
	if (!(!a.push || !o.push)) {
		var s = a.length, c = o.length;
		if (s !== c) if (s > c) a.length = c;
		else for (var l = s; l < c; l++) a.push(r === 1 ? o[l] : arraySlice.call(o[l]));
		for (var u = a[0] && a[0].length, l = 0; l < a.length; l++) if (r === 1) isNaN(a[l]) && (a[l] = o[l]);
		else for (var d = 0; d < u; d++) isNaN(a[l][d]) && (a[l][d] = o[l][d]);
	}
}
function cloneValue(t) {
	if (isArrayLike(t)) {
		var n = t.length;
		if (isArrayLike(t[0])) {
			for (var r = [], a = 0; a < n; a++) r.push(arraySlice.call(t[a]));
			return r;
		}
		return arraySlice.call(t);
	}
	return t;
}
function rgba2String(t) {
	return t[0] = Math.floor(t[0]) || 0, t[1] = Math.floor(t[1]) || 0, t[2] = Math.floor(t[2]) || 0, t[3] = t[3] == null ? 1 : t[3], "rgba(" + t.join(",") + ")";
}
function guessArrayDim(t) {
	return isArrayLike(t && t[0]) ? 2 : 1;
}
var VALUE_TYPE_NUMBER = 0, VALUE_TYPE_1D_ARRAY = 1, VALUE_TYPE_2D_ARRAY = 2, VALUE_TYPE_COLOR = 3, VALUE_TYPE_LINEAR_GRADIENT = 4, VALUE_TYPE_RADIAL_GRADIENT = 5, VALUE_TYPE_UNKOWN = 6;
function isGradientValueType(t) {
	return t === VALUE_TYPE_LINEAR_GRADIENT || t === VALUE_TYPE_RADIAL_GRADIENT;
}
function isArrayValueType(t) {
	return t === VALUE_TYPE_1D_ARRAY || t === VALUE_TYPE_2D_ARRAY;
}
var tmpRgba = [
	0,
	0,
	0,
	0
], Track = function() {
	function t(t) {
		this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = t;
	}
	return t.prototype.isFinished = function() {
		return this._finished;
	}, t.prototype.setFinished = function() {
		this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
	}, t.prototype.needsAnimate = function() {
		return this.keyframes.length >= 1;
	}, t.prototype.getAdditiveTrack = function() {
		return this._additiveTrack;
	}, t.prototype.addKeyframe = function(t, n, r) {
		this._needsSort = !0;
		var a = this.keyframes, o = a.length, s = !1, c = VALUE_TYPE_UNKOWN, l = n;
		if (isArrayLike(n)) {
			var u = guessArrayDim(n);
			c = u, (u === 1 && !isNumber(n[0]) || u === 2 && !isNumber(n[0][0])) && (s = !0);
		} else if (isNumber(n) && !eqNaN(n)) c = VALUE_TYPE_NUMBER;
		else if (isString(n)) if (!isNaN(+n)) c = VALUE_TYPE_NUMBER;
		else {
			var d = parse(n);
			d && (l = d, c = VALUE_TYPE_COLOR);
		}
		else if (isGradientObject(n)) {
			var f = extend({}, l);
			f.colorStops = map(n.colorStops, function(t) {
				return {
					offset: t.offset,
					color: parse(t.color)
				};
			}), isLinearGradient(n) ? c = VALUE_TYPE_LINEAR_GRADIENT : isRadialGradient(n) && (c = VALUE_TYPE_RADIAL_GRADIENT), l = f;
		}
		o === 0 ? this.valType = c : (c !== this.valType || c === VALUE_TYPE_UNKOWN) && (s = !0), this.discrete = this.discrete || s;
		var p = {
			time: t,
			value: l,
			rawValue: n,
			percent: 0
		};
		return r && (p.easing = r, p.easingFunc = isFunction(r) ? r : easing_default[r] || createCubicEasingFunc(r)), a.push(p), p;
	}, t.prototype.prepare = function(t, n) {
		var r = this.keyframes;
		this._needsSort && r.sort(function(t, n) {
			return t.time - n.time;
		});
		for (var a = this.valType, o = r.length, s = r[o - 1], c = this.discrete, l = isArrayValueType(a), u = isGradientValueType(a), d = 0; d < o; d++) {
			var f = r[d], p = f.value, h = s.value;
			f.percent = f.time / t, c || (l && d !== o - 1 ? fillArray(p, h, a) : u && fillColorStops(p.colorStops, h.colorStops));
		}
		if (!c && a !== VALUE_TYPE_RADIAL_GRADIENT && n && this.needsAnimate() && n.needsAnimate() && a === n.valType && !n._finished) {
			this._additiveTrack = n;
			for (var g = r[0].value, d = 0; d < o; d++) a === VALUE_TYPE_NUMBER ? r[d].additiveValue = r[d].value - g : a === VALUE_TYPE_COLOR ? r[d].additiveValue = add1DArray([], r[d].value, g, -1) : isArrayValueType(a) && (r[d].additiveValue = a === VALUE_TYPE_1D_ARRAY ? add1DArray([], r[d].value, g, -1) : add2DArray([], r[d].value, g, -1));
		}
	}, t.prototype.step = function(t, n) {
		if (!this._finished) {
			this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
			var r = this._additiveTrack != null, a = r ? "additiveValue" : "value", o = this.valType, s = this.keyframes, c = s.length, l = this.propName, u = o === VALUE_TYPE_COLOR, d, f = this._lastFr, p = Math.min, h, g;
			if (c === 1) h = g = s[0];
			else {
				if (n < 0) d = 0;
				else if (n < this._lastFrP) {
					for (d = p(f + 1, c - 1); d >= 0 && !(s[d].percent <= n); d--);
					d = p(d, c - 2);
				} else {
					for (d = f; d < c && !(s[d].percent > n); d++);
					d = p(d - 1, c - 2);
				}
				g = s[d + 1], h = s[d];
			}
			if (h && g) {
				this._lastFr = d, this._lastFrP = n;
				var _ = g.percent - h.percent, v = _ === 0 ? 1 : p((n - h.percent) / _, 1);
				g.easingFunc && (v = g.easingFunc(v));
				var y = r ? this._additiveValue : u ? tmpRgba : t[l];
				if ((isArrayValueType(o) || u) && !y && (y = this._additiveValue = []), this.discrete) t[l] = v < 1 ? h.rawValue : g.rawValue;
				else if (isArrayValueType(o)) o === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(y, h[a], g[a], v) : interpolate2DArray(y, h[a], g[a], v);
				else if (isGradientValueType(o)) {
					var b = h[a], x = g[a], S = o === VALUE_TYPE_LINEAR_GRADIENT;
					t[l] = {
						type: S ? "linear" : "radial",
						x: interpolateNumber$1(b.x, x.x, v),
						y: interpolateNumber$1(b.y, x.y, v),
						colorStops: map(b.colorStops, function(t, n) {
							var r = x.colorStops[n];
							return {
								offset: interpolateNumber$1(t.offset, r.offset, v),
								color: rgba2String(interpolate1DArray([], t.color, r.color, v))
							};
						}),
						global: x.global
					}, S ? (t[l].x2 = interpolateNumber$1(b.x2, x.x2, v), t[l].y2 = interpolateNumber$1(b.y2, x.y2, v)) : t[l].r = interpolateNumber$1(b.r, x.r, v);
				} else if (u) interpolate1DArray(y, h[a], g[a], v), r || (t[l] = rgba2String(y));
				else {
					var C = interpolateNumber$1(h[a], g[a], v);
					r ? this._additiveValue = C : t[l] = C;
				}
				r && this._addToTarget(t);
			}
		}
	}, t.prototype._addToTarget = function(t) {
		var n = this.valType, r = this.propName, a = this._additiveValue;
		n === VALUE_TYPE_NUMBER ? t[r] = t[r] + a : n === VALUE_TYPE_COLOR ? (parse(t[r], tmpRgba), add1DArray(tmpRgba, tmpRgba, a, 1), t[r] = rgba2String(tmpRgba)) : n === VALUE_TYPE_1D_ARRAY ? add1DArray(t[r], t[r], a, 1) : n === VALUE_TYPE_2D_ARRAY && add2DArray(t[r], t[r], a, 1);
	}, t;
}(), Animator_default = function() {
	function t(t, n, r, a) {
		if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = n, n && a) {
			logError("Can' use additive animation on looped animation.");
			return;
		}
		this._additiveAnimators = a, this._allowDiscrete = r;
	}
	return t.prototype.getMaxTime = function() {
		return this._maxTime;
	}, t.prototype.getDelay = function() {
		return this._delay;
	}, t.prototype.getLoop = function() {
		return this._loop;
	}, t.prototype.getTarget = function() {
		return this._target;
	}, t.prototype.changeTarget = function(t) {
		this._target = t;
	}, t.prototype.when = function(t, n, r) {
		return this.whenWithKeys(t, n, keys(n), r);
	}, t.prototype.whenWithKeys = function(t, n, r, a) {
		for (var o = this._tracks, s = 0; s < r.length; s++) {
			var c = r[s], l = o[c];
			if (!l) {
				l = o[c] = new Track(c);
				var u = void 0, d = this._getAdditiveTrack(c);
				if (d) {
					var f = d.keyframes, p = f[f.length - 1];
					u = p && p.value, d.valType === VALUE_TYPE_COLOR && u && (u = rgba2String(u));
				} else u = this._target[c];
				if (u == null) continue;
				t > 0 && l.addKeyframe(0, cloneValue(u), a), this._trackKeys.push(c);
			}
			l.addKeyframe(t, cloneValue(n[c]), a);
		}
		return this._maxTime = Math.max(this._maxTime, t), this;
	}, t.prototype.pause = function() {
		this._clip.pause(), this._paused = !0;
	}, t.prototype.resume = function() {
		this._clip.resume(), this._paused = !1;
	}, t.prototype.isPaused = function() {
		return !!this._paused;
	}, t.prototype.duration = function(t) {
		return this._maxTime = t, this._force = !0, this;
	}, t.prototype._doneCallback = function() {
		this._setTracksFinished(), this._clip = null;
		var t = this._doneCbs;
		if (t) for (var n = t.length, r = 0; r < n; r++) t[r].call(this);
	}, t.prototype._abortedCallback = function() {
		this._setTracksFinished();
		var t = this.animation, n = this._abortedCbs;
		if (t && t.removeClip(this._clip), this._clip = null, n) for (var r = 0; r < n.length; r++) n[r].call(this);
	}, t.prototype._setTracksFinished = function() {
		for (var t = this._tracks, n = this._trackKeys, r = 0; r < n.length; r++) t[n[r]].setFinished();
	}, t.prototype._getAdditiveTrack = function(t) {
		var n, r = this._additiveAnimators;
		if (r) for (var a = 0; a < r.length; a++) {
			var o = r[a].getTrack(t);
			o && (n = o);
		}
		return n;
	}, t.prototype.start = function(t) {
		if (!(this._started > 0)) {
			this._started = 1;
			for (var n = this, r = [], a = this._maxTime || 0, o = 0; o < this._trackKeys.length; o++) {
				var s = this._trackKeys[o], c = this._tracks[s], l = this._getAdditiveTrack(s), u = c.keyframes, d = u.length;
				if (c.prepare(a, l), c.needsAnimate()) if (!this._allowDiscrete && c.discrete) {
					var f = u[d - 1];
					f && (n._target[c.propName] = f.rawValue), c.setFinished();
				} else r.push(c);
			}
			if (r.length || this._force) {
				var p = new Clip_default({
					life: a,
					loop: this._loop,
					delay: this._delay || 0,
					onframe: function(t) {
						n._started = 2;
						var a = n._additiveAnimators;
						if (a) {
							for (var o = !1, s = 0; s < a.length; s++) if (a[s]._clip) {
								o = !0;
								break;
							}
							o || (n._additiveAnimators = null);
						}
						for (var s = 0; s < r.length; s++) r[s].step(n._target, t);
						var c = n._onframeCbs;
						if (c) for (var s = 0; s < c.length; s++) c[s](n._target, t);
					},
					ondestroy: function() {
						n._doneCallback();
					}
				});
				this._clip = p, this.animation && this.animation.addClip(p), t && p.setEasing(t);
			} else this._doneCallback();
			return this;
		}
	}, t.prototype.stop = function(t) {
		if (this._clip) {
			var n = this._clip;
			t && n.onframe(1), this._abortedCallback();
		}
	}, t.prototype.delay = function(t) {
		return this._delay = t, this;
	}, t.prototype.during = function(t) {
		return t && (this._onframeCbs ||= [], this._onframeCbs.push(t)), this;
	}, t.prototype.done = function(t) {
		return t && (this._doneCbs ||= [], this._doneCbs.push(t)), this;
	}, t.prototype.aborted = function(t) {
		return t && (this._abortedCbs ||= [], this._abortedCbs.push(t)), this;
	}, t.prototype.getClip = function() {
		return this._clip;
	}, t.prototype.getTrack = function(t) {
		return this._tracks[t];
	}, t.prototype.getTracks = function() {
		var t = this;
		return map(this._trackKeys, function(n) {
			return t._tracks[n];
		});
	}, t.prototype.stopTracks = function(t, n) {
		if (!t.length || !this._clip) return !0;
		for (var r = this._tracks, a = this._trackKeys, o = 0; o < t.length; o++) {
			var s = r[t[o]];
			s && !s.isFinished() && (n ? s.step(this._target, 1) : this._started === 1 && s.step(this._target, 0), s.setFinished());
		}
		for (var c = !0, o = 0; o < a.length; o++) if (!r[a[o]].isFinished()) {
			c = !1;
			break;
		}
		return c && this._abortedCallback(), c;
	}, t.prototype.saveTo = function(t, n, r) {
		if (t) {
			n ||= this._trackKeys;
			for (var a = 0; a < n.length; a++) {
				var o = n[a], s = this._tracks[o];
				if (!(!s || s.isFinished())) {
					var c = s.keyframes, l = c[r ? 0 : c.length - 1];
					l && (t[o] = cloneValue(l.rawValue));
				}
			}
		}
	}, t.prototype.__changeFinalValue = function(t, n) {
		n ||= keys(t);
		for (var r = 0; r < n.length; r++) {
			var a = n[r], o = this._tracks[a];
			if (o) {
				var s = o.keyframes;
				if (s.length > 1) {
					var c = s.pop();
					o.addKeyframe(c.time, t[a]), o.prepare(this._maxTime, o.getAdditiveTrack());
				}
			}
		}
	}, t;
}();
function getTime() {
	return (/* @__PURE__ */ new Date()).getTime();
}
var Animation_default = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this) || this;
		return r._running = !1, r._time = 0, r._pausedTime = 0, r._pauseStart = 0, r._paused = !1, n ||= {}, r.stage = n.stage || {}, r;
	}
	return n.prototype.addClip = function(t) {
		t.animation && this.removeClip(t), this._head ? (this._tail.next = t, t.prev = this._tail, t.next = null, this._tail = t) : this._head = this._tail = t, t.animation = this;
	}, n.prototype.addAnimator = function(t) {
		t.animation = this;
		var n = t.getClip();
		n && this.addClip(n);
	}, n.prototype.removeClip = function(t) {
		if (t.animation) {
			var n = t.prev, r = t.next;
			n ? n.next = r : this._head = r, r ? r.prev = n : this._tail = n, t.next = t.prev = t.animation = null;
		}
	}, n.prototype.removeAnimator = function(t) {
		var n = t.getClip();
		n && this.removeClip(n), t.animation = null;
	}, n.prototype.update = function(t) {
		for (var n = getTime() - this._pausedTime, r = n - this._time, a = this._head; a;) {
			var o = a.next;
			a.step(n, r) ? (a.ondestroy(), this.removeClip(a), a = o) : a = o;
		}
		this._time = n, t || (this.trigger("frame", r), this.stage.update && this.stage.update());
	}, n.prototype._startLoop = function() {
		var t = this;
		this._running = !0;
		function n() {
			t._running && (requestAnimationFrame_default(n), !t._paused && t.update());
		}
		requestAnimationFrame_default(n);
	}, n.prototype.start = function() {
		this._running || (this._time = getTime(), this._pausedTime = 0, this._startLoop());
	}, n.prototype.stop = function() {
		this._running = !1;
	}, n.prototype.pause = function() {
		this._paused ||= (this._pauseStart = getTime(), !0);
	}, n.prototype.resume = function() {
		this._paused &&= (this._pausedTime += getTime() - this._pauseStart, !1);
	}, n.prototype.clear = function() {
		for (var t = this._head; t;) {
			var n = t.next;
			t.prev = t.next = t.animation = null, t = n;
		}
		this._head = this._tail = null;
	}, n.prototype.isFinished = function() {
		return this._head == null;
	}, n.prototype.animate = function(t, n) {
		n ||= {}, this.start();
		var r = new Animator_default(t, n.loop);
		return this.addAnimator(r), r;
	}, n;
}(Eventful_default), TOUCH_CLICK_DELAY = 300, globalEventSupported = env_default.domSupported, localNativeListenerNames = (function() {
	var t = [
		"click",
		"dblclick",
		"mousewheel",
		"wheel",
		"mouseout",
		"mouseup",
		"mousedown",
		"mousemove",
		"contextmenu"
	], n = [
		"touchstart",
		"touchend",
		"touchmove"
	], r = {
		pointerdown: 1,
		pointerup: 1,
		pointermove: 1,
		pointerout: 1
	};
	return {
		mouse: t,
		touch: n,
		pointer: map(t, function(t) {
			var n = t.replace("mouse", "pointer");
			return r.hasOwnProperty(n) ? n : t;
		})
	};
})(), globalNativeListenerNames = {
	mouse: ["mousemove", "mouseup"],
	pointer: ["pointermove", "pointerup"]
}, wheelEventSupported = !1;
function isPointerFromTouch(t) {
	var n = t.pointerType;
	return n === "pen" || n === "touch";
}
function setTouchTimer(t) {
	t.touching = !0, t.touchTimer != null && (clearTimeout(t.touchTimer), t.touchTimer = null), t.touchTimer = setTimeout(function() {
		t.touching = !1, t.touchTimer = null;
	}, 700);
}
function markTouch(t) {
	t && (t.zrByTouch = !0);
}
function normalizeGlobalEvent(t, n) {
	return normalizeEvent(t.dom, new FakeGlobalEvent(t, n), !0);
}
function isLocalEl(t, n) {
	for (var r = n, a = !1; r && r.nodeType !== 9 && !(a = r.domBelongToZr || r !== n && r === t.painterRoot);) r = r.parentNode;
	return a;
}
var FakeGlobalEvent = function() {
	function t(t, n) {
		this.stopPropagation = noop, this.stopImmediatePropagation = noop, this.preventDefault = noop, this.type = n.type, this.target = this.currentTarget = t.dom, this.pointerType = n.pointerType, this.clientX = n.clientX, this.clientY = n.clientY;
	}
	return t;
}(), localDOMHandlers = {
	mousedown: function(t) {
		t = normalizeEvent(this.dom, t), this.__mayPointerCapture = [t.zrX, t.zrY], this.trigger("mousedown", t);
	},
	mousemove: function(t) {
		t = normalizeEvent(this.dom, t);
		var n = this.__mayPointerCapture;
		n && (t.zrX !== n[0] || t.zrY !== n[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", t);
	},
	mouseup: function(t) {
		t = normalizeEvent(this.dom, t), this.__togglePointerCapture(!1), this.trigger("mouseup", t);
	},
	mouseout: function(t) {
		t = normalizeEvent(this.dom, t);
		var n = t.toElement || t.relatedTarget;
		isLocalEl(this, n) || (this.__pointerCapturing && (t.zrEventControl = "no_globalout"), this.trigger("mouseout", t));
	},
	wheel: function(t) {
		wheelEventSupported = !0, t = normalizeEvent(this.dom, t), this.trigger("mousewheel", t);
	},
	mousewheel: function(t) {
		wheelEventSupported || (t = normalizeEvent(this.dom, t), this.trigger("mousewheel", t));
	},
	touchstart: function(t) {
		t = normalizeEvent(this.dom, t), markTouch(t), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(t, "start"), localDOMHandlers.mousemove.call(this, t), localDOMHandlers.mousedown.call(this, t);
	},
	touchmove: function(t) {
		t = normalizeEvent(this.dom, t), markTouch(t), this.handler.processGesture(t, "change"), localDOMHandlers.mousemove.call(this, t);
	},
	touchend: function(t) {
		t = normalizeEvent(this.dom, t), markTouch(t), this.handler.processGesture(t, "end"), localDOMHandlers.mouseup.call(this, t), /* @__PURE__ */ new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY && localDOMHandlers.click.call(this, t);
	},
	pointerdown: function(t) {
		localDOMHandlers.mousedown.call(this, t);
	},
	pointermove: function(t) {
		isPointerFromTouch(t) || localDOMHandlers.mousemove.call(this, t);
	},
	pointerup: function(t) {
		localDOMHandlers.mouseup.call(this, t);
	},
	pointerout: function(t) {
		isPointerFromTouch(t) || localDOMHandlers.mouseout.call(this, t);
	}
};
each([
	"click",
	"dblclick",
	"contextmenu"
], function(t) {
	localDOMHandlers[t] = function(n) {
		n = normalizeEvent(this.dom, n), this.trigger(t, n);
	};
});
var globalDOMHandlers = {
	pointermove: function(t) {
		isPointerFromTouch(t) || globalDOMHandlers.mousemove.call(this, t);
	},
	pointerup: function(t) {
		globalDOMHandlers.mouseup.call(this, t);
	},
	mousemove: function(t) {
		this.trigger("mousemove", t);
	},
	mouseup: function(t) {
		var n = this.__pointerCapturing;
		this.__togglePointerCapture(!1), this.trigger("mouseup", t), n && (t.zrEventControl = "only_globalout", this.trigger("mouseout", t));
	}
};
function mountLocalDOMEventListeners(t, n) {
	var r = n.domHandlers;
	env_default.pointerEventsSupported ? each(localNativeListenerNames.pointer, function(a) {
		mountSingleDOMEventListener(n, a, function(n) {
			r[a].call(t, n);
		});
	}) : (env_default.touchEventsSupported && each(localNativeListenerNames.touch, function(a) {
		mountSingleDOMEventListener(n, a, function(o) {
			r[a].call(t, o), setTouchTimer(n);
		});
	}), each(localNativeListenerNames.mouse, function(a) {
		mountSingleDOMEventListener(n, a, function(o) {
			o = getNativeEvent(o), n.touching || r[a].call(t, o);
		});
	}));
}
function mountGlobalDOMEventListeners(t, n) {
	env_default.pointerEventsSupported ? each(globalNativeListenerNames.pointer, r) : env_default.touchEventsSupported || each(globalNativeListenerNames.mouse, r);
	function r(r) {
		function a(a) {
			a = getNativeEvent(a), isLocalEl(t, a.target) || (a = normalizeGlobalEvent(t, a), n.domHandlers[r].call(t, a));
		}
		mountSingleDOMEventListener(n, r, a, { capture: !0 });
	}
}
function mountSingleDOMEventListener(t, n, r, a) {
	t.mounted[n] = r, t.listenerOpts[n] = a, addEventListener(t.domTarget, n, r, a);
}
function unmountDOMEventListeners(t) {
	var n = t.mounted;
	for (var r in n) n.hasOwnProperty(r) && removeEventListener(t.domTarget, r, n[r], t.listenerOpts[r]);
	t.mounted = {};
}
var DOMHandlerScope = function() {
	function t(t, n) {
		this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = t, this.domHandlers = n;
	}
	return t;
}(), HandlerProxy_default = function(t) {
	__extends(n, t);
	function n(n, r) {
		var a = t.call(this) || this;
		return a.__pointerCapturing = !1, a.dom = n, a.painterRoot = r, a._localHandlerScope = new DOMHandlerScope(n, localDOMHandlers), globalEventSupported && (a._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers)), mountLocalDOMEventListeners(a, a._localHandlerScope), a;
	}
	return n.prototype.dispose = function() {
		unmountDOMEventListeners(this._localHandlerScope), globalEventSupported && unmountDOMEventListeners(this._globalHandlerScope);
	}, n.prototype.setCursor = function(t) {
		this.dom.style && (this.dom.style.cursor = t || "default");
	}, n.prototype.__togglePointerCapture = function(t) {
		if (this.__mayPointerCapture = null, globalEventSupported && this.__pointerCapturing ^ +t) {
			this.__pointerCapturing = t;
			var n = this._globalHandlerScope;
			t ? mountGlobalDOMEventListeners(this, n) : unmountDOMEventListeners(n);
		}
	}, n;
}(Eventful_default), dpr = 1;
env_default.hasGlobalWindow && (dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var devicePixelRatio = dpr, DARK_MODE_THRESHOLD = .4, DARK_LABEL_COLOR = "#333", LIGHT_LABEL_COLOR = "#ccc", LIGHTER_LABEL_COLOR = "#eee", mIdentity = identity, EPSILON$2 = 5e-5;
function isNotAroundZero(t) {
	return t > EPSILON$2 || t < -EPSILON$2;
}
var scaleTmp = [], tmpTransform = [], originTransform = create$2(), abs = Math.abs, Transformable = function() {
	function t() {}
	return t.prototype.getLocalTransform = function(n) {
		return t.getLocalTransform(this, n);
	}, t.prototype.setPosition = function(t) {
		this.x = t[0], this.y = t[1];
	}, t.prototype.setScale = function(t) {
		this.scaleX = t[0], this.scaleY = t[1];
	}, t.prototype.setSkew = function(t) {
		this.skewX = t[0], this.skewY = t[1];
	}, t.prototype.setOrigin = function(t) {
		this.originX = t[0], this.originY = t[1];
	}, t.prototype.needLocalTransform = function() {
		return isNotAroundZero(this.rotation) || isNotAroundZero(this.x) || isNotAroundZero(this.y) || isNotAroundZero(this.scaleX - 1) || isNotAroundZero(this.scaleY - 1) || isNotAroundZero(this.skewX) || isNotAroundZero(this.skewY);
	}, t.prototype.updateTransform = function() {
		var t = this.parent && this.parent.transform, n = this.needLocalTransform(), r = this.transform;
		if (!(n || t)) {
			r && (mIdentity(r), this.invTransform = null);
			return;
		}
		r ||= create$2(), n ? this.getLocalTransform(r) : mIdentity(r), t && (n ? mul(r, t, r) : copy(r, t)), this.transform = r, this._resolveGlobalScaleRatio(r);
	}, t.prototype._resolveGlobalScaleRatio = function(t) {
		var n = this.globalScaleRatio;
		if (n != null && n !== 1) {
			this.getGlobalScale(scaleTmp);
			var r = scaleTmp[0] < 0 ? -1 : 1, a = scaleTmp[1] < 0 ? -1 : 1, o = ((scaleTmp[0] - r) * n + r) / scaleTmp[0] || 0, s = ((scaleTmp[1] - a) * n + a) / scaleTmp[1] || 0;
			t[0] *= o, t[1] *= o, t[2] *= s, t[3] *= s;
		}
		this.invTransform = this.invTransform || create$2(), invert(this.invTransform, t);
	}, t.prototype.getComputedTransform = function() {
		for (var t = this, n = []; t;) n.push(t), t = t.parent;
		for (; t = n.pop();) t.updateTransform();
		return this.transform;
	}, t.prototype.setLocalTransform = function(t) {
		if (t) {
			var n = t[0] * t[0] + t[1] * t[1], r = t[2] * t[2] + t[3] * t[3], a = Math.atan2(t[1], t[0]), o = Math.PI / 2 + a - Math.atan2(t[3], t[2]);
			r = Math.sqrt(r) * Math.cos(o), n = Math.sqrt(n), this.skewX = o, this.skewY = 0, this.rotation = -a, this.x = +t[4], this.y = +t[5], this.scaleX = n, this.scaleY = r, this.originX = 0, this.originY = 0;
		}
	}, t.prototype.decomposeTransform = function() {
		if (this.transform) {
			var t = this.parent, n = this.transform;
			t && t.transform && (t.invTransform = t.invTransform || create$2(), mul(tmpTransform, t.invTransform, n), n = tmpTransform);
			var r = this.originX, a = this.originY;
			(r || a) && (originTransform[4] = r, originTransform[5] = a, mul(tmpTransform, n, originTransform), tmpTransform[4] -= r, tmpTransform[5] -= a, n = tmpTransform), this.setLocalTransform(n);
		}
	}, t.prototype.getGlobalScale = function(t) {
		var n = this.transform;
		return t ||= [], n ? (t[0] = Math.sqrt(n[0] * n[0] + n[1] * n[1]), t[1] = Math.sqrt(n[2] * n[2] + n[3] * n[3]), n[0] < 0 && (t[0] = -t[0]), n[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
	}, t.prototype.transformCoordToLocal = function(t, n) {
		var r = [t, n], a = this.invTransform;
		return a && applyTransform(r, r, a), r;
	}, t.prototype.transformCoordToGlobal = function(t, n) {
		var r = [t, n], a = this.transform;
		return a && applyTransform(r, r, a), r;
	}, t.prototype.getLineScale = function() {
		var t = this.transform;
		return t && abs(t[0] - 1) > 1e-10 && abs(t[3] - 1) > 1e-10 ? Math.sqrt(abs(t[0] * t[3] - t[2] * t[1])) : 1;
	}, t.prototype.copyTransform = function(t) {
		copyTransform(this, t);
	}, t.getLocalTransform = function(t, n) {
		n ||= [];
		var r = t.originX || 0, a = t.originY || 0, o = t.scaleX, s = t.scaleY, c = t.anchorX, l = t.anchorY, u = t.rotation || 0, d = t.x, f = t.y, p = t.skewX ? Math.tan(t.skewX) : 0, h = t.skewY ? Math.tan(-t.skewY) : 0;
		if (r || a || c || l) {
			var g = r + c, _ = a + l;
			n[4] = -g * o - p * _ * s, n[5] = -_ * s - h * g * o;
		} else n[4] = n[5] = 0;
		return n[0] = o, n[3] = s, n[1] = h * o, n[2] = p * s, u && rotate(n, n, u), n[4] += r + d, n[5] += a + f, n;
	}, t.initDefaultProps = (function() {
		var n = t.prototype;
		n.scaleX = n.scaleY = n.globalScaleRatio = 1, n.x = n.y = n.originX = n.originY = n.skewX = n.skewY = n.rotation = n.anchorX = n.anchorY = 0;
	})(), t;
}(), TRANSFORMABLE_PROPS = [
	"x",
	"y",
	"originX",
	"originY",
	"anchorX",
	"anchorY",
	"rotation",
	"scaleX",
	"scaleY",
	"skewX",
	"skewY"
];
function copyTransform(t, n) {
	for (var r = 0; r < TRANSFORMABLE_PROPS.length; r++) {
		var a = TRANSFORMABLE_PROPS[r];
		t[a] = n[a];
	}
}
var Transformable_default = Transformable, textWidthCache = {};
function getWidth(t, n) {
	n ||= "12px sans-serif";
	var r = textWidthCache[n];
	r ||= textWidthCache[n] = new LRU_default(500);
	var a = r.get(t);
	return a ?? (a = platformApi.measureText(t, n).width, r.put(t, a)), a;
}
function innerGetBoundingRect(t, n, r, a) {
	var o = getWidth(t, n), s = getLineHeight(n);
	return new BoundingRect_default(adjustTextX(0, o, r), adjustTextY$1(0, s, a), o, s);
}
function getBoundingRect(t, n, r, a) {
	var o = ((t || "") + "").split("\n");
	if (o.length === 1) return innerGetBoundingRect(o[0], n, r, a);
	for (var s = new BoundingRect_default(0, 0, 0, 0), c = 0; c < o.length; c++) {
		var l = innerGetBoundingRect(o[c], n, r, a);
		c === 0 ? s.copy(l) : s.union(l);
	}
	return s;
}
function adjustTextX(t, n, r) {
	return r === "right" ? t -= n : r === "center" && (t -= n / 2), t;
}
function adjustTextY$1(t, n, r) {
	return r === "middle" ? t -= n / 2 : r === "bottom" && (t -= n), t;
}
function getLineHeight(t) {
	return getWidth("国", t);
}
function parsePercent(t, n) {
	return typeof t == "string" ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * n : parseFloat(t) : t;
}
function calculateTextPosition(t, n, r) {
	var a = n.position || "inside", o = n.distance == null ? 5 : n.distance, s = r.height, c = r.width, l = s / 2, u = r.x, d = r.y, f = "left", p = "top";
	if (a instanceof Array) u += parsePercent(a[0], r.width), d += parsePercent(a[1], r.height), f = null, p = null;
	else switch (a) {
		case "left":
			u -= o, d += l, f = "right", p = "middle";
			break;
		case "right":
			u += o + c, d += l, p = "middle";
			break;
		case "top":
			u += c / 2, d -= o, f = "center", p = "bottom";
			break;
		case "bottom":
			u += c / 2, d += s + o, f = "center";
			break;
		case "inside":
			u += c / 2, d += l, f = "center", p = "middle";
			break;
		case "insideLeft":
			u += o, d += l, p = "middle";
			break;
		case "insideRight":
			u += c - o, d += l, f = "right", p = "middle";
			break;
		case "insideTop":
			u += c / 2, d += o, f = "center";
			break;
		case "insideBottom":
			u += c / 2, d += s - o, f = "center", p = "bottom";
			break;
		case "insideTopLeft":
			u += o, d += o;
			break;
		case "insideTopRight":
			u += c - o, d += o, f = "right";
			break;
		case "insideBottomLeft":
			u += o, d += s - o, p = "bottom";
			break;
		case "insideBottomRight":
			u += c - o, d += s - o, f = "right", p = "bottom";
			break;
	}
	return t ||= {}, t.x = u, t.y = d, t.align = f, t.verticalAlign = p, t;
}
init_dist$2();
var PRESERVED_NORMAL_STATE = "__zr_normal__", PRIMARY_STATES_KEYS$1 = TRANSFORMABLE_PROPS.concat(["ignore"]), DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function(t, n) {
	return t[n] = !0, t;
}, { ignore: !1 }), tmpTextPosCalcRes = {}, tmpBoundingRect = new BoundingRect_default(0, 0, 0, 0), Element = function() {
	function t(t) {
		this.id = guid(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t);
	}
	return t.prototype._init = function(t) {
		this.attr(t);
	}, t.prototype.drift = function(t, n, r) {
		switch (this.draggable) {
			case "horizontal":
				n = 0;
				break;
			case "vertical":
				t = 0;
				break;
		}
		var a = this.transform;
		a ||= this.transform = [
			1,
			0,
			0,
			1,
			0,
			0
		], a[4] += t, a[5] += n, this.decomposeTransform(), this.markRedraw();
	}, t.prototype.beforeUpdate = function() {}, t.prototype.afterUpdate = function() {}, t.prototype.update = function() {
		this.updateTransform(), this.__dirty && this.updateInnerText();
	}, t.prototype.updateInnerText = function(t) {
		var n = this._textContent;
		if (n && (!n.ignore || t)) {
			this.textConfig ||= {};
			var r = this.textConfig, a = r.local, o = n.innerTransformable, s = void 0, c = void 0, l = !1;
			o.parent = a ? this : null;
			var u = !1;
			if (o.copyTransform(n), r.position != null) {
				var d = tmpBoundingRect;
				r.layoutRect ? d.copy(r.layoutRect) : d.copy(this.getBoundingRect()), a || d.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(tmpTextPosCalcRes, r, d) : calculateTextPosition(tmpTextPosCalcRes, r, d), o.x = tmpTextPosCalcRes.x, o.y = tmpTextPosCalcRes.y, s = tmpTextPosCalcRes.align, c = tmpTextPosCalcRes.verticalAlign;
				var f = r.origin;
				if (f && r.rotation != null) {
					var p = void 0, h = void 0;
					f === "center" ? (p = d.width * .5, h = d.height * .5) : (p = parsePercent(f[0], d.width), h = parsePercent(f[1], d.height)), u = !0, o.originX = -o.x + p + (a ? 0 : d.x), o.originY = -o.y + h + (a ? 0 : d.y);
				}
			}
			r.rotation != null && (o.rotation = r.rotation);
			var g = r.offset;
			g && (o.x += g[0], o.y += g[1], u || (o.originX = -g[0], o.originY = -g[1]));
			var _ = r.inside == null ? typeof r.position == "string" && r.position.indexOf("inside") >= 0 : r.inside, v = this._innerTextDefaultStyle ||= {}, y = void 0, b = void 0, x = void 0;
			_ && this.canBeInsideText() ? (y = r.insideFill, b = r.insideStroke, (y == null || y === "auto") && (y = this.getInsideTextFill()), (b == null || b === "auto") && (b = this.getInsideTextStroke(y), x = !0)) : (y = r.outsideFill, b = r.outsideStroke, (y == null || y === "auto") && (y = this.getOutsideFill()), (b == null || b === "auto") && (b = this.getOutsideStroke(y), x = !0)), y ||= "#000", (y !== v.fill || b !== v.stroke || x !== v.autoStroke || s !== v.align || c !== v.verticalAlign) && (l = !0, v.fill = y, v.stroke = b, v.autoStroke = x, v.align = s, v.verticalAlign = c, n.setDefaultTextStyle(v)), n.__dirty |= 1, l && n.dirtyStyle(!0);
		}
	}, t.prototype.canBeInsideText = function() {
		return !0;
	}, t.prototype.getInsideTextFill = function() {
		return "#fff";
	}, t.prototype.getInsideTextStroke = function(t) {
		return "#000";
	}, t.prototype.getOutsideFill = function() {
		return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
	}, t.prototype.getOutsideStroke = function(t) {
		var n = this.__zr && this.__zr.getBackgroundColor(), r = typeof n == "string" && parse(n);
		r ||= [
			255,
			255,
			255,
			1
		];
		for (var a = r[3], o = this.__zr.isDarkMode(), s = 0; s < 3; s++) r[s] = r[s] * a + (o ? 0 : 255) * (1 - a);
		return r[3] = 1, stringify(r, "rgba");
	}, t.prototype.traverse = function(t, n) {}, t.prototype.attrKV = function(t, n) {
		t === "textConfig" ? this.setTextConfig(n) : t === "textContent" ? this.setTextContent(n) : t === "clipPath" ? this.setClipPath(n) : t === "extra" ? (this.extra = this.extra || {}, extend(this.extra, n)) : this[t] = n;
	}, t.prototype.hide = function() {
		this.ignore = !0, this.markRedraw();
	}, t.prototype.show = function() {
		this.ignore = !1, this.markRedraw();
	}, t.prototype.attr = function(t, n) {
		if (typeof t == "string") this.attrKV(t, n);
		else if (isObject(t)) for (var r = keys(t), a = 0; a < r.length; a++) {
			var o = r[a];
			this.attrKV(o, t[o]);
		}
		return this.markRedraw(), this;
	}, t.prototype.saveCurrentToNormalState = function(t) {
		this._innerSaveToNormal(t);
		for (var n = this._normalState, r = 0; r < this.animators.length; r++) {
			var a = this.animators[r], o = a.__fromStateTransition;
			if (!(a.getLoop() || o && o !== "__zr_normal__")) {
				var s = a.targetName, c = s ? n[s] : n;
				a.saveTo(c);
			}
		}
	}, t.prototype._innerSaveToNormal = function(t) {
		var n = this._normalState;
		n ||= this._normalState = {}, t.textConfig && !n.textConfig && (n.textConfig = this.textConfig), this._savePrimaryToNormal(t, n, PRIMARY_STATES_KEYS$1);
	}, t.prototype._savePrimaryToNormal = function(t, n, r) {
		for (var a = 0; a < r.length; a++) {
			var o = r[a];
			t[o] != null && !(o in n) && (n[o] = this[o]);
		}
	}, t.prototype.hasState = function() {
		return this.currentStates.length > 0;
	}, t.prototype.getState = function(t) {
		return this.states[t];
	}, t.prototype.ensureState = function(t) {
		var n = this.states;
		return n[t] || (n[t] = {}), n[t];
	}, t.prototype.clearStates = function(t) {
		this.useState(PRESERVED_NORMAL_STATE, !1, t);
	}, t.prototype.useState = function(t, n, r, a) {
		var o = t === PRESERVED_NORMAL_STATE;
		if (!(!this.hasState() && o)) {
			var s = this.currentStates, c = this.stateTransition;
			if (!(indexOf(s, t) >= 0 && (n || s.length === 1))) {
				var l;
				if (this.stateProxy && !o && (l = this.stateProxy(t)), l ||= this.states && this.states[t], !l && !o) {
					logError("State " + t + " not exists.");
					return;
				}
				o || this.saveCurrentToNormalState(l);
				var u = !!(l && l.hoverLayer || a);
				u && this._toggleHoverLayerFlag(!0), this._applyStateObj(t, l, this._normalState, n, !r && !this.__inHover && c && c.duration > 0, c);
				var d = this._textContent, f = this._textGuide;
				return d && d.useState(t, n, r, u), f && f.useState(t, n, r, u), o ? (this.currentStates = [], this._normalState = {}) : n ? this.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(), this.markRedraw(), !u && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= -2), l;
			}
		}
	}, t.prototype.useStates = function(t, n, r) {
		if (!t.length) this.clearStates();
		else {
			var a = [], o = this.currentStates, s = t.length, c = s === o.length;
			if (c) {
				for (var l = 0; l < s; l++) if (t[l] !== o[l]) {
					c = !1;
					break;
				}
			}
			if (c) return;
			for (var l = 0; l < s; l++) {
				var u = t[l], d = void 0;
				this.stateProxy && (d = this.stateProxy(u, t)), d ||= this.states[u], d && a.push(d);
			}
			var f = a[s - 1], p = !!(f && f.hoverLayer || r);
			p && this._toggleHoverLayerFlag(!0);
			var h = this._mergeStates(a), g = this.stateTransition;
			this.saveCurrentToNormalState(h), this._applyStateObj(t.join(","), h, this._normalState, !1, !n && !this.__inHover && g && g.duration > 0, g);
			var _ = this._textContent, v = this._textGuide;
			_ && _.useStates(t, n, p), v && v.useStates(t, n, p), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !p && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= -2);
		}
	}, t.prototype.isSilent = function() {
		for (var t = this.silent, n = this.parent; !t && n;) {
			if (n.silent) {
				t = !0;
				break;
			}
			n = n.parent;
		}
		return t;
	}, t.prototype._updateAnimationTargets = function() {
		for (var t = 0; t < this.animators.length; t++) {
			var n = this.animators[t];
			n.targetName && n.changeTarget(this[n.targetName]);
		}
	}, t.prototype.removeState = function(t) {
		var n = indexOf(this.currentStates, t);
		if (n >= 0) {
			var r = this.currentStates.slice();
			r.splice(n, 1), this.useStates(r);
		}
	}, t.prototype.replaceState = function(t, n, r) {
		var a = this.currentStates.slice(), o = indexOf(a, t), s = indexOf(a, n) >= 0;
		o >= 0 ? s ? a.splice(o, 1) : a[o] = n : r && !s && a.push(n), this.useStates(a);
	}, t.prototype.toggleState = function(t, n) {
		n ? this.useState(t, !0) : this.removeState(t);
	}, t.prototype._mergeStates = function(t) {
		for (var n = {}, r, a = 0; a < t.length; a++) {
			var o = t[a];
			extend(n, o), o.textConfig && (r ||= {}, extend(r, o.textConfig));
		}
		return r && (n.textConfig = r), n;
	}, t.prototype._applyStateObj = function(t, n, r, a, o, s) {
		var c = !(n && a);
		n && n.textConfig ? (this.textConfig = extend({}, a ? this.textConfig : r.textConfig), extend(this.textConfig, n.textConfig)) : c && r.textConfig && (this.textConfig = r.textConfig);
		for (var l = {}, u = !1, d = 0; d < PRIMARY_STATES_KEYS$1.length; d++) {
			var f = PRIMARY_STATES_KEYS$1[d], p = o && DEFAULT_ANIMATABLE_MAP[f];
			n && n[f] != null ? p ? (u = !0, l[f] = n[f]) : this[f] = n[f] : c && r[f] != null && (p ? (u = !0, l[f] = r[f]) : this[f] = r[f]);
		}
		if (!o) for (var d = 0; d < this.animators.length; d++) {
			var h = this.animators[d], g = h.targetName;
			h.getLoop() || h.__changeFinalValue(g ? (n || r)[g] : n || r);
		}
		u && this._transitionState(t, l, s);
	}, t.prototype._attachComponent = function(t) {
		if (t.__zr && !t.__hostTarget) {
			if (process$1.env.NODE_ENV !== "production") throw Error("Text element has been added to zrender.");
			return;
		}
		if (t === this) {
			if (process$1.env.NODE_ENV !== "production") throw Error("Recursive component attachment.");
			return;
		}
		var n = this.__zr;
		n && t.addSelfToZr(n), t.__zr = n, t.__hostTarget = this;
	}, t.prototype._detachComponent = function(t) {
		t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null;
	}, t.prototype.getClipPath = function() {
		return this._clipPath;
	}, t.prototype.setClipPath = function(t) {
		this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw();
	}, t.prototype.removeClipPath = function() {
		var t = this._clipPath;
		t && (this._detachComponent(t), this._clipPath = null, this.markRedraw());
	}, t.prototype.getTextContent = function() {
		return this._textContent;
	}, t.prototype.setTextContent = function(t) {
		var n = this._textContent;
		if (n !== t) {
			if (n && n !== t && this.removeTextContent(), process$1.env.NODE_ENV !== "production" && t.__zr && !t.__hostTarget) throw Error("Text element has been added to zrender.");
			t.innerTransformable = new Transformable_default(), this._attachComponent(t), this._textContent = t, this.markRedraw();
		}
	}, t.prototype.setTextConfig = function(t) {
		this.textConfig ||= {}, extend(this.textConfig, t), this.markRedraw();
	}, t.prototype.removeTextConfig = function() {
		this.textConfig = null, this.markRedraw();
	}, t.prototype.removeTextContent = function() {
		var t = this._textContent;
		t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
	}, t.prototype.getTextGuideLine = function() {
		return this._textGuide;
	}, t.prototype.setTextGuideLine = function(t) {
		this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw();
	}, t.prototype.removeTextGuideLine = function() {
		var t = this._textGuide;
		t && (this._detachComponent(t), this._textGuide = null, this.markRedraw());
	}, t.prototype.markRedraw = function() {
		this.__dirty |= 1;
		var t = this.__zr;
		t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
	}, t.prototype.dirty = function() {
		this.markRedraw();
	}, t.prototype._toggleHoverLayerFlag = function(t) {
		this.__inHover = t;
		var n = this._textContent, r = this._textGuide;
		n && (n.__inHover = t), r && (r.__inHover = t);
	}, t.prototype.addSelfToZr = function(t) {
		if (this.__zr !== t) {
			this.__zr = t;
			var n = this.animators;
			if (n) for (var r = 0; r < n.length; r++) t.animation.addAnimator(n[r]);
			this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t);
		}
	}, t.prototype.removeSelfFromZr = function(t) {
		if (this.__zr) {
			this.__zr = null;
			var n = this.animators;
			if (n) for (var r = 0; r < n.length; r++) t.animation.removeAnimator(n[r]);
			this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t);
		}
	}, t.prototype.animate = function(t, n, r) {
		var a = t ? this[t] : this;
		if (process$1.env.NODE_ENV !== "production" && !a) {
			logError("Property \"" + t + "\" is not existed in element " + this.id);
			return;
		}
		var o = new Animator_default(a, n, r);
		return t && (o.targetName = t), this.addAnimator(o, t), o;
	}, t.prototype.addAnimator = function(t, n) {
		var r = this.__zr, a = this;
		t.during(function() {
			a.updateDuringAnimation(n);
		}).done(function() {
			var n = a.animators, r = indexOf(n, t);
			r >= 0 && n.splice(r, 1);
		}), this.animators.push(t), r && r.animation.addAnimator(t), r && r.wakeUp();
	}, t.prototype.updateDuringAnimation = function(t) {
		this.markRedraw();
	}, t.prototype.stopAnimation = function(t, n) {
		for (var r = this.animators, a = r.length, o = [], s = 0; s < a; s++) {
			var c = r[s];
			!t || t === c.scope ? c.stop(n) : o.push(c);
		}
		return this.animators = o, this;
	}, t.prototype.animateTo = function(t, n, r) {
		animateTo(this, t, n, r);
	}, t.prototype.animateFrom = function(t, n, r) {
		animateTo(this, t, n, r, !0);
	}, t.prototype._transitionState = function(t, n, r, a) {
		for (var o = animateTo(this, n, r, a), s = 0; s < o.length; s++) o[s].__fromStateTransition = t;
	}, t.prototype.getBoundingRect = function() {
		return null;
	}, t.prototype.getPaintRect = function() {
		return null;
	}, t.initDefaultProps = (function() {
		var n = t.prototype;
		n.type = "element", n.name = "", n.ignore = n.silent = n.isGroup = n.draggable = n.dragging = n.ignoreClip = n.__inHover = !1, n.__dirty = 1;
		var r = {};
		function a(t, n, a) {
			r[t + n + a] || (console.warn("DEPRECATED: '" + t + "' has been deprecated. use '" + n + "', '" + a + "' instead"), r[t + n + a] = !0);
		}
		function o(t, r, o, c) {
			Object.defineProperty(n, t, {
				get: function() {
					if (process$1.env.NODE_ENV !== "production" && a(t, o, c), !this[r]) {
						var n = this[r] = [];
						l(this, n);
					}
					return this[r];
				},
				set: function(n) {
					process$1.env.NODE_ENV !== "production" && a(t, o, c), this[o] = n[0], this[c] = n[1], this[r] = n, l(this, n);
				}
			});
			function l(t, n) {
				Object.defineProperty(n, 0, {
					get: function() {
						return t[o];
					},
					set: function(n) {
						t[o] = n;
					}
				}), Object.defineProperty(n, 1, {
					get: function() {
						return t[c];
					},
					set: function(n) {
						t[c] = n;
					}
				});
			}
		}
		Object.defineProperty && (o("position", "_legacyPos", "x", "y"), o("scale", "_legacyScale", "scaleX", "scaleY"), o("origin", "_legacyOrigin", "originX", "originY"));
	})(), t;
}();
mixin(Element, Eventful_default), mixin(Element, Transformable_default);
function animateTo(t, n, r, a, o) {
	r ||= {};
	var s = [];
	animateToShallow(t, "", t, n, r, a, s, o);
	var c = s.length, l = !1, u = r.done, d = r.aborted, f = function() {
		l = !0, c--, c <= 0 && (l ? u && u() : d && d());
	}, p = function() {
		c--, c <= 0 && (l ? u && u() : d && d());
	};
	c || u && u(), s.length > 0 && r.during && s[0].during(function(t, n) {
		r.during(n);
	});
	for (var h = 0; h < s.length; h++) {
		var g = s[h];
		f && g.done(f), p && g.aborted(p), r.force && g.duration(r.duration), g.start(r.easing);
	}
	return s;
}
function copyArrShallow(t, n, r) {
	for (var a = 0; a < r; a++) t[a] = n[a];
}
function is2DArray(t) {
	return isArrayLike(t[0]);
}
function copyValue(t, n, r) {
	if (isArrayLike(n[r])) if (isArrayLike(t[r]) || (t[r] = []), isTypedArray(n[r])) {
		var a = n[r].length;
		t[r].length !== a && (t[r] = new n[r].constructor(a), copyArrShallow(t[r], n[r], a));
	} else {
		var o = n[r], s = t[r], c = o.length;
		if (is2DArray(o)) for (var l = o[0].length, u = 0; u < c; u++) s[u] ? copyArrShallow(s[u], o[u], l) : s[u] = Array.prototype.slice.call(o[u]);
		else copyArrShallow(s, o, c);
		s.length = o.length;
	}
	else t[r] = n[r];
}
function isValueSame(t, n) {
	return t === n || isArrayLike(t) && isArrayLike(n) && is1DArraySame(t, n);
}
function is1DArraySame(t, n) {
	var r = t.length;
	if (r !== n.length) return !1;
	for (var a = 0; a < r; a++) if (t[a] !== n[a]) return !1;
	return !0;
}
function animateToShallow(t, n, r, a, o, s, c, l) {
	for (var u = keys(a), d = o.duration, f = o.delay, p = o.additive, h = o.setToFinal, g = !isObject(s), _ = t.animators, v = [], y = 0; y < u.length; y++) {
		var b = u[y], x = a[b];
		if (x != null && r[b] != null && (g || s[b])) if (isObject(x) && !isArrayLike(x) && !isGradientObject(x)) {
			if (n) {
				l || (r[b] = x, t.updateDuringAnimation(n));
				continue;
			}
			animateToShallow(t, b, r[b], x, o, s && s[b], c, l);
		} else v.push(b);
		else l || (r[b] = x, t.updateDuringAnimation(n), v.push(b));
	}
	var S = v.length;
	if (!p && S) for (var C = 0; C < _.length; C++) {
		var w = _[C];
		if (w.targetName === n && w.stopTracks(v)) {
			var T = indexOf(_, w);
			_.splice(T, 1);
		}
	}
	if (o.force || (v = filter(v, function(t) {
		return !isValueSame(a[t], r[t]);
	}), S = v.length), S > 0 || o.force && !c.length) {
		var E = void 0, D = void 0, O = void 0;
		if (l) {
			D = {}, h && (E = {});
			for (var C = 0; C < S; C++) {
				var b = v[C];
				D[b] = r[b], h ? E[b] = a[b] : r[b] = a[b];
			}
		} else if (h) {
			O = {};
			for (var C = 0; C < S; C++) {
				var b = v[C];
				O[b] = cloneValue(r[b]), copyValue(r, a, b);
			}
		}
		var w = new Animator_default(r, !1, !1, p ? filter(_, function(t) {
			return t.targetName === n;
		}) : null);
		w.targetName = n, o.scope && (w.scope = o.scope), h && E && w.whenWithKeys(0, E, v), O && w.whenWithKeys(0, O, v), w.whenWithKeys(d ?? 500, l ? D : a, v).delay(f || 0), t.addAnimator(w, n), c.push(w);
	}
}
var Element_default = Element;
init_dist$2();
var Group$3 = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this) || this;
		return r.isGroup = !0, r._children = [], r.attr(n), r;
	}
	return n.prototype.childrenRef = function() {
		return this._children;
	}, n.prototype.children = function() {
		return this._children.slice();
	}, n.prototype.childAt = function(t) {
		return this._children[t];
	}, n.prototype.childOfName = function(t) {
		for (var n = this._children, r = 0; r < n.length; r++) if (n[r].name === t) return n[r];
	}, n.prototype.childCount = function() {
		return this._children.length;
	}, n.prototype.add = function(t) {
		if (t && (t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), process$1.env.NODE_ENV !== "production" && t.__hostTarget)) throw "This elemenet has been used as an attachment";
		return this;
	}, n.prototype.addBefore = function(t, n) {
		if (t && t !== this && t.parent !== this && n && n.parent === this) {
			var r = this._children, a = r.indexOf(n);
			a >= 0 && (r.splice(a, 0, t), this._doAdd(t));
		}
		return this;
	}, n.prototype.replace = function(t, n) {
		var r = indexOf(this._children, t);
		return r >= 0 && this.replaceAt(n, r), this;
	}, n.prototype.replaceAt = function(t, n) {
		var r = this._children, a = r[n];
		if (t && t !== this && t.parent !== this && t !== a) {
			r[n] = t, a.parent = null;
			var o = this.__zr;
			o && a.removeSelfFromZr(o), this._doAdd(t);
		}
		return this;
	}, n.prototype._doAdd = function(t) {
		t.parent && t.parent.remove(t), t.parent = this;
		var n = this.__zr;
		n && n !== t.__zr && t.addSelfToZr(n), n && n.refresh();
	}, n.prototype.remove = function(t) {
		var n = this.__zr, r = this._children, a = indexOf(r, t);
		return a < 0 ? this : (r.splice(a, 1), t.parent = null, n && t.removeSelfFromZr(n), n && n.refresh(), this);
	}, n.prototype.removeAll = function() {
		for (var t = this._children, n = this.__zr, r = 0; r < t.length; r++) {
			var a = t[r];
			n && a.removeSelfFromZr(n), a.parent = null;
		}
		return t.length = 0, this;
	}, n.prototype.eachChild = function(t, n) {
		for (var r = this._children, a = 0; a < r.length; a++) {
			var o = r[a];
			t.call(n, o, a);
		}
		return this;
	}, n.prototype.traverse = function(t, n) {
		for (var r = 0; r < this._children.length; r++) {
			var a = this._children[r], o = t.call(n, a);
			a.isGroup && !o && a.traverse(t, n);
		}
		return this;
	}, n.prototype.addSelfToZr = function(n) {
		t.prototype.addSelfToZr.call(this, n);
		for (var r = 0; r < this._children.length; r++) this._children[r].addSelfToZr(n);
	}, n.prototype.removeSelfFromZr = function(n) {
		t.prototype.removeSelfFromZr.call(this, n);
		for (var r = 0; r < this._children.length; r++) this._children[r].removeSelfFromZr(n);
	}, n.prototype.getBoundingRect = function(t) {
		for (var n = new BoundingRect_default(0, 0, 0, 0), r = t || this._children, a = [], o = null, s = 0; s < r.length; s++) {
			var c = r[s];
			if (!(c.ignore || c.invisible)) {
				var l = c.getBoundingRect(), u = c.getLocalTransform(a);
				u ? (BoundingRect_default.applyTransform(n, l, u), o ||= n.clone(), o.union(n)) : (o ||= l.clone(), o.union(l));
			}
		}
		return o || n;
	}, n;
}(Element_default);
Group$3.prototype.type = "group";
var Group_default = Group$3, zrender_exports = /* @__PURE__ */ __export({
	dispose: () => dispose$1,
	disposeAll: () => disposeAll,
	getElementSSRData: () => getElementSSRData,
	getInstance: () => getInstance,
	init: () => init$2,
	registerPainter: () => registerPainter,
	registerSSRDataGetter: () => registerSSRDataGetter,
	version: () => version$1
});
init_dist$2();
var painterCtors = {}, instances$1 = {};
function delInstance(t) {
	delete instances$1[t];
}
function isDarkMode(t) {
	if (!t) return !1;
	if (typeof t == "string") return lum(t, 1) < DARK_MODE_THRESHOLD;
	if (t.colorStops) {
		for (var n = t.colorStops, r = 0, a = n.length, o = 0; o < a; o++) r += lum(n[o].color, 1);
		return r /= a, r < DARK_MODE_THRESHOLD;
	}
	return !1;
}
var ZRender = function() {
	function t(t, n, r) {
		var a = this;
		this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, r ||= {}, this.dom = n, this.id = t;
		var o = new Storage_default(), c = r.renderer || "canvas";
		if (painterCtors[c] || (c = keys(painterCtors)[0]), process$1.env.NODE_ENV !== "production" && !painterCtors[c]) throw Error("Renderer '" + c + "' is not imported. Please import it first.");
		r.useDirtyRect = r.useDirtyRect == null ? !1 : r.useDirtyRect;
		var l = new painterCtors[c](n, o, r, t), u = r.ssr || l.ssrOnly;
		this.storage = o, this.painter = l;
		var d = !env_default.node && !env_default.worker && !u ? new HandlerProxy_default(l.getViewportRoot(), l.root) : null, f = r.useCoarsePointer, p = f == null || f === "auto" ? env_default.touchEventsSupported : !!f, g = 44, _;
		p && (_ = retrieve2(r.pointerSize, g)), this.handler = new Handler_default(o, l, d, l.root, _), this.animation = new Animation_default({ stage: { update: u ? null : function() {
			return a._flush(!0);
		} } }), u || this.animation.start();
	}
	return t.prototype.add = function(t) {
		this._disposed || !t || (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh());
	}, t.prototype.remove = function(t) {
		this._disposed || !t || (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh());
	}, t.prototype.configLayer = function(t, n) {
		this._disposed || (this.painter.configLayer && this.painter.configLayer(t, n), this.refresh());
	}, t.prototype.setBackgroundColor = function(t) {
		this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = isDarkMode(t));
	}, t.prototype.getBackgroundColor = function() {
		return this._backgroundColor;
	}, t.prototype.setDarkMode = function(t) {
		this._darkMode = t;
	}, t.prototype.isDarkMode = function() {
		return this._darkMode;
	}, t.prototype.refreshImmediately = function(t) {
		this._disposed || (t || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
	}, t.prototype.refresh = function() {
		this._disposed || (this._needsRefresh = !0, this.animation.start());
	}, t.prototype.flush = function() {
		this._disposed || this._flush(!1);
	}, t.prototype._flush = function(t) {
		var n, r = getTime();
		this._needsRefresh && (n = !0, this.refreshImmediately(t)), this._needsRefreshHover && (n = !0, this.refreshHoverImmediately());
		var a = getTime();
		n ? (this._stillFrameAccum = 0, this.trigger("rendered", { elapsedTime: a - r })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
	}, t.prototype.setSleepAfterStill = function(t) {
		this._sleepAfterStill = t;
	}, t.prototype.wakeUp = function() {
		this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
	}, t.prototype.refreshHover = function() {
		this._needsRefreshHover = !0;
	}, t.prototype.refreshHoverImmediately = function() {
		this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
	}, t.prototype.resize = function(t) {
		this._disposed || (t ||= {}, this.painter.resize(t.width, t.height), this.handler.resize());
	}, t.prototype.clearAnimation = function() {
		this._disposed || this.animation.clear();
	}, t.prototype.getWidth = function() {
		if (!this._disposed) return this.painter.getWidth();
	}, t.prototype.getHeight = function() {
		if (!this._disposed) return this.painter.getHeight();
	}, t.prototype.setCursorStyle = function(t) {
		this._disposed || this.handler.setCursorStyle(t);
	}, t.prototype.findHover = function(t, n) {
		if (!this._disposed) return this.handler.findHover(t, n);
	}, t.prototype.on = function(t, n, r) {
		return this._disposed || this.handler.on(t, n, r), this;
	}, t.prototype.off = function(t, n) {
		this._disposed || this.handler.off(t, n);
	}, t.prototype.trigger = function(t, n) {
		this._disposed || this.handler.trigger(t, n);
	}, t.prototype.clear = function() {
		if (!this._disposed) {
			for (var t = this.storage.getRoots(), n = 0; n < t.length; n++) t[n] instanceof Group_default && t[n].removeSelfFromZr(this);
			this.storage.delAllRoots(), this.painter.clear();
		}
	}, t.prototype.dispose = function() {
		this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, delInstance(this.id));
	}, t;
}();
function init$2(t, n) {
	var r = new ZRender(guid(), t, n);
	return instances$1[r.id] = r, r;
}
function dispose$1(t) {
	t.dispose();
}
function disposeAll() {
	for (var t in instances$1) instances$1.hasOwnProperty(t) && instances$1[t].dispose();
	instances$1 = {};
}
function getInstance(t) {
	return instances$1[t];
}
function registerPainter(t, n) {
	painterCtors[t] = n;
}
var ssrDataGetter;
function getElementSSRData(t) {
	if (typeof ssrDataGetter == "function") return ssrDataGetter(t);
}
function registerSSRDataGetter(t) {
	ssrDataGetter = t;
}
var version$1 = "5.6.1", RADIAN_EPSILON = 1e-4, ROUND_SUPPORTED_PRECISION_MAX = 20;
function _trim(t) {
	return t.replace(/^\s+|\s+$/g, "");
}
function linearMap$2(t, n, r, a) {
	var o = n[0], s = n[1], c = r[0], l = r[1], u = s - o, d = l - c;
	if (u === 0) return d === 0 ? c : (c + l) / 2;
	if (a) {
		if (u > 0) {
			if (t <= o) return c;
			if (t >= s) return l;
		} else if (t >= o) return c;
		else if (t <= s) return l;
	} else {
		if (t === o) return c;
		if (t === s) return l;
	}
	return (t - o) / u * d + c;
}
function parsePercent$1(t, n) {
	switch (t) {
		case "center":
		case "middle":
			t = "50%";
			break;
		case "left":
		case "top":
			t = "0%";
			break;
		case "right":
		case "bottom":
			t = "100%";
			break;
	}
	return isString(t) ? _trim(t).match(/%$/) ? parseFloat(t) / 100 * n : parseFloat(t) : t == null ? NaN : +t;
}
function round$1(t, n, r) {
	return n ??= 10, n = Math.min(Math.max(0, n), ROUND_SUPPORTED_PRECISION_MAX), t = (+t).toFixed(n), r ? t : +t;
}
function asc$1(t) {
	return t.sort(function(t, n) {
		return t - n;
	}), t;
}
function getPrecision(t) {
	if (t = +t, isNaN(t)) return 0;
	if (t > 1e-14) {
		for (var n = 1, r = 0; r < 15; r++, n *= 10) if (Math.round(t * n) / n === t) return r;
	}
	return getPrecisionSafe(t);
}
function getPrecisionSafe(t) {
	var n = t.toString().toLowerCase(), r = n.indexOf("e"), a = r > 0 ? +n.slice(r + 1) : 0, o = r > 0 ? r : n.length, s = n.indexOf("."), c = s < 0 ? 0 : o - 1 - s;
	return Math.max(0, c - a);
}
function getPixelPrecision(t, n) {
	var r = Math.log, a = Math.LN10, o = Math.floor(r(t[1] - t[0]) / a), s = Math.round(r(Math.abs(n[1] - n[0])) / a), c = Math.min(Math.max(-o + s, 0), 20);
	return isFinite(c) ? c : 20;
}
function getPercentWithPrecision(t, n, r) {
	return t[n] && getPercentSeats(t, r)[n] || 0;
}
function getPercentSeats(t, n) {
	var r = reduce(t, function(t, n) {
		return t + (isNaN(n) ? 0 : n);
	}, 0);
	if (r === 0) return [];
	for (var a = 10 ** n, o = map(t, function(t) {
		return (isNaN(t) ? 0 : t) / r * a * 100;
	}), s = a * 100, c = map(o, function(t) {
		return Math.floor(t);
	}), l = reduce(c, function(t, n) {
		return t + n;
	}, 0), u = map(o, function(t, n) {
		return t - c[n];
	}); l < s;) {
		for (var d = -Infinity, f = null, p = 0, h = u.length; p < h; ++p) u[p] > d && (d = u[p], f = p);
		++c[f], u[f] = 0, ++l;
	}
	return map(c, function(t) {
		return t / a;
	});
}
function addSafe(t, n) {
	var r = Math.max(getPrecision(t), getPrecision(n)), a = t + n;
	return r > ROUND_SUPPORTED_PRECISION_MAX ? a : round$1(a, r);
}
var MAX_SAFE_INTEGER = 9007199254740991;
function remRadian(t) {
	var n = Math.PI * 2;
	return (t % n + n) % n;
}
function isRadianAroundZero(t) {
	return t > -RADIAN_EPSILON && t < RADIAN_EPSILON;
}
var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function parseDate(t) {
	if (t instanceof Date) return t;
	if (isString(t)) {
		var n = TIME_REG.exec(t);
		if (!n) return /* @__PURE__ */ new Date(NaN);
		if (n[8]) {
			var r = +n[4] || 0;
			return n[8].toUpperCase() !== "Z" && (r -= +n[8].slice(0, 3)), new Date(Date.UTC(+n[1], (n[2] || 1) - 1, +n[3] || 1, r, +(n[5] || 0), +n[6] || 0, n[7] ? +n[7].substring(0, 3) : 0));
		} else return new Date(+n[1], (n[2] || 1) - 1, +n[3] || 1, +n[4] || 0, +(n[5] || 0), +n[6] || 0, n[7] ? +n[7].substring(0, 3) : 0);
	} else if (t == null) return /* @__PURE__ */ new Date(NaN);
	return new Date(Math.round(t));
}
function quantity(t) {
	return 10 ** quantityExponent(t);
}
function quantityExponent(t) {
	if (t === 0) return 0;
	var n = Math.floor(Math.log(t) / Math.LN10);
	return t / 10 ** n >= 10 && n++, n;
}
function nice(t, n) {
	var r = quantityExponent(t), a = 10 ** r, o = t / a;
	return t = (n ? o < 1.5 ? 1 : o < 2.5 ? 2 : o < 4 ? 3 : o < 7 ? 5 : 10 : o < 1 ? 1 : o < 2 ? 2 : o < 3 ? 3 : o < 5 ? 5 : 10) * a, r >= -20 ? +t.toFixed(r < 0 ? -r : 0) : t;
}
function quantile(t, n) {
	var r = (t.length - 1) * n + 1, a = Math.floor(r), o = +t[a - 1], s = r - a;
	return s ? o + s * (t[a] - o) : o;
}
function reformIntervals(t) {
	t.sort(function(t, n) {
		return l(t, n, 0) ? -1 : 1;
	});
	for (var n = -Infinity, r = 1, a = 0; a < t.length;) {
		for (var o = t[a].interval, s = t[a].close, c = 0; c < 2; c++) o[c] <= n && (o[c] = n, s[c] = c ? 1 : 1 - r), n = o[c], r = s[c];
		o[0] === o[1] && s[0] * s[1] !== 1 ? t.splice(a, 1) : a++;
	}
	return t;
	function l(t, n, r) {
		return t.interval[r] < n.interval[r] || t.interval[r] === n.interval[r] && (t.close[r] - n.close[r] === (r ? -1 : 1) || !r && l(t, n, 1));
	}
}
function numericToNumber(t) {
	var n = parseFloat(t);
	return n == t && (n !== 0 || !isString(t) || t.indexOf("x") <= 0) ? n : NaN;
}
function isNumeric(t) {
	return !isNaN(numericToNumber(t));
}
function getRandomIdBase() {
	return Math.round(Math.random() * 9);
}
function getGreatestCommonDividor(t, n) {
	return n === 0 ? t : getGreatestCommonDividor(n, t % n);
}
function getLeastCommonMultiple(t, n) {
	return t == null ? n : n == null ? t : t * n / getGreatestCommonDividor(t, n);
}
init_dist$2();
var ECHARTS_PREFIX = "[ECharts] ", storedLogs = {}, hasConsole = typeof console < "u" && console.warn && console.log;
function outputLog(t, n, r) {
	if (hasConsole) {
		if (r) {
			if (storedLogs[n]) return;
			storedLogs[n] = !0;
		}
		console[t](ECHARTS_PREFIX + n);
	}
}
function log(t, n) {
	outputLog("log", t, n);
}
function warn(t, n) {
	outputLog("warn", t, n);
}
function error(t, n) {
	outputLog("error", t, n);
}
function deprecateLog(t) {
	process$1.env.NODE_ENV !== "production" && outputLog("warn", "DEPRECATED: " + t, !0);
}
function deprecateReplaceLog(t, n, r) {
	process$1.env.NODE_ENV !== "production" && deprecateLog((r ? "[" + r + "]" : "") + (t + " is deprecated, use " + n + " instead."));
}
function makePrintable() {
	var t = [...arguments], n = "";
	if (process$1.env.NODE_ENV !== "production") {
		var r = function(t) {
			return t === void 0 ? "undefined" : t === Infinity ? "Infinity" : t === -Infinity ? "-Infinity" : eqNaN(t) ? "NaN" : t instanceof Date ? "Date(" + t.toISOString() + ")" : isFunction(t) ? "function () { ... }" : isRegExp(t) ? t + "" : null;
		};
		n = map(t, function(t) {
			if (isString(t)) return t;
			var n = r(t);
			if (n != null) return n;
			if (typeof JSON < "u" && JSON.stringify) try {
				return JSON.stringify(t, function(t, n) {
					return r(n) ?? n;
				});
			} catch {
				return "?";
			}
			else return "?";
		}).join(" ");
	}
	return n;
}
function throwError(t) {
	throw Error(t);
}
init_dist$2();
function interpolateNumber(t, n, r) {
	return (n - t) * r + t;
}
var DUMMY_COMPONENT_NAME_PREFIX = "series\0", INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
function normalizeToArray(t) {
	return t instanceof Array ? t : t == null ? [] : [t];
}
function defaultEmphasis(t, n, r) {
	if (t) {
		t[n] = t[n] || {}, t.emphasis = t.emphasis || {}, t.emphasis[n] = t.emphasis[n] || {};
		for (var a = 0, o = r.length; a < o; a++) {
			var s = r[a];
			!t.emphasis[n].hasOwnProperty(s) && t[n].hasOwnProperty(s) && (t.emphasis[n][s] = t[n][s]);
		}
	}
}
var TEXT_STYLE_OPTIONS = /* @__PURE__ */ "fontStyle.fontWeight.fontSize.fontFamily.rich.tag.color.textBorderColor.textBorderWidth.width.height.lineHeight.align.verticalAlign.baseline.shadowColor.shadowBlur.shadowOffsetX.shadowOffsetY.textShadowColor.textShadowBlur.textShadowOffsetX.textShadowOffsetY.backgroundColor.borderColor.borderWidth.borderRadius.padding".split(".");
function getDataItemValue(t) {
	return isObject(t) && !isArray(t) && !(t instanceof Date) ? t.value : t;
}
function isDataItemOption(t) {
	return isObject(t) && !(t instanceof Array);
}
function mappingToExists(t, n, r) {
	var a = r === "normalMerge", o = r === "replaceMerge", c = r === "replaceAll";
	t ||= [], n = (n || []).slice();
	var l = createHashMap();
	each(n, function(t, r) {
		if (!isObject(t)) {
			n[r] = null;
			return;
		}
		process$1.env.NODE_ENV !== "production" && (t.id != null && !isValidIdOrName(t.id) && warnInvalidateIdOrName(t.id), t.name != null && !isValidIdOrName(t.name) && warnInvalidateIdOrName(t.name));
	});
	var u = prepareResult(t, l, r);
	return (a || o) && mappingById(u, t, l, n), a && mappingByName(u, n), a || o ? mappingByIndex(u, n, o) : c && mappingInReplaceAllMode(u, n), makeIdAndName(u), u;
}
function prepareResult(t, n, r) {
	var a = [];
	if (r === "replaceAll") return a;
	for (var o = 0; o < t.length; o++) {
		var s = t[o];
		s && s.id != null && n.set(s.id, o), a.push({
			existing: r === "replaceMerge" || isComponentIdInternal(s) ? null : s,
			newOption: null,
			keyInfo: null,
			brandNew: null
		});
	}
	return a;
}
function mappingById(t, n, r, a) {
	each(a, function(o, s) {
		if (!(!o || o.id == null)) {
			var c = makeComparableKey(o.id), l = r.get(c);
			if (l != null) {
				var u = t[l];
				assert(!u.newOption, "Duplicated option on id \"" + c + "\"."), u.newOption = o, u.existing = n[l], a[s] = null;
			}
		}
	});
}
function mappingByName(t, n) {
	each(n, function(r, a) {
		if (!(!r || r.name == null)) for (var o = 0; o < t.length; o++) {
			var s = t[o].existing;
			if (!t[o].newOption && s && (s.id == null || r.id == null) && !isComponentIdInternal(r) && !isComponentIdInternal(s) && keyExistAndEqual("name", s, r)) {
				t[o].newOption = r, n[a] = null;
				return;
			}
		}
	});
}
function mappingByIndex(t, n, r) {
	each(n, function(n) {
		if (n) {
			for (var a, o = 0; (a = t[o]) && (a.newOption || isComponentIdInternal(a.existing) || a.existing && n.id != null && !keyExistAndEqual("id", n, a.existing));) o++;
			a ? (a.newOption = n, a.brandNew = r) : t.push({
				newOption: n,
				brandNew: r,
				existing: null,
				keyInfo: null
			}), o++;
		}
	});
}
function mappingInReplaceAllMode(t, n) {
	each(n, function(n) {
		t.push({
			newOption: n,
			brandNew: !0,
			existing: null,
			keyInfo: null
		});
	});
}
function makeIdAndName(t) {
	var n = createHashMap();
	each(t, function(t) {
		var r = t.existing;
		r && n.set(r.id, t);
	}), each(t, function(t) {
		var r = t.newOption;
		assert(!r || r.id == null || !n.get(r.id) || n.get(r.id) === t, "id duplicates: " + (r && r.id)), r && r.id != null && n.set(r.id, t), !t.keyInfo && (t.keyInfo = {});
	}), each(t, function(t, r) {
		var a = t.existing, o = t.newOption, s = t.keyInfo;
		if (isObject(o)) {
			if (s.name = o.name == null ? a ? a.name : DUMMY_COMPONENT_NAME_PREFIX + r : makeComparableKey(o.name), a) s.id = makeComparableKey(a.id);
			else if (o.id != null) s.id = makeComparableKey(o.id);
			else {
				var c = 0;
				do
					s.id = "\0" + s.name + "\0" + c++;
				while (n.get(s.id));
			}
			n.set(s.id, t);
		}
	});
}
function keyExistAndEqual(t, n, r) {
	var a = convertOptionIdName(n[t], null), o = convertOptionIdName(r[t], null);
	return a != null && o != null && a === o;
}
function makeComparableKey(t) {
	if (process$1.env.NODE_ENV !== "production" && t == null) throw Error();
	return convertOptionIdName(t, "");
}
function convertOptionIdName(t, n) {
	return t == null ? n : isString(t) ? t : isNumber(t) || isStringSafe(t) ? t + "" : n;
}
function warnInvalidateIdOrName(t) {
	process$1.env.NODE_ENV !== "production" && warn("`" + t + "` is invalid id or name. Must be a string or number.");
}
function isValidIdOrName(t) {
	return isStringSafe(t) || isNumeric(t);
}
function isNameSpecified(t) {
	var n = t.name;
	return !!(n && n.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
function isComponentIdInternal(t) {
	return t && t.id != null && makeComparableKey(t.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
}
function makeInternalComponentId(t) {
	return INTERNAL_COMPONENT_ID_PREFIX + t;
}
function setComponentTypeToKeyInfo(t, n, r) {
	each(t, function(t) {
		var a = t.newOption;
		isObject(a) && (t.keyInfo.mainType = n, t.keyInfo.subType = determineSubType(n, a, t.existing, r));
	});
}
function determineSubType(t, n, r, a) {
	return n.type ? n.type : r ? r.subType : a.determineSubType(t, n);
}
function compressBatches(t, n) {
	var r = {}, a = {};
	return o(t || [], r), o(n || [], a, r), [s(r), s(a)];
	function o(t, n, r) {
		for (var a = 0, o = t.length; a < o; a++) {
			var s = convertOptionIdName(t[a].seriesId, null);
			if (s == null) return;
			for (var c = normalizeToArray(t[a].dataIndex), l = r && r[s], u = 0, d = c.length; u < d; u++) {
				var f = c[u];
				l && l[f] ? l[f] = null : (n[s] || (n[s] = {}))[f] = 1;
			}
		}
	}
	function s(t, n) {
		var r = [];
		for (var a in t) if (t.hasOwnProperty(a) && t[a] != null) if (n) r.push(+a);
		else {
			var o = s(t[a], !0);
			o.length && r.push({
				seriesId: a,
				dataIndex: o
			});
		}
		return r;
	}
}
function queryDataIndex(t, n) {
	if (n.dataIndexInside != null) return n.dataIndexInside;
	if (n.dataIndex != null) return isArray(n.dataIndex) ? map(n.dataIndex, function(n) {
		return t.indexOfRawIndex(n);
	}) : t.indexOfRawIndex(n.dataIndex);
	if (n.name != null) return isArray(n.name) ? map(n.name, function(n) {
		return t.indexOfName(n);
	}) : t.indexOfName(n.name);
}
function makeInner() {
	var t = "__ec_inner_" + innerUniqueIndex++;
	return function(n) {
		return n[t] || (n[t] = {});
	};
}
var innerUniqueIndex = getRandomIdBase();
function parseFinder(t, n, r) {
	var a = preParseFinder(n, r), o = a.mainTypeSpecified, s = a.queryOptionMap, c = a.others, l = r ? r.defaultMainType : null;
	return !o && l && s.set(l, {}), s.each(function(n, a) {
		var o = queryReferringComponents(t, a, n, {
			useDefault: l === a,
			enableAll: r && r.enableAll != null ? r.enableAll : !0,
			enableNone: r && r.enableNone != null ? r.enableNone : !0
		});
		c[a + "Models"] = o.models, c[a + "Model"] = o.models[0];
	}), c;
}
function preParseFinder(t, n) {
	var r;
	if (isString(t)) {
		var a = {};
		a[t + "Index"] = 0, r = a;
	} else r = t;
	var o = createHashMap(), s = {}, c = !1;
	return each(r, function(t, r) {
		if (r === "dataIndex" || r === "dataIndexInside") {
			s[r] = t;
			return;
		}
		var a = r.match(/^(\w+)(Index|Id|Name)$/) || [], l = a[1], u = (a[2] || "").toLowerCase();
		if (!(!l || !u || n && n.includeMainTypes && indexOf(n.includeMainTypes, l) < 0)) {
			c ||= !!l;
			var d = o.get(l) || o.set(l, {});
			d[u] = t;
		}
	}), {
		mainTypeSpecified: c,
		queryOptionMap: o,
		others: s
	};
}
var SINGLE_REFERRING = {
	useDefault: !0,
	enableAll: !1,
	enableNone: !1
}, MULTIPLE_REFERRING = {
	useDefault: !1,
	enableAll: !0,
	enableNone: !0
};
function queryReferringComponents(t, n, r, a) {
	a ||= SINGLE_REFERRING;
	var o = r.index, s = r.id, c = r.name, l = {
		models: null,
		specified: o != null || s != null || c != null
	};
	if (!l.specified) {
		var u = void 0;
		return l.models = a.useDefault && (u = t.getComponent(n)) ? [u] : [], l;
	}
	return o === "none" || o === !1 ? (assert(a.enableNone, "`\"none\"` or `false` is not a valid value on index option."), l.models = [], l) : (o === "all" && (assert(a.enableAll, "`\"all\"` is not a valid value on index option."), o = s = c = null), l.models = t.queryComponents({
		mainType: n,
		index: o,
		id: s,
		name: c
	}), l);
}
function setAttribute(t, n, r) {
	t.setAttribute ? t.setAttribute(n, r) : t[n] = r;
}
function getAttribute(t, n) {
	return t.getAttribute ? t.getAttribute(n) : t[n];
}
function getTooltipRenderMode(t) {
	return t === "auto" ? env_default.domSupported ? "html" : "richText" : t || "html";
}
function groupData(t, n) {
	var r = createHashMap(), a = [];
	return each(t, function(t) {
		var o = n(t);
		(r.get(o) || (a.push(o), r.set(o, []))).push(t);
	}), {
		keys: a,
		buckets: r
	};
}
function interpolateRawValues(t, n, r, a, o) {
	var s = n == null || n === "auto";
	if (a == null) return a;
	if (isNumber(a)) {
		var c = interpolateNumber(r || 0, a, o);
		return round$1(c, s ? Math.max(getPrecision(r || 0), getPrecision(a)) : n);
	} else if (isString(a)) return o < 1 ? r : a;
	else {
		for (var l = [], u = r, d = a, f = Math.max(u ? u.length : 0, d.length), p = 0; p < f; ++p) {
			var h = t.getDimensionInfo(p);
			if (h && h.type === "ordinal") l[p] = (o < 1 && u ? u : d)[p];
			else {
				var g = u && u[p] ? u[p] : 0, _ = d[p], c = interpolateNumber(g, _, o);
				l[p] = round$1(c, s ? Math.max(getPrecision(g), getPrecision(_)) : n);
			}
		}
		return l;
	}
}
init_dist$2();
var TYPE_DELIMITER = ".", IS_CONTAINER = "___EC__COMPONENT__CONTAINER___", IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
function parseClassType(t) {
	var n = {
		main: "",
		sub: ""
	};
	if (t) {
		var r = t.split(TYPE_DELIMITER);
		n.main = r[0] || "", n.sub = r[1] || "";
	}
	return n;
}
function checkClassType(t) {
	assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), "componentType \"" + t + "\" illegal");
}
function isExtendedClass(t) {
	return !!(t && t[IS_EXTENDED_CLASS]);
}
function enableClassExtend(t, n) {
	t.$constructor = t, t.extend = function(t) {
		process$1.env.NODE_ENV !== "production" && each(n, function(n) {
			t[n] || console.warn("Method `" + n + "` should be implemented" + (t.type ? " in " + t.type : "") + ".");
		});
		var r = this, a;
		return isESClass(r) ? a = function(t) {
			__extends(n, t);
			function n() {
				return t.apply(this, arguments) || this;
			}
			return n;
		}(r) : (a = function() {
			(t.$constructor || r).apply(this, arguments);
		}, inherits(a, this)), extend(a.prototype, t), a[IS_EXTENDED_CLASS] = !0, a.extend = this.extend, a.superCall = superCall, a.superApply = superApply, a.superClass = r, a;
	};
}
function isESClass(t) {
	return isFunction(t) && /^class\s/.test(Function.prototype.toString.call(t));
}
function mountExtend(t, n) {
	t.extend = n.extend;
}
var classBase = Math.round(Math.random() * 10);
function enableClassCheck(t) {
	var n = ["__\0is_clz", classBase++].join("_");
	t.prototype[n] = !0, process$1.env.NODE_ENV !== "production" && assert(!t.isInstance, "The method \"is\" can not be defined."), t.isInstance = function(t) {
		return !!(t && t[n]);
	};
}
function superCall(t, n) {
	var r = [...arguments].slice(2);
	return this.superClass.prototype[n].apply(t, r);
}
function superApply(t, n, r) {
	return this.superClass.prototype[n].apply(t, r);
}
function enableClassManagement(t) {
	var n = {};
	t.registerClass = function(t) {
		var a = t.type || t.prototype.type;
		if (a) {
			checkClassType(a), t.prototype.type = a;
			var o = parseClassType(a);
			if (!o.sub) process$1.env.NODE_ENV !== "production" && n[o.main] && console.warn(o.main + " exists."), n[o.main] = t;
			else if (o.sub !== IS_CONTAINER) {
				var c = r(o);
				c[o.sub] = t;
			}
		}
		return t;
	}, t.getClass = function(t, r, a) {
		var o = n[t];
		if (o && o[IS_CONTAINER] && (o = r ? o[r] : null), a && !o) throw Error(r ? "Component " + t + "." + (r || "") + " is used but not imported." : t + ".type should be specified.");
		return o;
	}, t.getClassesByMainType = function(t) {
		var r = parseClassType(t), a = [], o = n[r.main];
		return o && o[IS_CONTAINER] ? each(o, function(t, n) {
			n !== IS_CONTAINER && a.push(t);
		}) : a.push(o), a;
	}, t.hasClass = function(t) {
		return !!n[parseClassType(t).main];
	}, t.getAllClassMainTypes = function() {
		var t = [];
		return each(n, function(n, r) {
			t.push(r);
		}), t;
	}, t.hasSubTypes = function(t) {
		var r = n[parseClassType(t).main];
		return r && r[IS_CONTAINER];
	};
	function r(t) {
		var r = n[t.main];
		return (!r || !r[IS_CONTAINER]) && (r = n[t.main] = {}, r[IS_CONTAINER] = !0), r;
	}
}
function makeStyleMapper(t, n) {
	for (var r = 0; r < t.length; r++) t[r][1] || (t[r][1] = t[r][0]);
	return n ||= !1, function(r, a, o) {
		for (var s = {}, c = 0; c < t.length; c++) {
			var l = t[c][1];
			if (!(a && indexOf(a, l) >= 0 || o && indexOf(o, l) < 0)) {
				var u = r.getShallow(l, n);
				u != null && (s[t[c][0]] = u);
			}
		}
		return s;
	};
}
var getAreaStyle = makeStyleMapper([
	["fill", "color"],
	["shadowBlur"],
	["shadowOffsetX"],
	["shadowOffsetY"],
	["opacity"],
	["shadowColor"]
]), AreaStyleMixin = function() {
	function t() {}
	return t.prototype.getAreaStyle = function(t, n) {
		return getAreaStyle(this, t, n);
	}, t;
}(), globalImageCache = new LRU_default(50);
function findExistImage(t) {
	if (typeof t == "string") {
		var n = globalImageCache.get(t);
		return n && n.image;
	} else return t;
}
function createOrUpdateImage(t, n, r, a, o) {
	if (t) if (typeof t == "string") {
		if (n && n.__zrImageSrc === t || !r) return n;
		var s = globalImageCache.get(t), c = {
			hostEl: r,
			cb: a,
			cbPayload: o
		};
		return s ? (n = s.image, !isImageReady(n) && s.pending.push(c)) : (n = platformApi.loadImage(t, imageOnLoad, imageOnLoad), n.__zrImageSrc = t, globalImageCache.put(t, n.__cachedImgObj = {
			image: n,
			pending: [c]
		})), n;
	} else return t;
	else return n;
}
function imageOnLoad() {
	var t = this.__cachedImgObj;
	this.onload = this.onerror = this.__cachedImgObj = null;
	for (var n = 0; n < t.pending.length; n++) {
		var r = t.pending[n], a = r.cb;
		a && a(this, r.cbPayload), r.hostEl.dirty();
	}
	t.pending.length = 0;
}
function isImageReady(t) {
	return t && t.width && t.height;
}
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function truncateText(t, n, r, a, o) {
	var s = {};
	return truncateText2(s, t, n, r, a, o), s.text;
}
function truncateText2(t, n, r, a, o, s) {
	if (!r) {
		t.text = "", t.isTruncated = !1;
		return;
	}
	var c = (n + "").split("\n");
	s = prepareTruncateOptions(r, a, o, s);
	for (var l = !1, u = {}, d = 0, f = c.length; d < f; d++) truncateSingleLine(u, c[d], s), c[d] = u.textLine, l ||= u.isTruncated;
	t.text = c.join("\n"), t.isTruncated = l;
}
function prepareTruncateOptions(t, n, r, a) {
	a ||= {};
	var o = extend({}, a);
	o.font = n, r = retrieve2(r, "..."), o.maxIterations = retrieve2(a.maxIterations, 2);
	var s = o.minChar = retrieve2(a.minChar, 0);
	o.cnCharWidth = getWidth("国", n);
	var c = o.ascCharWidth = getWidth("a", n);
	o.placeholder = retrieve2(a.placeholder, "");
	for (var l = t = Math.max(0, t - 1), u = 0; u < s && l >= c; u++) l -= c;
	var d = getWidth(r, n);
	return d > l && (r = "", d = 0), l = t - d, o.ellipsis = r, o.ellipsisWidth = d, o.contentWidth = l, o.containerWidth = t, o;
}
function truncateSingleLine(t, n, r) {
	var a = r.containerWidth, o = r.font, s = r.contentWidth;
	if (!a) {
		t.textLine = "", t.isTruncated = !1;
		return;
	}
	var c = getWidth(n, o);
	if (c <= a) {
		t.textLine = n, t.isTruncated = !1;
		return;
	}
	for (var l = 0;; l++) {
		if (c <= s || l >= r.maxIterations) {
			n += r.ellipsis;
			break;
		}
		var u = l === 0 ? estimateLength(n, s, r.ascCharWidth, r.cnCharWidth) : c > 0 ? Math.floor(n.length * s / c) : 0;
		n = n.substr(0, u), c = getWidth(n, o);
	}
	n === "" && (n = r.placeholder), t.textLine = n, t.isTruncated = !0;
}
function estimateLength(t, n, r, a) {
	for (var o = 0, s = 0, c = t.length; s < c && o < n; s++) {
		var l = t.charCodeAt(s);
		o += 0 <= l && l <= 127 ? r : a;
	}
	return s;
}
function parsePlainText(t, n) {
	t != null && (t += "");
	var r = n.overflow, a = n.padding, o = n.font, s = r === "truncate", c = getLineHeight(o), l = retrieve2(n.lineHeight, c), u = !!n.backgroundColor, d = n.lineOverflow === "truncate", f = !1, p = n.width, h = p != null && (r === "break" || r === "breakAll") ? t ? wrapText(t, n.font, p, r === "breakAll", 0).lines : [] : t ? t.split("\n") : [], g = h.length * l, _ = retrieve2(n.height, g);
	if (g > _ && d) {
		var v = Math.floor(_ / l);
		f ||= h.length > v, h = h.slice(0, v);
	}
	if (t && s && p != null) for (var y = prepareTruncateOptions(p, o, n.ellipsis, {
		minChar: n.truncateMinChar,
		placeholder: n.placeholder
	}), b = {}, x = 0; x < h.length; x++) truncateSingleLine(b, h[x], y), h[x] = b.textLine, f ||= b.isTruncated;
	for (var S = _, C = 0, x = 0; x < h.length; x++) C = Math.max(getWidth(h[x], o), C);
	p ??= C;
	var w = C;
	return a && (S += a[0] + a[2], w += a[1] + a[3], p += a[1] + a[3]), u && (w = p), {
		lines: h,
		height: _,
		outerWidth: w,
		outerHeight: S,
		lineHeight: l,
		calculatedLineHeight: c,
		contentWidth: C,
		contentHeight: g,
		width: p,
		isTruncated: f
	};
}
var RichTextToken = function() {
	function t() {}
	return t;
}(), RichTextLine = function() {
	function t(t) {
		this.tokens = [], t && (this.tokens = t);
	}
	return t;
}(), RichTextContentBlock = function() {
	function t() {
		this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = !1;
	}
	return t;
}();
function parseRichText(t, n) {
	var r = new RichTextContentBlock();
	if (t != null && (t += ""), !t) return r;
	for (var a = n.width, o = n.height, s = n.overflow, c = (s === "break" || s === "breakAll") && a != null ? {
		width: a,
		accumWidth: 0,
		breakAll: s === "breakAll"
	} : null, l = STYLE_REG.lastIndex = 0, u; (u = STYLE_REG.exec(t)) != null;) {
		var d = u.index;
		d > l && pushTokens(r, t.substring(l, d), n, c), pushTokens(r, u[2], n, c, u[1]), l = STYLE_REG.lastIndex;
	}
	l < t.length && pushTokens(r, t.substring(l, t.length), n, c);
	var f = [], p = 0, h = 0, g = n.padding, _ = s === "truncate", v = n.lineOverflow === "truncate", y = {};
	function b(t, n, r) {
		t.width = n, t.lineHeight = r, p += r, h = Math.max(h, n);
	}
	outer: for (var x = 0; x < r.lines.length; x++) {
		for (var S = r.lines[x], C = 0, w = 0, T = 0; T < S.tokens.length; T++) {
			var E = S.tokens[T], D = E.styleName && n.rich[E.styleName] || {}, O = E.textPadding = D.padding, A = O ? O[1] + O[3] : 0, j = E.font = D.font || n.font;
			E.contentHeight = getLineHeight(j);
			var M = retrieve2(D.height, E.contentHeight);
			if (E.innerHeight = M, O && (M += O[0] + O[2]), E.height = M, E.lineHeight = retrieve3(D.lineHeight, n.lineHeight, M), E.align = D && D.align || n.align, E.verticalAlign = D && D.verticalAlign || "middle", v && o != null && p + E.lineHeight > o) {
				var N = r.lines.length;
				T > 0 ? (S.tokens = S.tokens.slice(0, T), b(S, w, C), r.lines = r.lines.slice(0, x + 1)) : r.lines = r.lines.slice(0, x), r.isTruncated = r.isTruncated || r.lines.length < N;
				break outer;
			}
			var P = D.width, F = P == null || P === "auto";
			if (typeof P == "string" && P.charAt(P.length - 1) === "%") E.percentWidth = P, f.push(E), E.contentWidth = getWidth(E.text, j);
			else {
				if (F) {
					var I = D.backgroundColor, L = I && I.image;
					L && (L = findExistImage(L), isImageReady(L) && (E.width = Math.max(E.width, L.width * M / L.height)));
				}
				var R = _ && a != null ? a - w : null;
				R != null && R < E.width ? !F || R < A ? (E.text = "", E.width = E.contentWidth = 0) : (truncateText2(y, E.text, R - A, j, n.ellipsis, { minChar: n.truncateMinChar }), E.text = y.text, r.isTruncated = r.isTruncated || y.isTruncated, E.width = E.contentWidth = getWidth(E.text, j)) : E.contentWidth = getWidth(E.text, j);
			}
			E.width += A, w += E.width, D && (C = Math.max(C, E.lineHeight));
		}
		b(S, w, C);
	}
	r.outerWidth = r.width = retrieve2(a, h), r.outerHeight = r.height = retrieve2(o, p), r.contentHeight = p, r.contentWidth = h, g && (r.outerWidth += g[1] + g[3], r.outerHeight += g[0] + g[2]);
	for (var x = 0; x < f.length; x++) {
		var E = f[x], z = E.percentWidth;
		E.width = parseInt(z, 10) / 100 * r.width;
	}
	return r;
}
function pushTokens(t, n, r, a, o) {
	var s = n === "", c = o && r.rich[o] || {}, l = t.lines, u = c.font || r.font, d = !1, f, p;
	if (a) {
		var h = c.padding, g = h ? h[1] + h[3] : 0;
		if (c.width != null && c.width !== "auto") {
			var _ = parsePercent(c.width, a.width) + g;
			l.length > 0 && _ + a.accumWidth > a.width && (f = n.split("\n"), d = !0), a.accumWidth = _;
		} else {
			var v = wrapText(n, u, a.width, a.breakAll, a.accumWidth);
			a.accumWidth = v.accumWidth + g, p = v.linesWidths, f = v.lines;
		}
	} else f = n.split("\n");
	for (var y = 0; y < f.length; y++) {
		var b = f[y], x = new RichTextToken();
		if (x.styleName = o, x.text = b, x.isLineHolder = !b && !s, typeof c.width == "number" ? x.width = c.width : x.width = p ? p[y] : getWidth(b, u), !y && !d) {
			var S = (l[l.length - 1] || (l[0] = new RichTextLine())).tokens, C = S.length;
			C === 1 && S[0].isLineHolder ? S[0] = x : (b || !C || s) && S.push(x);
		} else l.push(new RichTextLine([x]));
	}
}
function isAlphabeticLetter(t) {
	var n = t.charCodeAt(0);
	return n >= 32 && n <= 591 || n >= 880 && n <= 4351 || n >= 4608 && n <= 5119 || n >= 7680 && n <= 8303;
}
var breakCharMap = reduce(",&?/;] ".split(""), function(t, n) {
	return t[n] = !0, t;
}, {});
function isWordBreakChar(t) {
	return isAlphabeticLetter(t) ? !!breakCharMap[t] : !0;
}
function wrapText(t, n, r, a, o) {
	for (var s = [], c = [], l = "", u = "", d = 0, f = 0, p = 0; p < t.length; p++) {
		var h = t.charAt(p);
		if (h === "\n") {
			u && (l += u, f += d), s.push(l), c.push(f), l = "", u = "", d = 0, f = 0;
			continue;
		}
		var g = getWidth(h, n), _ = a ? !1 : !isWordBreakChar(h);
		if (s.length ? f + g > r : o + f + g > r) {
			f ? (l || u) && (_ ? (l || (l = u, u = "", d = 0, f = d), s.push(l), c.push(f - d), u += h, d += g, l = "", f = d) : (u && (l += u, u = "", d = 0), s.push(l), c.push(f), l = h, f = g)) : _ ? (s.push(u), c.push(d), u = h, d = g) : (s.push(h), c.push(g));
			continue;
		}
		f += g, _ ? (u += h, d += g) : (u && (l += u, u = "", d = 0), l += h);
	}
	return !s.length && !l && (l = t, u = "", d = 0), u && (l += u), l && (s.push(l), c.push(f)), s.length === 1 && (f += o), {
		accumWidth: f,
		lines: s,
		linesWidths: c
	};
}
var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10), DEFAULT_COMMON_STYLE = {
	shadowBlur: 0,
	shadowOffsetX: 0,
	shadowOffsetY: 0,
	shadowColor: "#000",
	opacity: 1,
	blend: "source-over"
}, DEFAULT_COMMON_ANIMATION_PROPS = { style: {
	shadowBlur: !0,
	shadowOffsetX: !0,
	shadowOffsetY: !0,
	shadowColor: !0,
	opacity: !0
} };
DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = !0;
var PRIMARY_STATES_KEYS = [
	"z",
	"z2",
	"invisible"
], PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"], Displayable = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype._init = function(n) {
		for (var r = keys(n), a = 0; a < r.length; a++) {
			var o = r[a];
			o === "style" ? this.useStyle(n[o]) : t.prototype.attrKV.call(this, o, n[o]);
		}
		this.style || this.useStyle({});
	}, n.prototype.beforeBrush = function() {}, n.prototype.afterBrush = function() {}, n.prototype.innerBeforeBrush = function() {}, n.prototype.innerAfterBrush = function() {}, n.prototype.shouldBePainted = function(t, n, r, a) {
		var o = this.transform;
		if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, t, n) || o && !o[0] && !o[3]) return !1;
		if (r && this.__clipPaths) {
			for (var s = 0; s < this.__clipPaths.length; ++s) if (this.__clipPaths[s].isZeroArea()) return !1;
		}
		if (a && this.parent) for (var c = this.parent; c;) {
			if (c.ignore) return !1;
			c = c.parent;
		}
		return !0;
	}, n.prototype.contain = function(t, n) {
		return this.rectContain(t, n);
	}, n.prototype.traverse = function(t, n) {
		t.call(n, this);
	}, n.prototype.rectContain = function(t, n) {
		var r = this.transformCoordToLocal(t, n);
		return this.getBoundingRect().contain(r[0], r[1]);
	}, n.prototype.getPaintRect = function() {
		var t = this._paintRect;
		if (!this._paintRect || this.__dirty) {
			var n = this.transform, r = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, c = a.shadowOffsetY || 0;
			t = this._paintRect ||= new BoundingRect_default(0, 0, 0, 0), n ? BoundingRect_default.applyTransform(t, r, n) : t.copy(r), (o || s || c) && (t.width += o * 2 + Math.abs(s), t.height += o * 2 + Math.abs(c), t.x = Math.min(t.x, t.x + s - o), t.y = Math.min(t.y, t.y + c - o));
			var l = this.dirtyRectTolerance;
			t.isZero() || (t.x = Math.floor(t.x - l), t.y = Math.floor(t.y - l), t.width = Math.ceil(t.width + 1 + l * 2), t.height = Math.ceil(t.height + 1 + l * 2));
		}
		return t;
	}, n.prototype.setPrevPaintRect = function(t) {
		t ? (this._prevPaintRect = this._prevPaintRect || new BoundingRect_default(0, 0, 0, 0), this._prevPaintRect.copy(t)) : this._prevPaintRect = null;
	}, n.prototype.getPrevPaintRect = function() {
		return this._prevPaintRect;
	}, n.prototype.animateStyle = function(t) {
		return this.animate("style", t);
	}, n.prototype.updateDuringAnimation = function(t) {
		t === "style" ? this.dirtyStyle() : this.markRedraw();
	}, n.prototype.attrKV = function(n, r) {
		n === "style" ? this.style ? this.setStyle(r) : this.useStyle(r) : t.prototype.attrKV.call(this, n, r);
	}, n.prototype.setStyle = function(t, n) {
		return typeof t == "string" ? this.style[t] = n : extend(this.style, t), this.dirtyStyle(), this;
	}, n.prototype.dirtyStyle = function(t) {
		t || this.markRedraw(), this.__dirty |= 2, this._rect &&= null;
	}, n.prototype.dirty = function() {
		this.dirtyStyle();
	}, n.prototype.styleChanged = function() {
		return !!(this.__dirty & 2);
	}, n.prototype.styleUpdated = function() {
		this.__dirty &= -3;
	}, n.prototype.createStyle = function(t) {
		return createObject(DEFAULT_COMMON_STYLE, t);
	}, n.prototype.useStyle = function(t) {
		t[STYLE_MAGIC_KEY] || (t = this.createStyle(t)), this.__inHover ? this.__hoverStyle = t : this.style = t, this.dirtyStyle();
	}, n.prototype.isStyleObject = function(t) {
		return t[STYLE_MAGIC_KEY];
	}, n.prototype._innerSaveToNormal = function(n) {
		t.prototype._innerSaveToNormal.call(this, n);
		var r = this._normalState;
		n.style && !r.style && (r.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(n, r, PRIMARY_STATES_KEYS);
	}, n.prototype._applyStateObj = function(n, r, a, o, s, c) {
		t.prototype._applyStateObj.call(this, n, r, a, o, s, c);
		var l = !(r && o), u;
		if (r && r.style ? s ? o ? u = r.style : (u = this._mergeStyle(this.createStyle(), a.style), this._mergeStyle(u, r.style)) : (u = this._mergeStyle(this.createStyle(), o ? this.style : a.style), this._mergeStyle(u, r.style)) : l && (u = a.style), u) if (s) {
			var d = this.style;
			if (this.style = this.createStyle(l ? {} : d), l) for (var f = keys(d), p = 0; p < f.length; p++) {
				var h = f[p];
				h in u && (u[h] = u[h], this.style[h] = d[h]);
			}
			for (var g = keys(u), p = 0; p < g.length; p++) {
				var h = g[p];
				this.style[h] = this.style[h];
			}
			this._transitionState(n, { style: u }, c, this.getAnimationStyleProps());
		} else this.useStyle(u);
		for (var _ = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS, p = 0; p < _.length; p++) {
			var h = _[p];
			r && r[h] != null ? this[h] = r[h] : l && a[h] != null && (this[h] = a[h]);
		}
	}, n.prototype._mergeStates = function(n) {
		for (var r = t.prototype._mergeStates.call(this, n), a, o = 0; o < n.length; o++) {
			var s = n[o];
			s.style && (a ||= {}, this._mergeStyle(a, s.style));
		}
		return a && (r.style = a), r;
	}, n.prototype._mergeStyle = function(t, n) {
		return extend(t, n), t;
	}, n.prototype.getAnimationStyleProps = function() {
		return DEFAULT_COMMON_ANIMATION_PROPS;
	}, n.initDefaultProps = (function() {
		var t = n.prototype;
		t.type = "displayable", t.invisible = !1, t.z = 0, t.z2 = 0, t.zlevel = 0, t.culling = !1, t.cursor = "pointer", t.rectHover = !1, t.incremental = !1, t._rect = null, t.dirtyRectTolerance = 0, t.__dirty = 3;
	})(), n;
}(Element_default), tmpRect = new BoundingRect_default(0, 0, 0, 0), viewRect = new BoundingRect_default(0, 0, 0, 0);
function isDisplayableCulled(t, n, r) {
	return tmpRect.copy(t.getBoundingRect()), t.transform && tmpRect.applyTransform(t.transform), viewRect.width = n, viewRect.height = r, !tmpRect.intersect(viewRect);
}
var Displayable_default = Displayable, mathMin$9 = Math.min, mathMax$9 = Math.max, mathSin$4 = Math.sin, mathCos$4 = Math.cos, PI2$8 = Math.PI * 2, start = create$1(), end = create$1(), extremity = create$1();
function fromPoints(t, n, r) {
	if (t.length !== 0) {
		for (var a = t[0], o = a[0], s = a[0], c = a[1], l = a[1], u = 1; u < t.length; u++) a = t[u], o = mathMin$9(o, a[0]), s = mathMax$9(s, a[0]), c = mathMin$9(c, a[1]), l = mathMax$9(l, a[1]);
		n[0] = o, n[1] = c, r[0] = s, r[1] = l;
	}
}
function fromLine(t, n, r, a, o, s) {
	o[0] = mathMin$9(t, r), o[1] = mathMin$9(n, a), s[0] = mathMax$9(t, r), s[1] = mathMax$9(n, a);
}
var xDim = [], yDim = [];
function fromCubic(t, n, r, a, o, s, c, l, u, d) {
	var f = cubicExtrema, p = cubicAt, h = f(t, r, o, c, xDim);
	u[0] = Infinity, u[1] = Infinity, d[0] = -Infinity, d[1] = -Infinity;
	for (var g = 0; g < h; g++) {
		var _ = p(t, r, o, c, xDim[g]);
		u[0] = mathMin$9(_, u[0]), d[0] = mathMax$9(_, d[0]);
	}
	h = f(n, a, s, l, yDim);
	for (var g = 0; g < h; g++) {
		var v = p(n, a, s, l, yDim[g]);
		u[1] = mathMin$9(v, u[1]), d[1] = mathMax$9(v, d[1]);
	}
	u[0] = mathMin$9(t, u[0]), d[0] = mathMax$9(t, d[0]), u[0] = mathMin$9(c, u[0]), d[0] = mathMax$9(c, d[0]), u[1] = mathMin$9(n, u[1]), d[1] = mathMax$9(n, d[1]), u[1] = mathMin$9(l, u[1]), d[1] = mathMax$9(l, d[1]);
}
function fromQuadratic(t, n, r, a, o, s, c, l) {
	var u = quadraticExtremum, d = quadraticAt$1, f = mathMax$9(mathMin$9(u(t, r, o), 1), 0), p = mathMax$9(mathMin$9(u(n, a, s), 1), 0), h = d(t, r, o, f), g = d(n, a, s, p);
	c[0] = mathMin$9(t, o, h), c[1] = mathMin$9(n, s, g), l[0] = mathMax$9(t, o, h), l[1] = mathMax$9(n, s, g);
}
function fromArc(t, n, r, a, o, s, c, l, u) {
	var d = min, f = max, p = Math.abs(o - s);
	if (p % PI2$8 < 1e-4 && p > 1e-4) {
		l[0] = t - r, l[1] = n - a, u[0] = t + r, u[1] = n + a;
		return;
	}
	if (start[0] = mathCos$4(o) * r + t, start[1] = mathSin$4(o) * a + n, end[0] = mathCos$4(s) * r + t, end[1] = mathSin$4(s) * a + n, d(l, start, end), f(u, start, end), o %= PI2$8, o < 0 && (o += PI2$8), s %= PI2$8, s < 0 && (s += PI2$8), o > s && !c ? s += PI2$8 : o < s && c && (o += PI2$8), c) {
		var h = s;
		s = o, o = h;
	}
	for (var g = 0; g < s; g += Math.PI / 2) g > o && (extremity[0] = mathCos$4(g) * r + t, extremity[1] = mathSin$4(g) * a + n, d(l, extremity, l), f(u, extremity, u));
}
var CMD$4 = {
	M: 1,
	L: 2,
	C: 3,
	Q: 4,
	A: 5,
	Z: 6,
	R: 7
}, tmpOutX = [], tmpOutY = [], min$1 = [], max$1 = [], min2 = [], max2 = [], mathMin$8 = Math.min, mathMax$8 = Math.max, mathCos$3 = Math.cos, mathSin$3 = Math.sin, mathAbs$2 = Math.abs, PI$8 = Math.PI, PI2$7 = PI$8 * 2, hasTypedArray = typeof Float32Array < "u", tmpAngles = [];
function modPI2(t) {
	return Math.round(t / PI$8 * 1e8) / 1e8 % 2 * PI$8;
}
function normalizeArcAngles(t, n) {
	var r = modPI2(t[0]);
	r < 0 && (r += PI2$7);
	var a = r - t[0], o = t[1];
	o += a, !n && o - r >= PI2$7 ? o = r + PI2$7 : n && r - o >= PI2$7 ? o = r - PI2$7 : !n && r > o ? o = r + (PI2$7 - modPI2(r - o)) : n && r < o && (o = r - (PI2$7 - modPI2(o - r))), t[0] = r, t[1] = o;
}
var PathProxy_default = function() {
	function t(t) {
		this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = !1), this._saveData && (this.data = []);
	}
	return t.prototype.increaseVersion = function() {
		this._version++;
	}, t.prototype.getVersion = function() {
		return this._version;
	}, t.prototype.setScale = function(t, n, r) {
		r ||= 0, r > 0 && (this._ux = mathAbs$2(r / devicePixelRatio / t) || 0, this._uy = mathAbs$2(r / devicePixelRatio / n) || 0);
	}, t.prototype.setDPR = function(t) {
		this.dpr = t;
	}, t.prototype.setContext = function(t) {
		this._ctx = t;
	}, t.prototype.getContext = function() {
		return this._ctx;
	}, t.prototype.beginPath = function() {
		return this._ctx && this._ctx.beginPath(), this.reset(), this;
	}, t.prototype.reset = function() {
		this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
	}, t.prototype.moveTo = function(t, n) {
		return this._drawPendingPt(), this.addData(CMD$4.M, t, n), this._ctx && this._ctx.moveTo(t, n), this._x0 = t, this._y0 = n, this._xi = t, this._yi = n, this;
	}, t.prototype.lineTo = function(t, n) {
		var r = mathAbs$2(t - this._xi), a = mathAbs$2(n - this._yi), o = r > this._ux || a > this._uy;
		if (this.addData(CMD$4.L, t, n), this._ctx && o && this._ctx.lineTo(t, n), o) this._xi = t, this._yi = n, this._pendingPtDist = 0;
		else {
			var s = r * r + a * a;
			s > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = n, this._pendingPtDist = s);
		}
		return this;
	}, t.prototype.bezierCurveTo = function(t, n, r, a, o, s) {
		return this._drawPendingPt(), this.addData(CMD$4.C, t, n, r, a, o, s), this._ctx && this._ctx.bezierCurveTo(t, n, r, a, o, s), this._xi = o, this._yi = s, this;
	}, t.prototype.quadraticCurveTo = function(t, n, r, a) {
		return this._drawPendingPt(), this.addData(CMD$4.Q, t, n, r, a), this._ctx && this._ctx.quadraticCurveTo(t, n, r, a), this._xi = r, this._yi = a, this;
	}, t.prototype.arc = function(t, n, r, a, o, s) {
		this._drawPendingPt(), tmpAngles[0] = a, tmpAngles[1] = o, normalizeArcAngles(tmpAngles, s), a = tmpAngles[0], o = tmpAngles[1];
		var c = o - a;
		return this.addData(CMD$4.A, t, n, r, r, a, c, 0, s ? 0 : 1), this._ctx && this._ctx.arc(t, n, r, a, o, s), this._xi = mathCos$3(o) * r + t, this._yi = mathSin$3(o) * r + n, this;
	}, t.prototype.arcTo = function(t, n, r, a, o) {
		return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, n, r, a, o), this;
	}, t.prototype.rect = function(t, n, r, a) {
		return this._drawPendingPt(), this._ctx && this._ctx.rect(t, n, r, a), this.addData(CMD$4.R, t, n, r, a), this;
	}, t.prototype.closePath = function() {
		this._drawPendingPt(), this.addData(CMD$4.Z);
		var t = this._ctx, n = this._x0, r = this._y0;
		return t && t.closePath(), this._xi = n, this._yi = r, this;
	}, t.prototype.fill = function(t) {
		t && t.fill(), this.toStatic();
	}, t.prototype.stroke = function(t) {
		t && t.stroke(), this.toStatic();
	}, t.prototype.len = function() {
		return this._len;
	}, t.prototype.setData = function(t) {
		var n = t.length;
		!(this.data && this.data.length === n) && hasTypedArray && (this.data = new Float32Array(n));
		for (var r = 0; r < n; r++) this.data[r] = t[r];
		this._len = n;
	}, t.prototype.appendPath = function(t) {
		t instanceof Array || (t = [t]);
		for (var n = t.length, r = 0, a = this._len, o = 0; o < n; o++) r += t[o].len();
		hasTypedArray && this.data instanceof Float32Array && (this.data = new Float32Array(a + r));
		for (var o = 0; o < n; o++) for (var s = t[o].data, c = 0; c < s.length; c++) this.data[a++] = s[c];
		this._len = a;
	}, t.prototype.addData = function(t, n, r, a, o, s, c, l, u) {
		if (this._saveData) {
			var d = this.data;
			this._len + arguments.length > d.length && (this._expandData(), d = this.data);
			for (var f = 0; f < arguments.length; f++) d[this._len++] = arguments[f];
		}
	}, t.prototype._drawPendingPt = function() {
		this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
	}, t.prototype._expandData = function() {
		if (!(this.data instanceof Array)) {
			for (var t = [], n = 0; n < this._len; n++) t[n] = this.data[n];
			this.data = t;
		}
	}, t.prototype.toStatic = function() {
		if (this._saveData) {
			this._drawPendingPt();
			var t = this.data;
			t instanceof Array && (t.length = this._len, hasTypedArray && this._len > 11 && (this.data = new Float32Array(t)));
		}
	}, t.prototype.getBoundingRect = function() {
		min$1[0] = min$1[1] = min2[0] = min2[1] = Number.MAX_VALUE, max$1[0] = max$1[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
		var t = this.data, n = 0, r = 0, a = 0, o = 0, s;
		for (s = 0; s < this._len;) {
			var c = t[s++], l = s === 1;
			switch (l && (n = t[s], r = t[s + 1], a = n, o = r), c) {
				case CMD$4.M:
					n = a = t[s++], r = o = t[s++], min2[0] = a, min2[1] = o, max2[0] = a, max2[1] = o;
					break;
				case CMD$4.L:
					fromLine(n, r, t[s], t[s + 1], min2, max2), n = t[s++], r = t[s++];
					break;
				case CMD$4.C:
					fromCubic(n, r, t[s++], t[s++], t[s++], t[s++], t[s], t[s + 1], min2, max2), n = t[s++], r = t[s++];
					break;
				case CMD$4.Q:
					fromQuadratic(n, r, t[s++], t[s++], t[s], t[s + 1], min2, max2), n = t[s++], r = t[s++];
					break;
				case CMD$4.A:
					var u = t[s++], d = t[s++], f = t[s++], p = t[s++], h = t[s++], g = t[s++] + h;
					s += 1;
					var _ = !t[s++];
					l && (a = mathCos$3(h) * f + u, o = mathSin$3(h) * p + d), fromArc(u, d, f, p, h, g, _, min2, max2), n = mathCos$3(g) * f + u, r = mathSin$3(g) * p + d;
					break;
				case CMD$4.R:
					a = n = t[s++], o = r = t[s++];
					var v = t[s++], y = t[s++];
					fromLine(a, o, a + v, o + y, min2, max2);
					break;
				case CMD$4.Z:
					n = a, r = o;
					break;
			}
			min(min$1, min$1, min2), max(max$1, max$1, max2);
		}
		return s === 0 && (min$1[0] = min$1[1] = max$1[0] = max$1[1] = 0), new BoundingRect_default(min$1[0], min$1[1], max$1[0] - min$1[0], max$1[1] - min$1[1]);
	}, t.prototype._calculateLength = function() {
		var t = this.data, n = this._len, r = this._ux, a = this._uy, o = 0, s = 0, c = 0, l = 0;
		this._pathSegLen ||= [];
		for (var u = this._pathSegLen, d = 0, f = 0, p = 0; p < n;) {
			var h = t[p++], g = p === 1;
			g && (o = t[p], s = t[p + 1], c = o, l = s);
			var _ = -1;
			switch (h) {
				case CMD$4.M:
					o = c = t[p++], s = l = t[p++];
					break;
				case CMD$4.L:
					var v = t[p++], y = t[p++], b = v - o, x = y - s;
					(mathAbs$2(b) > r || mathAbs$2(x) > a || p === n - 1) && (_ = Math.sqrt(b * b + x * x), o = v, s = y);
					break;
				case CMD$4.C:
					var S = t[p++], C = t[p++], v = t[p++], y = t[p++], w = t[p++], T = t[p++];
					_ = cubicLength(o, s, S, C, v, y, w, T, 10), o = w, s = T;
					break;
				case CMD$4.Q:
					var S = t[p++], C = t[p++], v = t[p++], y = t[p++];
					_ = quadraticLength(o, s, S, C, v, y, 10), o = v, s = y;
					break;
				case CMD$4.A:
					var E = t[p++], D = t[p++], O = t[p++], A = t[p++], j = t[p++], M = t[p++], N = M + j;
					p += 1, g && (c = mathCos$3(j) * O + E, l = mathSin$3(j) * A + D), _ = mathMax$8(O, A) * mathMin$8(PI2$7, Math.abs(M)), o = mathCos$3(N) * O + E, s = mathSin$3(N) * A + D;
					break;
				case CMD$4.R:
					c = o = t[p++], l = s = t[p++];
					var P = t[p++], F = t[p++];
					_ = P * 2 + F * 2;
					break;
				case CMD$4.Z:
					var b = c - o, x = l - s;
					_ = Math.sqrt(b * b + x * x), o = c, s = l;
					break;
			}
			_ >= 0 && (u[f++] = _, d += _);
		}
		return this._pathLen = d, d;
	}, t.prototype.rebuildPath = function(t, n) {
		var r = this.data, a = this._ux, o = this._uy, s = this._len, c, l, u, d, f, p, h = n < 1, g, _, v = 0, y = 0, b, x = 0, S, C;
		if (!(h && (this._pathSegLen || this._calculateLength(), g = this._pathSegLen, _ = this._pathLen, b = n * _, !b))) lo: for (var w = 0; w < s;) {
			var T = r[w++], E = w === 1;
			switch (E && (u = r[w], d = r[w + 1], c = u, l = d), T !== CMD$4.L && x > 0 && (t.lineTo(S, C), x = 0), T) {
				case CMD$4.M:
					c = u = r[w++], l = d = r[w++], t.moveTo(u, d);
					break;
				case CMD$4.L:
					f = r[w++], p = r[w++];
					var D = mathAbs$2(f - u), O = mathAbs$2(p - d);
					if (D > a || O > o) {
						if (h) {
							var A = g[y++];
							if (v + A > b) {
								var j = (b - v) / A;
								t.lineTo(u * (1 - j) + f * j, d * (1 - j) + p * j);
								break lo;
							}
							v += A;
						}
						t.lineTo(f, p), u = f, d = p, x = 0;
					} else {
						var M = D * D + O * O;
						M > x && (S = f, C = p, x = M);
					}
					break;
				case CMD$4.C:
					var N = r[w++], P = r[w++], F = r[w++], I = r[w++], L = r[w++], R = r[w++];
					if (h) {
						var A = g[y++];
						if (v + A > b) {
							var j = (b - v) / A;
							cubicSubdivide(u, N, F, L, j, tmpOutX), cubicSubdivide(d, P, I, R, j, tmpOutY), t.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
							break lo;
						}
						v += A;
					}
					t.bezierCurveTo(N, P, F, I, L, R), u = L, d = R;
					break;
				case CMD$4.Q:
					var N = r[w++], P = r[w++], F = r[w++], I = r[w++];
					if (h) {
						var A = g[y++];
						if (v + A > b) {
							var j = (b - v) / A;
							quadraticSubdivide(u, N, F, j, tmpOutX), quadraticSubdivide(d, P, I, j, tmpOutY), t.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
							break lo;
						}
						v += A;
					}
					t.quadraticCurveTo(N, P, F, I), u = F, d = I;
					break;
				case CMD$4.A:
					var z = r[w++], B = r[w++], V = r[w++], H = r[w++], U = r[w++], W = r[w++], G = r[w++], K = !r[w++], q = V > H ? V : H, J = mathAbs$2(V - H) > .001, Y = U + W, X = !1;
					if (h) {
						var A = g[y++];
						v + A > b && (Y = U + W * (b - v) / A, X = !0), v += A;
					}
					if (J && t.ellipse ? t.ellipse(z, B, V, H, G, U, Y, K) : t.arc(z, B, q, U, Y, K), X) break lo;
					E && (c = mathCos$3(U) * V + z, l = mathSin$3(U) * H + B), u = mathCos$3(Y) * V + z, d = mathSin$3(Y) * H + B;
					break;
				case CMD$4.R:
					c = u = r[w], l = d = r[w + 1], f = r[w++], p = r[w++];
					var Z = r[w++], Q = r[w++];
					if (h) {
						var A = g[y++];
						if (v + A > b) {
							var $ = b - v;
							t.moveTo(f, p), t.lineTo(f + mathMin$8($, Z), p), $ -= Z, $ > 0 && t.lineTo(f + Z, p + mathMin$8($, Q)), $ -= Q, $ > 0 && t.lineTo(f + mathMax$8(Z - $, 0), p + Q), $ -= Z, $ > 0 && t.lineTo(f, p + mathMax$8(Q - $, 0));
							break lo;
						}
						v += A;
					}
					t.rect(f, p, Z, Q);
					break;
				case CMD$4.Z:
					if (h) {
						var A = g[y++];
						if (v + A > b) {
							var j = (b - v) / A;
							t.lineTo(u * (1 - j) + c * j, d * (1 - j) + l * j);
							break lo;
						}
						v += A;
					}
					t.closePath(), u = c, d = l;
			}
		}
	}, t.prototype.clone = function() {
		var n = new t(), r = this.data;
		return n.data = r.slice ? r.slice() : Array.prototype.slice.call(r), n._len = this._len, n;
	}, t.CMD = CMD$4, t.initDefaultProps = (function() {
		var n = t.prototype;
		n._saveData = !0, n._ux = 0, n._uy = 0, n._pendingPtDist = 0, n._version = 0;
	})(), t;
}();
function containStroke$4(t, n, r, a, o, s, c) {
	if (o === 0) return !1;
	var l = o, u = 0, d = t;
	if (c > n + l && c > a + l || c < n - l && c < a - l || s > t + l && s > r + l || s < t - l && s < r - l) return !1;
	if (t !== r) u = (n - a) / (t - r), d = (t * a - r * n) / (t - r);
	else return Math.abs(s - t) <= l / 2;
	var f = u * s - c + d;
	return f * f / (u * u + 1) <= l / 2 * l / 2;
}
function containStroke$3(t, n, r, a, o, s, c, l, u, d, f) {
	if (u === 0) return !1;
	var p = u;
	return f > n + p && f > a + p && f > s + p && f > l + p || f < n - p && f < a - p && f < s - p && f < l - p || d > t + p && d > r + p && d > o + p && d > c + p || d < t - p && d < r - p && d < o - p && d < c - p ? !1 : cubicProjectPoint(t, n, r, a, o, s, c, l, d, f, null) <= p / 2;
}
function containStroke$2(t, n, r, a, o, s, c, l, u) {
	if (c === 0) return !1;
	var d = c;
	return u > n + d && u > a + d && u > s + d || u < n - d && u < a - d && u < s - d || l > t + d && l > r + d && l > o + d || l < t - d && l < r - d && l < o - d ? !1 : quadraticProjectPoint(t, n, r, a, o, s, l, u, null) <= d / 2;
}
var PI2$6 = Math.PI * 2;
function normalizeRadian(t) {
	return t %= PI2$6, t < 0 && (t += PI2$6), t;
}
var PI2$5 = Math.PI * 2;
function containStroke$1(t, n, r, a, o, s, c, l, u) {
	if (c === 0) return !1;
	var d = c;
	l -= t, u -= n;
	var f = Math.sqrt(l * l + u * u);
	if (f - d > r || f + d < r) return !1;
	if (Math.abs(a - o) % PI2$5 < 1e-4) return !0;
	if (s) {
		var p = a;
		a = normalizeRadian(o), o = normalizeRadian(p);
	} else a = normalizeRadian(a), o = normalizeRadian(o);
	a > o && (o += PI2$5);
	var h = Math.atan2(u, l);
	return h < 0 && (h += PI2$5), h >= a && h <= o || h + PI2$5 >= a && h + PI2$5 <= o;
}
function windingLine(t, n, r, a, o, s) {
	if (s > n && s > a || s < n && s < a || a === n) return 0;
	var c = (s - n) / (a - n), l = a < n ? 1 : -1;
	(c === 1 || c === 0) && (l = a < n ? .5 : -.5);
	var u = c * (r - t) + t;
	return u === o ? Infinity : u > o ? l : 0;
}
var CMD$3 = PathProxy_default.CMD, PI2$4 = Math.PI * 2, EPSILON$1 = 1e-4;
function isAroundEqual$1(t, n) {
	return Math.abs(t - n) < EPSILON$1;
}
var roots = [
	-1,
	-1,
	-1
], extrema = [-1, -1];
function swapExtrema() {
	var t = extrema[0];
	extrema[0] = extrema[1], extrema[1] = t;
}
function windingCubic(t, n, r, a, o, s, c, l, u, d) {
	if (d > n && d > a && d > s && d > l || d < n && d < a && d < s && d < l) return 0;
	var f = cubicRootAt(n, a, s, l, d, roots);
	if (f === 0) return 0;
	for (var p = 0, h = -1, g = void 0, _ = void 0, v = 0; v < f; v++) {
		var y = roots[v], b = y === 0 || y === 1 ? .5 : 1;
		cubicAt(t, r, o, c, y) < u || (h < 0 && (h = cubicExtrema(n, a, s, l, extrema), extrema[1] < extrema[0] && h > 1 && swapExtrema(), g = cubicAt(n, a, s, l, extrema[0]), h > 1 && (_ = cubicAt(n, a, s, l, extrema[1]))), h === 2 ? y < extrema[0] ? p += g < n ? b : -b : y < extrema[1] ? p += _ < g ? b : -b : p += l < _ ? b : -b : y < extrema[0] ? p += g < n ? b : -b : p += l < g ? b : -b);
	}
	return p;
}
function windingQuadratic(t, n, r, a, o, s, c, l) {
	if (l > n && l > a && l > s || l < n && l < a && l < s) return 0;
	var u = quadraticRootAt(n, a, s, l, roots);
	if (u === 0) return 0;
	var d = quadraticExtremum(n, a, s);
	if (d >= 0 && d <= 1) {
		for (var f = 0, p = quadraticAt$1(n, a, s, d), h = 0; h < u; h++) {
			var g = roots[h] === 0 || roots[h] === 1 ? .5 : 1, _ = quadraticAt$1(t, r, o, roots[h]);
			_ < c || (roots[h] < d ? f += p < n ? g : -g : f += s < p ? g : -g);
		}
		return f;
	} else {
		var g = roots[0] === 0 || roots[0] === 1 ? .5 : 1, _ = quadraticAt$1(t, r, o, roots[0]);
		return _ < c ? 0 : s < n ? g : -g;
	}
}
function windingArc(t, n, r, a, o, s, c, l) {
	if (l -= n, l > r || l < -r) return 0;
	var u = Math.sqrt(r * r - l * l);
	roots[0] = -u, roots[1] = u;
	var d = Math.abs(a - o);
	if (d < 1e-4) return 0;
	if (d >= PI2$4 - 1e-4) {
		a = 0, o = PI2$4;
		var f = s ? 1 : -1;
		return c >= roots[0] + t && c <= roots[1] + t ? f : 0;
	}
	if (a > o) {
		var p = a;
		a = o, o = p;
	}
	a < 0 && (a += PI2$4, o += PI2$4);
	for (var h = 0, g = 0; g < 2; g++) {
		var _ = roots[g];
		if (_ + t > c) {
			var v = Math.atan2(l, _), f = s ? 1 : -1;
			v < 0 && (v = PI2$4 + v), (v >= a && v <= o || v + PI2$4 >= a && v + PI2$4 <= o) && (v > Math.PI / 2 && v < Math.PI * 1.5 && (f = -f), h += f);
		}
	}
	return h;
}
function containPath(t, n, r, a, o) {
	for (var s = t.data, c = t.len(), l = 0, u = 0, d = 0, f = 0, p = 0, h, g, _ = 0; _ < c;) {
		var v = s[_++], y = _ === 1;
		switch (v === CMD$3.M && _ > 1 && (r || (l += windingLine(u, d, f, p, a, o))), y && (u = s[_], d = s[_ + 1], f = u, p = d), v) {
			case CMD$3.M:
				f = s[_++], p = s[_++], u = f, d = p;
				break;
			case CMD$3.L:
				if (r) {
					if (containStroke$4(u, d, s[_], s[_ + 1], n, a, o)) return !0;
				} else l += windingLine(u, d, s[_], s[_ + 1], a, o) || 0;
				u = s[_++], d = s[_++];
				break;
			case CMD$3.C:
				if (r) {
					if (containStroke$3(u, d, s[_++], s[_++], s[_++], s[_++], s[_], s[_ + 1], n, a, o)) return !0;
				} else l += windingCubic(u, d, s[_++], s[_++], s[_++], s[_++], s[_], s[_ + 1], a, o) || 0;
				u = s[_++], d = s[_++];
				break;
			case CMD$3.Q:
				if (r) {
					if (containStroke$2(u, d, s[_++], s[_++], s[_], s[_ + 1], n, a, o)) return !0;
				} else l += windingQuadratic(u, d, s[_++], s[_++], s[_], s[_ + 1], a, o) || 0;
				u = s[_++], d = s[_++];
				break;
			case CMD$3.A:
				var b = s[_++], x = s[_++], S = s[_++], C = s[_++], w = s[_++], T = s[_++];
				_ += 1;
				var E = !!(1 - s[_++]);
				h = Math.cos(w) * S + b, g = Math.sin(w) * C + x, y ? (f = h, p = g) : l += windingLine(u, d, h, g, a, o);
				var D = (a - b) * C / S + b;
				if (r) {
					if (containStroke$1(b, x, C, w, w + T, E, n, D, o)) return !0;
				} else l += windingArc(b, x, C, w, w + T, E, D, o);
				u = Math.cos(w + T) * S + b, d = Math.sin(w + T) * C + x;
				break;
			case CMD$3.R:
				f = u = s[_++], p = d = s[_++];
				var O = s[_++], A = s[_++];
				if (h = f + O, g = p + A, r) {
					if (containStroke$4(f, p, h, p, n, a, o) || containStroke$4(h, p, h, g, n, a, o) || containStroke$4(h, g, f, g, n, a, o) || containStroke$4(f, g, f, p, n, a, o)) return !0;
				} else l += windingLine(h, p, h, g, a, o), l += windingLine(f, g, f, p, a, o);
				break;
			case CMD$3.Z:
				if (r) {
					if (containStroke$4(u, d, f, p, n, a, o)) return !0;
				} else l += windingLine(u, d, f, p, a, o);
				u = f, d = p;
				break;
		}
	}
	return !r && !isAroundEqual$1(d, p) && (l += windingLine(u, d, f, p, a, o) || 0), l !== 0;
}
function contain$2(t, n, r) {
	return containPath(t, 0, !1, n, r);
}
function containStroke(t, n, r, a) {
	return containPath(t, n, !0, r, a);
}
var DEFAULT_PATH_STYLE = defaults({
	fill: "#000",
	stroke: null,
	strokePercent: 1,
	fillOpacity: 1,
	strokeOpacity: 1,
	lineDashOffset: 0,
	lineWidth: 1,
	lineCap: "butt",
	miterLimit: 10,
	strokeNoScale: !1,
	strokeFirst: !1
}, DEFAULT_COMMON_STYLE), DEFAULT_PATH_ANIMATION_PROPS = { style: defaults({
	fill: !0,
	stroke: !0,
	strokePercent: !0,
	fillOpacity: !0,
	strokeOpacity: !0,
	lineDashOffset: !0,
	lineWidth: !0,
	miterLimit: !0
}, DEFAULT_COMMON_ANIMATION_PROPS.style) }, pathCopyParams = TRANSFORMABLE_PROPS.concat([
	"invisible",
	"culling",
	"z",
	"z2",
	"zlevel",
	"parent"
]), Path_default = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype.update = function() {
		var r = this;
		t.prototype.update.call(this);
		var a = this.style;
		if (a.decal) {
			var o = this._decalEl = this._decalEl || new n();
			o.buildPath === n.prototype.buildPath && (o.buildPath = function(t) {
				r.buildPath(t, r.shape);
			}), o.silent = !0;
			var s = o.style;
			for (var c in a) s[c] !== a[c] && (s[c] = a[c]);
			s.fill = a.fill ? a.decal : null, s.decal = null, s.shadowColor = null, a.strokeFirst && (s.stroke = null);
			for (var l = 0; l < pathCopyParams.length; ++l) o[pathCopyParams[l]] = this[pathCopyParams[l]];
			o.__dirty |= 1;
		} else this._decalEl &&= null;
	}, n.prototype.getDecalElement = function() {
		return this._decalEl;
	}, n.prototype._init = function(n) {
		var r = keys(n);
		this.shape = this.getDefaultShape();
		var a = this.getDefaultStyle();
		a && this.useStyle(a);
		for (var o = 0; o < r.length; o++) {
			var s = r[o], c = n[s];
			s === "style" ? this.style ? extend(this.style, c) : this.useStyle(c) : s === "shape" ? extend(this.shape, c) : t.prototype.attrKV.call(this, s, c);
		}
		this.style || this.useStyle({});
	}, n.prototype.getDefaultStyle = function() {
		return null;
	}, n.prototype.getDefaultShape = function() {
		return {};
	}, n.prototype.canBeInsideText = function() {
		return this.hasFill();
	}, n.prototype.getInsideTextFill = function() {
		var t = this.style.fill;
		if (t !== "none") {
			if (isString(t)) {
				var n = lum(t, 0);
				return n > .5 ? DARK_LABEL_COLOR : n > .2 ? LIGHTER_LABEL_COLOR : LIGHT_LABEL_COLOR;
			} else if (t) return LIGHT_LABEL_COLOR;
		}
		return DARK_LABEL_COLOR;
	}, n.prototype.getInsideTextStroke = function(t) {
		var n = this.style.fill;
		if (isString(n)) {
			var r = this.__zr;
			if (!!(r && r.isDarkMode()) == lum(t, 0) < .4) return n;
		}
	}, n.prototype.buildPath = function(t, n, r) {}, n.prototype.pathUpdated = function() {
		this.__dirty &= -5;
	}, n.prototype.getUpdatedPathProxy = function(t) {
		return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, t), this.path;
	}, n.prototype.createPathProxy = function() {
		this.path = new PathProxy_default(!1);
	}, n.prototype.hasStroke = function() {
		var t = this.style, n = t.stroke;
		return !(n == null || n === "none" || !(t.lineWidth > 0));
	}, n.prototype.hasFill = function() {
		var t = this.style.fill;
		return t != null && t !== "none";
	}, n.prototype.getBoundingRect = function() {
		var t = this._rect, n = this.style, r = !t;
		if (r) {
			var a = !1;
			this.path || (a = !0, this.createPathProxy());
			var o = this.path;
			(a || this.__dirty & 4) && (o.beginPath(), this.buildPath(o, this.shape, !1), this.pathUpdated()), t = o.getBoundingRect();
		}
		if (this._rect = t, this.hasStroke() && this.path && this.path.len() > 0) {
			var s = this._rectStroke ||= t.clone();
			if (this.__dirty || r) {
				s.copy(t);
				var c = n.strokeNoScale ? this.getLineScale() : 1, l = n.lineWidth;
				if (!this.hasFill()) {
					var u = this.strokeContainThreshold;
					l = Math.max(l, u ?? 4);
				}
				c > 1e-10 && (s.width += l / c, s.height += l / c, s.x -= l / c / 2, s.y -= l / c / 2);
			}
			return s;
		}
		return t;
	}, n.prototype.contain = function(t, n) {
		var r = this.transformCoordToLocal(t, n), a = this.getBoundingRect(), o = this.style;
		if (t = r[0], n = r[1], a.contain(t, n)) {
			var s = this.path;
			if (this.hasStroke()) {
				var c = o.lineWidth, l = o.strokeNoScale ? this.getLineScale() : 1;
				if (l > 1e-10 && (this.hasFill() || (c = Math.max(c, this.strokeContainThreshold)), containStroke(s, c / l, t, n))) return !0;
			}
			if (this.hasFill()) return contain$2(s, t, n);
		}
		return !1;
	}, n.prototype.dirtyShape = function() {
		this.__dirty |= 4, this._rect &&= null, this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
	}, n.prototype.dirty = function() {
		this.dirtyStyle(), this.dirtyShape();
	}, n.prototype.animateShape = function(t) {
		return this.animate("shape", t);
	}, n.prototype.updateDuringAnimation = function(t) {
		t === "style" ? this.dirtyStyle() : t === "shape" ? this.dirtyShape() : this.markRedraw();
	}, n.prototype.attrKV = function(n, r) {
		n === "shape" ? this.setShape(r) : t.prototype.attrKV.call(this, n, r);
	}, n.prototype.setShape = function(t, n) {
		var r = this.shape;
		return r ||= this.shape = {}, typeof t == "string" ? r[t] = n : extend(r, t), this.dirtyShape(), this;
	}, n.prototype.shapeChanged = function() {
		return !!(this.__dirty & 4);
	}, n.prototype.createStyle = function(t) {
		return createObject(DEFAULT_PATH_STYLE, t);
	}, n.prototype._innerSaveToNormal = function(n) {
		t.prototype._innerSaveToNormal.call(this, n);
		var r = this._normalState;
		n.shape && !r.shape && (r.shape = extend({}, this.shape));
	}, n.prototype._applyStateObj = function(n, r, a, o, s, c) {
		t.prototype._applyStateObj.call(this, n, r, a, o, s, c);
		var l = !(r && o), u;
		if (r && r.shape ? s ? o ? u = r.shape : (u = extend({}, a.shape), extend(u, r.shape)) : (u = extend({}, o ? this.shape : a.shape), extend(u, r.shape)) : l && (u = a.shape), u) if (s) {
			this.shape = extend({}, this.shape);
			for (var d = {}, f = keys(u), p = 0; p < f.length; p++) {
				var h = f[p];
				typeof u[h] == "object" ? this.shape[h] = u[h] : d[h] = u[h];
			}
			this._transitionState(n, { shape: d }, c);
		} else this.shape = u, this.dirtyShape();
	}, n.prototype._mergeStates = function(n) {
		for (var r = t.prototype._mergeStates.call(this, n), a, o = 0; o < n.length; o++) {
			var s = n[o];
			s.shape && (a ||= {}, this._mergeStyle(a, s.shape));
		}
		return a && (r.shape = a), r;
	}, n.prototype.getAnimationStyleProps = function() {
		return DEFAULT_PATH_ANIMATION_PROPS;
	}, n.prototype.isZeroArea = function() {
		return !1;
	}, n.extend = function(t) {
		var r = function(n) {
			__extends(r, n);
			function r(r) {
				var a = n.call(this, r) || this;
				return t.init && t.init.call(a, r), a;
			}
			return r.prototype.getDefaultStyle = function() {
				return clone$1(t.style);
			}, r.prototype.getDefaultShape = function() {
				return clone$1(t.shape);
			}, r;
		}(n);
		for (var a in t) typeof t[a] == "function" && (r.prototype[a] = t[a]);
		return r;
	}, n.initDefaultProps = (function() {
		var t = n.prototype;
		t.type = "path", t.strokeContainThreshold = 5, t.segmentIgnoreThreshold = 0, t.subPixelOptimize = !1, t.autoBatch = !1, t.__dirty = 7;
	})(), n;
}(Displayable_default), DEFAULT_TSPAN_STYLE = defaults({
	strokeFirst: !0,
	font: DEFAULT_FONT,
	x: 0,
	y: 0,
	textAlign: "left",
	textBaseline: "top",
	miterLimit: 2
}, DEFAULT_PATH_STYLE), TSpan = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.hasStroke = function() {
		var t = this.style, n = t.stroke;
		return n != null && n !== "none" && t.lineWidth > 0;
	}, n.prototype.hasFill = function() {
		var t = this.style.fill;
		return t != null && t !== "none";
	}, n.prototype.createStyle = function(t) {
		return createObject(DEFAULT_TSPAN_STYLE, t);
	}, n.prototype.setBoundingRect = function(t) {
		this._rect = t;
	}, n.prototype.getBoundingRect = function() {
		var t = this.style;
		if (!this._rect) {
			var n = t.text;
			n == null ? n = "" : n += "";
			var r = getBoundingRect(n, t.font, t.textAlign, t.textBaseline);
			if (r.x += t.x || 0, r.y += t.y || 0, this.hasStroke()) {
				var a = t.lineWidth;
				r.x -= a / 2, r.y -= a / 2, r.width += a, r.height += a;
			}
			this._rect = r;
		}
		return this._rect;
	}, n.initDefaultProps = (function() {
		var t = n.prototype;
		t.dirtyRectTolerance = 10;
	})(), n;
}(Displayable_default);
TSpan.prototype.type = "tspan";
var TSpan_default = TSpan, DEFAULT_IMAGE_STYLE = defaults({
	x: 0,
	y: 0
}, DEFAULT_COMMON_STYLE), DEFAULT_IMAGE_ANIMATION_PROPS = { style: defaults({
	x: !0,
	y: !0,
	width: !0,
	height: !0,
	sx: !0,
	sy: !0,
	sWidth: !0,
	sHeight: !0
}, DEFAULT_COMMON_ANIMATION_PROPS.style) };
function isImageLike$1(t) {
	return !!(t && typeof t != "string" && t.width && t.height);
}
var ZRImage = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.createStyle = function(t) {
		return createObject(DEFAULT_IMAGE_STYLE, t);
	}, n.prototype._getSize = function(t) {
		var n = this.style, r = n[t];
		if (r != null) return r;
		var a = isImageLike$1(n.image) ? n.image : this.__image;
		if (!a) return 0;
		var o = t === "width" ? "height" : "width", s = n[o];
		return s == null ? a[t] : a[t] / a[o] * s;
	}, n.prototype.getWidth = function() {
		return this._getSize("width");
	}, n.prototype.getHeight = function() {
		return this._getSize("height");
	}, n.prototype.getAnimationStyleProps = function() {
		return DEFAULT_IMAGE_ANIMATION_PROPS;
	}, n.prototype.getBoundingRect = function() {
		var t = this.style;
		return this._rect ||= new BoundingRect_default(t.x || 0, t.y || 0, this.getWidth(), this.getHeight()), this._rect;
	}, n;
}(Displayable_default);
ZRImage.prototype.type = "image";
var Image_default = ZRImage;
function buildPath$2(t, n) {
	var r = n.x, a = n.y, o = n.width, s = n.height, c = n.r, l, u, d, f;
	o < 0 && (r += o, o = -o), s < 0 && (a += s, s = -s), typeof c == "number" ? l = u = d = f = c : c instanceof Array ? c.length === 1 ? l = u = d = f = c[0] : c.length === 2 ? (l = d = c[0], u = f = c[1]) : c.length === 3 ? (l = c[0], u = f = c[1], d = c[2]) : (l = c[0], u = c[1], d = c[2], f = c[3]) : l = u = d = f = 0;
	var p;
	l + u > o && (p = l + u, l *= o / p, u *= o / p), d + f > o && (p = d + f, d *= o / p, f *= o / p), u + d > s && (p = u + d, u *= s / p, d *= s / p), l + f > s && (p = l + f, l *= s / p, f *= s / p), t.moveTo(r + l, a), t.lineTo(r + o - u, a), u !== 0 && t.arc(r + o - u, a + u, u, -Math.PI / 2, 0), t.lineTo(r + o, a + s - d), d !== 0 && t.arc(r + o - d, a + s - d, d, 0, Math.PI / 2), t.lineTo(r + f, a + s), f !== 0 && t.arc(r + f, a + s - f, f, Math.PI / 2, Math.PI), t.lineTo(r, a + l), l !== 0 && t.arc(r + l, a + l, l, Math.PI, Math.PI * 1.5);
}
var round$3 = Math.round;
function subPixelOptimizeLine$1(t, n, r) {
	if (n) {
		var a = n.x1, o = n.x2, s = n.y1, c = n.y2;
		t.x1 = a, t.x2 = o, t.y1 = s, t.y2 = c;
		var l = r && r.lineWidth;
		return l ? (round$3(a * 2) === round$3(o * 2) && (t.x1 = t.x2 = subPixelOptimize$1(a, l, !0)), round$3(s * 2) === round$3(c * 2) && (t.y1 = t.y2 = subPixelOptimize$1(s, l, !0)), t) : t;
	}
}
function subPixelOptimizeRect$1(t, n, r) {
	if (n) {
		var a = n.x, o = n.y, s = n.width, c = n.height;
		t.x = a, t.y = o, t.width = s, t.height = c;
		var l = r && r.lineWidth;
		return l ? (t.x = subPixelOptimize$1(a, l, !0), t.y = subPixelOptimize$1(o, l, !0), t.width = Math.max(subPixelOptimize$1(a + s, l, !1) - t.x, s === 0 ? 0 : 1), t.height = Math.max(subPixelOptimize$1(o + c, l, !1) - t.y, c === 0 ? 0 : 1), t) : t;
	}
}
function subPixelOptimize$1(t, n, r) {
	if (!n) return t;
	var a = round$3(t * 2);
	return (a + round$3(n)) % 2 == 0 ? a / 2 : (a + (r ? 1 : -1)) / 2;
}
var RectShape = function() {
	function t() {
		this.x = 0, this.y = 0, this.width = 0, this.height = 0;
	}
	return t;
}(), subPixelOptimizeOutputShape$1 = {}, Rect$2 = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype.getDefaultShape = function() {
		return new RectShape();
	}, n.prototype.buildPath = function(t, n) {
		var r, a, o, s;
		if (this.subPixelOptimize) {
			var c = subPixelOptimizeRect$1(subPixelOptimizeOutputShape$1, n, this.style);
			r = c.x, a = c.y, o = c.width, s = c.height, c.r = n.r, n = c;
		} else r = n.x, a = n.y, o = n.width, s = n.height;
		n.r ? buildPath$2(t, n) : t.rect(r, a, o, s);
	}, n.prototype.isZeroArea = function() {
		return !this.shape.width || !this.shape.height;
	}, n;
}(Path_default);
Rect$2.prototype.type = "rect";
var Rect_default = Rect$2;
init_dist$2();
var DEFAULT_RICH_TEXT_COLOR = { fill: "#000" }, DEFAULT_STROKE_LINE_WIDTH = 2, DEFAULT_TEXT_ANIMATION_PROPS = { style: defaults({
	fill: !0,
	stroke: !0,
	fillOpacity: !0,
	strokeOpacity: !0,
	lineWidth: !0,
	fontSize: !0,
	lineHeight: !0,
	width: !0,
	height: !0,
	textShadowColor: !0,
	textShadowBlur: !0,
	textShadowOffsetX: !0,
	textShadowOffsetY: !0,
	backgroundColor: !0,
	padding: !0,
	borderColor: !0,
	borderWidth: !0,
	borderRadius: !0
}, DEFAULT_COMMON_ANIMATION_PROPS.style) }, ZRText = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this) || this;
		return r.type = "text", r._children = [], r._defaultStyle = DEFAULT_RICH_TEXT_COLOR, r.attr(n), r;
	}
	return n.prototype.childrenRef = function() {
		return this._children;
	}, n.prototype.update = function() {
		t.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
		for (var n = 0; n < this._children.length; n++) {
			var r = this._children[n];
			r.zlevel = this.zlevel, r.z = this.z, r.z2 = this.z2, r.culling = this.culling, r.cursor = this.cursor, r.invisible = this.invisible;
		}
	}, n.prototype.updateTransform = function() {
		var n = this.innerTransformable;
		n ? (n.updateTransform(), n.transform && (this.transform = n.transform)) : t.prototype.updateTransform.call(this);
	}, n.prototype.getLocalTransform = function(n) {
		var r = this.innerTransformable;
		return r ? r.getLocalTransform(n) : t.prototype.getLocalTransform.call(this, n);
	}, n.prototype.getComputedTransform = function() {
		return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), t.prototype.getComputedTransform.call(this);
	}, n.prototype._updateSubTexts = function() {
		this._childCursor = 0, normalizeTextStyle(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
	}, n.prototype.addSelfToZr = function(n) {
		t.prototype.addSelfToZr.call(this, n);
		for (var r = 0; r < this._children.length; r++) this._children[r].__zr = n;
	}, n.prototype.removeSelfFromZr = function(n) {
		t.prototype.removeSelfFromZr.call(this, n);
		for (var r = 0; r < this._children.length; r++) this._children[r].__zr = null;
	}, n.prototype.getBoundingRect = function() {
		if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
			for (var t = new BoundingRect_default(0, 0, 0, 0), n = this._children, r = [], a = null, o = 0; o < n.length; o++) {
				var s = n[o], c = s.getBoundingRect(), l = s.getLocalTransform(r);
				l ? (t.copy(c), t.applyTransform(l), a ||= t.clone(), a.union(t)) : (a ||= c.clone(), a.union(c));
			}
			this._rect = a || t;
		}
		return this._rect;
	}, n.prototype.setDefaultTextStyle = function(t) {
		this._defaultStyle = t || DEFAULT_RICH_TEXT_COLOR;
	}, n.prototype.setTextContent = function(t) {
		if (process$1.env.NODE_ENV !== "production") throw Error("Can't attach text on another text");
	}, n.prototype._mergeStyle = function(t, n) {
		if (!n) return t;
		var r = n.rich, a = t.rich || r && {};
		return extend(t, n), r && a ? (this._mergeRich(a, r), t.rich = a) : a && (t.rich = a), t;
	}, n.prototype._mergeRich = function(t, n) {
		for (var r = keys(n), a = 0; a < r.length; a++) {
			var o = r[a];
			t[o] = t[o] || {}, extend(t[o], n[o]);
		}
	}, n.prototype.getAnimationStyleProps = function() {
		return DEFAULT_TEXT_ANIMATION_PROPS;
	}, n.prototype._getOrCreateChild = function(t) {
		var n = this._children[this._childCursor];
		return (!n || !(n instanceof t)) && (n = new t()), this._children[this._childCursor++] = n, n.__zr = this.__zr, n.parent = this, n;
	}, n.prototype._updatePlainTexts = function() {
		var t = this.style, n = t.font || "12px sans-serif", r = t.padding, a = parsePlainText(getStyleText(t), t), o = needDrawBackground(t), s = !!t.backgroundColor, c = a.outerHeight, l = a.outerWidth, u = a.contentWidth, d = a.lines, f = a.lineHeight, p = this._defaultStyle;
		this.isTruncated = !!a.isTruncated;
		var h = t.x || 0, g = t.y || 0, _ = t.align || p.align || "left", v = t.verticalAlign || p.verticalAlign || "top", y = h, b = adjustTextY$1(g, a.contentHeight, v);
		if (o || r) {
			var x = adjustTextX(h, l, _), S = adjustTextY$1(g, c, v);
			o && this._renderBackground(t, t, x, S, l, c);
		}
		b += f / 2, r && (y = getTextXForPadding(h, _, r), v === "top" ? b += r[0] : v === "bottom" && (b -= r[2]));
		for (var C = 0, w = !1, T = getFill("fill" in t ? t.fill : (w = !0, p.fill)), E = getStroke("stroke" in t ? t.stroke : !s && (!p.autoStroke || w) ? (C = DEFAULT_STROKE_LINE_WIDTH, p.stroke) : null), D = t.textShadowBlur > 0, O = t.width != null && (t.overflow === "truncate" || t.overflow === "break" || t.overflow === "breakAll"), A = a.calculatedLineHeight, j = 0; j < d.length; j++) {
			var M = this._getOrCreateChild(TSpan_default), N = M.createStyle();
			M.useStyle(N), N.text = d[j], N.x = y, N.y = b, _ && (N.textAlign = _), N.textBaseline = "middle", N.opacity = t.opacity, N.strokeFirst = !0, D && (N.shadowBlur = t.textShadowBlur || 0, N.shadowColor = t.textShadowColor || "transparent", N.shadowOffsetX = t.textShadowOffsetX || 0, N.shadowOffsetY = t.textShadowOffsetY || 0), N.stroke = E, N.fill = T, E && (N.lineWidth = t.lineWidth || C, N.lineDash = t.lineDash, N.lineDashOffset = t.lineDashOffset || 0), N.font = n, setSeparateFont(N, t), b += f, O && M.setBoundingRect(new BoundingRect_default(adjustTextX(N.x, u, N.textAlign), adjustTextY$1(N.y, A, N.textBaseline), u, A));
		}
	}, n.prototype._updateRichTexts = function() {
		var t = this.style, n = parseRichText(getStyleText(t), t), r = n.width, a = n.outerWidth, o = n.outerHeight, s = t.padding, c = t.x || 0, l = t.y || 0, u = this._defaultStyle, d = t.align || u.align, f = t.verticalAlign || u.verticalAlign;
		this.isTruncated = !!n.isTruncated;
		var p = adjustTextX(c, a, d), h = adjustTextY$1(l, o, f), g = p, _ = h;
		s && (g += s[3], _ += s[0]);
		var v = g + r;
		needDrawBackground(t) && this._renderBackground(t, t, p, h, a, o);
		for (var y = !!t.backgroundColor, b = 0; b < n.lines.length; b++) {
			for (var x = n.lines[b], S = x.tokens, C = S.length, w = x.lineHeight, T = x.width, E = 0, D = g, O = v, A = C - 1, j = void 0; E < C && (j = S[E], !j.align || j.align === "left");) this._placeToken(j, t, w, _, D, "left", y), T -= j.width, D += j.width, E++;
			for (; A >= 0 && (j = S[A], j.align === "right");) this._placeToken(j, t, w, _, O, "right", y), T -= j.width, O -= j.width, A--;
			for (D += (r - (D - g) - (v - O) - T) / 2; E <= A;) j = S[E], this._placeToken(j, t, w, _, D + j.width / 2, "center", y), D += j.width, E++;
			_ += w;
		}
	}, n.prototype._placeToken = function(t, n, r, a, o, s, c) {
		var l = n.rich[t.styleName] || {};
		l.text = t.text;
		var u = t.verticalAlign, d = a + r / 2;
		u === "top" ? d = a + t.height / 2 : u === "bottom" && (d = a + r - t.height / 2), !t.isLineHolder && needDrawBackground(l) && this._renderBackground(l, n, s === "right" ? o - t.width : s === "center" ? o - t.width / 2 : o, d - t.height / 2, t.width, t.height);
		var f = !!l.backgroundColor, p = t.textPadding;
		p && (o = getTextXForPadding(o, s, p), d -= t.height / 2 - p[0] - t.innerHeight / 2);
		var h = this._getOrCreateChild(TSpan_default), g = h.createStyle();
		h.useStyle(g);
		var _ = this._defaultStyle, v = !1, y = 0, b = getFill("fill" in l ? l.fill : "fill" in n ? n.fill : (v = !0, _.fill)), x = getStroke("stroke" in l ? l.stroke : "stroke" in n ? n.stroke : !f && !c && (!_.autoStroke || v) ? (y = DEFAULT_STROKE_LINE_WIDTH, _.stroke) : null), S = l.textShadowBlur > 0 || n.textShadowBlur > 0;
		g.text = t.text, g.x = o, g.y = d, S && (g.shadowBlur = l.textShadowBlur || n.textShadowBlur || 0, g.shadowColor = l.textShadowColor || n.textShadowColor || "transparent", g.shadowOffsetX = l.textShadowOffsetX || n.textShadowOffsetX || 0, g.shadowOffsetY = l.textShadowOffsetY || n.textShadowOffsetY || 0), g.textAlign = s, g.textBaseline = "middle", g.font = t.font || "12px sans-serif", g.opacity = retrieve3(l.opacity, n.opacity, 1), setSeparateFont(g, l), x && (g.lineWidth = retrieve3(l.lineWidth, n.lineWidth, y), g.lineDash = retrieve2(l.lineDash, n.lineDash), g.lineDashOffset = n.lineDashOffset || 0, g.stroke = x), b && (g.fill = b);
		var C = t.contentWidth, w = t.contentHeight;
		h.setBoundingRect(new BoundingRect_default(adjustTextX(g.x, C, g.textAlign), adjustTextY$1(g.y, w, g.textBaseline), C, w));
	}, n.prototype._renderBackground = function(t, n, r, a, o, s) {
		var c = t.backgroundColor, l = t.borderWidth, u = t.borderColor, d = c && c.image, f = c && !d, p = t.borderRadius, h = this, g, _;
		if (f || t.lineHeight || l && u) {
			g = this._getOrCreateChild(Rect_default), g.useStyle(g.createStyle()), g.style.fill = null;
			var v = g.shape;
			v.x = r, v.y = a, v.width = o, v.height = s, v.r = p, g.dirtyShape();
		}
		if (f) {
			var y = g.style;
			y.fill = c || null, y.fillOpacity = retrieve2(t.fillOpacity, 1);
		} else if (d) {
			_ = this._getOrCreateChild(Image_default), _.onload = function() {
				h.dirtyStyle();
			};
			var b = _.style;
			b.image = c.image, b.x = r, b.y = a, b.width = o, b.height = s;
		}
		if (l && u) {
			var y = g.style;
			y.lineWidth = l, y.stroke = u, y.strokeOpacity = retrieve2(t.strokeOpacity, 1), y.lineDash = t.borderDash, y.lineDashOffset = t.borderDashOffset || 0, g.strokeContainThreshold = 0, g.hasFill() && g.hasStroke() && (y.strokeFirst = !0, y.lineWidth *= 2);
		}
		var x = (g || _).style;
		x.shadowBlur = t.shadowBlur || 0, x.shadowColor = t.shadowColor || "transparent", x.shadowOffsetX = t.shadowOffsetX || 0, x.shadowOffsetY = t.shadowOffsetY || 0, x.opacity = retrieve3(t.opacity, n.opacity, 1);
	}, n.makeFont = function(t) {
		var n = "";
		return hasSeparateFont(t) && (n = [
			t.fontStyle,
			t.fontWeight,
			parseFontSize(t.fontSize),
			t.fontFamily || "sans-serif"
		].join(" ")), n && trim(n) || t.textFont || t.font;
	}, n;
}(Displayable_default), VALID_TEXT_ALIGN = {
	left: !0,
	right: 1,
	center: 1
}, VALID_TEXT_VERTICAL_ALIGN = {
	top: 1,
	bottom: 1,
	middle: 1
}, FONT_PARTS = [
	"fontStyle",
	"fontWeight",
	"fontSize",
	"fontFamily"
];
function parseFontSize(t) {
	return typeof t == "string" && (t.indexOf("px") !== -1 || t.indexOf("rem") !== -1 || t.indexOf("em") !== -1) ? t : isNaN(+t) ? "12px" : t + "px";
}
function setSeparateFont(t, n) {
	for (var r = 0; r < FONT_PARTS.length; r++) {
		var a = FONT_PARTS[r], o = n[a];
		o != null && (t[a] = o);
	}
}
function hasSeparateFont(t) {
	return t.fontSize != null || t.fontFamily || t.fontWeight;
}
function normalizeTextStyle(t) {
	return normalizeStyle(t), each(t.rich, normalizeStyle), t;
}
function normalizeStyle(t) {
	if (t) {
		t.font = ZRText.makeFont(t);
		var n = t.align;
		n === "middle" && (n = "center"), t.align = n == null || VALID_TEXT_ALIGN[n] ? n : "left";
		var r = t.verticalAlign;
		r === "center" && (r = "middle"), t.verticalAlign = r == null || VALID_TEXT_VERTICAL_ALIGN[r] ? r : "top", t.padding &&= normalizeCssArray$1(t.padding);
	}
}
function getStroke(t, n) {
	return t == null || n <= 0 || t === "transparent" || t === "none" ? null : t.image || t.colorStops ? "#000" : t;
}
function getFill(t) {
	return t == null || t === "none" ? null : t.image || t.colorStops ? "#000" : t;
}
function getTextXForPadding(t, n, r) {
	return n === "right" ? t - r[1] : n === "center" ? t + r[3] / 2 - r[1] / 2 : t + r[3];
}
function getStyleText(t) {
	var n = t.text;
	return n != null && (n += ""), n;
}
function needDrawBackground(t) {
	return !!(t.backgroundColor || t.lineHeight || t.borderWidth && t.borderColor);
}
var Text_default = ZRText, getECData = makeInner(), setCommonECData = function(t, n, r, a) {
	if (a) {
		var o = getECData(a);
		o.dataIndex = r, o.dataType = n, o.seriesIndex = t, o.ssrType = "chart", a.type === "group" && a.traverse(function(a) {
			var o = getECData(a);
			o.seriesIndex = t, o.dataIndex = r, o.dataType = n, o.ssrType = "chart";
		});
	}
};
init_dist$2();
var _highlightNextDigit = 1, _highlightKeyMap = {}, getSavedStates = makeInner(), getComponentStates = makeInner(), SPECIAL_STATES = [
	"emphasis",
	"blur",
	"select"
], DISPLAY_STATES = [
	"normal",
	"emphasis",
	"blur",
	"select"
], HIGHLIGHT_ACTION_TYPE = "highlight", DOWNPLAY_ACTION_TYPE = "downplay", SELECT_ACTION_TYPE = "select", UNSELECT_ACTION_TYPE = "unselect", TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
function hasFillOrStroke(t) {
	return t != null && t !== "none";
}
function doChangeHoverState(t, n, r) {
	t.onHoverStateChange && (t.hoverState || 0) !== r && t.onHoverStateChange(n), t.hoverState = r;
}
function singleEnterEmphasis(t) {
	doChangeHoverState(t, "emphasis", 2);
}
function singleLeaveEmphasis(t) {
	t.hoverState === 2 && doChangeHoverState(t, "normal", 0);
}
function singleEnterBlur(t) {
	doChangeHoverState(t, "blur", 1);
}
function singleLeaveBlur(t) {
	t.hoverState === 1 && doChangeHoverState(t, "normal", 0);
}
function singleEnterSelect(t) {
	t.selected = !0;
}
function singleLeaveSelect(t) {
	t.selected = !1;
}
function updateElementState(t, n, r) {
	n(t, r);
}
function traverseUpdateState(t, n, r) {
	updateElementState(t, n, r), t.isGroup && t.traverse(function(t) {
		updateElementState(t, n, r);
	});
}
function setStatesFlag(t, n) {
	switch (n) {
		case "emphasis":
			t.hoverState = 2;
			break;
		case "normal":
			t.hoverState = 0;
			break;
		case "blur":
			t.hoverState = 1;
			break;
		case "select": t.selected = !0;
	}
}
function getFromStateStyle(t, n, r, a) {
	for (var o = t.style, s = {}, c = 0; c < n.length; c++) {
		var l = n[c];
		s[l] = o[l] ?? (a && a[l]);
	}
	for (var c = 0; c < t.animators.length; c++) {
		var u = t.animators[c];
		u.__fromStateTransition && u.__fromStateTransition.indexOf(r) < 0 && u.targetName === "style" && u.saveTo(s, n);
	}
	return s;
}
function createEmphasisDefaultState(t, n, r, a) {
	var o = r && indexOf(r, "select") >= 0, s = !1;
	if (t instanceof Path_default) {
		var c = getSavedStates(t), l = o && c.selectFill || c.normalFill, u = o && c.selectStroke || c.normalStroke;
		if (hasFillOrStroke(l) || hasFillOrStroke(u)) {
			a ||= {};
			var d = a.style || {};
			d.fill === "inherit" ? (s = !0, a = extend({}, a), d = extend({}, d), d.fill = l) : !hasFillOrStroke(d.fill) && hasFillOrStroke(l) ? (s = !0, a = extend({}, a), d = extend({}, d), d.fill = liftColor(l)) : !hasFillOrStroke(d.stroke) && hasFillOrStroke(u) && (s || (a = extend({}, a), d = extend({}, d)), d.stroke = liftColor(u)), a.style = d;
		}
	}
	if (a && a.z2 == null) {
		s || (a = extend({}, a));
		var f = t.z2EmphasisLift;
		a.z2 = t.z2 + (f ?? 10);
	}
	return a;
}
function createSelectDefaultState(t, n, r) {
	if (r && r.z2 == null) {
		r = extend({}, r);
		var a = t.z2SelectLift;
		r.z2 = t.z2 + (a ?? 9);
	}
	return r;
}
function createBlurDefaultState(t, n, r) {
	var a = indexOf(t.currentStates, n) >= 0, o = t.style.opacity, s = a ? null : getFromStateStyle(t, ["opacity"], n, { opacity: 1 });
	r ||= {};
	var c = r.style || {};
	return c.opacity ?? (r = extend({}, r), c = extend({ opacity: a ? o : s.opacity * .1 }, c), r.style = c), r;
}
function elementStateProxy(t, n) {
	var r = this.states[t];
	if (this.style) {
		if (t === "emphasis") return createEmphasisDefaultState(this, t, n, r);
		if (t === "blur") return createBlurDefaultState(this, t, r);
		if (t === "select") return createSelectDefaultState(this, t, r);
	}
	return r;
}
function setDefaultStateProxy(t) {
	t.stateProxy = elementStateProxy;
	var n = t.getTextContent(), r = t.getTextGuideLine();
	n && (n.stateProxy = elementStateProxy), r && (r.stateProxy = elementStateProxy);
}
function enterEmphasisWhenMouseOver(t, n) {
	!shouldSilent(t, n) && !t.__highByOuter && traverseUpdateState(t, singleEnterEmphasis);
}
function leaveEmphasisWhenMouseOut(t, n) {
	!shouldSilent(t, n) && !t.__highByOuter && traverseUpdateState(t, singleLeaveEmphasis);
}
function enterEmphasis(t, n) {
	t.__highByOuter |= 1 << (n || 0), traverseUpdateState(t, singleEnterEmphasis);
}
function leaveEmphasis(t, n) {
	!(t.__highByOuter &= ~(1 << (n || 0))) && traverseUpdateState(t, singleLeaveEmphasis);
}
function enterBlur(t) {
	traverseUpdateState(t, singleEnterBlur);
}
function leaveBlur(t) {
	traverseUpdateState(t, singleLeaveBlur);
}
function enterSelect(t) {
	traverseUpdateState(t, singleEnterSelect);
}
function leaveSelect(t) {
	traverseUpdateState(t, singleLeaveSelect);
}
function shouldSilent(t, n) {
	return t.__highDownSilentOnTouch && n.zrByTouch;
}
function allLeaveBlur(t) {
	var n = t.getModel(), r = [], a = [];
	n.eachComponent(function(n, o) {
		var s = getComponentStates(o), c = n === "series", l = c ? t.getViewOfSeriesModel(o) : t.getViewOfComponentModel(o);
		!c && a.push(l), s.isBlured && (l.group.traverse(function(t) {
			singleLeaveBlur(t);
		}), c && r.push(o)), s.isBlured = !1;
	}), each(a, function(t) {
		t && t.toggleBlurSeries && t.toggleBlurSeries(r, !1, n);
	});
}
function blurSeries(t, n, r, a) {
	var o = a.getModel();
	r ||= "coordinateSystem";
	function s(t, n) {
		for (var r = 0; r < n.length; r++) {
			var a = t.getItemGraphicEl(n[r]);
			a && leaveBlur(a);
		}
	}
	if (t != null && !(!n || n === "none")) {
		var c = o.getSeriesByIndex(t), l = c.coordinateSystem;
		l && l.master && (l = l.master);
		var u = [];
		o.eachSeries(function(t) {
			var o = c === t, d = t.coordinateSystem;
			if (d && d.master && (d = d.master), !(r === "series" && !o || r === "coordinateSystem" && !(d && l ? d === l : o) || n === "series" && o)) {
				if (a.getViewOfSeriesModel(t).group.traverse(function(t) {
					t.__highByOuter && o && n === "self" || singleEnterBlur(t);
				}), isArrayLike(n)) s(t.getData(), n);
				else if (isObject(n)) for (var f = keys(n), p = 0; p < f.length; p++) s(t.getData(f[p]), n[f[p]]);
				u.push(t), getComponentStates(t).isBlured = !0;
			}
		}), o.eachComponent(function(t, n) {
			if (t !== "series") {
				var r = a.getViewOfComponentModel(n);
				r && r.toggleBlurSeries && r.toggleBlurSeries(u, !0, o);
			}
		});
	}
}
function blurComponent(t, n, r) {
	if (!(t == null || n == null)) {
		var a = r.getModel().getComponent(t, n);
		if (a) {
			getComponentStates(a).isBlured = !0;
			var o = r.getViewOfComponentModel(a);
			!o || !o.focusBlurEnabled || o.group.traverse(function(t) {
				singleEnterBlur(t);
			});
		}
	}
}
function blurSeriesFromHighlightPayload(t, n, r) {
	var a = t.seriesIndex, o = t.getData(n.dataType);
	if (!o) {
		process$1.env.NODE_ENV !== "production" && error("Unknown dataType " + n.dataType);
		return;
	}
	var c = queryDataIndex(o, n);
	c = (isArray(c) ? c[0] : c) || 0;
	var l = o.getItemGraphicEl(c);
	if (!l) for (var u = o.count(), d = 0; !l && d < u;) l = o.getItemGraphicEl(d++);
	if (l) {
		var f = getECData(l);
		blurSeries(a, f.focus, f.blurScope, r);
	} else {
		var p = t.get(["emphasis", "focus"]), h = t.get(["emphasis", "blurScope"]);
		p != null && blurSeries(a, p, h, r);
	}
}
function findComponentHighDownDispatchers(t, n, r, a) {
	var o = {
		focusSelf: !1,
		dispatchers: null
	};
	if (t == null || t === "series" || n == null || r == null) return o;
	var c = a.getModel().getComponent(t, n);
	if (!c) return o;
	var l = a.getViewOfComponentModel(c);
	if (!l || !l.findHighDownDispatchers) return o;
	for (var u = l.findHighDownDispatchers(r), d, f = 0; f < u.length; f++) if (process$1.env.NODE_ENV !== "production" && !isHighDownDispatcher(u[f]) && error("param should be highDownDispatcher"), getECData(u[f]).focus === "self") {
		d = !0;
		break;
	}
	return {
		focusSelf: d,
		dispatchers: u
	};
}
function handleGlobalMouseOverForHighDown(t, n, r) {
	process$1.env.NODE_ENV !== "production" && !isHighDownDispatcher(t) && error("param should be highDownDispatcher");
	var a = getECData(t), o = findComponentHighDownDispatchers(a.componentMainType, a.componentIndex, a.componentHighDownName, r), c = o.dispatchers, l = o.focusSelf;
	c ? (l && blurComponent(a.componentMainType, a.componentIndex, r), each(c, function(t) {
		return enterEmphasisWhenMouseOver(t, n);
	})) : (blurSeries(a.seriesIndex, a.focus, a.blurScope, r), a.focus === "self" && blurComponent(a.componentMainType, a.componentIndex, r), enterEmphasisWhenMouseOver(t, n));
}
function handleGlobalMouseOutForHighDown(t, n, r) {
	process$1.env.NODE_ENV !== "production" && !isHighDownDispatcher(t) && error("param should be highDownDispatcher"), allLeaveBlur(r);
	var a = getECData(t), o = findComponentHighDownDispatchers(a.componentMainType, a.componentIndex, a.componentHighDownName, r).dispatchers;
	o ? each(o, function(t) {
		return leaveEmphasisWhenMouseOut(t, n);
	}) : leaveEmphasisWhenMouseOut(t, n);
}
function toggleSelectionFromPayload(t, n, r) {
	if (isSelectChangePayload(n)) {
		var a = n.dataType, o = queryDataIndex(t.getData(a), n);
		isArray(o) || (o = [o]), t[n.type === "toggleSelect" ? "toggleSelect" : n.type === "select" ? "select" : "unselect"](o, a);
	}
}
function updateSeriesElementSelection(t) {
	each(t.getAllData(), function(n) {
		var r = n.data, a = n.type;
		r.eachItemGraphicEl(function(n, r) {
			t.isSelected(r, a) ? enterSelect(n) : leaveSelect(n);
		});
	});
}
function getAllSelectedIndices(t) {
	var n = [];
	return t.eachSeries(function(t) {
		each(t.getAllData(), function(r) {
			r.data;
			var a = r.type, o = t.getSelectedDataIndices();
			if (o.length > 0) {
				var s = {
					dataIndex: o,
					seriesIndex: t.seriesIndex
				};
				a != null && (s.dataType = a), n.push(s);
			}
		});
	}), n;
}
function enableHoverEmphasis(t, n, r) {
	setAsHighDownDispatcher(t, !0), traverseUpdateState(t, setDefaultStateProxy), enableHoverFocus(t, n, r);
}
function disableHoverEmphasis(t) {
	setAsHighDownDispatcher(t, !1);
}
function toggleHoverEmphasis(t, n, r, a) {
	a ? disableHoverEmphasis(t) : enableHoverEmphasis(t, n, r);
}
function enableHoverFocus(t, n, r) {
	var a = getECData(t);
	n == null ? a.focus &&= null : (a.focus = n, a.blurScope = r);
}
var OTHER_STATES = [
	"emphasis",
	"blur",
	"select"
], defaultStyleGetterMap = {
	itemStyle: "getItemStyle",
	lineStyle: "getLineStyle",
	areaStyle: "getAreaStyle"
};
function setStatesStylesFromModel(t, n, r, a) {
	r ||= "itemStyle";
	for (var o = 0; o < OTHER_STATES.length; o++) {
		var s = OTHER_STATES[o], c = n.getModel([s, r]), l = t.ensureState(s);
		l.style = a ? a(c) : c[defaultStyleGetterMap[r]]();
	}
}
function setAsHighDownDispatcher(t, n) {
	var r = n === !1, a = t;
	t.highDownSilentOnTouch && (a.__highDownSilentOnTouch = t.highDownSilentOnTouch), (!r || a.__highDownDispatcher) && (a.__highByOuter = a.__highByOuter || 0, a.__highDownDispatcher = !r);
}
function isHighDownDispatcher(t) {
	return !!(t && t.__highDownDispatcher);
}
function enableComponentHighDownFeatures(t, n, r) {
	var a = getECData(t);
	a.componentMainType = n.mainType, a.componentIndex = n.componentIndex, a.componentHighDownName = r;
}
function getHighlightDigit(t) {
	var n = _highlightKeyMap[t];
	return n == null && _highlightNextDigit <= 32 && (n = _highlightKeyMap[t] = _highlightNextDigit++), n;
}
function isSelectChangePayload(t) {
	var n = t.type;
	return n === "select" || n === "unselect" || n === "toggleSelect";
}
function isHighDownPayload(t) {
	var n = t.type;
	return n === "highlight" || n === "downplay";
}
function savePathStates(t) {
	var n = getSavedStates(t);
	n.normalFill = t.style.fill, n.normalStroke = t.style.stroke;
	var r = t.states.select || {};
	n.selectFill = r.style && r.style.fill || null, n.selectStroke = r.style && r.style.stroke || null;
}
var CMD$2 = PathProxy_default.CMD, points$2 = [
	[],
	[],
	[]
], mathSqrt$2 = Math.sqrt, mathAtan2 = Math.atan2;
function transformPath(t, n) {
	if (n) {
		var r = t.data, a = t.len(), o, s, c, l, u, d, f = CMD$2.M, p = CMD$2.C, h = CMD$2.L, g = CMD$2.R, _ = CMD$2.A, v = CMD$2.Q;
		for (c = 0, l = 0; c < a;) {
			switch (o = r[c++], l = c, s = 0, o) {
				case f:
					s = 1;
					break;
				case h:
					s = 1;
					break;
				case p:
					s = 3;
					break;
				case v:
					s = 2;
					break;
				case _:
					var y = n[4], b = n[5], x = mathSqrt$2(n[0] * n[0] + n[1] * n[1]), S = mathSqrt$2(n[2] * n[2] + n[3] * n[3]), C = mathAtan2(-n[1] / S, n[0] / x);
					r[c] *= x, r[c++] += y, r[c] *= S, r[c++] += b, r[c++] *= x, r[c++] *= S, r[c++] += C, r[c++] += C, c += 2, l = c;
					break;
				case g: d[0] = r[c++], d[1] = r[c++], applyTransform(d, d, n), r[l++] = d[0], r[l++] = d[1], d[0] += r[c++], d[1] += r[c++], applyTransform(d, d, n), r[l++] = d[0], r[l++] = d[1];
			}
			for (u = 0; u < s; u++) {
				var w = points$2[u];
				w[0] = r[c++], w[1] = r[c++], applyTransform(w, w, n), r[l++] = w[0], r[l++] = w[1];
			}
		}
		t.increaseVersion();
	}
}
var mathSqrt$1 = Math.sqrt, mathSin$2 = Math.sin, mathCos$2 = Math.cos, PI$7 = Math.PI;
function vMag(t) {
	return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
}
function vRatio(t, n) {
	return (t[0] * n[0] + t[1] * n[1]) / (vMag(t) * vMag(n));
}
function vAngle(t, n) {
	return (t[0] * n[1] < t[1] * n[0] ? -1 : 1) * Math.acos(vRatio(t, n));
}
function processArc(t, n, r, a, o, s, c, l, u, d, f) {
	var p = u * (PI$7 / 180), h = mathCos$2(p) * (t - r) / 2 + mathSin$2(p) * (n - a) / 2, g = -1 * mathSin$2(p) * (t - r) / 2 + mathCos$2(p) * (n - a) / 2, _ = h * h / (c * c) + g * g / (l * l);
	_ > 1 && (c *= mathSqrt$1(_), l *= mathSqrt$1(_));
	var v = (o === s ? -1 : 1) * mathSqrt$1((c * c * (l * l) - c * c * (g * g) - l * l * (h * h)) / (c * c * (g * g) + l * l * (h * h))) || 0, y = v * c * g / l, b = v * -l * h / c, x = (t + r) / 2 + mathCos$2(p) * y - mathSin$2(p) * b, S = (n + a) / 2 + mathSin$2(p) * y + mathCos$2(p) * b, C = vAngle([1, 0], [(h - y) / c, (g - b) / l]), w = [(h - y) / c, (g - b) / l], T = [(-1 * h - y) / c, (-1 * g - b) / l], E = vAngle(w, T);
	if (vRatio(w, T) <= -1 && (E = PI$7), vRatio(w, T) >= 1 && (E = 0), E < 0) {
		var D = Math.round(E / PI$7 * 1e6) / 1e6;
		E = PI$7 * 2 + D % 2 * PI$7;
	}
	f.addData(d, x, S, c, l, C, E, p, s);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi, numberReg$1 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(t) {
	var n = new PathProxy_default();
	if (!t) return n;
	var r = 0, a = 0, o = r, s = a, c, l = PathProxy_default.CMD, u = t.match(commandReg);
	if (!u) return n;
	for (var d = 0; d < u.length; d++) {
		for (var f = u[d], p = f.charAt(0), h = void 0, g = f.match(numberReg$1) || [], _ = g.length, v = 0; v < _; v++) g[v] = parseFloat(g[v]);
		for (var y = 0; y < _;) {
			var b = void 0, x = void 0, S = void 0, C = void 0, w = void 0, T = void 0, E = void 0, D = r, O = a, A = void 0, j = void 0;
			switch (p) {
				case "l":
					r += g[y++], a += g[y++], h = l.L, n.addData(h, r, a);
					break;
				case "L":
					r = g[y++], a = g[y++], h = l.L, n.addData(h, r, a);
					break;
				case "m":
					r += g[y++], a += g[y++], h = l.M, n.addData(h, r, a), o = r, s = a, p = "l";
					break;
				case "M":
					r = g[y++], a = g[y++], h = l.M, n.addData(h, r, a), o = r, s = a, p = "L";
					break;
				case "h":
					r += g[y++], h = l.L, n.addData(h, r, a);
					break;
				case "H":
					r = g[y++], h = l.L, n.addData(h, r, a);
					break;
				case "v":
					a += g[y++], h = l.L, n.addData(h, r, a);
					break;
				case "V":
					a = g[y++], h = l.L, n.addData(h, r, a);
					break;
				case "C":
					h = l.C, n.addData(h, g[y++], g[y++], g[y++], g[y++], g[y++], g[y++]), r = g[y - 2], a = g[y - 1];
					break;
				case "c":
					h = l.C, n.addData(h, g[y++] + r, g[y++] + a, g[y++] + r, g[y++] + a, g[y++] + r, g[y++] + a), r += g[y - 2], a += g[y - 1];
					break;
				case "S":
					b = r, x = a, A = n.len(), j = n.data, c === l.C && (b += r - j[A - 4], x += a - j[A - 3]), h = l.C, D = g[y++], O = g[y++], r = g[y++], a = g[y++], n.addData(h, b, x, D, O, r, a);
					break;
				case "s":
					b = r, x = a, A = n.len(), j = n.data, c === l.C && (b += r - j[A - 4], x += a - j[A - 3]), h = l.C, D = r + g[y++], O = a + g[y++], r += g[y++], a += g[y++], n.addData(h, b, x, D, O, r, a);
					break;
				case "Q":
					D = g[y++], O = g[y++], r = g[y++], a = g[y++], h = l.Q, n.addData(h, D, O, r, a);
					break;
				case "q":
					D = g[y++] + r, O = g[y++] + a, r += g[y++], a += g[y++], h = l.Q, n.addData(h, D, O, r, a);
					break;
				case "T":
					b = r, x = a, A = n.len(), j = n.data, c === l.Q && (b += r - j[A - 4], x += a - j[A - 3]), r = g[y++], a = g[y++], h = l.Q, n.addData(h, b, x, r, a);
					break;
				case "t":
					b = r, x = a, A = n.len(), j = n.data, c === l.Q && (b += r - j[A - 4], x += a - j[A - 3]), r += g[y++], a += g[y++], h = l.Q, n.addData(h, b, x, r, a);
					break;
				case "A":
					S = g[y++], C = g[y++], w = g[y++], T = g[y++], E = g[y++], D = r, O = a, r = g[y++], a = g[y++], h = l.A, processArc(D, O, r, a, T, E, S, C, w, h, n);
					break;
				case "a":
					S = g[y++], C = g[y++], w = g[y++], T = g[y++], E = g[y++], D = r, O = a, r += g[y++], a += g[y++], h = l.A, processArc(D, O, r, a, T, E, S, C, w, h, n);
					break;
			}
		}
		(p === "z" || p === "Z") && (h = l.Z, n.addData(h), r = o, a = s), c = h;
	}
	return n.toStatic(), n;
}
var SVGPath = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.applyTransform = function(t) {}, n;
}(Path_default);
function isPathProxy(t) {
	return t.setData != null;
}
function createPathOptions(t, n) {
	var r = createPathProxyFromString(t), a = extend({}, n);
	return a.buildPath = function(t) {
		if (isPathProxy(t)) {
			t.setData(r.data);
			var n = t.getContext();
			n && t.rebuildPath(n, 1);
		} else {
			var n = t;
			r.rebuildPath(n, 1);
		}
	}, a.applyTransform = function(t) {
		transformPath(r, t), this.dirtyShape();
	}, a;
}
function createFromString(t, n) {
	return new SVGPath(createPathOptions(t, n));
}
function extendFromString(t, n) {
	var r = createPathOptions(t, n);
	return function(t) {
		__extends(n, t);
		function n(n) {
			var a = t.call(this, n) || this;
			return a.applyTransform = r.applyTransform, a.buildPath = r.buildPath, a;
		}
		return n;
	}(SVGPath);
}
function mergePath$1(t, n) {
	for (var r = [], a = t.length, o = 0; o < a; o++) {
		var s = t[o];
		r.push(s.getUpdatedPathProxy(!0));
	}
	var c = new Path_default(n);
	return c.createPathProxy(), c.buildPath = function(t) {
		if (isPathProxy(t)) {
			t.appendPath(r);
			var n = t.getContext();
			n && t.rebuildPath(n, 1);
		}
	}, c;
}
function clonePath(t, n) {
	n ||= {};
	var r = new Path_default();
	return t.shape && r.setShape(t.shape), r.setStyle(t.style), n.bakeTransform ? transformPath(r.path, t.getComputedTransform()) : n.toLocal ? r.setLocalTransform(t.getComputedTransform()) : r.copyTransform(t), r.buildPath = t.buildPath, r.applyTransform = r.applyTransform, r.z = t.z, r.z2 = t.z2, r.zlevel = t.zlevel, r;
}
var CircleShape = function() {
	function t() {
		this.cx = 0, this.cy = 0, this.r = 0;
	}
	return t;
}(), Circle = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype.getDefaultShape = function() {
		return new CircleShape();
	}, n.prototype.buildPath = function(t, n) {
		t.moveTo(n.cx + n.r, n.cy), t.arc(n.cx, n.cy, n.r, 0, Math.PI * 2);
	}, n;
}(Path_default);
Circle.prototype.type = "circle";
var Circle_default = Circle, EllipseShape = function() {
	function t() {
		this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
	}
	return t;
}(), Ellipse = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype.getDefaultShape = function() {
		return new EllipseShape();
	}, n.prototype.buildPath = function(t, n) {
		var r = .5522848, a = n.cx, o = n.cy, s = n.rx, c = n.ry, l = s * r, u = c * r;
		t.moveTo(a - s, o), t.bezierCurveTo(a - s, o - u, a - l, o - c, a, o - c), t.bezierCurveTo(a + l, o - c, a + s, o - u, a + s, o), t.bezierCurveTo(a + s, o + u, a + l, o + c, a, o + c), t.bezierCurveTo(a - l, o + c, a - s, o + u, a - s, o), t.closePath();
	}, n;
}(Path_default);
Ellipse.prototype.type = "ellipse";
var Ellipse_default = Ellipse, PI$6 = Math.PI, PI2$3 = PI$6 * 2, mathSin$1 = Math.sin, mathCos$1 = Math.cos, mathACos = Math.acos, mathATan2 = Math.atan2, mathAbs$1 = Math.abs, mathSqrt = Math.sqrt, mathMax$7 = Math.max, mathMin$7 = Math.min, e = 1e-4;
function intersect(t, n, r, a, o, s, c, l) {
	var u = r - t, d = a - n, f = c - o, p = l - s, h = p * u - f * d;
	if (!(h * h < e)) return h = (f * (n - s) - p * (t - o)) / h, [t + h * u, n + h * d];
}
function computeCornerTangents(t, n, r, a, o, s, c) {
	var l = t - r, u = n - a, d = (c ? s : -s) / mathSqrt(l * l + u * u), f = d * u, p = -d * l, h = t + f, g = n + p, _ = r + f, v = a + p, y = (h + _) / 2, b = (g + v) / 2, x = _ - h, S = v - g, C = x * x + S * S, w = o - s, T = h * v - _ * g, E = (S < 0 ? -1 : 1) * mathSqrt(mathMax$7(0, w * w * C - T * T)), D = (T * S - x * E) / C, O = (-T * x - S * E) / C, A = (T * S + x * E) / C, j = (-T * x + S * E) / C, M = D - y, N = O - b, P = A - y, F = j - b;
	return M * M + N * N > P * P + F * F && (D = A, O = j), {
		cx: D,
		cy: O,
		x0: -f,
		y0: -p,
		x1: D * (o / w - 1),
		y1: O * (o / w - 1)
	};
}
function normalizeCornerRadius(t) {
	var n;
	if (isArray(t)) {
		var r = t.length;
		if (!r) return t;
		n = r === 1 ? [
			t[0],
			t[0],
			0,
			0
		] : r === 2 ? [
			t[0],
			t[0],
			t[1],
			t[1]
		] : r === 3 ? t.concat(t[2]) : t;
	} else n = [
		t,
		t,
		t,
		t
	];
	return n;
}
function buildPath$1(t, n) {
	var r, a = mathMax$7(n.r, 0), o = mathMax$7(n.r0 || 0, 0), s = a > 0;
	if (!(!s && !(o > 0))) {
		if (s || (a = o, o = 0), o > a) {
			var c = a;
			a = o, o = c;
		}
		var l = n.startAngle, u = n.endAngle;
		if (!(isNaN(l) || isNaN(u))) {
			var d = n.cx, f = n.cy, p = !!n.clockwise, h = mathAbs$1(u - l), g = h > PI2$3 && h % PI2$3;
			if (g > e && (h = g), !(a > e)) t.moveTo(d, f);
			else if (h > PI2$3 - e) t.moveTo(d + a * mathCos$1(l), f + a * mathSin$1(l)), t.arc(d, f, a, l, u, !p), o > e && (t.moveTo(d + o * mathCos$1(u), f + o * mathSin$1(u)), t.arc(d, f, o, u, l, p));
			else {
				var _ = void 0, v = void 0, y = void 0, b = void 0, x = void 0, S = void 0, C = void 0, w = void 0, T = void 0, E = void 0, D = void 0, O = void 0, A = void 0, j = void 0, M = void 0, N = void 0, P = a * mathCos$1(l), F = a * mathSin$1(l), I = o * mathCos$1(u), L = o * mathSin$1(u), R = h > e;
				if (R) {
					var z = n.cornerRadius;
					z && (r = normalizeCornerRadius(z), _ = r[0], v = r[1], y = r[2], b = r[3]);
					var B = mathAbs$1(a - o) / 2;
					if (x = mathMin$7(B, y), S = mathMin$7(B, b), C = mathMin$7(B, _), w = mathMin$7(B, v), D = T = mathMax$7(x, S), O = E = mathMax$7(C, w), (T > e || E > e) && (A = a * mathCos$1(u), j = a * mathSin$1(u), M = o * mathCos$1(l), N = o * mathSin$1(l), h < PI$6)) {
						var V = intersect(P, F, M, N, A, j, I, L);
						if (V) {
							var H = P - V[0], U = F - V[1], W = A - V[0], G = j - V[1], K = 1 / mathSin$1(mathACos((H * W + U * G) / (mathSqrt(H * H + U * U) * mathSqrt(W * W + G * G))) / 2), q = mathSqrt(V[0] * V[0] + V[1] * V[1]);
							D = mathMin$7(T, (a - q) / (K + 1)), O = mathMin$7(E, (o - q) / (K - 1));
						}
					}
				}
				if (!R) t.moveTo(d + P, f + F);
				else if (D > e) {
					var J = mathMin$7(y, D), Y = mathMin$7(b, D), X = computeCornerTangents(M, N, P, F, a, J, p), Z = computeCornerTangents(A, j, I, L, a, Y, p);
					t.moveTo(d + X.cx + X.x0, f + X.cy + X.y0), D < T && J === Y ? t.arc(d + X.cx, f + X.cy, D, mathATan2(X.y0, X.x0), mathATan2(Z.y0, Z.x0), !p) : (J > 0 && t.arc(d + X.cx, f + X.cy, J, mathATan2(X.y0, X.x0), mathATan2(X.y1, X.x1), !p), t.arc(d, f, a, mathATan2(X.cy + X.y1, X.cx + X.x1), mathATan2(Z.cy + Z.y1, Z.cx + Z.x1), !p), Y > 0 && t.arc(d + Z.cx, f + Z.cy, Y, mathATan2(Z.y1, Z.x1), mathATan2(Z.y0, Z.x0), !p));
				} else t.moveTo(d + P, f + F), t.arc(d, f, a, l, u, !p);
				if (!(o > e) || !R) t.lineTo(d + I, f + L);
				else if (O > e) {
					var J = mathMin$7(_, O), Y = mathMin$7(v, O), X = computeCornerTangents(I, L, A, j, o, -Y, p), Z = computeCornerTangents(P, F, M, N, o, -J, p);
					t.lineTo(d + X.cx + X.x0, f + X.cy + X.y0), O < E && J === Y ? t.arc(d + X.cx, f + X.cy, O, mathATan2(X.y0, X.x0), mathATan2(Z.y0, Z.x0), !p) : (Y > 0 && t.arc(d + X.cx, f + X.cy, Y, mathATan2(X.y0, X.x0), mathATan2(X.y1, X.x1), !p), t.arc(d, f, o, mathATan2(X.cy + X.y1, X.cx + X.x1), mathATan2(Z.cy + Z.y1, Z.cx + Z.x1), p), J > 0 && t.arc(d + Z.cx, f + Z.cy, J, mathATan2(Z.y1, Z.x1), mathATan2(Z.y0, Z.x0), !p));
				} else t.lineTo(d + I, f + L), t.arc(d, f, o, u, l, p);
			}
			t.closePath();
		}
	}
}
var SectorShape = function() {
	function t() {
		this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
	}
	return t;
}(), Sector = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype.getDefaultShape = function() {
		return new SectorShape();
	}, n.prototype.buildPath = function(t, n) {
		buildPath$1(t, n);
	}, n.prototype.isZeroArea = function() {
		return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
	}, n;
}(Path_default);
Sector.prototype.type = "sector";
var Sector_default = Sector, RingShape = function() {
	function t() {
		this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
	}
	return t;
}(), Ring = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype.getDefaultShape = function() {
		return new RingShape();
	}, n.prototype.buildPath = function(t, n) {
		var r = n.cx, a = n.cy, o = Math.PI * 2;
		t.moveTo(r + n.r, a), t.arc(r, a, n.r, 0, o, !1), t.moveTo(r + n.r0, a), t.arc(r, a, n.r0, 0, o, !0);
	}, n;
}(Path_default);
Ring.prototype.type = "ring";
var Ring_default = Ring;
function smoothBezier(t, n, r, a) {
	var o = [], s = [], c = [], l = [], u, d, f, p;
	if (a) {
		f = [Infinity, Infinity], p = [-Infinity, -Infinity];
		for (var h = 0, g = t.length; h < g; h++) min(f, f, t[h]), max(p, p, t[h]);
		min(f, f, a[0]), max(p, p, a[1]);
	}
	for (var h = 0, g = t.length; h < g; h++) {
		var _ = t[h];
		if (r) u = t[h ? h - 1 : g - 1], d = t[(h + 1) % g];
		else if (h === 0 || h === g - 1) {
			o.push(clone$3(t[h]));
			continue;
		} else u = t[h - 1], d = t[h + 1];
		sub(s, d, u), scale$1(s, s, n);
		var v = distance(_, u), y = distance(_, d), b = v + y;
		b !== 0 && (v /= b, y /= b), scale$1(c, s, -v), scale$1(l, s, y);
		var x = add([], _, c), S = add([], _, l);
		a && (max(x, x, f), min(x, x, p), max(S, S, f), min(S, S, p)), o.push(x), o.push(S);
	}
	return r && o.push(o.shift()), o;
}
function buildPath(t, n, r) {
	var a = n.smooth, o = n.points;
	if (o && o.length >= 2) {
		if (a) {
			var s = smoothBezier(o, a, r, n.smoothConstraint);
			t.moveTo(o[0][0], o[0][1]);
			for (var c = o.length, l = 0; l < (r ? c : c - 1); l++) {
				var u = s[l * 2], d = s[l * 2 + 1], f = o[(l + 1) % c];
				t.bezierCurveTo(u[0], u[1], d[0], d[1], f[0], f[1]);
			}
		} else {
			t.moveTo(o[0][0], o[0][1]);
			for (var l = 1, p = o.length; l < p; l++) t.lineTo(o[l][0], o[l][1]);
		}
		r && t.closePath();
	}
}
var PolygonShape = function() {
	function t() {
		this.points = null, this.smooth = 0, this.smoothConstraint = null;
	}
	return t;
}(), Polygon = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype.getDefaultShape = function() {
		return new PolygonShape();
	}, n.prototype.buildPath = function(t, n) {
		buildPath(t, n, !0);
	}, n;
}(Path_default);
Polygon.prototype.type = "polygon";
var Polygon_default = Polygon, PolylineShape = function() {
	function t() {
		this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
	}
	return t;
}(), Polyline$1 = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	}, n.prototype.getDefaultShape = function() {
		return new PolylineShape();
	}, n.prototype.buildPath = function(t, n) {
		buildPath(t, n, !1);
	}, n;
}(Path_default);
Polyline$1.prototype.type = "polyline";
var Polyline_default$1 = Polyline$1, subPixelOptimizeOutputShape = {}, LineShape = function() {
	function t() {
		this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
	}
	return t;
}(), Line$1 = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	}, n.prototype.getDefaultShape = function() {
		return new LineShape();
	}, n.prototype.buildPath = function(t, n) {
		var r, a, o, s;
		if (this.subPixelOptimize) {
			var c = subPixelOptimizeLine$1(subPixelOptimizeOutputShape, n, this.style);
			r = c.x1, a = c.y1, o = c.x2, s = c.y2;
		} else r = n.x1, a = n.y1, o = n.x2, s = n.y2;
		var l = n.percent;
		l !== 0 && (t.moveTo(r, a), l < 1 && (o = r * (1 - l) + o * l, s = a * (1 - l) + s * l), t.lineTo(o, s));
	}, n.prototype.pointAt = function(t) {
		var n = this.shape;
		return [n.x1 * (1 - t) + n.x2 * t, n.y1 * (1 - t) + n.y2 * t];
	}, n;
}(Path_default);
Line$1.prototype.type = "line";
var Line_default$1 = Line$1, out = [], BezierCurveShape = function() {
	function t() {
		this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
	}
	return t;
}();
function someVectorAt(t, n, r) {
	var a = t.cpx2, o = t.cpy2;
	return a != null || o != null ? [(r ? cubicDerivativeAt : cubicAt)(t.x1, t.cpx1, t.cpx2, t.x2, n), (r ? cubicDerivativeAt : cubicAt)(t.y1, t.cpy1, t.cpy2, t.y2, n)] : [(r ? quadraticDerivativeAt : quadraticAt$1)(t.x1, t.cpx1, t.x2, n), (r ? quadraticDerivativeAt : quadraticAt$1)(t.y1, t.cpy1, t.y2, n)];
}
var BezierCurve = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	}, n.prototype.getDefaultShape = function() {
		return new BezierCurveShape();
	}, n.prototype.buildPath = function(t, n) {
		var r = n.x1, a = n.y1, o = n.x2, s = n.y2, c = n.cpx1, l = n.cpy1, u = n.cpx2, d = n.cpy2, f = n.percent;
		f !== 0 && (t.moveTo(r, a), u == null || d == null ? (f < 1 && (quadraticSubdivide(r, c, o, f, out), c = out[1], o = out[2], quadraticSubdivide(a, l, s, f, out), l = out[1], s = out[2]), t.quadraticCurveTo(c, l, o, s)) : (f < 1 && (cubicSubdivide(r, c, u, o, f, out), c = out[1], u = out[2], o = out[3], cubicSubdivide(a, l, d, s, f, out), l = out[1], d = out[2], s = out[3]), t.bezierCurveTo(c, l, u, d, o, s)));
	}, n.prototype.pointAt = function(t) {
		return someVectorAt(this.shape, t, !1);
	}, n.prototype.tangentAt = function(t) {
		var n = someVectorAt(this.shape, t, !0);
		return normalize$3(n, n);
	}, n;
}(Path_default);
BezierCurve.prototype.type = "bezier-curve";
var BezierCurve_default = BezierCurve, ArcShape = function() {
	function t() {
		this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
	}
	return t;
}(), Arc = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	}, n.prototype.getDefaultShape = function() {
		return new ArcShape();
	}, n.prototype.buildPath = function(t, n) {
		var r = n.cx, a = n.cy, o = Math.max(n.r, 0), s = n.startAngle, c = n.endAngle, l = n.clockwise, u = Math.cos(s), d = Math.sin(s);
		t.moveTo(u * o + r, d * o + a), t.arc(r, a, o, s, c, !l);
	}, n;
}(Path_default);
Arc.prototype.type = "arc";
var Arc_default = Arc, CompoundPath_default = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n.type = "compound", n;
	}
	return n.prototype._updatePathDirty = function() {
		for (var t = this.shape.paths, n = this.shapeChanged(), r = 0; r < t.length; r++) n ||= t[r].shapeChanged();
		n && this.dirtyShape();
	}, n.prototype.beforeBrush = function() {
		this._updatePathDirty();
		for (var t = this.shape.paths || [], n = this.getGlobalScale(), r = 0; r < t.length; r++) t[r].path || t[r].createPathProxy(), t[r].path.setScale(n[0], n[1], t[r].segmentIgnoreThreshold);
	}, n.prototype.buildPath = function(t, n) {
		for (var r = n.paths || [], a = 0; a < r.length; a++) r[a].buildPath(t, r[a].shape, !0);
	}, n.prototype.afterBrush = function() {
		for (var t = this.shape.paths || [], n = 0; n < t.length; n++) t[n].pathUpdated();
	}, n.prototype.getBoundingRect = function() {
		return this._updatePathDirty.call(this), Path_default.prototype.getBoundingRect.call(this);
	}, n;
}(Path_default), Gradient_default = function() {
	function t(t) {
		this.colorStops = t || [];
	}
	return t.prototype.addColorStop = function(t, n) {
		this.colorStops.push({
			offset: t,
			color: n
		});
	}, t;
}(), LinearGradient_default = function(t) {
	__extends(n, t);
	function n(n, r, a, o, s, c) {
		var l = t.call(this, s) || this;
		return l.x = n ?? 0, l.y = r ?? 0, l.x2 = a ?? 1, l.y2 = o ?? 0, l.type = "linear", l.global = c || !1, l;
	}
	return n;
}(Gradient_default), RadialGradient_default = function(t) {
	__extends(n, t);
	function n(n, r, a, o, s) {
		var c = t.call(this, o) || this;
		return c.x = n ?? .5, c.y = r ?? .5, c.r = a ?? .5, c.type = "radial", c.global = s || !1, c;
	}
	return n;
}(Gradient_default), extent = [0, 0], extent2 = [0, 0], minTv = new Point_default(), maxTv = new Point_default(), OrientedBoundingRect_default = function() {
	function t(t, n) {
		this._corners = [], this._axes = [], this._origin = [0, 0];
		for (var r = 0; r < 4; r++) this._corners[r] = new Point_default();
		for (var r = 0; r < 2; r++) this._axes[r] = new Point_default();
		t && this.fromBoundingRect(t, n);
	}
	return t.prototype.fromBoundingRect = function(t, n) {
		var r = this._corners, a = this._axes, o = t.x, s = t.y, c = o + t.width, l = s + t.height;
		if (r[0].set(o, s), r[1].set(c, s), r[2].set(c, l), r[3].set(o, l), n) for (var u = 0; u < 4; u++) r[u].transform(n);
		Point_default.sub(a[0], r[1], r[0]), Point_default.sub(a[1], r[3], r[0]), a[0].normalize(), a[1].normalize();
		for (var u = 0; u < 2; u++) this._origin[u] = a[u].dot(r[0]);
	}, t.prototype.intersect = function(t, n) {
		var r = !0, a = !n;
		return minTv.set(Infinity, Infinity), maxTv.set(0, 0), !this._intersectCheckOneSide(this, t, minTv, maxTv, a, 1) && (r = !1, a) || !this._intersectCheckOneSide(t, this, minTv, maxTv, a, -1) && (r = !1, a) || a || Point_default.copy(n, r ? minTv : maxTv), r;
	}, t.prototype._intersectCheckOneSide = function(t, n, r, a, o, s) {
		for (var c = !0, l = 0; l < 2; l++) {
			var u = this._axes[l];
			if (this._getProjMinMaxOnAxis(l, t._corners, extent), this._getProjMinMaxOnAxis(l, n._corners, extent2), extent[1] < extent2[0] || extent[0] > extent2[1]) {
				if (c = !1, o) return c;
				var d = Math.abs(extent2[0] - extent[1]), f = Math.abs(extent[0] - extent2[1]);
				Math.min(d, f) > a.len() && (d < f ? Point_default.scale(a, u, -d * s) : Point_default.scale(a, u, f * s));
			} else if (r) {
				var d = Math.abs(extent2[0] - extent[1]), f = Math.abs(extent[0] - extent2[1]);
				Math.min(d, f) < r.len() && (d < f ? Point_default.scale(r, u, d * s) : Point_default.scale(r, u, -f * s));
			}
		}
		return c;
	}, t.prototype._getProjMinMaxOnAxis = function(t, n, r) {
		for (var a = this._axes[t], o = this._origin, s = n[0].dot(a) + o[t], c = s, l = s, u = 1; u < n.length; u++) {
			var d = n[u].dot(a) + o[t];
			c = Math.min(d, c), l = Math.max(d, l);
		}
		r[0] = c, r[1] = l;
	}, t;
}(), m = [], IncrementalDisplayable_default = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n.notClear = !0, n.incremental = !0, n._displayables = [], n._temporaryDisplayables = [], n._cursor = 0, n;
	}
	return n.prototype.traverse = function(t, n) {
		t.call(n, this);
	}, n.prototype.useStyle = function() {
		this.style = {};
	}, n.prototype.getCursor = function() {
		return this._cursor;
	}, n.prototype.innerAfterBrush = function() {
		this._cursor = this._displayables.length;
	}, n.prototype.clearDisplaybles = function() {
		this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
	}, n.prototype.clearTemporalDisplayables = function() {
		this._temporaryDisplayables = [];
	}, n.prototype.addDisplayable = function(t, n) {
		n ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.markRedraw();
	}, n.prototype.addDisplayables = function(t, n) {
		n ||= !1;
		for (var r = 0; r < t.length; r++) this.addDisplayable(t[r], n);
	}, n.prototype.getDisplayables = function() {
		return this._displayables;
	}, n.prototype.getTemporalDisplayables = function() {
		return this._temporaryDisplayables;
	}, n.prototype.eachPendingDisplayable = function(t) {
		for (var n = this._cursor; n < this._displayables.length; n++) t && t(this._displayables[n]);
		for (var n = 0; n < this._temporaryDisplayables.length; n++) t && t(this._temporaryDisplayables[n]);
	}, n.prototype.update = function() {
		this.updateTransform();
		for (var t = this._cursor; t < this._displayables.length; t++) {
			var n = this._displayables[t];
			n.parent = this, n.update(), n.parent = null;
		}
		for (var t = 0; t < this._temporaryDisplayables.length; t++) {
			var n = this._temporaryDisplayables[t];
			n.parent = this, n.update(), n.parent = null;
		}
	}, n.prototype.getBoundingRect = function() {
		if (!this._rect) {
			for (var t = new BoundingRect_default(Infinity, Infinity, -Infinity, -Infinity), n = 0; n < this._displayables.length; n++) {
				var r = this._displayables[n], a = r.getBoundingRect().clone();
				r.needLocalTransform() && a.applyTransform(r.getLocalTransform(m)), t.union(a);
			}
			this._rect = t;
		}
		return this._rect;
	}, n.prototype.contain = function(t, n) {
		var r = this.transformCoordToLocal(t, n);
		if (this.getBoundingRect().contain(r[0], r[1])) {
			for (var a = 0; a < this._displayables.length; a++) if (this._displayables[a].contain(t, n)) return !0;
		}
		return !1;
	}, n;
}(Displayable_default), transitionStore = makeInner();
function getAnimationConfig(t, n, r, a, o) {
	var s;
	if (n && n.ecModel) {
		var c = n.ecModel.getUpdatePayload();
		s = c && c.animation;
	}
	var l = n && n.isAnimationEnabled(), u = t === "update";
	if (l) {
		var d = void 0, f = void 0, p = void 0;
		return a ? (d = retrieve2(a.duration, 200), f = retrieve2(a.easing, "cubicOut"), p = 0) : (d = n.getShallow(u ? "animationDurationUpdate" : "animationDuration"), f = n.getShallow(u ? "animationEasingUpdate" : "animationEasing"), p = n.getShallow(u ? "animationDelayUpdate" : "animationDelay")), s && (s.duration != null && (d = s.duration), s.easing != null && (f = s.easing), s.delay != null && (p = s.delay)), isFunction(p) && (p = p(r, o)), isFunction(d) && (d = d(r)), {
			duration: d || 0,
			delay: p,
			easing: f
		};
	} else return null;
}
function animateOrSetProps(t, n, r, a, o, s, c) {
	var l = !1, u;
	isFunction(o) ? (c = s, s = o, o = null) : isObject(o) && (s = o.cb, c = o.during, l = o.isFrom, u = o.removeOpt, o = o.dataIndex);
	var d = t === "leave";
	d || n.stopAnimation("leave");
	var f = getAnimationConfig(t, a, o, d ? u || {} : null, a && a.getAnimationDelayParams ? a.getAnimationDelayParams(n, o) : null);
	if (f && f.duration > 0) {
		var p = f.duration, h = f.delay, g = f.easing, _ = {
			duration: p,
			delay: h || 0,
			easing: g,
			done: s,
			force: !!s || !!c,
			setToFinal: !d,
			scope: t,
			during: c
		};
		l ? n.animateFrom(r, _) : n.animateTo(r, _);
	} else n.stopAnimation(), !l && n.attr(r), c && c(1), s && s();
}
function updateProps(t, n, r, a, o, s) {
	animateOrSetProps("update", t, n, r, a, o, s);
}
function initProps(t, n, r, a, o, s) {
	animateOrSetProps("enter", t, n, r, a, o, s);
}
function isElementRemoved(t) {
	if (!t.__zr) return !0;
	for (var n = 0; n < t.animators.length; n++) if (t.animators[n].scope === "leave") return !0;
	return !1;
}
function removeElement(t, n, r, a, o, s) {
	isElementRemoved(t) || animateOrSetProps("leave", t, n, r, a, o, s);
}
function fadeOutDisplayable(t, n, r, a) {
	t.removeTextContent(), t.removeTextGuideLine(), removeElement(t, { style: { opacity: 0 } }, n, r, a);
}
function removeElementWithFadeOut(t, n, r) {
	function a() {
		t.parent && t.parent.remove(t);
	}
	t.isGroup ? t.traverse(function(t) {
		t.isGroup || fadeOutDisplayable(t, n, r, a);
	}) : fadeOutDisplayable(t, n, r, a);
}
function saveOldStyle(t) {
	transitionStore(t).oldStyle = t.style;
}
function getOldStyle(t) {
	return transitionStore(t).oldStyle;
}
var graphic_exports$1 = /* @__PURE__ */ __export({
	Arc: () => Arc_default,
	BezierCurve: () => BezierCurve_default,
	BoundingRect: () => BoundingRect_default,
	Circle: () => Circle_default,
	CompoundPath: () => CompoundPath_default,
	Ellipse: () => Ellipse_default,
	Group: () => Group_default,
	Image: () => Image_default,
	IncrementalDisplayable: () => IncrementalDisplayable_default,
	Line: () => Line_default$1,
	LinearGradient: () => LinearGradient_default,
	OrientedBoundingRect: () => OrientedBoundingRect_default,
	Path: () => Path_default,
	Point: () => Point_default,
	Polygon: () => Polygon_default,
	Polyline: () => Polyline_default$1,
	RadialGradient: () => RadialGradient_default,
	Rect: () => Rect_default,
	Ring: () => Ring_default,
	Sector: () => Sector_default,
	Text: () => Text_default,
	applyTransform: () => applyTransform$1,
	clipPointsByRect: () => clipPointsByRect,
	clipRectByRect: () => clipRectByRect,
	createIcon: () => createIcon,
	extendPath: () => extendPath,
	extendShape: () => extendShape,
	getShapeClass: () => getShapeClass,
	getTransform: () => getTransform$1,
	groupTransition: () => groupTransition,
	initProps: () => initProps,
	isElementRemoved: () => isElementRemoved,
	lineLineIntersect: () => lineLineIntersect$1,
	linePolygonIntersect: () => linePolygonIntersect,
	makeImage: () => makeImage,
	makePath: () => makePath,
	mergePath: () => mergePath,
	registerShape: () => registerShape,
	removeElement: () => removeElement,
	removeElementWithFadeOut: () => removeElementWithFadeOut,
	resizePath: () => resizePath,
	setTooltipConfig: () => setTooltipConfig,
	subPixelOptimize: () => subPixelOptimize,
	subPixelOptimizeLine: () => subPixelOptimizeLine,
	subPixelOptimizeRect: () => subPixelOptimizeRect,
	transformDirection: () => transformDirection,
	traverseElements: () => traverseElements,
	updateProps: () => updateProps
}), mathMax$6 = Math.max, mathMin$6 = Math.min, _customShapeMap = {};
function extendShape(t) {
	return Path_default.extend(t);
}
var extendPathFromString = extendFromString;
function extendPath(t, n) {
	return extendPathFromString(t, n);
}
function registerShape(t, n) {
	_customShapeMap[t] = n;
}
function getShapeClass(t) {
	if (_customShapeMap.hasOwnProperty(t)) return _customShapeMap[t];
}
function makePath(t, n, r, a) {
	var o = createFromString(t, n);
	return r && (a === "center" && (r = centerGraphic(r, o.getBoundingRect())), resizePath(o, r)), o;
}
function makeImage(t, n, r) {
	var a = new Image_default({
		style: {
			image: t,
			x: n.x,
			y: n.y,
			width: n.width,
			height: n.height
		},
		onload: function(t) {
			if (r === "center") {
				var o = {
					width: t.width,
					height: t.height
				};
				a.setStyle(centerGraphic(n, o));
			}
		}
	});
	return a;
}
function centerGraphic(t, n) {
	var r = n.width / n.height, a = t.height * r, o;
	a <= t.width ? o = t.height : (a = t.width, o = a / r);
	var s = t.x + t.width / 2, c = t.y + t.height / 2;
	return {
		x: s - a / 2,
		y: c - o / 2,
		width: a,
		height: o
	};
}
var mergePath = mergePath$1;
function resizePath(t, n) {
	if (t.applyTransform) {
		var r = t.getBoundingRect().calculateTransform(n);
		t.applyTransform(r);
	}
}
function subPixelOptimizeLine(t, n) {
	return subPixelOptimizeLine$1(t, t, { lineWidth: n }), t;
}
function subPixelOptimizeRect(t) {
	return subPixelOptimizeRect$1(t.shape, t.shape, t.style), t;
}
var subPixelOptimize = subPixelOptimize$1;
function getTransform$1(t, n) {
	for (var r = identity([]); t && t !== n;) mul(r, t.getLocalTransform(), r), t = t.parent;
	return r;
}
function applyTransform$1(t, n, r) {
	return n && !isArrayLike(n) && (n = Transformable_default.getLocalTransform(n)), r && (n = invert([], n)), applyTransform([], t, n);
}
function transformDirection(t, n, r) {
	var a = n[4] === 0 || n[5] === 0 || n[0] === 0 ? 1 : Math.abs(2 * n[4] / n[0]), o = n[4] === 0 || n[5] === 0 || n[2] === 0 ? 1 : Math.abs(2 * n[4] / n[2]), s = [t === "left" ? -a : t === "right" ? a : 0, t === "top" ? -o : t === "bottom" ? o : 0];
	return s = applyTransform$1(s, n, r), Math.abs(s[0]) > Math.abs(s[1]) ? s[0] > 0 ? "right" : "left" : s[1] > 0 ? "bottom" : "top";
}
function isNotGroup(t) {
	return !t.isGroup;
}
function isPath$1(t) {
	return t.shape != null;
}
function groupTransition(t, n, r) {
	if (!t || !n) return;
	function a(t) {
		var n = {};
		return t.traverse(function(t) {
			isNotGroup(t) && t.anid && (n[t.anid] = t);
		}), n;
	}
	function o(t) {
		var n = {
			x: t.x,
			y: t.y,
			rotation: t.rotation
		};
		return isPath$1(t) && (n.shape = extend({}, t.shape)), n;
	}
	var s = a(t);
	n.traverse(function(t) {
		if (isNotGroup(t) && t.anid) {
			var n = s[t.anid];
			if (n) {
				var a = o(t);
				t.attr(o(n)), updateProps(t, a, r, getECData(t).dataIndex);
			}
		}
	});
}
function clipPointsByRect(t, n) {
	return map(t, function(t) {
		var r = t[0];
		r = mathMax$6(r, n.x), r = mathMin$6(r, n.x + n.width);
		var a = t[1];
		return a = mathMax$6(a, n.y), a = mathMin$6(a, n.y + n.height), [r, a];
	});
}
function clipRectByRect(t, n) {
	var r = mathMax$6(t.x, n.x), a = mathMin$6(t.x + t.width, n.x + n.width), o = mathMax$6(t.y, n.y), s = mathMin$6(t.y + t.height, n.y + n.height);
	if (a >= r && s >= o) return {
		x: r,
		y: o,
		width: a - r,
		height: s - o
	};
}
function createIcon(t, n, r) {
	var a = extend({ rectHover: !0 }, n), o = a.style = { strokeNoScale: !0 };
	if (r ||= {
		x: -1,
		y: -1,
		width: 2,
		height: 2
	}, t) return t.indexOf("image://") === 0 ? (o.image = t.slice(8), defaults(o, r), new Image_default(a)) : makePath(t.replace("path://", ""), a, r, "center");
}
function linePolygonIntersect(t, n, r, a, o) {
	for (var s = 0, c = o[o.length - 1]; s < o.length; s++) {
		var l = o[s];
		if (lineLineIntersect$1(t, n, r, a, l[0], l[1], c[0], c[1])) return !0;
		c = l;
	}
}
function lineLineIntersect$1(t, n, r, a, o, s, c, l) {
	var u = r - t, d = a - n, f = c - o, p = l - s, h = crossProduct2d$1(f, p, u, d);
	if (nearZero(h)) return !1;
	var g = t - o, _ = n - s, v = crossProduct2d$1(g, _, u, d) / h;
	if (v < 0 || v > 1) return !1;
	var y = crossProduct2d$1(g, _, f, p) / h;
	return !(y < 0 || y > 1);
}
function crossProduct2d$1(t, n, r, a) {
	return t * a - r * n;
}
function nearZero(t) {
	return t <= 1e-6 && t >= -1e-6;
}
function setTooltipConfig(t) {
	var n = t.itemTooltipOption, r = t.componentModel, a = t.itemName, o = isString(n) ? { formatter: n } : n, s = r.mainType, c = r.componentIndex, l = {
		componentType: s,
		name: a,
		$vars: ["name"]
	};
	l[s + "Index"] = c;
	var u = t.formatterParamsExtra;
	u && each(keys(u), function(t) {
		hasOwn(l, t) || (l[t] = u[t], l.$vars.push(t));
	});
	var d = getECData(t.el);
	d.componentMainType = s, d.componentIndex = c, d.tooltipConfig = {
		name: a,
		option: defaults({
			content: a,
			encodeHTMLContent: !0,
			formatterParams: l
		}, o)
	};
}
function traverseElement(t, n) {
	var r;
	t.isGroup && (r = n(t)), r || t.traverse(n);
}
function traverseElements(t, n) {
	if (t) if (isArray(t)) for (var r = 0; r < t.length; r++) traverseElement(t[r], n);
	else traverseElement(t, n);
}
registerShape("circle", Circle_default), registerShape("ellipse", Ellipse_default), registerShape("sector", Sector_default), registerShape("ring", Ring_default), registerShape("polygon", Polygon_default), registerShape("polyline", Polyline_default$1), registerShape("rect", Rect_default), registerShape("line", Line_default$1), registerShape("bezierCurve", BezierCurve_default), registerShape("arc", Arc_default), init_dist$2();
var EMPTY_OBJ = {};
function setLabelText(t, n) {
	for (var r = 0; r < SPECIAL_STATES.length; r++) {
		var a = SPECIAL_STATES[r], o = n[a], s = t.ensureState(a);
		s.style = s.style || {}, s.style.text = o;
	}
	var c = t.currentStates.slice();
	t.clearStates(!0), t.setStyle({ text: n.normal }), t.useStates(c, !0);
}
function getLabelText(t, n, r) {
	var a = t.labelFetcher, o = t.labelDataIndex, s = t.labelDimIndex, c = n.normal, l;
	a && (l = a.getFormattedLabel(o, "normal", null, s, c && c.get("formatter"), r == null ? null : { interpolatedValue: r })), l ??= isFunction(t.defaultText) ? t.defaultText(o, t, r) : t.defaultText;
	for (var u = { normal: l }, d = 0; d < SPECIAL_STATES.length; d++) {
		var f = SPECIAL_STATES[d], p = n[f];
		u[f] = retrieve2(a ? a.getFormattedLabel(o, f, null, s, p && p.get("formatter")) : null, l);
	}
	return u;
}
function setLabelStyle(t, n, r, a) {
	r ||= EMPTY_OBJ;
	for (var o = t instanceof Text_default, s = !1, c = 0; c < DISPLAY_STATES.length; c++) {
		var l = n[DISPLAY_STATES[c]];
		if (l && l.getShallow("show")) {
			s = !0;
			break;
		}
	}
	var u = o ? t : t.getTextContent();
	if (s) {
		o || (u || (u = new Text_default(), t.setTextContent(u)), t.stateProxy && (u.stateProxy = t.stateProxy));
		var d = getLabelText(r, n), f = n.normal, p = !!f.getShallow("show"), h = createTextStyle(f, a && a.normal, r, !1, !o);
		h.text = d.normal, o || t.setTextConfig(createTextConfig(f, r, !1));
		for (var c = 0; c < SPECIAL_STATES.length; c++) {
			var g = SPECIAL_STATES[c], l = n[g];
			if (l) {
				var _ = u.ensureState(g), v = !!retrieve2(l.getShallow("show"), p);
				if (v !== p && (_.ignore = !v), _.style = createTextStyle(l, a && a[g], r, !0, !o), _.style.text = d[g], !o) {
					var y = t.ensureState(g);
					y.textConfig = createTextConfig(l, r, !0);
				}
			}
		}
		u.silent = !!f.getShallow("silent"), u.style.x != null && (h.x = u.style.x), u.style.y != null && (h.y = u.style.y), u.ignore = !p, u.useStyle(h), u.dirty(), r.enableTextSetter && (labelInner(u).setLabelText = function(t) {
			var a = getLabelText(r, n, t);
			setLabelText(u, a);
		});
	} else u && (u.ignore = !0);
	t.dirty();
}
function getLabelStatesModels(t, n) {
	n ||= "label";
	for (var r = { normal: t.getModel(n) }, a = 0; a < SPECIAL_STATES.length; a++) {
		var o = SPECIAL_STATES[a];
		r[o] = t.getModel([o, n]);
	}
	return r;
}
function createTextStyle(t, n, r, a, o) {
	var s = {};
	return setTextStyleCommon(s, t, r, a, o), n && extend(s, n), s;
}
function createTextConfig(t, n, r) {
	n ||= {};
	var a = {}, o, s = t.getShallow("rotate"), c = retrieve2(t.getShallow("distance"), r ? null : 5), l = t.getShallow("offset");
	return o = t.getShallow("position") || (r ? null : "inside"), o === "outside" && (o = n.defaultOutsidePosition || "top"), o != null && (a.position = o), l != null && (a.offset = l), s != null && (s *= Math.PI / 180, a.rotation = s), c != null && (a.distance = c), a.outsideFill = t.get("color") === "inherit" ? n.inheritColor || null : "auto", a;
}
function setTextStyleCommon(t, n, r, a, o) {
	r ||= EMPTY_OBJ;
	var s = n.ecModel, c = s && s.option.textStyle, l = getRichItemNames(n), u;
	if (l) {
		for (var d in u = {}, l) if (l.hasOwnProperty(d)) {
			var f = n.getModel(["rich", d]);
			setTokenTextStyle(u[d] = {}, f, c, r, a, o, !1, !0);
		}
	}
	u && (t.rich = u);
	var p = n.get("overflow");
	p && (t.overflow = p);
	var h = n.get("minMargin");
	h != null && (t.margin = h), setTokenTextStyle(t, n, c, r, a, o, !0, !1);
}
function getRichItemNames(t) {
	for (var n; t && t !== t.ecModel;) {
		var r = (t.option || EMPTY_OBJ).rich;
		if (r) {
			n ||= {};
			for (var a = keys(r), o = 0; o < a.length; o++) {
				var s = a[o];
				n[s] = 1;
			}
		}
		t = t.parentModel;
	}
	return n;
}
var TEXT_PROPS_WITH_GLOBAL = [
	"fontStyle",
	"fontWeight",
	"fontSize",
	"fontFamily",
	"textShadowColor",
	"textShadowBlur",
	"textShadowOffsetX",
	"textShadowOffsetY"
], TEXT_PROPS_SELF = [
	"align",
	"lineHeight",
	"width",
	"height",
	"tag",
	"verticalAlign",
	"ellipsis"
], TEXT_PROPS_BOX = [
	"padding",
	"borderWidth",
	"borderRadius",
	"borderDashOffset",
	"backgroundColor",
	"borderColor",
	"shadowColor",
	"shadowBlur",
	"shadowOffsetX",
	"shadowOffsetY"
];
function setTokenTextStyle(t, n, r, a, o, c, l, u) {
	r = !o && r || EMPTY_OBJ;
	var d = a && a.inheritColor, f = n.getShallow("color"), p = n.getShallow("textBorderColor"), h = retrieve2(n.getShallow("opacity"), r.opacity);
	(f === "inherit" || f === "auto") && (process$1.env.NODE_ENV !== "production" && f === "auto" && deprecateReplaceLog("color: 'auto'", "color: 'inherit'"), f = d || null), (p === "inherit" || p === "auto") && (process$1.env.NODE_ENV !== "production" && p === "auto" && deprecateReplaceLog("color: 'auto'", "color: 'inherit'"), p = d || null), c || (f ||= r.color, p ||= r.textBorderColor), f != null && (t.fill = f), p != null && (t.stroke = p);
	var g = retrieve2(n.getShallow("textBorderWidth"), r.textBorderWidth);
	g != null && (t.lineWidth = g);
	var _ = retrieve2(n.getShallow("textBorderType"), r.textBorderType);
	_ != null && (t.lineDash = _);
	var v = retrieve2(n.getShallow("textBorderDashOffset"), r.textBorderDashOffset);
	v != null && (t.lineDashOffset = v), !o && h == null && !u && (h = a && a.defaultOpacity), h != null && (t.opacity = h), !o && !c && t.fill == null && a.inheritColor && (t.fill = a.inheritColor);
	for (var y = 0; y < TEXT_PROPS_WITH_GLOBAL.length; y++) {
		var b = TEXT_PROPS_WITH_GLOBAL[y], x = retrieve2(n.getShallow(b), r[b]);
		x != null && (t[b] = x);
	}
	for (var y = 0; y < TEXT_PROPS_SELF.length; y++) {
		var b = TEXT_PROPS_SELF[y], x = n.getShallow(b);
		x != null && (t[b] = x);
	}
	if (t.verticalAlign == null) {
		var S = n.getShallow("baseline");
		S != null && (t.verticalAlign = S);
	}
	if (!l || !a.disableBox) {
		for (var y = 0; y < TEXT_PROPS_BOX.length; y++) {
			var b = TEXT_PROPS_BOX[y], x = n.getShallow(b);
			x != null && (t[b] = x);
		}
		var C = n.getShallow("borderType");
		C != null && (t.borderDash = C), (t.backgroundColor === "auto" || t.backgroundColor === "inherit") && d && (process$1.env.NODE_ENV !== "production" && t.backgroundColor === "auto" && deprecateReplaceLog("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), t.backgroundColor = d), (t.borderColor === "auto" || t.borderColor === "inherit") && d && (process$1.env.NODE_ENV !== "production" && t.borderColor === "auto" && deprecateReplaceLog("borderColor: 'auto'", "borderColor: 'inherit'"), t.borderColor = d);
	}
}
function getFont(t, n) {
	var r = n && n.getModel("textStyle");
	return trim([
		t.fontStyle || r && r.getShallow("fontStyle") || "",
		t.fontWeight || r && r.getShallow("fontWeight") || "",
		(t.fontSize || r && r.getShallow("fontSize") || 12) + "px",
		t.fontFamily || r && r.getShallow("fontFamily") || "sans-serif"
	].join(" "));
}
var labelInner = makeInner();
function setLabelValueAnimation(t, n, r, a) {
	if (t) {
		var o = labelInner(t);
		o.prevValue = o.value, o.value = r;
		var s = n.normal;
		o.valueAnimation = s.get("valueAnimation"), o.valueAnimation && (o.precision = s.get("precision"), o.defaultInterpolatedText = a, o.statesModels = n);
	}
}
function animateLabelValue(t, n, r, a, o) {
	var s = labelInner(t);
	if (!s.valueAnimation || s.prevValue === s.value) return;
	var c = s.defaultInterpolatedText, l = retrieve2(s.interpolatedValue, s.prevValue), u = s.value;
	function d(a) {
		var d = interpolateRawValues(r, s.precision, l, u, a);
		s.interpolatedValue = a === 1 ? null : d, setLabelText(t, getLabelText({
			labelDataIndex: n,
			labelFetcher: o,
			defaultText: c ? c(d) : d + ""
		}, s.statesModels, d));
	}
	t.percent = 0, (s.prevValue == null ? initProps : updateProps)(t, { percent: 1 }, a, n, null, d);
}
var PATH_COLOR = ["textStyle", "color"], textStyleParams = [
	"fontStyle",
	"fontWeight",
	"fontSize",
	"fontFamily",
	"padding",
	"lineHeight",
	"rich",
	"width",
	"height",
	"overflow"
], tmpText = new Text_default(), textStyle_default = function() {
	function t() {}
	return t.prototype.getTextColor = function(t) {
		var n = this.ecModel;
		return this.getShallow("color") || (!t && n ? n.get(PATH_COLOR) : null);
	}, t.prototype.getFont = function() {
		return getFont({
			fontStyle: this.getShallow("fontStyle"),
			fontWeight: this.getShallow("fontWeight"),
			fontSize: this.getShallow("fontSize"),
			fontFamily: this.getShallow("fontFamily")
		}, this.ecModel);
	}, t.prototype.getTextRect = function(t) {
		for (var n = {
			text: t,
			verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
		}, r = 0; r < textStyleParams.length; r++) n[textStyleParams[r]] = this.getShallow(textStyleParams[r]);
		return tmpText.useStyle(n), tmpText.update(), tmpText.getBoundingRect();
	}, t;
}(), LINE_STYLE_KEY_MAP = [
	["lineWidth", "width"],
	["stroke", "color"],
	["opacity"],
	["shadowBlur"],
	["shadowOffsetX"],
	["shadowOffsetY"],
	["shadowColor"],
	["lineDash", "type"],
	["lineDashOffset", "dashOffset"],
	["lineCap", "cap"],
	["lineJoin", "join"],
	["miterLimit"]
], getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP), LineStyleMixin = function() {
	function t() {}
	return t.prototype.getLineStyle = function(t) {
		return getLineStyle(this, t);
	}, t;
}(), ITEM_STYLE_KEY_MAP = [
	["fill", "color"],
	["stroke", "borderColor"],
	["lineWidth", "borderWidth"],
	["opacity"],
	["shadowBlur"],
	["shadowOffsetX"],
	["shadowOffsetY"],
	["shadowColor"],
	["lineDash", "borderType"],
	["lineDashOffset", "borderDashOffset"],
	["lineCap", "borderCap"],
	["lineJoin", "borderJoin"],
	["miterLimit", "borderMiterLimit"]
], getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP), ItemStyleMixin = function() {
	function t() {}
	return t.prototype.getItemStyle = function(t, n) {
		return getItemStyle(this, t, n);
	}, t;
}(), Model = function() {
	function t(t, n, r) {
		this.parentModel = n, this.ecModel = r, this.option = t;
	}
	return t.prototype.init = function(t, n, r) {}, t.prototype.mergeOption = function(t, n) {
		merge(this.option, t, !0);
	}, t.prototype.get = function(t, n) {
		return t == null ? this.option : this._doGet(this.parsePath(t), !n && this.parentModel);
	}, t.prototype.getShallow = function(t, n) {
		var r = this.option, a = r == null ? r : r[t];
		if (a == null && !n) {
			var o = this.parentModel;
			o && (a = o.getShallow(t));
		}
		return a;
	}, t.prototype.getModel = function(n, r) {
		var a = n != null, o = a ? this.parsePath(n) : null, s = a ? this._doGet(o) : this.option;
		return r ||= this.parentModel && this.parentModel.getModel(this.resolveParentPath(o)), new t(s, r, this.ecModel);
	}, t.prototype.isEmpty = function() {
		return this.option == null;
	}, t.prototype.restoreData = function() {}, t.prototype.clone = function() {
		var t = this.constructor;
		return new t(clone$1(this.option));
	}, t.prototype.parsePath = function(t) {
		return typeof t == "string" ? t.split(".") : t;
	}, t.prototype.resolveParentPath = function(t) {
		return t;
	}, t.prototype.isAnimationEnabled = function() {
		if (!env_default.node && this.option) {
			if (this.option.animation != null) return !!this.option.animation;
			if (this.parentModel) return this.parentModel.isAnimationEnabled();
		}
	}, t.prototype._doGet = function(t, n) {
		var r = this.option;
		if (!t) return r;
		for (var a = 0; a < t.length && !(t[a] && (r = r && typeof r == "object" ? r[t[a]] : null, r == null)); a++);
		return r == null && n && (r = n._doGet(this.resolveParentPath(t), n.parentModel)), r;
	}, t;
}();
enableClassExtend(Model), enableClassCheck(Model), mixin(Model, LineStyleMixin), mixin(Model, ItemStyleMixin), mixin(Model, AreaStyleMixin), mixin(Model, textStyle_default);
var Model_default = Model;
init_dist$2();
var base = Math.round(Math.random() * 10);
function getUID(t) {
	return [t || "", base++].join("_");
}
function enableSubTypeDefaulter(t) {
	var n = {};
	t.registerSubTypeDefaulter = function(t, r) {
		var a = parseClassType(t);
		n[a.main] = r;
	}, t.determineSubType = function(r, a) {
		var o = a.type;
		if (!o) {
			var s = parseClassType(r).main;
			t.hasSubTypes(r) && n[s] && (o = n[s](a));
		}
		return o;
	};
}
function enableTopologicalTravel(t, n) {
	t.topologicalTravel = function(t, n, a, o) {
		if (!t.length) return;
		var c = r(n), l = c.graph, u = c.noEntryList, d = {};
		for (each(t, function(t) {
			d[t] = !0;
		}); u.length;) {
			var f = u.pop(), p = l[f], h = !!d[f];
			h && (a.call(o, f, p.originalDeps.slice()), delete d[f]), each(p.successor, h ? _ : g);
		}
		each(d, function() {
			var r = "";
			throw process$1.env.NODE_ENV !== "production" && (r = makePrintable("Circular dependency may exists: ", d, t, n)), Error(r);
		});
		function g(t) {
			l[t].entryCount--, l[t].entryCount === 0 && u.push(t);
		}
		function _(t) {
			d[t] = !0, g(t);
		}
	};
	function r(t) {
		var r = {}, s = [];
		return each(t, function(c) {
			var l = a(r, c), u = o(l.originalDeps = n(c), t);
			l.entryCount = u.length, l.entryCount === 0 && s.push(c), each(u, function(t) {
				indexOf(l.predecessor, t) < 0 && l.predecessor.push(t);
				var n = a(r, t);
				indexOf(n.successor, t) < 0 && n.successor.push(c);
			});
		}), {
			graph: r,
			noEntryList: s
		};
	}
	function a(t, n) {
		return t[n] || (t[n] = {
			predecessor: [],
			successor: []
		}), t[n];
	}
	function o(t, n) {
		var r = [];
		return each(t, function(t) {
			indexOf(n, t) >= 0 && r.push(t);
		}), r;
	}
}
function inheritDefaultOption(t, n) {
	return merge(merge({}, t, !0), n, !0);
}
var langEN_default = {
	time: {
		month: [
			"January",
			"February",
			"March",
			"April",
			"May",
			"June",
			"July",
			"August",
			"September",
			"October",
			"November",
			"December"
		],
		monthAbbr: [
			"Jan",
			"Feb",
			"Mar",
			"Apr",
			"May",
			"Jun",
			"Jul",
			"Aug",
			"Sep",
			"Oct",
			"Nov",
			"Dec"
		],
		dayOfWeek: [
			"Sunday",
			"Monday",
			"Tuesday",
			"Wednesday",
			"Thursday",
			"Friday",
			"Saturday"
		],
		dayOfWeekAbbr: [
			"Sun",
			"Mon",
			"Tue",
			"Wed",
			"Thu",
			"Fri",
			"Sat"
		]
	},
	legend: { selector: {
		all: "All",
		inverse: "Inv"
	} },
	toolbox: {
		brush: { title: {
			rect: "Box Select",
			polygon: "Lasso Select",
			lineX: "Horizontally Select",
			lineY: "Vertically Select",
			keep: "Keep Selections",
			clear: "Clear Selections"
		} },
		dataView: {
			title: "Data View",
			lang: [
				"Data View",
				"Close",
				"Refresh"
			]
		},
		dataZoom: { title: {
			zoom: "Zoom",
			back: "Zoom Reset"
		} },
		magicType: { title: {
			line: "Switch to Line Chart",
			bar: "Switch to Bar Chart",
			stack: "Stack",
			tiled: "Tile"
		} },
		restore: { title: "Restore" },
		saveAsImage: {
			title: "Save as Image",
			lang: ["Right Click to Save Image"]
		}
	},
	series: { typeNames: {
		pie: "Pie chart",
		bar: "Bar chart",
		line: "Line chart",
		scatter: "Scatter plot",
		effectScatter: "Ripple scatter plot",
		radar: "Radar chart",
		tree: "Tree",
		treemap: "Treemap",
		boxplot: "Boxplot",
		candlestick: "Candlestick",
		k: "K line chart",
		heatmap: "Heat map",
		map: "Map",
		parallel: "Parallel coordinate map",
		lines: "Line graph",
		graph: "Relationship graph",
		sankey: "Sankey diagram",
		funnel: "Funnel chart",
		gauge: "Gauge",
		pictorialBar: "Pictorial bar",
		themeRiver: "Theme River Map",
		sunburst: "Sunburst",
		custom: "Custom chart",
		chart: "Chart"
	} },
	aria: {
		general: {
			withTitle: "This is a chart about \"{title}\"",
			withoutTitle: "This is a chart"
		},
		series: {
			single: {
				prefix: "",
				withName: " with type {seriesType} named {seriesName}.",
				withoutName: " with type {seriesType}."
			},
			multiple: {
				prefix: ". It consists of {seriesCount} series count.",
				withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
				withoutName: " The {seriesId} series is a {seriesType}.",
				separator: {
					middle: "",
					end: ""
				}
			}
		},
		data: {
			allData: "The data is as follows: ",
			partialData: "The first {displayCnt} items are: ",
			withName: "the data for {name} is {value}",
			withoutName: "{value}",
			separator: {
				middle: ", ",
				end: ". "
			}
		}
	}
}, langZH_default = {
	time: {
		month: [
			"一月",
			"二月",
			"三月",
			"四月",
			"五月",
			"六月",
			"七月",
			"八月",
			"九月",
			"十月",
			"十一月",
			"十二月"
		],
		monthAbbr: [
			"1月",
			"2月",
			"3月",
			"4月",
			"5月",
			"6月",
			"7月",
			"8月",
			"9月",
			"10月",
			"11月",
			"12月"
		],
		dayOfWeek: [
			"星期日",
			"星期一",
			"星期二",
			"星期三",
			"星期四",
			"星期五",
			"星期六"
		],
		dayOfWeekAbbr: [
			"日",
			"一",
			"二",
			"三",
			"四",
			"五",
			"六"
		]
	},
	legend: { selector: {
		all: "全选",
		inverse: "反选"
	} },
	toolbox: {
		brush: { title: {
			rect: "矩形选择",
			polygon: "圈选",
			lineX: "横向选择",
			lineY: "纵向选择",
			keep: "保持选择",
			clear: "清除选择"
		} },
		dataView: {
			title: "数据视图",
			lang: [
				"数据视图",
				"关闭",
				"刷新"
			]
		},
		dataZoom: { title: {
			zoom: "区域缩放",
			back: "区域缩放还原"
		} },
		magicType: { title: {
			line: "切换为折线图",
			bar: "切换为柱状图",
			stack: "切换为堆叠",
			tiled: "切换为平铺"
		} },
		restore: { title: "还原" },
		saveAsImage: {
			title: "保存为图片",
			lang: ["右键另存为图片"]
		}
	},
	series: { typeNames: {
		pie: "饼图",
		bar: "柱状图",
		line: "折线图",
		scatter: "散点图",
		effectScatter: "涟漪散点图",
		radar: "雷达图",
		tree: "树图",
		treemap: "矩形树图",
		boxplot: "箱型图",
		candlestick: "K线图",
		k: "K线图",
		heatmap: "热力图",
		map: "地图",
		parallel: "平行坐标图",
		lines: "线图",
		graph: "关系图",
		sankey: "桑基图",
		funnel: "漏斗图",
		gauge: "仪表盘图",
		pictorialBar: "象形柱图",
		themeRiver: "主题河流图",
		sunburst: "旭日图",
		custom: "自定义图表",
		chart: "图表"
	} },
	aria: {
		general: {
			withTitle: "这是一个关于“{title}”的图表。",
			withoutTitle: "这是一个图表，"
		},
		series: {
			single: {
				prefix: "",
				withName: "图表类型是{seriesType}，表示{seriesName}。",
				withoutName: "图表类型是{seriesType}。"
			},
			multiple: {
				prefix: "它由{seriesCount}个图表系列组成。",
				withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
				withoutName: "第{seriesId}个系列是一个{seriesType}，",
				separator: {
					middle: "；",
					end: "。"
				}
			}
		},
		data: {
			allData: "其数据是——",
			partialData: "其中，前{displayCnt}项是——",
			withName: "{name}的数据是{value}",
			withoutName: "{value}",
			separator: {
				middle: "，",
				end: ""
			}
		}
	}
}, LOCALE_ZH = "ZH", LOCALE_EN = "EN", DEFAULT_LOCALE = LOCALE_EN, localeStorage = {}, localeModels = {}, SYSTEM_LANG = env_default.domSupported ? function() {
	return (document.documentElement.lang || navigator.language || navigator.browserLanguage || DEFAULT_LOCALE).toUpperCase().indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
}() : DEFAULT_LOCALE;
function registerLocale(t, n) {
	t = t.toUpperCase(), localeModels[t] = new Model_default(n), localeStorage[t] = n;
}
function createLocaleObject(t) {
	if (isString(t)) {
		var n = localeStorage[t.toUpperCase()] || {};
		return t === LOCALE_ZH || t === LOCALE_EN ? clone$1(n) : merge(clone$1(n), clone$1(localeStorage[DEFAULT_LOCALE]), !1);
	} else return merge(clone$1(t), clone$1(localeStorage[DEFAULT_LOCALE]), !1);
}
function getLocaleModel(t) {
	return localeModels[t];
}
function getDefaultLocaleModel() {
	return localeModels[DEFAULT_LOCALE];
}
registerLocale(LOCALE_EN, langEN_default), registerLocale(LOCALE_ZH, langZH_default);
var ONE_SECOND = 1e3, ONE_MINUTE = ONE_SECOND * 60, ONE_HOUR = ONE_MINUTE * 60, ONE_DAY = ONE_HOUR * 24, ONE_YEAR = ONE_DAY * 365, defaultLeveledFormatter = {
	year: "{yyyy}",
	month: "{MMM}",
	day: "{d}",
	hour: "{HH}:{mm}",
	minute: "{HH}:{mm}",
	second: "{HH}:{mm}:{ss}",
	millisecond: "{HH}:{mm}:{ss} {SSS}",
	none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
}, fullDayFormatter = "{yyyy}-{MM}-{dd}", fullLeveledFormatter = {
	year: "{yyyy}",
	month: "{yyyy}-{MM}",
	day: fullDayFormatter,
	hour: fullDayFormatter + " " + defaultLeveledFormatter.hour,
	minute: fullDayFormatter + " " + defaultLeveledFormatter.minute,
	second: fullDayFormatter + " " + defaultLeveledFormatter.second,
	millisecond: defaultLeveledFormatter.none
}, primaryTimeUnits = [
	"year",
	"month",
	"day",
	"hour",
	"minute",
	"second",
	"millisecond"
], timeUnits = [
	"year",
	"half-year",
	"quarter",
	"month",
	"week",
	"half-week",
	"day",
	"half-day",
	"quarter-day",
	"hour",
	"minute",
	"second",
	"millisecond"
];
function pad(t, n) {
	return t += "", "0000".substr(0, n - t.length) + t;
}
function getPrimaryTimeUnit(t) {
	switch (t) {
		case "half-year":
		case "quarter": return "month";
		case "week":
		case "half-week": return "day";
		case "half-day":
		case "quarter-day": return "hour";
		default: return t;
	}
}
function isPrimaryTimeUnit(t) {
	return t === getPrimaryTimeUnit(t);
}
function getDefaultFormatPrecisionOfInterval(t) {
	switch (t) {
		case "year":
		case "month": return "day";
		case "millisecond": return "millisecond";
		default: return "second";
	}
}
function format(t, n, r, a) {
	var o = parseDate(t), s = o[fullYearGetterName(r)](), c = o[monthGetterName(r)]() + 1, l = Math.floor((c - 1) / 3) + 1, u = o[dateGetterName(r)](), d = o["get" + (r ? "UTC" : "") + "Day"](), f = o[hoursGetterName(r)](), p = (f - 1) % 12 + 1, h = o[minutesGetterName(r)](), g = o[secondsGetterName(r)](), _ = o[millisecondsGetterName(r)](), v = f >= 12 ? "pm" : "am", y = v.toUpperCase(), b = (a instanceof Model_default ? a : getLocaleModel(a || SYSTEM_LANG) || getDefaultLocaleModel()).getModel("time"), x = b.get("month"), S = b.get("monthAbbr"), C = b.get("dayOfWeek"), w = b.get("dayOfWeekAbbr");
	return (n || "").replace(/{a}/g, v + "").replace(/{A}/g, y + "").replace(/{yyyy}/g, s + "").replace(/{yy}/g, pad(s % 100 + "", 2)).replace(/{Q}/g, l + "").replace(/{MMMM}/g, x[c - 1]).replace(/{MMM}/g, S[c - 1]).replace(/{MM}/g, pad(c, 2)).replace(/{M}/g, c + "").replace(/{dd}/g, pad(u, 2)).replace(/{d}/g, u + "").replace(/{eeee}/g, C[d]).replace(/{ee}/g, w[d]).replace(/{e}/g, d + "").replace(/{HH}/g, pad(f, 2)).replace(/{H}/g, f + "").replace(/{hh}/g, pad(p + "", 2)).replace(/{h}/g, p + "").replace(/{mm}/g, pad(h, 2)).replace(/{m}/g, h + "").replace(/{ss}/g, pad(g, 2)).replace(/{s}/g, g + "").replace(/{SSS}/g, pad(_, 3)).replace(/{S}/g, _ + "");
}
function leveledFormat(t, n, r, a, o) {
	var s = null;
	if (isString(r)) s = r;
	else if (isFunction(r)) s = r(t.value, n, { level: t.level });
	else {
		var c = extend({}, defaultLeveledFormatter);
		if (t.level > 0) for (var l = 0; l < primaryTimeUnits.length; ++l) c[primaryTimeUnits[l]] = "{primary|" + c[primaryTimeUnits[l]] + "}";
		var u = r ? r.inherit === !1 ? r : defaults(r, c) : c, d = getUnitFromValue(t.value, o);
		if (u[d]) s = u[d];
		else if (u.inherit) {
			for (var l = timeUnits.indexOf(d) - 1; l >= 0; --l) if (u[d]) {
				s = u[d];
				break;
			}
			s ||= c.none;
		}
		if (isArray(s)) {
			var f = t.level == null ? 0 : t.level >= 0 ? t.level : s.length + t.level;
			f = Math.min(f, s.length - 1), s = s[f];
		}
	}
	return format(new Date(t.value), s, o, a);
}
function getUnitFromValue(t, n) {
	var r = parseDate(t), a = r[monthGetterName(n)]() + 1, o = r[dateGetterName(n)](), s = r[hoursGetterName(n)](), c = r[minutesGetterName(n)](), l = r[secondsGetterName(n)](), u = r[millisecondsGetterName(n)]() === 0, d = u && l === 0, f = d && c === 0, p = f && s === 0, h = p && o === 1;
	return h && a === 1 ? "year" : h ? "month" : p ? "day" : f ? "hour" : d ? "minute" : u ? "second" : "millisecond";
}
function getUnitValue(t, n, r) {
	var a = isNumber(t) ? parseDate(t) : t;
	switch (n ||= getUnitFromValue(t, r), n) {
		case "year": return a[fullYearGetterName(r)]();
		case "half-year": return a[monthGetterName(r)]() >= 6 ? 1 : 0;
		case "quarter": return Math.floor((a[monthGetterName(r)]() + 1) / 4);
		case "month": return a[monthGetterName(r)]();
		case "day": return a[dateGetterName(r)]();
		case "half-day": return a[hoursGetterName(r)]() / 24;
		case "hour": return a[hoursGetterName(r)]();
		case "minute": return a[minutesGetterName(r)]();
		case "second": return a[secondsGetterName(r)]();
		case "millisecond": return a[millisecondsGetterName(r)]();
	}
}
function fullYearGetterName(t) {
	return t ? "getUTCFullYear" : "getFullYear";
}
function monthGetterName(t) {
	return t ? "getUTCMonth" : "getMonth";
}
function dateGetterName(t) {
	return t ? "getUTCDate" : "getDate";
}
function hoursGetterName(t) {
	return t ? "getUTCHours" : "getHours";
}
function minutesGetterName(t) {
	return t ? "getUTCMinutes" : "getMinutes";
}
function secondsGetterName(t) {
	return t ? "getUTCSeconds" : "getSeconds";
}
function millisecondsGetterName(t) {
	return t ? "getUTCMilliseconds" : "getMilliseconds";
}
function fullYearSetterName(t) {
	return t ? "setUTCFullYear" : "setFullYear";
}
function monthSetterName(t) {
	return t ? "setUTCMonth" : "setMonth";
}
function dateSetterName(t) {
	return t ? "setUTCDate" : "setDate";
}
function hoursSetterName(t) {
	return t ? "setUTCHours" : "setHours";
}
function minutesSetterName(t) {
	return t ? "setUTCMinutes" : "setMinutes";
}
function secondsSetterName(t) {
	return t ? "setUTCSeconds" : "setSeconds";
}
function millisecondsSetterName(t) {
	return t ? "setUTCMilliseconds" : "setMilliseconds";
}
function getTextRect(t, n, r, a, o, s, c, l) {
	return new Text_default({ style: {
		text: t,
		font: n,
		align: r,
		verticalAlign: a,
		padding: o,
		rich: s,
		overflow: c ? "truncate" : null,
		lineHeight: l
	} }).getBoundingRect();
}
init_dist$2();
function addCommas(t) {
	if (!isNumeric(t)) return isString(t) ? t : "-";
	var n = (t + "").split(".");
	return n[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (n.length > 1 ? "." + n[1] : "");
}
function toCamelCase(t, n) {
	return t = (t || "").toLowerCase().replace(/-(.)/g, function(t, n) {
		return n.toUpperCase();
	}), n && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t;
}
var normalizeCssArray = normalizeCssArray$1;
function makeValueReadable(t, n, r) {
	var a = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
	function o(t) {
		return t && trim(t) ? t : "-";
	}
	function s(t) {
		return !!(t != null && !isNaN(t) && isFinite(t));
	}
	var c = n === "time", l = t instanceof Date;
	if (c || l) {
		var u = c ? parseDate(t) : t;
		if (isNaN(+u)) {
			if (l) return "-";
		} else return format(u, a, r);
	}
	if (n === "ordinal") return isStringSafe(t) ? o(t) : isNumber(t) && s(t) ? t + "" : "-";
	var d = numericToNumber(t);
	return s(d) ? addCommas(d) : isStringSafe(t) ? o(t) : typeof t == "boolean" ? t + "" : "-";
}
var TPL_VAR_ALIAS = [
	"a",
	"b",
	"c",
	"d",
	"e",
	"f",
	"g"
], wrapVar = function(t, n) {
	return "{" + t + (n ?? "") + "}";
};
function formatTpl(t, n, r) {
	isArray(n) || (n = [n]);
	var a = n.length;
	if (!a) return "";
	for (var o = n[0].$vars || [], s = 0; s < o.length; s++) {
		var c = TPL_VAR_ALIAS[s];
		t = t.replace(wrapVar(c), wrapVar(c, 0));
	}
	for (var l = 0; l < a; l++) for (var u = 0; u < o.length; u++) {
		var d = n[l][o[u]];
		t = t.replace(wrapVar(TPL_VAR_ALIAS[u], l), r ? encodeHTML(d) : d);
	}
	return t;
}
function formatTplSimple(t, n, r) {
	return each(n, function(n, a) {
		t = t.replace("{" + a + "}", r ? encodeHTML(n) : n);
	}), t;
}
function getTooltipMarker(t, n) {
	var r = isString(t) ? {
		color: t,
		extraCssText: n
	} : t || {}, a = r.color, o = r.type;
	n = r.extraCssText;
	var s = r.renderMode || "html";
	return a ? s === "html" ? o === "subItem" ? "<span style=\"display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:" + encodeHTML(a) + ";" + (n || "") + "\"></span>" : "<span style=\"display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:" + encodeHTML(a) + ";" + (n || "") + "\"></span>" : {
		renderMode: s,
		content: "{" + (r.markerId || "markerX") + "|}  ",
		style: o === "subItem" ? {
			width: 4,
			height: 4,
			borderRadius: 2,
			backgroundColor: a
		} : {
			width: 10,
			height: 10,
			borderRadius: 5,
			backgroundColor: a
		}
	} : "";
}
function formatTime(t, n, r) {
	process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("echarts.format.formatTime", "echarts.time.format"), (t === "week" || t === "month" || t === "quarter" || t === "half-year" || t === "year") && (t = "MM-dd\nyyyy");
	var a = parseDate(n), o = r ? "getUTC" : "get", c = a[o + "FullYear"](), l = a[o + "Month"]() + 1, u = a[o + "Date"](), d = a[o + "Hours"](), f = a[o + "Minutes"](), p = a[o + "Seconds"](), h = a[o + "Milliseconds"]();
	return t = t.replace("MM", pad(l, 2)).replace("M", l).replace("yyyy", c).replace("yy", pad(c % 100 + "", 2)).replace("dd", pad(u, 2)).replace("d", u).replace("hh", pad(d, 2)).replace("h", d).replace("mm", pad(f, 2)).replace("m", f).replace("ss", pad(p, 2)).replace("s", p).replace("SSS", pad(h, 3)), t;
}
function capitalFirst(t) {
	return t && t.charAt(0).toUpperCase() + t.substr(1);
}
function convertToColorString(t, n) {
	return n ||= "transparent", isString(t) ? t : isObject(t) && t.colorStops && (t.colorStops[0] || {}).color || n;
}
function windowOpen(t, n) {
	if (n === "_blank" || n === "blank") {
		var r = window.open();
		r.opener = null, r.location.href = t;
	} else window.open(t, n);
}
var each$15 = each, LOCATION_PARAMS = [
	"left",
	"right",
	"top",
	"bottom",
	"width",
	"height"
], HV_NAMES = [[
	"width",
	"left",
	"right"
], [
	"height",
	"top",
	"bottom"
]];
function boxLayout(t, n, r, a, o) {
	var s = 0, c = 0;
	a ??= Infinity, o ??= Infinity;
	var l = 0;
	n.eachChild(function(u, d) {
		var f = u.getBoundingRect(), p = n.childAt(d + 1), h = p && p.getBoundingRect(), g, _;
		if (t === "horizontal") {
			var v = f.width + (h ? -h.x + f.x : 0);
			g = s + v, g > a || u.newline ? (s = 0, g = v, c += l + r, l = f.height) : l = Math.max(l, f.height);
		} else {
			var y = f.height + (h ? -h.y + f.y : 0);
			_ = c + y, _ > o || u.newline ? (s += l + r, c = 0, _ = y, l = f.width) : l = Math.max(l, f.width);
		}
		u.newline || (u.x = s, u.y = c, u.markRedraw(), t === "horizontal" ? s = g + r : c = _ + r);
	});
}
var box = boxLayout;
curry(boxLayout, "vertical"), curry(boxLayout, "horizontal");
function getAvailableSize(t, n, r) {
	var a = n.width, o = n.height, s = parsePercent$1(t.left, a), c = parsePercent$1(t.top, o), l = parsePercent$1(t.right, a), u = parsePercent$1(t.bottom, o);
	return (isNaN(s) || isNaN(parseFloat(t.left))) && (s = 0), (isNaN(l) || isNaN(parseFloat(t.right))) && (l = a), (isNaN(c) || isNaN(parseFloat(t.top))) && (c = 0), (isNaN(u) || isNaN(parseFloat(t.bottom))) && (u = o), r = normalizeCssArray(r || 0), {
		width: Math.max(l - s - r[1] - r[3], 0),
		height: Math.max(u - c - r[0] - r[2], 0)
	};
}
function getLayoutRect(t, n, r) {
	r = normalizeCssArray(r || 0);
	var a = n.width, o = n.height, s = parsePercent$1(t.left, a), c = parsePercent$1(t.top, o), l = parsePercent$1(t.right, a), u = parsePercent$1(t.bottom, o), d = parsePercent$1(t.width, a), f = parsePercent$1(t.height, o), p = r[2] + r[0], h = r[1] + r[3], g = t.aspect;
	switch (isNaN(d) && (d = a - l - h - s), isNaN(f) && (f = o - u - p - c), g != null && (isNaN(d) && isNaN(f) && (g > a / o ? d = a * .8 : f = o * .8), isNaN(d) && (d = g * f), isNaN(f) && (f = d / g)), isNaN(s) && (s = a - l - d - h), isNaN(c) && (c = o - u - f - p), t.left || t.right) {
		case "center":
			s = a / 2 - d / 2 - r[3];
			break;
		case "right":
			s = a - d - h;
			break;
	}
	switch (t.top || t.bottom) {
		case "middle":
		case "center":
			c = o / 2 - f / 2 - r[0];
			break;
		case "bottom":
			c = o - f - p;
			break;
	}
	s ||= 0, c ||= 0, isNaN(d) && (d = a - h - s - (l || 0)), isNaN(f) && (f = o - p - c - (u || 0));
	var _ = new BoundingRect_default(s + r[3], c + r[0], d, f);
	return _.margin = r, _;
}
function positionElement(t, n, r, a, o, s) {
	var c = !o || !o.hv || o.hv[0], l = !o || !o.hv || o.hv[1], u = o && o.boundingMode || "all";
	if (s ||= t, s.x = t.x, s.y = t.y, !c && !l) return !1;
	var d;
	if (u === "raw") d = t.type === "group" ? new BoundingRect_default(0, 0, +n.width || 0, +n.height || 0) : t.getBoundingRect();
	else if (d = t.getBoundingRect(), t.needLocalTransform()) {
		var f = t.getLocalTransform();
		d = d.clone(), d.applyTransform(f);
	}
	var p = getLayoutRect(defaults({
		width: d.width,
		height: d.height
	}, n), r, a), h = c ? p.x - d.x : 0, g = l ? p.y - d.y : 0;
	return u === "raw" ? (s.x = h, s.y = g) : (s.x += h, s.y += g), s === t && t.markRedraw(), !0;
}
function sizeCalculable(t, n) {
	return t[HV_NAMES[n][0]] != null || t[HV_NAMES[n][1]] != null && t[HV_NAMES[n][2]] != null;
}
function fetchLayoutMode(t) {
	var n = t.layoutMode || t.constructor.layoutMode;
	return isObject(n) ? n : n ? { type: n } : null;
}
function mergeLayoutParam(t, n, r) {
	var a = r && r.ignoreSize;
	!isArray(a) && (a = [a, a]);
	var o = c(HV_NAMES[0], 0), s = c(HV_NAMES[1], 1);
	d(HV_NAMES[0], t, o), d(HV_NAMES[1], t, s);
	function c(r, o) {
		var s = {}, c = 0, d = {}, f = 0, p = 2;
		if (each$15(r, function(n) {
			d[n] = t[n];
		}), each$15(r, function(t) {
			l(n, t) && (s[t] = d[t] = n[t]), u(s, t) && c++, u(d, t) && f++;
		}), a[o]) return u(n, r[1]) ? d[r[2]] = null : u(n, r[2]) && (d[r[1]] = null), d;
		if (f === p || !c) return d;
		if (c >= p) return s;
		for (var h = 0; h < r.length; h++) {
			var g = r[h];
			if (!l(s, g) && l(t, g)) {
				s[g] = t[g];
				break;
			}
		}
		return s;
	}
	function l(t, n) {
		return t.hasOwnProperty(n);
	}
	function u(t, n) {
		return t[n] != null && t[n] !== "auto";
	}
	function d(t, n, r) {
		each$15(t, function(t) {
			n[t] = r[t];
		});
	}
}
function getLayoutParams(t) {
	return copyLayoutParams({}, t);
}
function copyLayoutParams(t, n) {
	return n && t && each$15(LOCATION_PARAMS, function(r) {
		n.hasOwnProperty(r) && (t[r] = n[r]);
	}), t;
}
var inner$21 = makeInner(), ComponentModel = function(t) {
	__extends(n, t);
	function n(n, r, a) {
		var o = t.call(this, n, r, a) || this;
		return o.uid = getUID("ec_cpt_model"), o;
	}
	return n.prototype.init = function(t, n, r) {
		this.mergeDefaultAndTheme(t, r);
	}, n.prototype.mergeDefaultAndTheme = function(t, n) {
		var r = fetchLayoutMode(this), a = r ? getLayoutParams(t) : {};
		merge(t, n.getTheme().get(this.mainType)), merge(t, this.getDefaultOption()), r && mergeLayoutParam(t, a, r);
	}, n.prototype.mergeOption = function(t, n) {
		merge(this.option, t, !0);
		var r = fetchLayoutMode(this);
		r && mergeLayoutParam(this.option, t, r);
	}, n.prototype.optionUpdated = function(t, n) {}, n.prototype.getDefaultOption = function() {
		var t = this.constructor;
		if (!isExtendedClass(t)) return t.defaultOption;
		var n = inner$21(this);
		if (!n.defaultOption) {
			for (var r = [], a = t; a;) {
				var o = a.prototype.defaultOption;
				o && r.push(o), a = a.superClass;
			}
			for (var s = {}, c = r.length - 1; c >= 0; c--) s = merge(s, r[c], !0);
			n.defaultOption = s;
		}
		return n.defaultOption;
	}, n.prototype.getReferringComponents = function(t, n) {
		var r = t + "Index", a = t + "Id";
		return queryReferringComponents(this.ecModel, t, {
			index: this.get(r, !0),
			id: this.get(a, !0)
		}, n);
	}, n.prototype.getBoxLayoutParams = function() {
		var t = this;
		return {
			left: t.get("left"),
			top: t.get("top"),
			right: t.get("right"),
			bottom: t.get("bottom"),
			width: t.get("width"),
			height: t.get("height")
		};
	}, n.prototype.getZLevelKey = function() {
		return "";
	}, n.prototype.setZLevel = function(t) {
		this.option.zlevel = t;
	}, n.protoInitialize = function() {
		var t = n.prototype;
		t.type = "component", t.id = "", t.name = "", t.mainType = "", t.subType = "", t.componentIndex = 0;
	}(), n;
}(Model_default);
mountExtend(ComponentModel, Model_default), enableClassManagement(ComponentModel), enableSubTypeDefaulter(ComponentModel), enableTopologicalTravel(ComponentModel, getDependencies);
function getDependencies(t) {
	var n = [];
	return each(ComponentModel.getClassesByMainType(t), function(t) {
		n = n.concat(t.dependencies || t.prototype.dependencies || []);
	}), n = map(n, function(t) {
		return parseClassType(t).main;
	}), t !== "dataset" && indexOf(n, "dataset") <= 0 && n.unshift("dataset"), n;
}
var Component_default = ComponentModel, platform = "";
typeof navigator < "u" && (platform = navigator.platform || "");
var decalColor = "rgba(0, 0, 0, 0.2)", globalDefault_default = {
	darkMode: "auto",
	colorBy: "series",
	color: [
		"#5470c6",
		"#91cc75",
		"#fac858",
		"#ee6666",
		"#73c0de",
		"#3ba272",
		"#fc8452",
		"#9a60b4",
		"#ea7ccc"
	],
	gradientColor: [
		"#f6efa6",
		"#d88273",
		"#bf444c"
	],
	aria: { decal: { decals: [
		{
			color: decalColor,
			dashArrayX: [1, 0],
			dashArrayY: [2, 5],
			symbolSize: 1,
			rotation: Math.PI / 6
		},
		{
			color: decalColor,
			symbol: "circle",
			dashArrayX: [[8, 8], [
				0,
				8,
				8,
				0
			]],
			dashArrayY: [6, 0],
			symbolSize: .8
		},
		{
			color: decalColor,
			dashArrayX: [1, 0],
			dashArrayY: [4, 3],
			rotation: -Math.PI / 4
		},
		{
			color: decalColor,
			dashArrayX: [[6, 6], [
				0,
				6,
				6,
				0
			]],
			dashArrayY: [6, 0]
		},
		{
			color: decalColor,
			dashArrayX: [[1, 0], [1, 6]],
			dashArrayY: [
				1,
				0,
				6,
				0
			],
			rotation: Math.PI / 4
		},
		{
			color: decalColor,
			symbol: "triangle",
			dashArrayX: [[9, 9], [
				0,
				9,
				9,
				0
			]],
			dashArrayY: [7, 2],
			symbolSize: .75
		}
	] } },
	textStyle: {
		fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
		fontSize: 12,
		fontStyle: "normal",
		fontWeight: "normal"
	},
	blendMode: null,
	stateAnimation: {
		duration: 300,
		easing: "cubicOut"
	},
	animation: "auto",
	animationDuration: 1e3,
	animationDurationUpdate: 500,
	animationEasing: "cubicInOut",
	animationEasingUpdate: "cubicInOut",
	animationThreshold: 2e3,
	progressiveThreshold: 3e3,
	progressive: 400,
	hoverLayerThreshold: 3e3,
	useUTC: !1
}, VISUAL_DIMENSIONS = createHashMap([
	"tooltip",
	"label",
	"itemName",
	"itemId",
	"itemGroupId",
	"itemChildGroupId",
	"seriesName"
]), SOURCE_FORMAT_ORIGINAL = "original", SOURCE_FORMAT_ARRAY_ROWS = "arrayRows", SOURCE_FORMAT_OBJECT_ROWS = "objectRows", SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns", SOURCE_FORMAT_TYPED_ARRAY = "typedArray", SOURCE_FORMAT_UNKNOWN = "unknown", SERIES_LAYOUT_BY_COLUMN = "column", BE_ORDINAL = {
	Must: 1,
	Might: 2,
	Not: 3
}, innerGlobalModel = makeInner();
function resetSourceDefaulter(t) {
	innerGlobalModel(t).datasetMap = createHashMap();
}
function makeSeriesEncodeForAxisCoordSys(t, n, r) {
	var a = {}, o = querySeriesUpstreamDatasetModel(n);
	if (!o || !t) return a;
	var s = [], c = [], l = n.ecModel, u = innerGlobalModel(l).datasetMap, d = o.uid + "_" + r.seriesLayoutBy, f, p;
	t = t.slice(), each(t, function(n, r) {
		var o = isObject(n) ? n : t[r] = { name: n };
		o.type === "ordinal" && f == null && (f = r, p = _(o)), a[o.name] = [];
	});
	var h = u.get(d) || u.set(d, {
		categoryWayDim: p,
		valueWayDim: 0
	});
	each(t, function(t, n) {
		var r = t.name, o = _(t);
		if (f == null) {
			var l = h.valueWayDim;
			g(a[r], l, o), g(c, l, o), h.valueWayDim += o;
		} else if (f === n) g(a[r], 0, o), g(s, 0, o);
		else {
			var l = h.categoryWayDim;
			g(a[r], l, o), g(c, l, o), h.categoryWayDim += o;
		}
	});
	function g(t, n, r) {
		for (var a = 0; a < r; a++) t.push(n + a);
	}
	function _(t) {
		var n = t.dimsDef;
		return n ? n.length : 1;
	}
	return s.length && (a.itemName = s), c.length && (a.seriesName = c), a;
}
function makeSeriesEncodeForNameBased(t, n, r) {
	var a = {};
	if (!querySeriesUpstreamDatasetModel(t)) return a;
	var o = n.sourceFormat, s = n.dimensionsDefine, c;
	(o === "objectRows" || o === "keyedColumns") && each(s, function(t, n) {
		(isObject(t) ? t.name : t) === "name" && (c = n);
	});
	var l = function() {
		for (var t = {}, a = {}, l = [], u = 0, d = Math.min(5, r); u < d; u++) {
			var f = doGuessOrdinal(n.data, o, n.seriesLayoutBy, s, n.startIndex, u);
			l.push(f);
			var p = f === BE_ORDINAL.Not;
			if (p && t.v == null && u !== c && (t.v = u), (t.n == null || t.n === t.v || !p && l[t.n] === BE_ORDINAL.Not) && (t.n = u), h(t) && l[t.n] !== BE_ORDINAL.Not) return t;
			p || (f === BE_ORDINAL.Might && a.v == null && u !== c && (a.v = u), (a.n == null || a.n === a.v) && (a.n = u));
		}
		function h(t) {
			return t.v != null && t.n != null;
		}
		return h(t) ? t : h(a) ? a : null;
	}();
	if (l) {
		a.value = [l.v];
		var u = c ?? l.n;
		a.itemName = [u], a.seriesName = [u];
	}
	return a;
}
function querySeriesUpstreamDatasetModel(t) {
	if (!t.get("data", !0)) return queryReferringComponents(t.ecModel, "dataset", {
		index: t.get("datasetIndex", !0),
		id: t.get("datasetId", !0)
	}, SINGLE_REFERRING).models[0];
}
function queryDatasetUpstreamDatasetModels(t) {
	return !t.get("transform", !0) && !t.get("fromTransformResult", !0) ? [] : queryReferringComponents(t.ecModel, "dataset", {
		index: t.get("fromDatasetIndex", !0),
		id: t.get("fromDatasetId", !0)
	}, SINGLE_REFERRING).models;
}
function guessOrdinal(t, n) {
	return doGuessOrdinal(t.data, t.sourceFormat, t.seriesLayoutBy, t.dimensionsDefine, t.startIndex, n);
}
function doGuessOrdinal(t, n, r, a, o, s) {
	var c, l = 5;
	if (isTypedArray(t)) return BE_ORDINAL.Not;
	var u, d;
	if (a) {
		var f = a[s];
		isObject(f) ? (u = f.name, d = f.type) : isString(f) && (u = f);
	}
	if (d != null) return d === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
	if (n === "arrayRows") {
		var p = t;
		if (r === "row") {
			for (var h = p[s], g = 0; g < (h || []).length && g < l; g++) if ((c = C(h[o + g])) != null) return c;
		} else for (var g = 0; g < p.length && g < l; g++) {
			var _ = p[o + g];
			if (_ && (c = C(_[s])) != null) return c;
		}
	} else if (n === "objectRows") {
		var v = t;
		if (!u) return BE_ORDINAL.Not;
		for (var g = 0; g < v.length && g < l; g++) {
			var y = v[g];
			if (y && (c = C(y[u])) != null) return c;
		}
	} else if (n === "keyedColumns") {
		var b = t;
		if (!u) return BE_ORDINAL.Not;
		var h = b[u];
		if (!h || isTypedArray(h)) return BE_ORDINAL.Not;
		for (var g = 0; g < h.length && g < l; g++) if ((c = C(h[g])) != null) return c;
	} else if (n === "original") for (var x = t, g = 0; g < x.length && g < l; g++) {
		var y = x[g], S = getDataItemValue(y);
		if (!isArray(S)) return BE_ORDINAL.Not;
		if ((c = C(S[s])) != null) return c;
	}
	function C(t) {
		var n = isString(t);
		if (t != null && Number.isFinite(Number(t)) && t !== "") return n ? BE_ORDINAL.Might : BE_ORDINAL.Not;
		if (n && t !== "-") return BE_ORDINAL.Must;
	}
	return BE_ORDINAL.Not;
}
init_dist$2();
var internalOptionCreatorMap = createHashMap();
function registerInternalOptionCreator(t, n) {
	assert(internalOptionCreatorMap.get(t) == null && n), internalOptionCreatorMap.set(t, n);
}
function concatInternalOptions(t, n, r) {
	var a = internalOptionCreatorMap.get(n);
	if (!a) return r;
	var o = a(t);
	if (!o) return r;
	if (process$1.env.NODE_ENV !== "production") for (var c = 0; c < o.length; c++) assert(isComponentIdInternal(o[c]));
	return r.concat(o);
}
var innerColor = makeInner(), innerDecal = makeInner(), PaletteMixin = function() {
	function t() {}
	return t.prototype.getColorFromPalette = function(t, n, r) {
		var a = normalizeToArray(this.get("color", !0)), o = this.get("colorLayer", !0);
		return getFromPalette(this, innerColor, a, o, t, n, r);
	}, t.prototype.clearColorPalette = function() {
		clearPalette(this, innerColor);
	}, t;
}();
function getDecalFromPalette(t, n, r, a) {
	return getFromPalette(t, innerDecal, normalizeToArray(t.get([
		"aria",
		"decal",
		"decals"
	])), null, n, r, a);
}
function getNearestPalette(t, n) {
	for (var r = t.length, a = 0; a < r; a++) if (t[a].length > n) return t[a];
	return t[r - 1];
}
function getFromPalette(t, n, r, a, o, s, c) {
	s ||= t;
	var l = n(s), u = l.paletteIdx || 0, d = l.paletteNameMap = l.paletteNameMap || {};
	if (d.hasOwnProperty(o)) return d[o];
	var f = c == null || !a ? r : getNearestPalette(a, c);
	if (f ||= r, !(!f || !f.length)) {
		var p = f[u];
		return o && (d[o] = p), l.paletteIdx = (u + 1) % f.length, p;
	}
}
function clearPalette(t, n) {
	n(t).paletteIdx = 0, n(t).paletteNameMap = {};
}
init_dist$2();
var reCreateSeriesIndices, assertSeriesInitialized, initBase, OPTION_INNER_KEY = "\0_ec_inner", OPTION_INNER_VALUE = 1, BUITIN_COMPONENTS_MAP = {
	grid: "GridComponent",
	polar: "PolarComponent",
	geo: "GeoComponent",
	singleAxis: "SingleAxisComponent",
	parallel: "ParallelComponent",
	calendar: "CalendarComponent",
	graphic: "GraphicComponent",
	toolbox: "ToolboxComponent",
	tooltip: "TooltipComponent",
	axisPointer: "AxisPointerComponent",
	brush: "BrushComponent",
	title: "TitleComponent",
	timeline: "TimelineComponent",
	markPoint: "MarkPointComponent",
	markLine: "MarkLineComponent",
	markArea: "MarkAreaComponent",
	legend: "LegendComponent",
	dataZoom: "DataZoomComponent",
	visualMap: "VisualMapComponent",
	xAxis: "GridComponent",
	yAxis: "GridComponent",
	angleAxis: "PolarComponent",
	radiusAxis: "PolarComponent"
}, BUILTIN_CHARTS_MAP = {
	line: "LineChart",
	bar: "BarChart",
	pie: "PieChart",
	scatter: "ScatterChart",
	radar: "RadarChart",
	map: "MapChart",
	tree: "TreeChart",
	treemap: "TreemapChart",
	graph: "GraphChart",
	gauge: "GaugeChart",
	funnel: "FunnelChart",
	parallel: "ParallelChart",
	sankey: "SankeyChart",
	boxplot: "BoxplotChart",
	candlestick: "CandlestickChart",
	effectScatter: "EffectScatterChart",
	lines: "LinesChart",
	heatmap: "HeatmapChart",
	pictorialBar: "PictorialBarChart",
	themeRiver: "ThemeRiverChart",
	sunburst: "SunburstChart",
	custom: "CustomChart"
}, componetsMissingLogPrinted = {};
function checkMissingComponents(t) {
	each(t, function(t, n) {
		if (!Component_default.hasClass(n)) {
			var r = BUITIN_COMPONENTS_MAP[n];
			r && !componetsMissingLogPrinted[r] && (error("Component " + n + " is used but not imported.\nimport { " + r + " } from 'echarts/components';\necharts.use([" + r + "]);"), componetsMissingLogPrinted[r] = !0);
		}
	});
}
var GlobalModel = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.init = function(t, n, r, a, o, s) {
		a ||= {}, this.option = null, this._theme = new Model_default(a), this._locale = new Model_default(o), this._optionManager = s;
	}, n.prototype.setOption = function(t, n, r) {
		process$1.env.NODE_ENV !== "production" && (assert(t != null, "option is null/undefined"), assert(t[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, "please use chart.getOption()"));
		var a = normalizeSetOptionInput(n);
		this._optionManager.setOption(t, r, a), this._resetOption(null, a);
	}, n.prototype.resetOption = function(t, n) {
		return this._resetOption(t, normalizeSetOptionInput(n));
	}, n.prototype._resetOption = function(t, n) {
		var r = !1, a = this._optionManager;
		if (!t || t === "recreate") {
			var o = a.mountOption(t === "recreate");
			process$1.env.NODE_ENV !== "production" && checkMissingComponents(o), !this.option || t === "recreate" ? initBase(this, o) : (this.restoreData(), this._mergeOption(o, n)), r = !0;
		}
		if ((t === "timeline" || t === "media") && this.restoreData(), !t || t === "recreate" || t === "timeline") {
			var c = a.getTimelineOption(this);
			c && (r = !0, this._mergeOption(c, n));
		}
		if (!t || t === "recreate" || t === "media") {
			var l = a.getMediaOption(this);
			l.length && each(l, function(t) {
				r = !0, this._mergeOption(t, n);
			}, this);
		}
		return r;
	}, n.prototype.mergeOption = function(t) {
		this._mergeOption(t, null);
	}, n.prototype._mergeOption = function(t, n) {
		var r = this.option, a = this._componentsMap, o = this._componentsCount, c = [], l = createHashMap(), u = n && n.replaceMergeMainTypeMap;
		resetSourceDefaulter(this), each(t, function(t, n) {
			t != null && (Component_default.hasClass(n) ? n && (c.push(n), l.set(n, !0)) : r[n] = r[n] == null ? clone$1(t) : merge(r[n], t, !0));
		}), u && u.each(function(t, n) {
			Component_default.hasClass(n) && !l.get(n) && (c.push(n), l.set(n, !0));
		}), Component_default.topologicalTravel(c, Component_default.getAllClassMainTypes(), d, this);
		function d(n) {
			var c = concatInternalOptions(this, n, normalizeToArray(t[n])), l = a.get(n), d = mappingToExists(l, c, l ? u && u.get(n) ? "replaceMerge" : "normalMerge" : "replaceAll");
			setComponentTypeToKeyInfo(d, n, Component_default), r[n] = null, a.set(n, null), o.set(n, 0);
			var f = [], p = [], h = 0, g, _;
			each(d, function(t, r) {
				var a = t.existing, o = t.newOption;
				if (!o) a && (a.mergeOption({}, this), a.optionUpdated({}, !1));
				else {
					var c = n === "series", l = Component_default.getClass(n, t.keyInfo.subType, !c);
					if (!l) {
						if (process$1.env.NODE_ENV !== "production") {
							var u = t.keyInfo.subType, d = BUILTIN_CHARTS_MAP[u];
							componetsMissingLogPrinted[u] || (componetsMissingLogPrinted[u] = !0, error(d ? "Series " + u + " is used but not imported.\nimport { " + d + " } from 'echarts/charts';\necharts.use([" + d + "]);" : "Unknown series " + u));
						}
						return;
					}
					if (n === "tooltip") {
						if (g) {
							process$1.env.NODE_ENV !== "production" && (_ ||= (warn("Currently only one tooltip component is allowed."), !0));
							return;
						}
						g = !0;
					}
					if (a && a.constructor === l) a.name = t.keyInfo.name, a.mergeOption(o, this), a.optionUpdated(o, !1);
					else {
						var v = extend({ componentIndex: r }, t.keyInfo);
						a = new l(o, this, this, v), extend(a, v), t.brandNew && (a.__requireNewView = !0), a.init(o, this, this), a.optionUpdated(null, !0);
					}
				}
				a ? (f.push(a.option), p.push(a), h++) : (f.push(void 0), p.push(void 0));
			}, this), r[n] = f, a.set(n, p), o.set(n, h), n === "series" && reCreateSeriesIndices(this);
		}
		this._seriesIndices || reCreateSeriesIndices(this);
	}, n.prototype.getOption = function() {
		var t = clone$1(this.option);
		return each(t, function(n, r) {
			if (Component_default.hasClass(r)) {
				for (var a = normalizeToArray(n), o = a.length, s = !1, c = o - 1; c >= 0; c--) a[c] && !isComponentIdInternal(a[c]) ? s = !0 : (a[c] = null, !s && o--);
				a.length = o, t[r] = a;
			}
		}), delete t[OPTION_INNER_KEY], t;
	}, n.prototype.getTheme = function() {
		return this._theme;
	}, n.prototype.getLocaleModel = function() {
		return this._locale;
	}, n.prototype.setUpdatePayload = function(t) {
		this._payload = t;
	}, n.prototype.getUpdatePayload = function() {
		return this._payload;
	}, n.prototype.getComponent = function(t, n) {
		var r = this._componentsMap.get(t);
		if (r) {
			var a = r[n || 0];
			if (a) return a;
			if (n == null) {
				for (var o = 0; o < r.length; o++) if (r[o]) return r[o];
			}
		}
	}, n.prototype.queryComponents = function(t) {
		var n = t.mainType;
		if (!n) return [];
		var r = t.index, a = t.id, o = t.name, s = this._componentsMap.get(n);
		if (!s || !s.length) return [];
		var c;
		return r == null ? c = a == null ? o == null ? filter(s, function(t) {
			return !!t;
		}) : queryByIdOrName("name", o, s) : queryByIdOrName("id", a, s) : (c = [], each(normalizeToArray(r), function(t) {
			s[t] && c.push(s[t]);
		})), filterBySubType(c, t);
	}, n.prototype.findComponents = function(t) {
		var n = t.query, r = t.mainType, a = o(n);
		return s(filterBySubType(a ? this.queryComponents(a) : filter(this._componentsMap.get(r), function(t) {
			return !!t;
		}), t));
		function o(t) {
			var n = r + "Index", a = r + "Id", o = r + "Name";
			return t && (t[n] != null || t[a] != null || t[o] != null) ? {
				mainType: r,
				index: t[n],
				id: t[a],
				name: t[o]
			} : null;
		}
		function s(n) {
			return t.filter ? filter(n, t.filter) : n;
		}
	}, n.prototype.eachComponent = function(t, n, r) {
		var a = this._componentsMap;
		if (isFunction(t)) {
			var o = n, s = t;
			a.each(function(t, n) {
				for (var r = 0; t && r < t.length; r++) {
					var a = t[r];
					a && s.call(o, n, a, a.componentIndex);
				}
			});
		} else for (var c = isString(t) ? a.get(t) : isObject(t) ? this.findComponents(t) : null, l = 0; c && l < c.length; l++) {
			var u = c[l];
			u && n.call(r, u, u.componentIndex);
		}
	}, n.prototype.getSeriesByName = function(t) {
		var n = convertOptionIdName(t, null);
		return filter(this._componentsMap.get("series"), function(t) {
			return !!t && n != null && t.name === n;
		});
	}, n.prototype.getSeriesByIndex = function(t) {
		return this._componentsMap.get("series")[t];
	}, n.prototype.getSeriesByType = function(t) {
		return filter(this._componentsMap.get("series"), function(n) {
			return !!n && n.subType === t;
		});
	}, n.prototype.getSeries = function() {
		return filter(this._componentsMap.get("series"), function(t) {
			return !!t;
		});
	}, n.prototype.getSeriesCount = function() {
		return this._componentsCount.get("series");
	}, n.prototype.eachSeries = function(t, n) {
		assertSeriesInitialized(this), each(this._seriesIndices, function(r) {
			var a = this._componentsMap.get("series")[r];
			t.call(n, a, r);
		}, this);
	}, n.prototype.eachRawSeries = function(t, n) {
		each(this._componentsMap.get("series"), function(r) {
			r && t.call(n, r, r.componentIndex);
		});
	}, n.prototype.eachSeriesByType = function(t, n, r) {
		assertSeriesInitialized(this), each(this._seriesIndices, function(a) {
			var o = this._componentsMap.get("series")[a];
			o.subType === t && n.call(r, o, a);
		}, this);
	}, n.prototype.eachRawSeriesByType = function(t, n, r) {
		return each(this.getSeriesByType(t), n, r);
	}, n.prototype.isSeriesFiltered = function(t) {
		return assertSeriesInitialized(this), this._seriesIndicesMap.get(t.componentIndex) == null;
	}, n.prototype.getCurrentSeriesIndices = function() {
		return (this._seriesIndices || []).slice();
	}, n.prototype.filterSeries = function(t, n) {
		assertSeriesInitialized(this);
		var r = [];
		each(this._seriesIndices, function(a) {
			var o = this._componentsMap.get("series")[a];
			t.call(n, o, a) && r.push(a);
		}, this), this._seriesIndices = r, this._seriesIndicesMap = createHashMap(r);
	}, n.prototype.restoreData = function(t) {
		reCreateSeriesIndices(this);
		var n = this._componentsMap, r = [];
		n.each(function(t, n) {
			Component_default.hasClass(n) && r.push(n);
		}), Component_default.topologicalTravel(r, Component_default.getAllClassMainTypes(), function(r) {
			each(n.get(r), function(n) {
				n && (r !== "series" || !isNotTargetSeries(n, t)) && n.restoreData();
			});
		});
	}, n.internalField = function() {
		reCreateSeriesIndices = function(t) {
			var n = t._seriesIndices = [];
			each(t._componentsMap.get("series"), function(t) {
				t && n.push(t.componentIndex);
			}), t._seriesIndicesMap = createHashMap(n);
		}, assertSeriesInitialized = function(t) {
			if (process$1.env.NODE_ENV !== "production" && !t._seriesIndices) throw Error("Option should contains series.");
		}, initBase = function(t, n) {
			t.option = {}, t.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE, t._componentsMap = createHashMap({ series: [] }), t._componentsCount = createHashMap();
			var r = n.aria;
			isObject(r) && r.enabled == null && (r.enabled = !0), mergeTheme(n, t._theme.option), merge(n, globalDefault_default, !1), t._mergeOption(n, null);
		};
	}(), n;
}(Model_default);
function isNotTargetSeries(t, n) {
	if (n) {
		var r = n.seriesIndex, a = n.seriesId, o = n.seriesName;
		return r != null && t.componentIndex !== r || a != null && t.id !== a || o != null && t.name !== o;
	}
}
function mergeTheme(t, n) {
	var r = t.color && !t.colorLayer;
	each(n, function(n, a) {
		a === "colorLayer" && r || Component_default.hasClass(a) || (typeof n == "object" ? t[a] = t[a] ? merge(t[a], n, !1) : clone$1(n) : t[a] ?? (t[a] = n));
	});
}
function queryByIdOrName(t, n, r) {
	if (isArray(n)) {
		var a = createHashMap();
		return each(n, function(t) {
			t != null && convertOptionIdName(t, null) != null && a.set(t, !0);
		}), filter(r, function(n) {
			return n && a.get(n[t]);
		});
	} else {
		var o = convertOptionIdName(n, null);
		return filter(r, function(n) {
			return n && o != null && n[t] === o;
		});
	}
}
function filterBySubType(t, n) {
	return n.hasOwnProperty("subType") ? filter(t, function(t) {
		return t && t.subType === n.subType;
	}) : t;
}
function normalizeSetOptionInput(t) {
	var n = createHashMap();
	return t && each(normalizeToArray(t.replaceMerge), function(t) {
		process$1.env.NODE_ENV !== "production" && assert(Component_default.hasClass(t), "\"" + t + "\" is not valid component main type in \"replaceMerge\""), n.set(t, !0);
	}), { replaceMergeMainTypeMap: n };
}
mixin(GlobalModel, PaletteMixin);
var Global_default = GlobalModel, availableMethods = [
	"getDom",
	"getZr",
	"getWidth",
	"getHeight",
	"getDevicePixelRatio",
	"dispatchAction",
	"isSSR",
	"isDisposed",
	"on",
	"off",
	"getDataURL",
	"getConnectedDataURL",
	"getOption",
	"getId",
	"updateLabelLayout"
], ExtensionAPI_default = function() {
	function t(t) {
		each(availableMethods, function(n) {
			this[n] = bind(t[n], t);
		}, this);
	}
	return t;
}(), coordinateSystemCreators = {}, CoordinateSystem_default = function() {
	function t() {
		this._coordinateSystems = [];
	}
	return t.prototype.create = function(t, n) {
		var r = [];
		each(coordinateSystemCreators, function(a, o) {
			var s = a.create(t, n);
			r = r.concat(s || []);
		}), this._coordinateSystems = r;
	}, t.prototype.update = function(t, n) {
		each(this._coordinateSystems, function(r) {
			r.update && r.update(t, n);
		});
	}, t.prototype.getCoordinateSystems = function() {
		return this._coordinateSystems.slice();
	}, t.register = function(t, n) {
		coordinateSystemCreators[t] = n;
	}, t.get = function(t) {
		return coordinateSystemCreators[t];
	}, t;
}();
init_dist$2();
var QUERY_REG = /^(min|max)?(.+)$/, OptionManager = function() {
	function t(t) {
		this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t;
	}
	return t.prototype.setOption = function(t, n, r) {
		t && (each(normalizeToArray(t.series), function(t) {
			t && t.data && isTypedArray(t.data) && setAsPrimitive(t.data);
		}), each(normalizeToArray(t.dataset), function(t) {
			t && t.source && isTypedArray(t.source) && setAsPrimitive(t.source);
		})), t = clone$1(t);
		var a = this._optionBackup, o = parseRawOption(t, n, !a);
		this._newBaseOption = o.baseOption, a ? (o.timelineOptions.length && (a.timelineOptions = o.timelineOptions), o.mediaList.length && (a.mediaList = o.mediaList), o.mediaDefault && (a.mediaDefault = o.mediaDefault)) : this._optionBackup = o;
	}, t.prototype.mountOption = function(t) {
		var n = this._optionBackup;
		return this._timelineOptions = n.timelineOptions, this._mediaList = n.mediaList, this._mediaDefault = n.mediaDefault, this._currentMediaIndices = [], clone$1(t ? n.baseOption : this._newBaseOption);
	}, t.prototype.getTimelineOption = function(t) {
		var n, r = this._timelineOptions;
		if (r.length) {
			var a = t.getComponent("timeline");
			a && (n = clone$1(r[a.getCurrentIndex()]));
		}
		return n;
	}, t.prototype.getMediaOption = function(t) {
		var n = this._api.getWidth(), r = this._api.getHeight(), a = this._mediaList, o = this._mediaDefault, s = [], c = [];
		if (!a.length && !o) return c;
		for (var l = 0, u = a.length; l < u; l++) applyMediaQuery(a[l].query, n, r) && s.push(l);
		return !s.length && o && (s = [-1]), s.length && !indicesEquals(s, this._currentMediaIndices) && (c = map(s, function(t) {
			return clone$1(t === -1 ? o.option : a[t].option);
		})), this._currentMediaIndices = s, c;
	}, t;
}();
function parseRawOption(t, n, r) {
	var a = [], o, c, l = t.baseOption, u = t.timeline, d = t.options, f = t.media, p = !!t.media, h = !!(d || u || l && l.timeline);
	l ? (c = l, c.timeline ||= u) : ((h || p) && (t.options = t.media = null), c = t), p && (isArray(f) ? each(f, function(t) {
		process$1.env.NODE_ENV !== "production" && t && !t.option && isObject(t.query) && isObject(t.query.option) && error("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), t && t.option && (t.query ? a.push(t) : o ||= t);
	}) : process$1.env.NODE_ENV !== "production" && error("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), g(c), each(d, function(t) {
		return g(t);
	}), each(a, function(t) {
		return g(t.option);
	});
	function g(t) {
		each(n, function(n) {
			n(t, r);
		});
	}
	return {
		baseOption: c,
		timelineOptions: d || [],
		mediaDefault: o,
		mediaList: a
	};
}
function applyMediaQuery(t, n, r) {
	var a = {
		width: n,
		height: r,
		aspectratio: n / r
	}, o = !0;
	return each(t, function(t, n) {
		var r = n.match(QUERY_REG);
		if (!(!r || !r[1] || !r[2])) {
			var s = r[1];
			compare(a[r[2].toLowerCase()], t, s) || (o = !1);
		}
	}), o;
}
function compare(t, n, r) {
	return r === "min" ? t >= n : r === "max" ? t <= n : t === n;
}
function indicesEquals(t, n) {
	return t.join(",") === n.join(",");
}
var OptionManager_default = OptionManager;
init_dist$2();
var each$14 = each, isObject$3 = isObject, POSSIBLE_STYLES = [
	"areaStyle",
	"lineStyle",
	"nodeStyle",
	"linkStyle",
	"chordStyle",
	"label",
	"labelLine"
];
function compatEC2ItemStyle(t) {
	var n = t && t.itemStyle;
	if (n) for (var r = 0, a = POSSIBLE_STYLES.length; r < a; r++) {
		var o = POSSIBLE_STYLES[r], c = n.normal, l = n.emphasis;
		c && c[o] && (process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("itemStyle.normal." + o, o), t[o] = t[o] || {}, t[o].normal ? merge(t[o].normal, c[o]) : t[o].normal = c[o], c[o] = null), l && l[o] && (process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("itemStyle.emphasis." + o, "emphasis." + o), t[o] = t[o] || {}, t[o].emphasis ? merge(t[o].emphasis, l[o]) : t[o].emphasis = l[o], l[o] = null);
	}
}
function convertNormalEmphasis(t, n, r) {
	if (t && t[n] && (t[n].normal || t[n].emphasis)) {
		var a = t[n].normal, o = t[n].emphasis;
		a && (process$1.env.NODE_ENV !== "production" && deprecateLog("'normal' hierarchy in " + n + " has been removed since 4.0. All style properties are configured in " + n + " directly now."), r ? (t[n].normal = t[n].emphasis = null, defaults(t[n], a)) : t[n] = a), o && (process$1.env.NODE_ENV !== "production" && deprecateLog(n + ".emphasis has been changed to emphasis." + n + " since 4.0"), t.emphasis = t.emphasis || {}, t.emphasis[n] = o, o.focus && (t.emphasis.focus = o.focus), o.blurScope && (t.emphasis.blurScope = o.blurScope));
	}
}
function removeEC3NormalStatus(t) {
	convertNormalEmphasis(t, "itemStyle"), convertNormalEmphasis(t, "lineStyle"), convertNormalEmphasis(t, "areaStyle"), convertNormalEmphasis(t, "label"), convertNormalEmphasis(t, "labelLine"), convertNormalEmphasis(t, "upperLabel"), convertNormalEmphasis(t, "edgeLabel");
}
function compatTextStyle(t, n) {
	var r = isObject$3(t) && t[n], a = isObject$3(r) && r.textStyle;
	if (a) {
		process$1.env.NODE_ENV !== "production" && deprecateLog("textStyle hierarchy in " + n + " has been removed since 4.0. All textStyle properties are configured in " + n + " directly now.");
		for (var o = 0, c = TEXT_STYLE_OPTIONS.length; o < c; o++) {
			var l = TEXT_STYLE_OPTIONS[o];
			a.hasOwnProperty(l) && (r[l] = a[l]);
		}
	}
}
function compatEC3CommonStyles(t) {
	t && (removeEC3NormalStatus(t), compatTextStyle(t, "label"), t.emphasis && compatTextStyle(t.emphasis, "label"));
}
function processSeries(t) {
	if (isObject$3(t)) {
		compatEC2ItemStyle(t), removeEC3NormalStatus(t), compatTextStyle(t, "label"), compatTextStyle(t, "upperLabel"), compatTextStyle(t, "edgeLabel"), t.emphasis && (compatTextStyle(t.emphasis, "label"), compatTextStyle(t.emphasis, "upperLabel"), compatTextStyle(t.emphasis, "edgeLabel"));
		var n = t.markPoint;
		n && (compatEC2ItemStyle(n), compatEC3CommonStyles(n));
		var r = t.markLine;
		r && (compatEC2ItemStyle(r), compatEC3CommonStyles(r));
		var a = t.markArea;
		a && compatEC3CommonStyles(a);
		var o = t.data;
		if (t.type === "graph") {
			o ||= t.nodes;
			var s = t.links || t.edges;
			if (s && !isTypedArray(s)) for (var c = 0; c < s.length; c++) compatEC3CommonStyles(s[c]);
			each(t.categories, function(t) {
				removeEC3NormalStatus(t);
			});
		}
		if (o && !isTypedArray(o)) for (var c = 0; c < o.length; c++) compatEC3CommonStyles(o[c]);
		if (n = t.markPoint, n && n.data) for (var l = n.data, c = 0; c < l.length; c++) compatEC3CommonStyles(l[c]);
		if (r = t.markLine, r && r.data) for (var u = r.data, c = 0; c < u.length; c++) isArray(u[c]) ? (compatEC3CommonStyles(u[c][0]), compatEC3CommonStyles(u[c][1])) : compatEC3CommonStyles(u[c]);
		t.type === "gauge" ? (compatTextStyle(t, "axisLabel"), compatTextStyle(t, "title"), compatTextStyle(t, "detail")) : t.type === "treemap" ? (convertNormalEmphasis(t.breadcrumb, "itemStyle"), each(t.levels, function(t) {
			removeEC3NormalStatus(t);
		})) : t.type === "tree" && removeEC3NormalStatus(t.leaves);
	}
}
function toArr(t) {
	return isArray(t) ? t : t ? [t] : [];
}
function toObj(t) {
	return (isArray(t) ? t[0] : t) || {};
}
function globalCompatStyle(t, n) {
	each$14(toArr(t.series), function(t) {
		isObject$3(t) && processSeries(t);
	});
	var r = [
		"xAxis",
		"yAxis",
		"radiusAxis",
		"angleAxis",
		"singleAxis",
		"parallelAxis",
		"radar"
	];
	n && r.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), each$14(r, function(n) {
		each$14(toArr(t[n]), function(t) {
			t && (compatTextStyle(t, "axisLabel"), compatTextStyle(t.axisPointer, "label"));
		});
	}), each$14(toArr(t.parallel), function(t) {
		var n = t && t.parallelAxisDefault;
		compatTextStyle(n, "axisLabel"), compatTextStyle(n && n.axisPointer, "label");
	}), each$14(toArr(t.calendar), function(t) {
		convertNormalEmphasis(t, "itemStyle"), compatTextStyle(t, "dayLabel"), compatTextStyle(t, "monthLabel"), compatTextStyle(t, "yearLabel");
	}), each$14(toArr(t.radar), function(t) {
		compatTextStyle(t, "name"), t.name && t.axisName == null && (t.axisName = t.name, delete t.name, process$1.env.NODE_ENV !== "production" && deprecateLog("name property in radar component has been changed to axisName")), t.nameGap != null && t.axisNameGap == null && (t.axisNameGap = t.nameGap, delete t.nameGap, process$1.env.NODE_ENV !== "production" && deprecateLog("nameGap property in radar component has been changed to axisNameGap")), process$1.env.NODE_ENV !== "production" && each$14(t.indicator, function(t) {
			t.text && deprecateReplaceLog("text", "name", "radar.indicator");
		});
	}), each$14(toArr(t.geo), function(t) {
		isObject$3(t) && (compatEC3CommonStyles(t), each$14(toArr(t.regions), function(t) {
			compatEC3CommonStyles(t);
		}));
	}), each$14(toArr(t.timeline), function(t) {
		compatEC3CommonStyles(t), convertNormalEmphasis(t, "label"), convertNormalEmphasis(t, "itemStyle"), convertNormalEmphasis(t, "controlStyle", !0);
		var n = t.data;
		isArray(n) && each(n, function(t) {
			isObject(t) && (convertNormalEmphasis(t, "label"), convertNormalEmphasis(t, "itemStyle"));
		});
	}), each$14(toArr(t.toolbox), function(t) {
		convertNormalEmphasis(t, "iconStyle"), each$14(t.feature, function(t) {
			convertNormalEmphasis(t, "iconStyle");
		});
	}), compatTextStyle(toObj(t.axisPointer), "label"), compatTextStyle(toObj(t.tooltip).axisPointer, "label");
}
init_dist$2();
function get(t, n) {
	for (var r = n.split(","), a = t, o = 0; o < r.length && (a &&= a[r[o]], a != null); o++);
	return a;
}
function set(t, n, r, a) {
	for (var o = n.split(","), s = t, c, l = 0; l < o.length - 1; l++) c = o[l], s[c] ?? (s[c] = {}), s = s[c];
	(a || s[o[l]] == null) && (s[o[l]] = r);
}
function compatLayoutProperties(t) {
	t && each(LAYOUT_PROPERTIES, function(n) {
		n[0] in t && !(n[1] in t) && (t[n[1]] = t[n[0]]);
	});
}
var LAYOUT_PROPERTIES = [
	["x", "left"],
	["y", "top"],
	["x2", "right"],
	["y2", "bottom"]
], COMPATITABLE_COMPONENTS = [
	"grid",
	"geo",
	"parallel",
	"legend",
	"toolbox",
	"title",
	"visualMap",
	"dataZoom",
	"timeline"
], BAR_ITEM_STYLE_MAP = [
	["borderRadius", "barBorderRadius"],
	["borderColor", "barBorderColor"],
	["borderWidth", "barBorderWidth"]
];
function compatBarItemStyle(t) {
	var n = t && t.itemStyle;
	if (n) for (var r = 0; r < BAR_ITEM_STYLE_MAP.length; r++) {
		var a = BAR_ITEM_STYLE_MAP[r][1], o = BAR_ITEM_STYLE_MAP[r][0];
		n[a] != null && (n[o] = n[a], process$1.env.NODE_ENV !== "production" && deprecateReplaceLog(a, o));
	}
}
function compatPieLabel(t) {
	t && t.alignTo === "edge" && t.margin != null && t.edgeDistance == null && (process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("label.margin", "label.edgeDistance", "pie"), t.edgeDistance = t.margin);
}
function compatSunburstState(t) {
	t && t.downplay && !t.blur && (t.blur = t.downplay, process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("downplay", "blur", "sunburst"));
}
function compatGraphFocus(t) {
	t && t.focusNodeAdjacency != null && (t.emphasis = t.emphasis || {}, t.emphasis.focus ?? (process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), t.emphasis.focus = "adjacency"));
}
function traverseTree(t, n) {
	if (t) for (var r = 0; r < t.length; r++) n(t[r]), t[r] && traverseTree(t[r].children, n);
}
function globalBackwardCompat(t, n) {
	globalCompatStyle(t, n), t.series = normalizeToArray(t.series), each(t.series, function(t) {
		if (isObject(t)) {
			var n = t.type;
			if (n === "line") t.clipOverflow != null && (t.clip = t.clipOverflow, process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("clipOverflow", "clip", "line"));
			else if (n === "pie" || n === "gauge") {
				t.clockWise != null && (t.clockwise = t.clockWise, process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("clockWise", "clockwise")), compatPieLabel(t.label);
				var r = t.data;
				if (r && !isTypedArray(r)) for (var a = 0; a < r.length; a++) compatPieLabel(r[a]);
				t.hoverOffset != null && (t.emphasis = t.emphasis || {}, (t.emphasis.scaleSize = null) && (process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("hoverOffset", "emphasis.scaleSize"), t.emphasis.scaleSize = t.hoverOffset));
			} else if (n === "gauge") {
				var o = get(t, "pointer.color");
				o != null && set(t, "itemStyle.color", o);
			} else if (n === "bar") {
				compatBarItemStyle(t), compatBarItemStyle(t.backgroundStyle), compatBarItemStyle(t.emphasis);
				var r = t.data;
				if (r && !isTypedArray(r)) for (var a = 0; a < r.length; a++) typeof r[a] == "object" && (compatBarItemStyle(r[a]), compatBarItemStyle(r[a] && r[a].emphasis));
			} else if (n === "sunburst") {
				var c = t.highlightPolicy;
				c && (t.emphasis = t.emphasis || {}, t.emphasis.focus || (t.emphasis.focus = c, process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("highlightPolicy", "emphasis.focus", "sunburst"))), compatSunburstState(t), traverseTree(t.data, compatSunburstState);
			} else n === "graph" || n === "sankey" ? compatGraphFocus(t) : n === "map" && (t.mapType && !t.map && (process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("mapType", "map", "map"), t.map = t.mapType), t.mapLocation && (process$1.env.NODE_ENV !== "production" && deprecateLog("`mapLocation` is not used anymore."), defaults(t, t.mapLocation)));
			t.hoverAnimation != null && (t.emphasis = t.emphasis || {}, t.emphasis && t.emphasis.scale == null && (process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("hoverAnimation", "emphasis.scale"), t.emphasis.scale = t.hoverAnimation)), compatLayoutProperties(t);
		}
	}), t.dataRange && (t.visualMap = t.dataRange), each(COMPATITABLE_COMPONENTS, function(n) {
		var r = t[n];
		r && (isArray(r) || (r = [r]), each(r, function(t) {
			compatLayoutProperties(t);
		}));
	});
}
function dataStack$1(t) {
	var n = createHashMap();
	t.eachSeries(function(t) {
		var r = t.get("stack");
		if (r) {
			var a = n.get(r) || n.set(r, []), o = t.getData(), s = {
				stackResultDimension: o.getCalculationInfo("stackResultDimension"),
				stackedOverDimension: o.getCalculationInfo("stackedOverDimension"),
				stackedDimension: o.getCalculationInfo("stackedDimension"),
				stackedByDimension: o.getCalculationInfo("stackedByDimension"),
				isStackedByIndex: o.getCalculationInfo("isStackedByIndex"),
				data: o,
				seriesModel: t
			};
			if (!s.stackedDimension || !(s.isStackedByIndex || s.stackedByDimension)) return;
			a.length && o.setCalculationInfo("stackedOnSeries", a[a.length - 1].seriesModel), a.push(s);
		}
	}), n.each(calculateStack);
}
function calculateStack(t) {
	each(t, function(n, r) {
		var a = [], o = [NaN, NaN], s = [n.stackResultDimension, n.stackedOverDimension], c = n.data, l = n.isStackedByIndex, u = n.seriesModel.get("stackStrategy") || "samesign";
		c.modify(s, function(s, d, f) {
			var p = c.get(n.stackedDimension, f);
			if (isNaN(p)) return o;
			var h, g;
			l ? g = c.getRawIndex(f) : h = c.get(n.stackedByDimension, f);
			for (var _ = NaN, v = r - 1; v >= 0; v--) {
				var y = t[v];
				if (l || (g = y.data.rawIndexOf(y.stackedByDimension, h)), g >= 0) {
					var b = y.data.getByRawIndex(y.stackResultDimension, g);
					if (u === "all" || u === "positive" && b > 0 || u === "negative" && b < 0 || u === "samesign" && p >= 0 && b > 0 || u === "samesign" && p <= 0 && b < 0) {
						p = addSafe(p, b), _ = b;
						break;
					}
				}
			}
			return a[0] = p, a[1] = _, a;
		});
	});
}
init_dist$2();
var SourceImpl = function() {
	function t(t) {
		this.data = t.data || (t.sourceFormat === "keyedColumns" ? {} : []), this.sourceFormat = t.sourceFormat || "unknown", this.seriesLayoutBy = t.seriesLayoutBy || "column", this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
		var n = this.dimensionsDefine = t.dimensionsDefine;
		if (n) for (var r = 0; r < n.length; r++) {
			var a = n[r];
			a.type == null && guessOrdinal(this, r) === BE_ORDINAL.Must && (a.type = "ordinal");
		}
	}
	return t;
}();
function isSourceInstance(t) {
	return t instanceof SourceImpl;
}
function createSource(t, n, r) {
	r ||= detectSourceFormat(t);
	var a = n.seriesLayoutBy, o = determineSourceDimensions(t, r, a, n.sourceHeader, n.dimensions);
	return new SourceImpl({
		data: t,
		sourceFormat: r,
		seriesLayoutBy: a,
		dimensionsDefine: o.dimensionsDefine,
		startIndex: o.startIndex,
		dimensionsDetectedCount: o.dimensionsDetectedCount,
		metaRawOption: clone$1(n)
	});
}
function createSourceFromSeriesDataOption(t) {
	return new SourceImpl({
		data: t,
		sourceFormat: isTypedArray(t) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
	});
}
function cloneSourceShallow(t) {
	return new SourceImpl({
		data: t.data,
		sourceFormat: t.sourceFormat,
		seriesLayoutBy: t.seriesLayoutBy,
		dimensionsDefine: clone$1(t.dimensionsDefine),
		startIndex: t.startIndex,
		dimensionsDetectedCount: t.dimensionsDetectedCount
	});
}
function detectSourceFormat(t) {
	var n = SOURCE_FORMAT_UNKNOWN;
	if (isTypedArray(t)) n = SOURCE_FORMAT_TYPED_ARRAY;
	else if (isArray(t)) {
		t.length === 0 && (n = SOURCE_FORMAT_ARRAY_ROWS);
		for (var r = 0, a = t.length; r < a; r++) {
			var o = t[r];
			if (o != null) {
				if (isArray(o) || isTypedArray(o)) {
					n = SOURCE_FORMAT_ARRAY_ROWS;
					break;
				} else if (isObject(o)) {
					n = SOURCE_FORMAT_OBJECT_ROWS;
					break;
				}
			}
		}
	} else if (isObject(t)) {
		for (var s in t) if (hasOwn(t, s) && isArrayLike(t[s])) {
			n = SOURCE_FORMAT_KEYED_COLUMNS;
			break;
		}
	}
	return n;
}
function determineSourceDimensions(t, n, r, a, o) {
	var c, l;
	if (!t) return {
		dimensionsDefine: normalizeDimensionsOption(o),
		startIndex: l,
		dimensionsDetectedCount: c
	};
	if (n === "arrayRows") {
		var u = t;
		a === "auto" || a == null ? arrayRowsTravelFirst(function(t) {
			t != null && t !== "-" && (isString(t) ? l ??= 1 : l = 0);
		}, r, u, 10) : l = isNumber(a) ? a : a ? 1 : 0, !o && l === 1 && (o = [], arrayRowsTravelFirst(function(t, n) {
			o[n] = t == null ? "" : t + "";
		}, r, u, Infinity)), c = o ? o.length : r === "row" ? u.length : u[0] ? u[0].length : null;
	} else if (n === "objectRows") o ||= objectRowsCollectDimensions(t);
	else if (n === "keyedColumns") o || (o = [], each(t, function(t, n) {
		o.push(n);
	}));
	else if (n === "original") {
		var d = getDataItemValue(t[0]);
		c = isArray(d) && d.length || 1;
	} else n === "typedArray" && process$1.env.NODE_ENV !== "production" && assert(!!o, "dimensions must be given if data is TypedArray.");
	return {
		startIndex: l,
		dimensionsDefine: normalizeDimensionsOption(o),
		dimensionsDetectedCount: c
	};
}
function objectRowsCollectDimensions(t) {
	for (var n = 0, r; n < t.length && !(r = t[n++]););
	if (r) return keys(r);
}
function normalizeDimensionsOption(t) {
	if (t) {
		var n = createHashMap();
		return map(t, function(t, r) {
			t = isObject(t) ? t : { name: t };
			var a = {
				name: t.name,
				displayName: t.displayName,
				type: t.type
			};
			if (a.name == null) return a;
			a.name += "", a.displayName ??= a.name;
			var o = n.get(a.name);
			return o ? a.name += "-" + o.count++ : n.set(a.name, { count: 1 }), a;
		});
	}
}
function arrayRowsTravelFirst(t, n, r, a) {
	if (n === "row") for (var o = 0; o < r.length && o < a; o++) t(r[o] ? r[o][0] : null, o);
	else for (var s = r[0] || [], o = 0; o < s.length && o < a; o++) t(s[o], o);
}
function shouldRetrieveDataByName(t) {
	var n = t.sourceFormat;
	return n === "objectRows" || n === "keyedColumns";
}
init_dist$2();
var _a, _b, _c, providerMethods, mountMethods, DefaultDataProvider = function() {
	function t(t, n) {
		var r = isSourceInstance(t) ? t : createSourceFromSeriesDataOption(t);
		this._source = r;
		var a = this._data = r.data;
		if (r.sourceFormat === "typedArray") {
			if (process$1.env.NODE_ENV !== "production" && n == null) throw Error("Typed array data must specify dimension size");
			this._offset = 0, this._dimSize = n, this._data = a;
		}
		mountMethods(this, a, r);
	}
	return t.prototype.getSource = function() {
		return this._source;
	}, t.prototype.count = function() {
		return 0;
	}, t.prototype.getItem = function(t, n) {}, t.prototype.appendData = function(t) {}, t.prototype.clean = function() {}, t.protoInitialize = function() {
		var n = t.prototype;
		n.pure = !1, n.persistent = !0;
	}(), t.internalField = function() {
		var t;
		mountMethods = function(t, o, c) {
			var l = c.sourceFormat, u = c.seriesLayoutBy, d = c.startIndex, f = c.dimensionsDefine, p = providerMethods[getMethodMapKey(l, u)];
			process$1.env.NODE_ENV !== "production" && assert(p, "Invalide sourceFormat: " + l), extend(t, p), l === "typedArray" ? (t.getItem = n, t.count = a, t.fillStorage = r) : (t.getItem = bind(getRawSourceItemGetter(l, u), null, o, d, f), t.count = bind(getRawSourceDataCounter(l, u), null, o, d, f));
		};
		var n = function(t, n) {
			t -= this._offset, n ||= [];
			for (var r = this._data, a = this._dimSize, o = a * t, s = 0; s < a; s++) n[s] = r[o + s];
			return n;
		}, r = function(t, n, r, a) {
			for (var o = this._data, s = this._dimSize, c = 0; c < s; c++) {
				for (var l = a[c], u = l[0] == null ? Infinity : l[0], d = l[1] == null ? -Infinity : l[1], f = n - t, p = r[c], h = 0; h < f; h++) {
					var g = o[h * s + c];
					p[t + h] = g, g < u && (u = g), g > d && (d = g);
				}
				l[0] = u, l[1] = d;
			}
		}, a = function() {
			return this._data ? this._data.length / this._dimSize : 0;
		};
		providerMethods = (t = {}, t[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = {
			pure: !0,
			appendData: o
		}, t[SOURCE_FORMAT_ARRAY_ROWS + "_row"] = {
			pure: !0,
			appendData: function() {
				throw Error("Do not support appendData when set seriesLayoutBy: \"row\".");
			}
		}, t[SOURCE_FORMAT_OBJECT_ROWS] = {
			pure: !0,
			appendData: o
		}, t[SOURCE_FORMAT_KEYED_COLUMNS] = {
			pure: !0,
			appendData: function(t) {
				var n = this._data;
				each(t, function(t, r) {
					for (var a = n[r] || (n[r] = []), o = 0; o < (t || []).length; o++) a.push(t[o]);
				});
			}
		}, t[SOURCE_FORMAT_ORIGINAL] = { appendData: o }, t[SOURCE_FORMAT_TYPED_ARRAY] = {
			persistent: !1,
			pure: !0,
			appendData: function(t) {
				process$1.env.NODE_ENV !== "production" && assert(isTypedArray(t), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = t;
			},
			clean: function() {
				this._offset += this.count(), this._data = null;
			}
		}, t);
		function o(t) {
			for (var n = 0; n < t.length; n++) this._data.push(t[n]);
		}
	}(), t;
}(), getItemSimply = function(t, n, r, a) {
	return t[a];
}, rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(t, n, r, a) {
	return t[a + n];
}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_row"] = function(t, n, r, a, o) {
	a += n;
	for (var s = o || [], c = t, l = 0; l < c.length; l++) {
		var u = c[l];
		s[l] = u ? u[a] : null;
	}
	return s;
}, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function(t, n, r, a, o) {
	for (var c = o || [], l = 0; l < r.length; l++) {
		var u = r[l].name;
		if (process$1.env.NODE_ENV !== "production" && u == null) throw Error();
		var d = t[u];
		c[l] = d ? d[a] : null;
	}
	return c;
}, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);
function getRawSourceItemGetter(t, n) {
	var r = rawSourceItemGetterMap[getMethodMapKey(t, n)];
	return process$1.env.NODE_ENV !== "production" && assert(r, "Do not support get item on \"" + t + "\", \"" + n + "\"."), r;
}
var countSimply = function(t, n, r) {
	return t.length;
}, rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(t, n, r) {
	return Math.max(0, t.length - n);
}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_row"] = function(t, n, r) {
	var a = t[0];
	return a ? Math.max(0, a.length - n) : 0;
}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function(t, n, r) {
	var a = r[0].name;
	if (process$1.env.NODE_ENV !== "production" && a == null) throw Error();
	var o = t[a];
	return o ? o.length : 0;
}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);
function getRawSourceDataCounter(t, n) {
	var r = rawSourceDataCounterMap[getMethodMapKey(t, n)];
	return process$1.env.NODE_ENV !== "production" && assert(r, "Do not support count on \"" + t + "\", \"" + n + "\"."), r;
}
var getRawValueSimply = function(t, n, r) {
	return t[n];
}, rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function(t, n, r) {
	return t[r];
}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function(t, n, r) {
	var a = getDataItemValue(t);
	return a instanceof Array ? a[n] : a;
}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);
function getRawSourceValueGetter(t) {
	var n = rawSourceValueGetterMap[t];
	return process$1.env.NODE_ENV !== "production" && assert(n, "Do not support get value on \"" + t + "\"."), n;
}
function getMethodMapKey(t, n) {
	return t === "arrayRows" ? t + "_" + n : t;
}
function retrieveRawValue(t, n, r) {
	if (t) {
		var a = t.getRawDataItem(n);
		if (a != null) {
			var o = t.getStore(), s = o.getSource().sourceFormat;
			if (r != null) {
				var c = t.getDimensionIndex(r), l = o.getDimensionProperty(c);
				return getRawSourceValueGetter(s)(a, c, l);
			} else {
				var u = a;
				return s === "original" && (u = getDataItemValue(a)), u;
			}
		}
	}
}
init_dist$2();
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g, DataFormatMixin = function() {
	function t() {}
	return t.prototype.getDataParams = function(t, n) {
		var r = this.getData(n), a = this.getRawValue(t, n), o = r.getRawIndex(t), s = r.getName(t), c = r.getRawDataItem(t), l = r.getItemVisual(t, "style"), u = l && l[r.getItemVisual(t, "drawType") || "fill"], d = l && l.stroke, f = this.mainType, p = f === "series", h = r.userOutput && r.userOutput.get();
		return {
			componentType: f,
			componentSubType: this.subType,
			componentIndex: this.componentIndex,
			seriesType: p ? this.subType : null,
			seriesIndex: this.seriesIndex,
			seriesId: p ? this.id : null,
			seriesName: p ? this.name : null,
			name: s,
			dataIndex: o,
			data: c,
			dataType: n,
			value: a,
			color: u,
			borderColor: d,
			dimensionNames: h ? h.fullDimensions : null,
			encode: h ? h.encode : null,
			$vars: [
				"seriesName",
				"name",
				"value"
			]
		};
	}, t.prototype.getFormattedLabel = function(t, n, r, a, o, c) {
		n ||= "normal";
		var l = this.getData(r), u = this.getDataParams(t, r);
		if (c && (u.value = c.interpolatedValue), a != null && isArray(u.value) && (u.value = u.value[a]), o ||= l.getItemModel(t).get(n === "normal" ? ["label", "formatter"] : [
			n,
			"label",
			"formatter"
		]), isFunction(o)) return u.status = n, u.dimensionIndex = a, o(u);
		if (isString(o)) return formatTpl(o, u).replace(DIMENSION_LABEL_REG, function(n, r) {
			var a = r.length, o = r;
			o.charAt(0) === "[" && o.charAt(a - 1) === "]" && (o = +o.slice(1, a - 1), process$1.env.NODE_ENV !== "production" && isNaN(o) && error("Invalide label formatter: @" + r + ", only support @[0], @[1], @[2], ..."));
			var u = retrieveRawValue(l, t, o);
			if (c && isArray(c.interpolatedValue)) {
				var d = l.getDimensionIndex(o);
				d >= 0 && (u = c.interpolatedValue[d]);
			}
			return u == null ? "" : u + "";
		});
	}, t.prototype.getRawValue = function(t, n) {
		return retrieveRawValue(this.getData(n), t);
	}, t.prototype.formatTooltip = function(t, n, r) {}, t;
}();
function normalizeTooltipFormatResult(t) {
	var n, r;
	return isObject(t) ? t.type ? r = t : process$1.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + makePrintable(t)) : n = t, {
		text: n,
		frag: r
	};
}
init_dist$2();
function createTask(t) {
	return new Task(t);
}
var Task = function() {
	function t(t) {
		t ||= {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0;
	}
	return t.prototype.perform = function(t) {
		var n = this._upstream, r = t && t.skip;
		if (this._dirty && n) {
			var a = this.context;
			a.data = a.outputData = n.context.outputData;
		}
		this.__pipeline && (this.__pipeline.currentTask = this);
		var o;
		this._plan && !r && (o = this._plan(this.context));
		var c = f(this._modBy), l = this._modDataCount || 0, u = f(t && t.modBy), d = t && t.modDataCount || 0;
		(c !== u || l !== d) && (o = "reset");
		function f(t) {
			return !(t >= 1) && (t = 1), t;
		}
		var p;
		(this._dirty || o === "reset") && (this._dirty = !1, p = this._doReset(r)), this._modBy = u, this._modDataCount = d;
		var h = t && t.step;
		if (n ? (process$1.env.NODE_ENV !== "production" && assert(n._outputDueEnd != null), this._dueEnd = n._outputDueEnd) : (process$1.env.NODE_ENV !== "production" && assert(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : Infinity), this._progress) {
			var g = this._dueIndex, _ = Math.min(h == null ? Infinity : this._dueIndex + h, this._dueEnd);
			if (!r && (p || g < _)) {
				var v = this._progress;
				if (isArray(v)) for (var y = 0; y < v.length; y++) this._doProgress(v[y], g, _, u, d);
				else this._doProgress(v, g, _, u, d);
			}
			this._dueIndex = _;
			var b = this._settedOutputEnd == null ? _ : this._settedOutputEnd;
			process$1.env.NODE_ENV !== "production" && assert(b >= this._outputDueEnd), this._outputDueEnd = b;
		} else this._dueIndex = this._outputDueEnd = this._settedOutputEnd == null ? this._dueEnd : this._settedOutputEnd;
		return this.unfinished();
	}, t.prototype.dirty = function() {
		this._dirty = !0, this._onDirty && this._onDirty(this.context);
	}, t.prototype._doProgress = function(t, n, r, a, o) {
		iterator.reset(n, r, a, o), this._callingProgress = t, this._callingProgress({
			start: n,
			end: r,
			count: r - n,
			next: iterator.next
		}, this.context);
	}, t.prototype._doReset = function(t) {
		this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
		var n, r;
		!t && this._reset && (n = this._reset(this.context), n && n.progress && (r = n.forceFirstProgress, n = n.progress), isArray(n) && !n.length && (n = null)), this._progress = n, this._modBy = this._modDataCount = null;
		var a = this._downstream;
		return a && a.dirty(), r;
	}, t.prototype.unfinished = function() {
		return this._progress && this._dueIndex < this._dueEnd;
	}, t.prototype.pipe = function(t) {
		process$1.env.NODE_ENV !== "production" && assert(t && !t._disposed && t !== this), (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty());
	}, t.prototype.dispose = function() {
		this._disposed ||= (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, !0);
	}, t.prototype.getUpstream = function() {
		return this._upstream;
	}, t.prototype.getDownstream = function() {
		return this._downstream;
	}, t.prototype.setOutputEnd = function(t) {
		this._outputDueEnd = this._settedOutputEnd = t;
	}, t;
}(), iterator = function() {
	var t, n, r, a, o, s = { reset: function(u, d, f, p) {
		n = u, t = d, r = f, a = p, o = Math.ceil(a / r), s.next = r > 1 && a > 0 ? l : c;
	} };
	return s;
	function c() {
		return n < t ? n++ : null;
	}
	function l() {
		var s = n % o * r + Math.ceil(n / o), c = n >= t ? null : s < a ? s : n;
		return n++, c;
	}
}();
init_dist$2();
function parseDataValue(t, n) {
	var r = n && n.type;
	return r === "ordinal" ? t : (r === "time" && !isNumber(t) && t != null && t !== "-" && (t = +parseDate(t)), t == null || t === "" ? NaN : Number(t));
}
var valueParserMap = createHashMap({
	number: function(t) {
		return parseFloat(t);
	},
	time: function(t) {
		return +parseDate(t);
	},
	trim: function(t) {
		return isString(t) ? trim(t) : t;
	}
});
function getRawValueParser(t) {
	return valueParserMap.get(t);
}
var ORDER_COMPARISON_OP_MAP = {
	lt: function(t, n) {
		return t < n;
	},
	lte: function(t, n) {
		return t <= n;
	},
	gt: function(t, n) {
		return t > n;
	},
	gte: function(t, n) {
		return t >= n;
	}
}, FilterOrderComparator = function() {
	function t(t, n) {
		if (!isNumber(n)) {
			var r = "";
			process$1.env.NODE_ENV !== "production" && (r = "rvalue of \"<\", \">\", \"<=\", \">=\" can only be number in filter."), throwError(r);
		}
		this._opFn = ORDER_COMPARISON_OP_MAP[t], this._rvalFloat = numericToNumber(n);
	}
	return t.prototype.evaluate = function(t) {
		return isNumber(t) ? this._opFn(t, this._rvalFloat) : this._opFn(numericToNumber(t), this._rvalFloat);
	}, t;
}(), SortOrderComparator = function() {
	function t(t, n) {
		var r = t === "desc";
		this._resultLT = r ? 1 : -1, n ??= r ? "min" : "max", this._incomparable = n === "min" ? -Infinity : Infinity;
	}
	return t.prototype.evaluate = function(t, n) {
		var r = isNumber(t) ? t : numericToNumber(t), a = isNumber(n) ? n : numericToNumber(n), o = isNaN(r), s = isNaN(a);
		if (o && (r = this._incomparable), s && (a = this._incomparable), o && s) {
			var c = isString(t), l = isString(n);
			c && (r = l ? t : 0), l && (a = c ? n : 0);
		}
		return r < a ? this._resultLT : r > a ? -this._resultLT : 0;
	}, t;
}(), FilterEqualityComparator = function() {
	function t(t, n) {
		this._rval = n, this._isEQ = t, this._rvalTypeof = typeof n, this._rvalFloat = numericToNumber(n);
	}
	return t.prototype.evaluate = function(t) {
		var n = t === this._rval;
		if (!n) {
			var r = typeof t;
			r !== this._rvalTypeof && (r === "number" || this._rvalTypeof === "number") && (n = numericToNumber(t) === this._rvalFloat);
		}
		return this._isEQ ? n : !n;
	}, t;
}();
function createFilterComparator(t, n) {
	return t === "eq" || t === "ne" ? new FilterEqualityComparator(t === "eq", n) : hasOwn(ORDER_COMPARISON_OP_MAP, t) ? new FilterOrderComparator(t, n) : null;
}
init_dist$2();
var ExternalSource = function() {
	function t() {}
	return t.prototype.getRawData = function() {
		throw Error("not supported");
	}, t.prototype.getRawDataItem = function(t) {
		throw Error("not supported");
	}, t.prototype.cloneRawData = function() {}, t.prototype.getDimensionInfo = function(t) {}, t.prototype.cloneAllDimensionInfo = function() {}, t.prototype.count = function() {}, t.prototype.retrieveValue = function(t, n) {}, t.prototype.retrieveValueFromItem = function(t, n) {}, t.prototype.convertValue = function(t, n) {
		return parseDataValue(t, n);
	}, t;
}();
function createExternalSource(t, n) {
	var r = new ExternalSource(), a = t.data, o = r.sourceFormat = t.sourceFormat, c = t.startIndex, l = "";
	t.seriesLayoutBy !== "column" && (process$1.env.NODE_ENV !== "production" && (l = "`seriesLayoutBy` of upstream dataset can only be \"column\" in data transform."), throwError(l));
	var u = [], d = {}, f = t.dimensionsDefine;
	if (f) each(f, function(t, n) {
		var r = t.name, a = {
			index: n,
			name: r,
			displayName: t.displayName
		};
		if (u.push(a), r != null) {
			var o = "";
			hasOwn(d, r) && (process$1.env.NODE_ENV !== "production" && (o = "dimension name \"" + r + "\" duplicated."), throwError(o)), d[r] = a;
		}
	});
	else for (var p = 0; p < t.dimensionsDetectedCount; p++) u.push({ index: p });
	var h = getRawSourceItemGetter(o, SERIES_LAYOUT_BY_COLUMN);
	n.__isBuiltIn && (r.getRawDataItem = function(t) {
		return h(a, c, u, t);
	}, r.getRawData = bind(getRawData, null, t)), r.cloneRawData = bind(cloneRawData, null, t), r.count = bind(getRawSourceDataCounter(o, SERIES_LAYOUT_BY_COLUMN), null, a, c, u);
	var g = getRawSourceValueGetter(o);
	r.retrieveValue = function(t, n) {
		return _(h(a, c, u, t), n);
	};
	var _ = r.retrieveValueFromItem = function(t, n) {
		if (t != null) {
			var r = u[n];
			if (r) return g(t, n, r.name);
		}
	};
	return r.getDimensionInfo = bind(getDimensionInfo, null, u, d), r.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, u), r;
}
function getRawData(t) {
	var n = t.sourceFormat;
	if (!isSupportedSourceFormat(n)) {
		var r = "";
		process$1.env.NODE_ENV !== "production" && (r = "`getRawData` is not supported in source format " + n), throwError(r);
	}
	return t.data;
}
function cloneRawData(t) {
	var n = t.sourceFormat, r = t.data;
	if (!isSupportedSourceFormat(n)) {
		var a = "";
		process$1.env.NODE_ENV !== "production" && (a = "`cloneRawData` is not supported in source format " + n), throwError(a);
	}
	if (n === "arrayRows") {
		for (var o = [], c = 0, l = r.length; c < l; c++) o.push(r[c].slice());
		return o;
	} else if (n === "objectRows") {
		for (var o = [], c = 0, l = r.length; c < l; c++) o.push(extend({}, r[c]));
		return o;
	}
}
function getDimensionInfo(t, n, r) {
	if (r != null) {
		if (isNumber(r) || !isNaN(r) && !hasOwn(n, r)) return t[r];
		if (hasOwn(n, r)) return n[r];
	}
}
function cloneAllDimensionInfo(t) {
	return clone$1(t);
}
var externalTransformMap = createHashMap();
function registerExternalTransform(t) {
	t = clone$1(t);
	var n = t.type, r = "";
	n || (process$1.env.NODE_ENV !== "production" && (r = "Must have a `type` when `registerTransform`."), throwError(r));
	var a = n.split(":");
	a.length !== 2 && (process$1.env.NODE_ENV !== "production" && (r = "Name must include namespace like \"ns:regression\"."), throwError(r));
	var o = !1;
	a[0] === "echarts" && (n = a[1], o = !0), t.__isBuiltIn = o, externalTransformMap.set(n, t);
}
function applyDataTransform(t, n, r) {
	var a = normalizeToArray(t), o = a.length, c = "";
	o || (process$1.env.NODE_ENV !== "production" && (c = "If `transform` declared, it should at least contain one transform."), throwError(c));
	for (var l = 0, u = o; l < u; l++) {
		var d = a[l];
		n = applySingleDataTransform(d, n, r, o === 1 ? null : l), l !== u - 1 && (n.length = Math.max(n.length, 1));
	}
	return n;
}
function applySingleDataTransform(t, n, r, a) {
	var o = "";
	n.length || (process$1.env.NODE_ENV !== "production" && (o = "Must have at least one upstream dataset."), throwError(o)), isObject(t) || (process$1.env.NODE_ENV !== "production" && (o = "transform declaration must be an object rather than " + typeof t + "."), throwError(o));
	var c = t.type, l = externalTransformMap.get(c);
	l || (process$1.env.NODE_ENV !== "production" && (o = "Can not find transform on type \"" + c + "\"."), throwError(o));
	var u = map(n, function(t) {
		return createExternalSource(t, l);
	}), d = normalizeToArray(l.transform({
		upstream: u[0],
		upstreamList: u,
		config: clone$1(t.config)
	}));
	return process$1.env.NODE_ENV !== "production" && t.print && log(map(d, function(t) {
		var n = a == null ? "" : " === pipe index: " + a;
		return [
			"=== dataset index: " + r.datasetIndex + n + " ===",
			"- transform result data:",
			makePrintable(t.data),
			"- transform result dimensions:",
			makePrintable(t.dimensions)
		].join("\n");
	}).join("\n")), map(d, function(t, r) {
		var a = "";
		isObject(t) || (process$1.env.NODE_ENV !== "production" && (a = "A transform should not return some empty results."), throwError(a)), t.data || (process$1.env.NODE_ENV !== "production" && (a = "Transform result data should be not be null or undefined"), throwError(a)), isSupportedSourceFormat(detectSourceFormat(t.data)) || (process$1.env.NODE_ENV !== "production" && (a = "Transform result data should be array rows or object rows."), throwError(a));
		var o, c = n[0];
		if (c && r === 0 && !t.dimensions) {
			var l = c.startIndex;
			l && (t.data = c.data.slice(0, l).concat(t.data)), o = {
				seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
				sourceHeader: l,
				dimensions: c.metaRawOption.dimensions
			};
		} else o = {
			seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
			sourceHeader: 0,
			dimensions: t.dimensions
		};
		return createSource(t.data, o, null);
	});
}
function isSupportedSourceFormat(t) {
	return t === "arrayRows" || t === "objectRows";
}
init_dist$2();
var UNDEFINED = "undefined", CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array, CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array, CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array, CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array, dataCtors = {
	float: CtorFloat64Array,
	int: CtorInt32Array,
	ordinal: Array,
	number: Array,
	time: CtorFloat64Array
}, defaultDimValueGetters;
function getIndicesCtor(t) {
	return t > 65535 ? CtorUint32Array : CtorUint16Array;
}
function getInitialExtent() {
	return [Infinity, -Infinity];
}
function cloneChunk(t) {
	var n = t.constructor;
	return n === Array ? t.slice() : new n(t);
}
function prepareStore(t, n, r, a, o) {
	var s = dataCtors[r || "float"];
	if (o) {
		var c = t[n], l = c && c.length;
		if (l !== a) {
			for (var u = new s(a), d = 0; d < l; d++) u[d] = c[d];
			t[n] = u;
		}
	} else t[n] = new s(a);
}
var DataStore_default = function() {
	function t() {
		this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = createHashMap();
	}
	return t.prototype.initData = function(t, n, r) {
		process$1.env.NODE_ENV !== "production" && assert(isFunction(t.getItem) && isFunction(t.count), "Invalid data provider."), this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
		var a = t.getSource(), o = this.defaultDimValueGetter = defaultDimValueGetters[a.sourceFormat];
		this._dimValueGetter = r || o, this._rawExtent = [];
		var c = shouldRetrieveDataByName(a);
		this._dimensions = map(n, function(t) {
			return process$1.env.NODE_ENV !== "production" && c && assert(t.property != null), {
				type: t.type,
				property: t.property
			};
		}), this._initDataFromProvider(0, t.count());
	}, t.prototype.getProvider = function() {
		return this._provider;
	}, t.prototype.getSource = function() {
		return this._provider.getSource();
	}, t.prototype.ensureCalculationDimension = function(t, n) {
		var r = this._calcDimNameToIdx, a = this._dimensions, o = r.get(t);
		if (o != null) {
			if (a[o].type === n) return o;
		} else o = a.length;
		return a[o] = { type: n }, r.set(t, o), this._chunks[o] = new dataCtors[n || "float"](this._rawCount), this._rawExtent[o] = getInitialExtent(), o;
	}, t.prototype.collectOrdinalMeta = function(t, n) {
		var r = this._chunks[t], a = this._dimensions[t], o = this._rawExtent, s = a.ordinalOffset || 0, c = r.length;
		s === 0 && (o[t] = getInitialExtent());
		for (var l = o[t], u = s; u < c; u++) {
			var d = r[u] = n.parseAndCollect(r[u]);
			isNaN(d) || (l[0] = Math.min(d, l[0]), l[1] = Math.max(d, l[1]));
		}
		a.ordinalMeta = n, a.ordinalOffset = c, a.type = "ordinal";
	}, t.prototype.getOrdinalMeta = function(t) {
		return this._dimensions[t].ordinalMeta;
	}, t.prototype.getDimensionProperty = function(t) {
		var n = this._dimensions[t];
		return n && n.property;
	}, t.prototype.appendData = function(t) {
		process$1.env.NODE_ENV !== "production" && assert(!this._indices, "appendData can only be called on raw data.");
		var n = this._provider, r = this.count();
		n.appendData(t);
		var a = n.count();
		return n.persistent || (a += r), r < a && this._initDataFromProvider(r, a, !0), [r, a];
	}, t.prototype.appendValues = function(t, n) {
		for (var r = this._chunks, a = this._dimensions, o = a.length, s = this._rawExtent, c = this.count(), l = c + Math.max(t.length, n || 0), u = 0; u < o; u++) {
			var d = a[u];
			prepareStore(r, u, d.type, l, !0);
		}
		for (var f = [], p = c; p < l; p++) for (var h = p - c, g = 0; g < o; g++) {
			var d = a[g], _ = defaultDimValueGetters.arrayRows.call(this, t[h] || f, d.property, h, g);
			r[g][p] = _;
			var v = s[g];
			_ < v[0] && (v[0] = _), _ > v[1] && (v[1] = _);
		}
		return this._rawCount = this._count = l, {
			start: c,
			end: l
		};
	}, t.prototype._initDataFromProvider = function(t, n, r) {
		for (var a = this._provider, o = this._chunks, s = this._dimensions, c = s.length, l = this._rawExtent, u = map(s, function(t) {
			return t.property;
		}), d = 0; d < c; d++) {
			var f = s[d];
			l[d] || (l[d] = getInitialExtent()), prepareStore(o, d, f.type, n, r);
		}
		if (a.fillStorage) a.fillStorage(t, n, o, l);
		else for (var p = [], h = t; h < n; h++) {
			p = a.getItem(h, p);
			for (var g = 0; g < c; g++) {
				var _ = o[g], v = this._dimValueGetter(p, u[g], h, g);
				_[h] = v;
				var y = l[g];
				v < y[0] && (y[0] = v), v > y[1] && (y[1] = v);
			}
		}
		!a.persistent && a.clean && a.clean(), this._rawCount = this._count = n, this._extent = [];
	}, t.prototype.count = function() {
		return this._count;
	}, t.prototype.get = function(t, n) {
		if (!(n >= 0 && n < this._count)) return NaN;
		var r = this._chunks[t];
		return r ? r[this.getRawIndex(n)] : NaN;
	}, t.prototype.getValues = function(t, n) {
		var r = [], a = [];
		if (n == null) {
			n = t, t = [];
			for (var o = 0; o < this._dimensions.length; o++) a.push(o);
		} else a = t;
		for (var o = 0, s = a.length; o < s; o++) r.push(this.get(a[o], n));
		return r;
	}, t.prototype.getByRawIndex = function(t, n) {
		if (!(n >= 0 && n < this._rawCount)) return NaN;
		var r = this._chunks[t];
		return r ? r[n] : NaN;
	}, t.prototype.getSum = function(t) {
		var n = this._chunks[t], r = 0;
		if (n) for (var a = 0, o = this.count(); a < o; a++) {
			var s = this.get(t, a);
			isNaN(s) || (r += s);
		}
		return r;
	}, t.prototype.getMedian = function(t) {
		var n = [];
		this.each([t], function(t) {
			isNaN(t) || n.push(t);
		});
		var r = n.sort(function(t, n) {
			return t - n;
		}), a = this.count();
		return a === 0 ? 0 : a % 2 == 1 ? r[(a - 1) / 2] : (r[a / 2] + r[a / 2 - 1]) / 2;
	}, t.prototype.indexOfRawIndex = function(t) {
		if (t >= this._rawCount || t < 0) return -1;
		if (!this._indices) return t;
		var n = this._indices, r = n[t];
		if (r != null && r < this._count && r === t) return t;
		for (var a = 0, o = this._count - 1; a <= o;) {
			var s = (a + o) / 2 | 0;
			if (n[s] < t) a = s + 1;
			else if (n[s] > t) o = s - 1;
			else return s;
		}
		return -1;
	}, t.prototype.indicesOfNearest = function(t, n, r) {
		var a = this._chunks[t], o = [];
		if (!a) return o;
		r ??= Infinity;
		for (var s = Infinity, c = -1, l = 0, u = 0, d = this.count(); u < d; u++) {
			var f = n - a[this.getRawIndex(u)], p = Math.abs(f);
			p <= r && ((p < s || p === s && f >= 0 && c < 0) && (s = p, c = f, l = 0), f === c && (o[l++] = u));
		}
		return o.length = l, o;
	}, t.prototype.getIndices = function() {
		var t, n = this._indices;
		if (n) {
			var r = n.constructor, a = this._count;
			if (r === Array) {
				t = new r(a);
				for (var o = 0; o < a; o++) t[o] = n[o];
			} else t = new r(n.buffer, 0, a);
		} else {
			var r = getIndicesCtor(this._rawCount);
			t = new r(this.count());
			for (var o = 0; o < t.length; o++) t[o] = o;
		}
		return t;
	}, t.prototype.filter = function(t, n) {
		if (!this._count) return this;
		for (var r = this.clone(), a = r.count(), o = new (getIndicesCtor(r._rawCount))(a), s = [], c = t.length, l = 0, u = t[0], d = r._chunks, f = 0; f < a; f++) {
			var p = void 0, h = r.getRawIndex(f);
			if (c === 0) p = n(f);
			else if (c === 1) {
				var g = d[u][h];
				p = n(g, f);
			} else {
				for (var _ = 0; _ < c; _++) s[_] = d[t[_]][h];
				s[_] = f, p = n.apply(null, s);
			}
			p && (o[l++] = h);
		}
		return l < a && (r._indices = o), r._count = l, r._extent = [], r._updateGetRawIdx(), r;
	}, t.prototype.selectRange = function(t) {
		var n = this.clone(), r = n._count;
		if (!r) return this;
		var a = keys(t), o = a.length;
		if (!o) return this;
		var s = n.count(), c = new (getIndicesCtor(n._rawCount))(s), l = 0, u = a[0], d = t[u][0], f = t[u][1], p = n._chunks, h = !1;
		if (!n._indices) {
			var g = 0;
			if (o === 1) {
				for (var _ = p[a[0]], v = 0; v < r; v++) {
					var y = _[v];
					(y >= d && y <= f || isNaN(y)) && (c[l++] = g), g++;
				}
				h = !0;
			} else if (o === 2) {
				for (var _ = p[a[0]], b = p[a[1]], x = t[a[1]][0], S = t[a[1]][1], v = 0; v < r; v++) {
					var y = _[v], C = b[v];
					(y >= d && y <= f || isNaN(y)) && (C >= x && C <= S || isNaN(C)) && (c[l++] = g), g++;
				}
				h = !0;
			}
		}
		if (!h) if (o === 1) for (var v = 0; v < s; v++) {
			var w = n.getRawIndex(v), y = p[a[0]][w];
			(y >= d && y <= f || isNaN(y)) && (c[l++] = w);
		}
		else for (var v = 0; v < s; v++) {
			for (var T = !0, w = n.getRawIndex(v), E = 0; E < o; E++) {
				var D = a[E], y = p[D][w];
				(y < t[D][0] || y > t[D][1]) && (T = !1);
			}
			T && (c[l++] = n.getRawIndex(v));
		}
		return l < s && (n._indices = c), n._count = l, n._extent = [], n._updateGetRawIdx(), n;
	}, t.prototype.map = function(t, n) {
		var r = this.clone(t);
		return this._updateDims(r, t, n), r;
	}, t.prototype.modify = function(t, n) {
		this._updateDims(this, t, n);
	}, t.prototype._updateDims = function(t, n, r) {
		for (var a = t._chunks, o = [], s = n.length, c = t.count(), l = [], u = t._rawExtent, d = 0; d < n.length; d++) u[n[d]] = getInitialExtent();
		for (var f = 0; f < c; f++) {
			for (var p = t.getRawIndex(f), h = 0; h < s; h++) l[h] = a[n[h]][p];
			l[s] = f;
			var g = r && r.apply(null, l);
			if (g != null) {
				typeof g != "object" && (o[0] = g, g = o);
				for (var d = 0; d < g.length; d++) {
					var _ = n[d], v = g[d], y = u[_], b = a[_];
					b && (b[p] = v), v < y[0] && (y[0] = v), v > y[1] && (y[1] = v);
				}
			}
		}
	}, t.prototype.lttbDownSample = function(t, n) {
		var r = this.clone([t], !0), a = r._chunks[t], o = this.count(), s = 0, c = Math.floor(1 / n), l = this.getRawIndex(0), u, d, f, p = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(o / c) + 2) * 2, o));
		p[s++] = l;
		for (var h = 1; h < o - 1; h += c) {
			for (var g = Math.min(h + c, o - 1), _ = Math.min(h + c * 2, o), v = (_ + g) / 2, y = 0, b = g; b < _; b++) {
				var x = this.getRawIndex(b), S = a[x];
				isNaN(S) || (y += S);
			}
			y /= _ - g;
			var C = h, w = Math.min(h + c, o), T = h - 1, E = a[l];
			u = -1, f = C;
			for (var D = -1, O = 0, b = C; b < w; b++) {
				var x = this.getRawIndex(b), S = a[x];
				if (isNaN(S)) {
					O++, D < 0 && (D = x);
					continue;
				}
				d = Math.abs((T - v) * (S - E) - (T - b) * (y - E)), d > u && (u = d, f = x);
			}
			O > 0 && O < w - C && (p[s++] = Math.min(D, f), f = Math.max(D, f)), p[s++] = f, l = f;
		}
		return p[s++] = this.getRawIndex(o - 1), r._count = s, r._indices = p, r.getRawIndex = this._getRawIdx, r;
	}, t.prototype.minmaxDownSample = function(t, n) {
		for (var r = this.clone([t], !0), a = r._chunks, o = Math.floor(1 / n), s = a[t], c = this.count(), l = new (getIndicesCtor(this._rawCount))(Math.ceil(c / o) * 2), u = 0, d = 0; d < c; d += o) {
			var f = d, p = s[this.getRawIndex(f)], h = d, g = s[this.getRawIndex(h)], _ = o;
			d + o > c && (_ = c - d);
			for (var v = 0; v < _; v++) {
				var y = s[this.getRawIndex(d + v)];
				y < p && (p = y, f = d + v), y > g && (g = y, h = d + v);
			}
			var b = this.getRawIndex(f), x = this.getRawIndex(h);
			f < h ? (l[u++] = b, l[u++] = x) : (l[u++] = x, l[u++] = b);
		}
		return r._count = u, r._indices = l, r._updateGetRawIdx(), r;
	}, t.prototype.downSample = function(t, n, r, a) {
		for (var o = this.clone([t], !0), s = o._chunks, c = [], l = Math.floor(1 / n), u = s[t], d = this.count(), f = o._rawExtent[t] = getInitialExtent(), p = new (getIndicesCtor(this._rawCount))(Math.ceil(d / l)), h = 0, g = 0; g < d; g += l) {
			l > d - g && (l = d - g, c.length = l);
			for (var _ = 0; _ < l; _++) c[_] = u[this.getRawIndex(g + _)];
			var v = r(c), y = this.getRawIndex(Math.min(g + a(c, v) || 0, d - 1));
			u[y] = v, v < f[0] && (f[0] = v), v > f[1] && (f[1] = v), p[h++] = y;
		}
		return o._count = h, o._indices = p, o._updateGetRawIdx(), o;
	}, t.prototype.each = function(t, n) {
		if (this._count) for (var r = t.length, a = this._chunks, o = 0, s = this.count(); o < s; o++) {
			var c = this.getRawIndex(o);
			switch (r) {
				case 0:
					n(o);
					break;
				case 1:
					n(a[t[0]][c], o);
					break;
				case 2:
					n(a[t[0]][c], a[t[1]][c], o);
					break;
				default:
					for (var l = 0, u = []; l < r; l++) u[l] = a[t[l]][c];
					u[l] = o, n.apply(null, u);
			}
		}
	}, t.prototype.getDataExtent = function(t) {
		var n = this._chunks[t], r = getInitialExtent();
		if (!n) return r;
		var a = this.count(), o = !this._indices, s;
		if (o) return this._rawExtent[t].slice();
		if (s = this._extent[t], s) return s.slice();
		s = r;
		for (var c = s[0], l = s[1], u = 0; u < a; u++) {
			var d = n[this.getRawIndex(u)];
			d < c && (c = d), d > l && (l = d);
		}
		return s = [c, l], this._extent[t] = s, s;
	}, t.prototype.getRawDataItem = function(t) {
		var n = this.getRawIndex(t);
		if (this._provider.persistent) return this._provider.getItem(n);
		for (var r = [], a = this._chunks, o = 0; o < a.length; o++) r.push(a[o][n]);
		return r;
	}, t.prototype.clone = function(n, r) {
		var a = new t(), o = this._chunks, s = n && reduce(n, function(t, n) {
			return t[n] = !0, t;
		}, {});
		if (s) for (var c = 0; c < o.length; c++) a._chunks[c] = s[c] ? cloneChunk(o[c]) : o[c];
		else a._chunks = o;
		return this._copyCommonProps(a), r || (a._indices = this._cloneIndices()), a._updateGetRawIdx(), a;
	}, t.prototype._copyCommonProps = function(t) {
		t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = clone$1(this._extent), t._rawExtent = clone$1(this._rawExtent);
	}, t.prototype._cloneIndices = function() {
		if (this._indices) {
			var t = this._indices.constructor, n = void 0;
			if (t === Array) {
				var r = this._indices.length;
				n = new t(r);
				for (var a = 0; a < r; a++) n[a] = this._indices[a];
			} else n = new t(this._indices);
			return n;
		}
		return null;
	}, t.prototype._getRawIdxIdentity = function(t) {
		return t;
	}, t.prototype._getRawIdx = function(t) {
		return t < this._count && t >= 0 ? this._indices[t] : -1;
	}, t.prototype._updateGetRawIdx = function() {
		this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
	}, t.internalField = function() {
		function t(t, n, r, a) {
			return parseDataValue(t[a], this._dimensions[a]);
		}
		defaultDimValueGetters = {
			arrayRows: t,
			objectRows: function(t, n, r, a) {
				return parseDataValue(t[n], this._dimensions[a]);
			},
			keyedColumns: t,
			original: function(t, n, r, a) {
				var o = t && (t.value == null ? t : t.value);
				return parseDataValue(o instanceof Array ? o[a] : o, this._dimensions[a]);
			},
			typedArray: function(t, n, r, a) {
				return t[a];
			}
		};
	}(), t;
}();
init_dist$2();
var SourceManager = function() {
	function t(t) {
		this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = t;
	}
	return t.prototype.dirty = function() {
		this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
	}, t.prototype._setLocalSource = function(t, n) {
		this._sourceList = t, this._upstreamSignList = n, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
	}, t.prototype._getVersionSign = function() {
		return this._sourceHost.uid + "_" + this._versionSignBase;
	}, t.prototype.prepareSource = function() {
		this._isDirty() && (this._createSource(), this._dirty = !1);
	}, t.prototype._createSource = function() {
		this._setLocalSource([], []);
		var t = this._sourceHost, n = this._getUpstreamSourceManagers(), r = !!n.length, a, o;
		if (isSeries(t)) {
			var c = t, l = void 0, u = void 0, d = void 0;
			if (r) {
				var f = n[0];
				f.prepareSource(), d = f.getSource(), l = d.data, u = d.sourceFormat, o = [f._getVersionSign()];
			} else l = c.get("data", !0), u = isTypedArray(l) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL, o = [];
			var p = this._getSourceMetaRawOption() || {}, h = d && d.metaRawOption || {}, g = retrieve2(p.seriesLayoutBy, h.seriesLayoutBy) || null, _ = retrieve2(p.sourceHeader, h.sourceHeader), v = retrieve2(p.dimensions, h.dimensions);
			a = g !== h.seriesLayoutBy || !!_ != !!h.sourceHeader || v ? [createSource(l, {
				seriesLayoutBy: g,
				sourceHeader: _,
				dimensions: v
			}, u)] : [];
		} else {
			var y = t;
			if (r) {
				var b = this._applyTransform(n);
				a = b.sourceList, o = b.upstreamSignList;
			} else a = [createSource(y.get("source", !0), this._getSourceMetaRawOption(), null)], o = [];
		}
		process$1.env.NODE_ENV !== "production" && assert(a && o), this._setLocalSource(a, o);
	}, t.prototype._applyTransform = function(t) {
		var n = this._sourceHost, r = n.get("transform", !0), a = n.get("fromTransformResult", !0);
		if (process$1.env.NODE_ENV !== "production" && assert(a != null || r != null), a != null) {
			var o = "";
			t.length !== 1 && (process$1.env.NODE_ENV !== "production" && (o = "When using `fromTransformResult`, there should be only one upstream dataset"), doThrow(o));
		}
		var c, l = [], u = [];
		return each(t, function(t) {
			t.prepareSource();
			var n = t.getSource(a || 0), r = "";
			a != null && !n && (process$1.env.NODE_ENV !== "production" && (r = "Can not retrieve result by `fromTransformResult`: " + a), doThrow(r)), l.push(n), u.push(t._getVersionSign());
		}), r ? c = applyDataTransform(r, l, { datasetIndex: n.componentIndex }) : a != null && (c = [cloneSourceShallow(l[0])]), {
			sourceList: c,
			upstreamSignList: u
		};
	}, t.prototype._isDirty = function() {
		if (this._dirty) return !0;
		for (var t = this._getUpstreamSourceManagers(), n = 0; n < t.length; n++) {
			var r = t[n];
			if (r._isDirty() || this._upstreamSignList[n] !== r._getVersionSign()) return !0;
		}
	}, t.prototype.getSource = function(t) {
		t ||= 0;
		var n = this._sourceList[t];
		if (!n) {
			var r = this._getUpstreamSourceManagers();
			return r[0] && r[0].getSource(t);
		}
		return n;
	}, t.prototype.getSharedDataStore = function(t) {
		process$1.env.NODE_ENV !== "production" && assert(isSeries(this._sourceHost), "Can only call getDataStore on series source manager.");
		var n = t.makeStoreSchema();
		return this._innerGetDataStore(n.dimensions, t.source, n.hash);
	}, t.prototype._innerGetDataStore = function(t, n, r) {
		var a = 0, o = this._storeList, s = o[a];
		s ||= o[a] = {};
		var c = s[r];
		if (!c) {
			var l = this._getUpstreamSourceManagers()[0];
			isSeries(this._sourceHost) && l ? c = l._innerGetDataStore(t, n, r) : (c = new DataStore_default(), c.initData(new DefaultDataProvider(n, t.length), t)), s[r] = c;
		}
		return c;
	}, t.prototype._getUpstreamSourceManagers = function() {
		var t = this._sourceHost;
		if (isSeries(t)) {
			var n = querySeriesUpstreamDatasetModel(t);
			return n ? [n.getSourceManager()] : [];
		} else return map(queryDatasetUpstreamDatasetModels(t), function(t) {
			return t.getSourceManager();
		});
	}, t.prototype._getSourceMetaRawOption = function() {
		var t = this._sourceHost, n, r, a;
		if (isSeries(t)) n = t.get("seriesLayoutBy", !0), r = t.get("sourceHeader", !0), a = t.get("dimensions", !0);
		else if (!this._getUpstreamSourceManagers().length) {
			var o = t;
			n = o.get("seriesLayoutBy", !0), r = o.get("sourceHeader", !0), a = o.get("dimensions", !0);
		}
		return {
			seriesLayoutBy: n,
			sourceHeader: r,
			dimensions: a
		};
	}, t;
}();
function disableTransformOptionMerge(t) {
	t.option.transform && setAsPrimitive(t.option.transform);
}
function isSeries(t) {
	return t.mainType === "series";
}
function doThrow(t) {
	throw Error(t);
}
init_dist$2();
var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
function getTooltipLineHeight(t) {
	var n = t.lineHeight;
	return n == null ? TOOLTIP_LINE_HEIGHT_CSS : "line-height:" + encodeHTML(n + "") + "px";
}
function getTooltipTextStyle(t, n) {
	var r = t.color || "#6e7079", a = t.fontSize || 12, o = t.fontWeight || "400", s = t.color || "#464646", c = t.fontSize || 14, l = t.fontWeight || "900";
	return n === "html" ? {
		nameStyle: "font-size:" + encodeHTML(a + "") + "px;color:" + encodeHTML(r) + ";font-weight:" + encodeHTML(o + ""),
		valueStyle: "font-size:" + encodeHTML(c + "") + "px;color:" + encodeHTML(s) + ";font-weight:" + encodeHTML(l + "")
	} : {
		nameStyle: {
			fontSize: a,
			fill: r,
			fontWeight: o
		},
		valueStyle: {
			fontSize: c,
			fill: s,
			fontWeight: l
		}
	};
}
var HTML_GAPS = [
	0,
	10,
	20,
	30
], RICH_TEXT_GAPS = [
	"",
	"\n",
	"\n\n",
	"\n\n\n"
];
function createTooltipMarkup(t, n) {
	return n.type = t, n;
}
function isSectionFragment(t) {
	return t.type === "section";
}
function getBuilder(t) {
	return isSectionFragment(t) ? buildSection : buildNameValue;
}
function getBlockGapLevel(t) {
	if (isSectionFragment(t)) {
		var n = 0, r = t.blocks.length, a = r > 1 || r > 0 && !t.noHeader;
		return each(t.blocks, function(t) {
			var r = getBlockGapLevel(t);
			r >= n && (n = r + +(a && (!r || isSectionFragment(t) && !t.noHeader)));
		}), n;
	}
	return 0;
}
function buildSection(t, n, r, a) {
	var o = n.noHeader, s = getGap(getBlockGapLevel(n)), c = [], l = n.blocks || [];
	assert(!l || isArray(l)), l ||= [];
	var u = t.orderMode;
	if (n.sortBlocks && u) {
		l = l.slice();
		var d = {
			valueAsc: "asc",
			valueDesc: "desc"
		};
		if (hasOwn(d, u)) {
			var f = new SortOrderComparator(d[u], null);
			l.sort(function(t, n) {
				return f.evaluate(t.sortParam, n.sortParam);
			});
		} else u === "seriesDesc" && l.reverse();
	}
	each(l, function(r, o) {
		var l = n.valueFormatter, u = getBuilder(r)(l ? extend(extend({}, t), { valueFormatter: l }) : t, r, o > 0 ? s.html : 0, a);
		u != null && c.push(u);
	});
	var p = t.renderMode === "richText" ? c.join(s.richText) : wrapBlockHTML(a, c.join(""), o ? r : s.html);
	if (o) return p;
	var h = makeValueReadable(n.header, "ordinal", t.useUTC), g = getTooltipTextStyle(a, t.renderMode).nameStyle, _ = getTooltipLineHeight(a);
	return t.renderMode === "richText" ? wrapInlineNameRichText(t, h, g) + s.richText + p : wrapBlockHTML(a, "<div style=\"" + g + ";" + _ + ";\">" + encodeHTML(h) + "</div>" + p, r);
}
function buildNameValue(t, n, r, a) {
	var o = t.renderMode, s = n.noName, c = n.noValue, l = !n.markerType, u = n.name, d = t.useUTC, f = n.valueFormatter || t.valueFormatter || function(t) {
		return t = isArray(t) ? t : [t], map(t, function(t, n) {
			return makeValueReadable(t, isArray(g) ? g[n] : g, d);
		});
	};
	if (!(s && c)) {
		var p = l ? "" : t.markupStyleCreator.makeTooltipMarker(n.markerType, n.markerColor || "#333", o), h = s ? "" : makeValueReadable(u, "ordinal", d), g = n.valueType, _ = c ? [] : f(n.value, n.dataIndex), v = !l || !s, y = !l && s, b = getTooltipTextStyle(a, o), x = b.nameStyle, S = b.valueStyle;
		return o === "richText" ? (l ? "" : p) + (s ? "" : wrapInlineNameRichText(t, h, x)) + (c ? "" : wrapInlineValueRichText(t, _, v, y, S)) : wrapBlockHTML(a, (l ? "" : p) + (s ? "" : wrapInlineNameHTML(h, !l, x)) + (c ? "" : wrapInlineValueHTML(_, v, y, S)), r);
	}
}
function buildTooltipMarkup(t, n, r, a, o, s) {
	if (t) return getBuilder(t)({
		useUTC: o,
		renderMode: r,
		orderMode: a,
		markupStyleCreator: n,
		valueFormatter: t.valueFormatter
	}, t, 0, s);
}
function getGap(t) {
	return {
		html: HTML_GAPS[t],
		richText: RICH_TEXT_GAPS[t]
	};
}
function wrapBlockHTML(t, n, r) {
	var a = "<div style=\"clear:both\"></div>", o = "margin: " + r + "px 0 0", s = getTooltipLineHeight(t);
	return "<div style=\"" + o + ";" + s + ";\">" + n + a + "</div>";
}
function wrapInlineNameHTML(t, n, r) {
	var a = n ? "margin-left:2px" : "";
	return "<span style=\"" + r + ";" + a + "\">" + encodeHTML(t) + "</span>";
}
function wrapInlineValueHTML(t, n, r, a) {
	var o = n ? "float:right;margin-left:" + (r ? "10px" : "20px") : "";
	return t = isArray(t) ? t : [t], "<span style=\"" + o + ";" + a + "\">" + map(t, function(t) {
		return encodeHTML(t);
	}).join("&nbsp;&nbsp;") + "</span>";
}
function wrapInlineNameRichText(t, n, r) {
	return t.markupStyleCreator.wrapRichTextStyle(n, r);
}
function wrapInlineValueRichText(t, n, r, a, o) {
	var s = [o], c = a ? 10 : 20;
	return r && s.push({
		padding: [
			0,
			0,
			0,
			c
		],
		align: "right"
	}), t.markupStyleCreator.wrapRichTextStyle(isArray(n) ? n.join("  ") : n, s);
}
function retrieveVisualColorForTooltipMarker(t, n) {
	var r = t.getData().getItemVisual(n, "style")[t.visualDrawType];
	return convertToColorString(r);
}
function getPaddingFromTooltipModel(t, n) {
	return t.get("padding") ?? (n === "richText" ? [8, 10] : 10);
}
var TooltipMarkupStyleCreator = function() {
	function t() {
		this.richTextStyles = {}, this._nextStyleNameId = getRandomIdBase();
	}
	return t.prototype._generateStyleName = function() {
		return "__EC_aUTo_" + this._nextStyleNameId++;
	}, t.prototype.makeTooltipMarker = function(t, n, r) {
		var a = r === "richText" ? this._generateStyleName() : null, o = getTooltipMarker({
			color: n,
			type: t,
			renderMode: r,
			markerId: a
		});
		return isString(o) ? o : (process$1.env.NODE_ENV !== "production" && assert(a), this.richTextStyles[a] = o.style, o.content);
	}, t.prototype.wrapRichTextStyle = function(t, n) {
		var r = {};
		isArray(n) ? each(n, function(t) {
			return extend(r, t);
		}) : extend(r, n);
		var a = this._generateStyleName();
		return this.richTextStyles[a] = r, "{" + a + "|" + t + "}";
	}, t;
}();
function defaultSeriesFormatTooltip(t) {
	var n = t.series, r = t.dataIndex, a = t.multipleSeries, o = n.getData(), s = o.mapDimensionsAll("defaultedTooltip"), c = s.length, l = n.getRawValue(r), u = isArray(l), d = retrieveVisualColorForTooltipMarker(n, r), f, p, h, g;
	if (c > 1 || u && !c) {
		var _ = formatTooltipArrayValue(l, n, r, s, d);
		f = _.inlineValues, p = _.inlineValueTypes, h = _.blocks, g = _.inlineValues[0];
	} else if (c) {
		var v = o.getDimensionInfo(s[0]);
		g = f = retrieveRawValue(o, r, s[0]), p = v.type;
	} else g = f = u ? l[0] : l;
	var y = isNameSpecified(n), b = y && n.name || "", x = o.getName(r), S = a ? b : x;
	return createTooltipMarkup("section", {
		header: b,
		noHeader: a || !y,
		sortParam: g,
		blocks: [createTooltipMarkup("nameValue", {
			markerType: "item",
			markerColor: d,
			name: S,
			noName: !trim(S),
			value: f,
			valueType: p,
			dataIndex: r
		})].concat(h || [])
	});
}
function formatTooltipArrayValue(t, n, r, a, o) {
	var s = n.getData(), c = reduce(t, function(t, n, r) {
		var a = s.getDimensionInfo(r);
		return t ||= a && a.tooltip !== !1 && a.displayName != null;
	}, !1), l = [], u = [], d = [];
	a.length ? each(a, function(t) {
		f(retrieveRawValue(s, r, t), t);
	}) : each(t, f);
	function f(t, n) {
		var r = s.getDimensionInfo(n);
		!r || r.otherDims.tooltip === !1 || (c ? d.push(createTooltipMarkup("nameValue", {
			markerType: "subItem",
			markerColor: o,
			name: r.displayName,
			value: t,
			valueType: r.type
		})) : (l.push(t), u.push(r.type)));
	}
	return {
		inlineValues: l,
		inlineValueTypes: u,
		blocks: d
	};
}
init_dist$2();
var inner$20 = makeInner();
function getSelectionKey(t, n) {
	return t.getName(n) || t.getId(n);
}
var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled", SeriesModel = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n._selectedDataIndicesMap = {}, n;
	}
	return n.prototype.init = function(t, n, r) {
		this.seriesIndex = this.componentIndex, this.dataTask = createTask({
			count: dataTaskCount,
			reset: dataTaskReset
		}), this.dataTask.context = { model: this }, this.mergeDefaultAndTheme(t, r), (inner$20(this).sourceManager = new SourceManager(this)).prepareSource();
		var a = this.getInitialData(t, r);
		wrapData(a, this), this.dataTask.context.data = a, process$1.env.NODE_ENV !== "production" && assert(a, "getInitialData returned invalid data."), inner$20(this).dataBeforeProcessed = a, autoSeriesName(this), this._initSelectedMapFromData(a);
	}, n.prototype.mergeDefaultAndTheme = function(t, n) {
		var r = fetchLayoutMode(this), a = r ? getLayoutParams(t) : {}, o = this.subType;
		Component_default.hasClass(o) && (o += "Series"), merge(t, n.getTheme().get(this.subType)), merge(t, this.getDefaultOption()), defaultEmphasis(t, "label", ["show"]), this.fillDataTextStyle(t.data), r && mergeLayoutParam(t, a, r);
	}, n.prototype.mergeOption = function(t, n) {
		t = merge(this.option, t, !0), this.fillDataTextStyle(t.data);
		var r = fetchLayoutMode(this);
		r && mergeLayoutParam(this.option, t, r);
		var a = inner$20(this).sourceManager;
		a.dirty(), a.prepareSource();
		var o = this.getInitialData(t, n);
		wrapData(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, inner$20(this).dataBeforeProcessed = o, autoSeriesName(this), this._initSelectedMapFromData(o);
	}, n.prototype.fillDataTextStyle = function(t) {
		if (t && !isTypedArray(t)) for (var n = ["show"], r = 0; r < t.length; r++) t[r] && t[r].label && defaultEmphasis(t[r], "label", n);
	}, n.prototype.getInitialData = function(t, n) {}, n.prototype.appendData = function(t) {
		this.getRawData().appendData(t.data);
	}, n.prototype.getData = function(t) {
		var n = getCurrentTask(this);
		if (n) {
			var r = n.context.data;
			return t == null || !r.getLinkedData ? r : r.getLinkedData(t);
		} else return inner$20(this).data;
	}, n.prototype.getAllData = function() {
		var t = this.getData();
		return t && t.getLinkedDataAll ? t.getLinkedDataAll() : [{ data: t }];
	}, n.prototype.setData = function(t) {
		var n = getCurrentTask(this);
		if (n) {
			var r = n.context;
			r.outputData = t, n !== this.dataTask && (r.data = t);
		}
		inner$20(this).data = t;
	}, n.prototype.getEncode = function() {
		var t = this.get("encode", !0);
		if (t) return createHashMap(t);
	}, n.prototype.getSourceManager = function() {
		return inner$20(this).sourceManager;
	}, n.prototype.getSource = function() {
		return this.getSourceManager().getSource();
	}, n.prototype.getRawData = function() {
		return inner$20(this).dataBeforeProcessed;
	}, n.prototype.getColorBy = function() {
		return this.get("colorBy") || "series";
	}, n.prototype.isColorBySeries = function() {
		return this.getColorBy() === "series";
	}, n.prototype.getBaseAxis = function() {
		var t = this.coordinateSystem;
		return t && t.getBaseAxis && t.getBaseAxis();
	}, n.prototype.formatTooltip = function(t, n, r) {
		return defaultSeriesFormatTooltip({
			series: this,
			dataIndex: t,
			multipleSeries: n
		});
	}, n.prototype.isAnimationEnabled = function() {
		var t = this.ecModel;
		if (env_default.node && !(t && t.ssr)) return !1;
		var n = this.getShallow("animation");
		return n && this.getData().count() > this.getShallow("animationThreshold") && (n = !1), !!n;
	}, n.prototype.restoreData = function() {
		this.dataTask.dirty();
	}, n.prototype.getColorFromPalette = function(t, n, r) {
		var a = this.ecModel, o = PaletteMixin.prototype.getColorFromPalette.call(this, t, n, r);
		return o ||= a.getColorFromPalette(t, n, r), o;
	}, n.prototype.coordDimToDataDim = function(t) {
		return this.getRawData().mapDimensionsAll(t);
	}, n.prototype.getProgressive = function() {
		return this.get("progressive");
	}, n.prototype.getProgressiveThreshold = function() {
		return this.get("progressiveThreshold");
	}, n.prototype.select = function(t, n) {
		this._innerSelect(this.getData(n), t);
	}, n.prototype.unselect = function(t, n) {
		var r = this.option.selectedMap;
		if (r) {
			var a = this.option.selectedMode, o = this.getData(n);
			if (a === "series" || r === "all") {
				this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
				return;
			}
			for (var s = 0; s < t.length; s++) {
				var c = t[s], l = getSelectionKey(o, c);
				r[l] = !1, this._selectedDataIndicesMap[l] = -1;
			}
		}
	}, n.prototype.toggleSelect = function(t, n) {
		for (var r = [], a = 0; a < t.length; a++) r[0] = t[a], this.isSelected(t[a], n) ? this.unselect(r, n) : this.select(r, n);
	}, n.prototype.getSelectedDataIndices = function() {
		if (this.option.selectedMap === "all") return [].slice.call(this.getData().getIndices());
		for (var t = this._selectedDataIndicesMap, n = keys(t), r = [], a = 0; a < n.length; a++) {
			var o = t[n[a]];
			o >= 0 && r.push(o);
		}
		return r;
	}, n.prototype.isSelected = function(t, n) {
		var r = this.option.selectedMap;
		if (!r) return !1;
		var a = this.getData(n);
		return (r === "all" || r[getSelectionKey(a, t)]) && !a.getItemModel(t).get(["select", "disabled"]);
	}, n.prototype.isUniversalTransitionEnabled = function() {
		if (this.__universalTransitionEnabled) return !0;
		var t = this.option.universalTransition;
		return t ? t === !0 ? !0 : t && t.enabled : !1;
	}, n.prototype._innerSelect = function(t, n) {
		var r, a, o = this.option, s = o.selectedMode, c = n.length;
		if (!(!s || !c)) {
			if (s === "series") o.selectedMap = "all";
			else if (s === "multiple") {
				isObject(o.selectedMap) || (o.selectedMap = {});
				for (var l = o.selectedMap, u = 0; u < c; u++) {
					var d = n[u], f = getSelectionKey(t, d);
					l[f] = !0, this._selectedDataIndicesMap[f] = t.getRawIndex(d);
				}
			} else if (s === "single" || s === !0) {
				var p = n[c - 1], f = getSelectionKey(t, p);
				o.selectedMap = (r = {}, r[f] = !0, r), this._selectedDataIndicesMap = (a = {}, a[f] = t.getRawIndex(p), a);
			}
		}
	}, n.prototype._initSelectedMapFromData = function(t) {
		if (!this.option.selectedMap) {
			var n = [];
			t.hasItemOption && t.each(function(r) {
				var a = t.getRawDataItem(r);
				a && a.selected && n.push(r);
			}), n.length > 0 && this._innerSelect(t, n);
		}
	}, n.registerClass = function(t) {
		return Component_default.registerClass(t);
	}, n.protoInitialize = function() {
		var t = n.prototype;
		t.type = "series.__base__", t.seriesIndex = 0, t.ignoreStyleOnData = !1, t.hasSymbolVisual = !1, t.defaultSymbol = "circle", t.visualStyleAccessPath = "itemStyle", t.visualDrawType = "fill";
	}(), n;
}(Component_default);
mixin(SeriesModel, DataFormatMixin), mixin(SeriesModel, PaletteMixin), mountExtend(SeriesModel, Component_default);
function autoSeriesName(t) {
	var n = t.name;
	isNameSpecified(t) || (t.name = getSeriesAutoName(t) || n);
}
function getSeriesAutoName(t) {
	var n = t.getRawData(), r = n.mapDimensionsAll("seriesName"), a = [];
	return each(r, function(t) {
		var r = n.getDimensionInfo(t);
		r.displayName && a.push(r.displayName);
	}), a.join(" ");
}
function dataTaskCount(t) {
	return t.model.getRawData().count();
}
function dataTaskReset(t) {
	var n = t.model;
	return n.setData(n.getRawData().cloneShallow()), dataTaskProgress;
}
function dataTaskProgress(t, n) {
	n.outputData && t.end > n.outputData.count() && n.model.getRawData().cloneShallow(n.outputData);
}
function wrapData(t, n) {
	each(concatArray(t.CHANGABLE_METHODS, t.DOWNSAMPLE_METHODS), function(r) {
		t.wrapMethod(r, curry(onDataChange, n));
	});
}
function onDataChange(t, n) {
	var r = getCurrentTask(t);
	return r && r.setOutputEnd((n || this).count()), n;
}
function getCurrentTask(t) {
	var n = (t.ecModel || {}).scheduler, r = n && n.getPipeline(t.uid);
	if (r) {
		var a = r.currentTask;
		if (a) {
			var o = a.agentStubMap;
			o && (a = o.get(t.uid));
		}
		return a;
	}
}
var Series_default = SeriesModel, ComponentView = function() {
	function t() {
		this.group = new Group_default(), this.uid = getUID("viewComponent");
	}
	return t.prototype.init = function(t, n) {}, t.prototype.render = function(t, n, r, a) {}, t.prototype.dispose = function(t, n) {}, t.prototype.updateView = function(t, n, r, a) {}, t.prototype.updateLayout = function(t, n, r, a) {}, t.prototype.updateVisual = function(t, n, r, a) {}, t.prototype.toggleBlurSeries = function(t, n, r) {}, t.prototype.eachRendered = function(t) {
		var n = this.group;
		n && n.traverse(t);
	}, t;
}();
enableClassExtend(ComponentView), enableClassManagement(ComponentView);
var Component_default$1 = ComponentView;
function createRenderPlanner() {
	var t = makeInner();
	return function(n) {
		var r = t(n), a = n.pipelineContext, o = !!r.large, s = !!r.progressiveRender, c = r.large = !!(a && a.large), l = r.progressiveRender = !!(a && a.progressiveRender);
		return (o !== c || s !== l) && "reset";
	};
}
init_dist$2();
var inner$19 = makeInner(), renderPlanner = createRenderPlanner(), ChartView = function() {
	function t() {
		this.group = new Group_default(), this.uid = getUID("viewChart"), this.renderTask = createTask({
			plan: renderTaskPlan,
			reset: renderTaskReset
		}), this.renderTask.context = { view: this };
	}
	return t.prototype.init = function(t, n) {}, t.prototype.render = function(t, n, r, a) {
		if (process$1.env.NODE_ENV !== "production") throw Error("render method must been implemented");
	}, t.prototype.highlight = function(t, n, r, a) {
		var o = t.getData(a && a.dataType);
		if (!o) {
			process$1.env.NODE_ENV !== "production" && error("Unknown dataType " + a.dataType);
			return;
		}
		toggleHighlight(o, a, "emphasis");
	}, t.prototype.downplay = function(t, n, r, a) {
		var o = t.getData(a && a.dataType);
		if (!o) {
			process$1.env.NODE_ENV !== "production" && error("Unknown dataType " + a.dataType);
			return;
		}
		toggleHighlight(o, a, "normal");
	}, t.prototype.remove = function(t, n) {
		this.group.removeAll();
	}, t.prototype.dispose = function(t, n) {}, t.prototype.updateView = function(t, n, r, a) {
		this.render(t, n, r, a);
	}, t.prototype.updateLayout = function(t, n, r, a) {
		this.render(t, n, r, a);
	}, t.prototype.updateVisual = function(t, n, r, a) {
		this.render(t, n, r, a);
	}, t.prototype.eachRendered = function(t) {
		traverseElements(this.group, t);
	}, t.markUpdateMethod = function(t, n) {
		inner$19(t).updateMethod = n;
	}, t.protoInitialize = function() {
		var n = t.prototype;
		n.type = "chart";
	}(), t;
}();
function elSetState(t, n, r) {
	t && isHighDownDispatcher(t) && (n === "emphasis" ? enterEmphasis : leaveEmphasis)(t, r);
}
function toggleHighlight(t, n, r) {
	var a = queryDataIndex(t, n), o = n && n.highlightKey != null ? getHighlightDigit(n.highlightKey) : null;
	a == null ? t.eachItemGraphicEl(function(t) {
		elSetState(t, r, o);
	}) : each(normalizeToArray(a), function(n) {
		elSetState(t.getItemGraphicEl(n), r, o);
	});
}
enableClassExtend(ChartView, ["dispose"]), enableClassManagement(ChartView);
function renderTaskPlan(t) {
	return renderPlanner(t.model);
}
function renderTaskReset(t) {
	var n = t.model, r = t.ecModel, a = t.api, o = t.payload, s = n.pipelineContext.progressiveRender, c = t.view, l = o && inner$19(o).updateMethod, u = s ? "incrementalPrepareRender" : l && c[l] ? l : "render";
	return u !== "render" && c[u](n, r, a, o), progressMethodMap[u];
}
var progressMethodMap = {
	incrementalPrepareRender: { progress: function(t, n) {
		n.view.incrementalRender(t, n.model, n.ecModel, n.api, n.payload);
	} },
	render: {
		forceFirstProgress: !0,
		progress: function(t, n) {
			n.view.render(n.model, n.ecModel, n.api, n.payload);
		}
	}
}, Chart_default = ChartView, ORIGIN_METHOD = "\0__throttleOriginMethod", RATE = "\0__throttleRate", THROTTLE_TYPE = "\0__throttleType";
function throttle(t, n, r) {
	var a, o = 0, s = 0, c = null, l, u, d, f;
	n ||= 0;
	function p() {
		s = (/* @__PURE__ */ new Date()).getTime(), c = null, t.apply(u, d || []);
	}
	var h = function() {
		var t = [...arguments];
		a = (/* @__PURE__ */ new Date()).getTime(), u = this, d = t;
		var h = f || n, g = f || r;
		f = null, l = a - (g ? o : s) - h, clearTimeout(c), g ? c = setTimeout(p, h) : l >= 0 ? p() : c = setTimeout(p, -l), o = a;
	};
	return h.clear = function() {
		c &&= (clearTimeout(c), null);
	}, h.debounceNextCall = function(t) {
		f = t;
	}, h;
}
function createOrUpdate(t, n, r, a) {
	var o = t[n];
	if (o) {
		var s = o[ORIGIN_METHOD] || o, c = o[THROTTLE_TYPE];
		if (o[RATE] !== r || c !== a) {
			if (r == null || !a) return t[n] = s;
			o = t[n] = throttle(s, r, a === "debounce"), o[ORIGIN_METHOD] = s, o[THROTTLE_TYPE] = a, o[RATE] = r;
		}
		return o;
	}
}
function clear(t, n) {
	var r = t[n];
	r && r[ORIGIN_METHOD] && (r.clear && r.clear(), t[n] = r[ORIGIN_METHOD]);
}
var inner$18 = makeInner(), defaultStyleMappers = {
	itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, !0),
	lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, !0)
}, defaultColorKey = {
	lineStyle: "stroke",
	itemStyle: "fill"
};
function getStyleMapper(t, n) {
	return t.visualStyleMapper || defaultStyleMappers[n] || (console.warn("Unknown style type '" + n + "'."), defaultStyleMappers.itemStyle);
}
function getDefaultColorKey(t, n) {
	return t.visualDrawType || defaultColorKey[n] || (console.warn("Unknown style type '" + n + "'."), "fill");
}
var seriesStyleTask = {
	createOnAllSeries: !0,
	performRawSeries: !0,
	reset: function(t, n) {
		var r = t.getData(), a = t.visualStyleAccessPath || "itemStyle", o = t.getModel(a), s = getStyleMapper(t, a)(o), c = o.getShallow("decal");
		c && (r.setVisual("decal", c), c.dirty = !0);
		var l = getDefaultColorKey(t, a), u = s[l], d = isFunction(u) ? u : null, f = s.fill === "auto" || s.stroke === "auto";
		if (!s[l] || d || f) {
			var p = t.getColorFromPalette(t.name, null, n.getSeriesCount());
			s[l] || (s[l] = p, r.setVisual("colorFromPalette", !0)), s.fill = s.fill === "auto" || isFunction(s.fill) ? p : s.fill, s.stroke = s.stroke === "auto" || isFunction(s.stroke) ? p : s.stroke;
		}
		if (r.setVisual("style", s), r.setVisual("drawType", l), !n.isSeriesFiltered(t) && d) return r.setVisual("colorFromPalette", !1), { dataEach: function(n, r) {
			var a = t.getDataParams(r), o = extend({}, s);
			o[l] = d(a), n.setItemVisual(r, "style", o);
		} };
	}
}, sharedModel = new Model_default(), dataStyleTask = {
	createOnAllSeries: !0,
	performRawSeries: !0,
	reset: function(t, n) {
		if (!(t.ignoreStyleOnData || n.isSeriesFiltered(t))) {
			var r = t.getData(), a = t.visualStyleAccessPath || "itemStyle", o = getStyleMapper(t, a), s = r.getVisual("drawType");
			return { dataEach: r.hasItemOption ? function(t, n) {
				var r = t.getRawDataItem(n);
				if (r && r[a]) {
					sharedModel.option = r[a];
					var c = o(sharedModel);
					extend(t.ensureUniqueItemVisual(n, "style"), c), sharedModel.option.decal && (t.setItemVisual(n, "decal", sharedModel.option.decal), sharedModel.option.decal.dirty = !0), s in c && t.setItemVisual(n, "colorFromPalette", !1);
				}
			} : null };
		}
	}
}, dataColorPaletteTask = {
	performRawSeries: !0,
	overallReset: function(t) {
		var n = createHashMap();
		t.eachSeries(function(t) {
			var r = t.getColorBy();
			if (!t.isColorBySeries()) {
				var a = t.type + "-" + r, o = n.get(a);
				o || (o = {}, n.set(a, o)), inner$18(t).scope = o;
			}
		}), t.eachSeries(function(n) {
			if (!(n.isColorBySeries() || t.isSeriesFiltered(n))) {
				var r = n.getRawData(), a = {}, o = n.getData(), s = inner$18(n).scope, c = getDefaultColorKey(n, n.visualStyleAccessPath || "itemStyle");
				o.each(function(t) {
					var n = o.getRawIndex(t);
					a[n] = t;
				}), r.each(function(t) {
					var l = a[t];
					if (o.getItemVisual(l, "colorFromPalette")) {
						var u = o.ensureUniqueItemVisual(l, "style"), d = r.getName(t) || t + "", f = r.count();
						u[c] = n.getColorFromPalette(d, s, f);
					}
				});
			}
		});
	}
}, PI$5 = Math.PI;
function defaultLoading(t, n) {
	n ||= {}, defaults(n, {
		text: "loading",
		textColor: "#000",
		fontSize: 12,
		fontWeight: "normal",
		fontStyle: "normal",
		fontFamily: "sans-serif",
		maskColor: "rgba(255, 255, 255, 0.8)",
		showSpinner: !0,
		color: "#5470c6",
		spinnerRadius: 10,
		lineWidth: 5,
		zlevel: 0
	});
	var r = new Group_default(), a = new Rect_default({
		style: { fill: n.maskColor },
		zlevel: n.zlevel,
		z: 1e4
	});
	r.add(a);
	var o = new Text_default({
		style: {
			text: n.text,
			fill: n.textColor,
			fontSize: n.fontSize,
			fontWeight: n.fontWeight,
			fontStyle: n.fontStyle,
			fontFamily: n.fontFamily
		},
		zlevel: n.zlevel,
		z: 10001
	}), s = new Rect_default({
		style: { fill: "none" },
		textContent: o,
		textConfig: {
			position: "right",
			distance: 10
		},
		zlevel: n.zlevel,
		z: 10001
	});
	r.add(s);
	var c;
	return n.showSpinner && (c = new Arc_default({
		shape: {
			startAngle: -PI$5 / 2,
			endAngle: -PI$5 / 2 + .1,
			r: n.spinnerRadius
		},
		style: {
			stroke: n.color,
			lineCap: "round",
			lineWidth: n.lineWidth
		},
		zlevel: n.zlevel,
		z: 10001
	}), c.animateShape(!0).when(1e3, { endAngle: PI$5 * 3 / 2 }).start("circularInOut"), c.animateShape(!0).when(1e3, { startAngle: PI$5 * 3 / 2 }).delay(300).start("circularInOut"), r.add(c)), r.resize = function() {
		var r = o.getBoundingRect().width, l = n.showSpinner ? n.spinnerRadius : 0, u = (t.getWidth() - l * 2 - (n.showSpinner && r ? 10 : 0) - r) / 2 - (n.showSpinner && r ? 0 : 5 + r / 2) + (n.showSpinner ? 0 : r / 2) + (r ? 0 : l), d = t.getHeight() / 2;
		n.showSpinner && c.setShape({
			cx: u,
			cy: d
		}), s.setShape({
			x: u - l,
			y: d - l,
			width: l * 2,
			height: l * 2
		}), a.setShape({
			x: 0,
			y: 0,
			width: t.getWidth(),
			height: t.getHeight()
		});
	}, r.resize(), r;
}
init_dist$2();
var Scheduler = function() {
	function t(t, n, r, a) {
		this._stageTaskMap = createHashMap(), this.ecInstance = t, this.api = n, r = this._dataProcessorHandlers = r.slice(), a = this._visualHandlers = a.slice(), this._allHandlers = r.concat(a);
	}
	return t.prototype.restoreData = function(t, n) {
		t.restoreData(n), this._stageTaskMap.each(function(t) {
			var n = t.overallTask;
			n && n.dirty();
		});
	}, t.prototype.getPerformArgs = function(t, n) {
		if (t.__pipeline) {
			var r = this._pipelineMap.get(t.__pipeline.id), a = r.context, o = !n && r.progressiveEnabled && (!a || a.progressiveRender) && t.__idxInPipeline > r.blockIndex ? r.step : null, s = a && a.modDataCount;
			return {
				step: o,
				modBy: s == null ? null : Math.ceil(s / o),
				modDataCount: s
			};
		}
	}, t.prototype.getPipeline = function(t) {
		return this._pipelineMap.get(t);
	}, t.prototype.updateStreamModes = function(t, n) {
		var r = this._pipelineMap.get(t.uid), a = t.getData().count(), o = r.progressiveEnabled && n.incrementalPrepareRender && a >= r.threshold, s = t.get("large") && a >= t.get("largeThreshold");
		t.pipelineContext = r.context = {
			progressiveRender: o,
			modDataCount: t.get("progressiveChunkMode") === "mod" ? a : null,
			large: s
		};
	}, t.prototype.restorePipelines = function(t) {
		var n = this, r = n._pipelineMap = createHashMap();
		t.eachSeries(function(t) {
			var a = t.getProgressive(), o = t.uid;
			r.set(o, {
				id: o,
				head: null,
				tail: null,
				threshold: t.getProgressiveThreshold(),
				progressiveEnabled: a && !(t.preventIncremental && t.preventIncremental()),
				blockIndex: -1,
				step: Math.round(a || 700),
				count: 0
			}), n._pipe(t, t.dataTask);
		});
	}, t.prototype.prepareStageTasks = function() {
		var t = this._stageTaskMap, n = this.api.getModel(), r = this.api;
		each(this._allHandlers, function(a) {
			var o = t.get(a.uid) || t.set(a.uid, {}), c = "";
			process$1.env.NODE_ENV !== "production" && (c = "\"reset\" and \"overallReset\" must not be both specified."), assert(!(a.reset && a.overallReset), c), a.reset && this._createSeriesStageTask(a, o, n, r), a.overallReset && this._createOverallStageTask(a, o, n, r);
		}, this);
	}, t.prototype.prepareView = function(t, n, r, a) {
		var o = t.renderTask, s = o.context;
		s.model = n, s.ecModel = r, s.api = a, o.__block = !t.incrementalPrepareRender, this._pipe(n, o);
	}, t.prototype.performDataProcessorTasks = function(t, n) {
		this._performStageTasks(this._dataProcessorHandlers, t, n, { block: !0 });
	}, t.prototype.performVisualTasks = function(t, n, r) {
		this._performStageTasks(this._visualHandlers, t, n, r);
	}, t.prototype._performStageTasks = function(t, n, r, a) {
		a ||= {};
		var o = !1, s = this;
		each(t, function(t, l) {
			if (!(a.visualType && a.visualType !== t.visualType)) {
				var u = s._stageTaskMap.get(t.uid), d = u.seriesTaskMap, f = u.overallTask;
				if (f) {
					var p, h = f.agentStubMap;
					h.each(function(t) {
						c(a, t) && (t.dirty(), p = !0);
					}), p && f.dirty(), s.updatePayload(f, r);
					var g = s.getPerformArgs(f, a.block);
					h.each(function(t) {
						t.perform(g);
					}), f.perform(g) && (o = !0);
				} else d && d.each(function(l, u) {
					c(a, l) && l.dirty();
					var d = s.getPerformArgs(l, a.block);
					d.skip = !t.performRawSeries && n.isSeriesFiltered(l.context.model), s.updatePayload(l, r), l.perform(d) && (o = !0);
				});
			}
		});
		function c(t, n) {
			return t.setDirty && (!t.dirtyMap || t.dirtyMap.get(n.__pipeline.id));
		}
		this.unfinished = o || this.unfinished;
	}, t.prototype.performSeriesTasks = function(t) {
		var n;
		t.eachSeries(function(t) {
			n = t.dataTask.perform() || n;
		}), this.unfinished = n || this.unfinished;
	}, t.prototype.plan = function() {
		this._pipelineMap.each(function(t) {
			var n = t.tail;
			do {
				if (n.__block) {
					t.blockIndex = n.__idxInPipeline;
					break;
				}
				n = n.getUpstream();
			} while (n);
		});
	}, t.prototype.updatePayload = function(t, n) {
		n !== "remain" && (t.context.payload = n);
	}, t.prototype._createSeriesStageTask = function(t, n, r, a) {
		var o = this, s = n.seriesTaskMap, c = n.seriesTaskMap = createHashMap(), l = t.seriesType, u = t.getTargetSeries;
		t.createOnAllSeries ? r.eachRawSeries(d) : l ? r.eachRawSeriesByType(l, d) : u && u(r, a).each(d);
		function d(n) {
			var l = n.uid, u = c.set(l, s && s.get(l) || createTask({
				plan: seriesTaskPlan,
				reset: seriesTaskReset,
				count: seriesTaskCount
			}));
			u.context = {
				model: n,
				ecModel: r,
				api: a,
				useClearVisual: t.isVisual && !t.isLayout,
				plan: t.plan,
				reset: t.reset,
				scheduler: o
			}, o._pipe(n, u);
		}
	}, t.prototype._createOverallStageTask = function(t, n, r, a) {
		var o = this, c = n.overallTask = n.overallTask || createTask({ reset: overallTaskReset });
		c.context = {
			ecModel: r,
			api: a,
			overallReset: t.overallReset,
			scheduler: o
		};
		var l = c.agentStubMap, u = c.agentStubMap = createHashMap(), d = t.seriesType, f = t.getTargetSeries, p = !0, h = !1, g = "";
		process$1.env.NODE_ENV !== "production" && (g = "\"createOnAllSeries\" is not supported for \"overallReset\", because it will block all streams."), assert(!t.createOnAllSeries, g), d ? r.eachRawSeriesByType(d, _) : f ? f(r, a).each(_) : (p = !1, each(r.getSeries(), _));
		function _(t) {
			var n = t.uid, r = u.set(n, l && l.get(n) || (h = !0, createTask({
				reset: stubReset,
				onDirty: stubOnDirty
			})));
			r.context = {
				model: t,
				overallProgress: p
			}, r.agent = c, r.__block = p, o._pipe(t, r);
		}
		h && c.dirty();
	}, t.prototype._pipe = function(t, n) {
		var r = t.uid, a = this._pipelineMap.get(r);
		!a.head && (a.head = n), a.tail && a.tail.pipe(n), a.tail = n, n.__idxInPipeline = a.count++, n.__pipeline = a;
	}, t.wrapStageHandler = function(t, n) {
		return isFunction(t) && (t = {
			overallReset: t,
			seriesType: detectSeriseType(t)
		}), t.uid = getUID("stageHandler"), n && (t.visualType = n), t;
	}, t;
}();
function overallTaskReset(t) {
	t.overallReset(t.ecModel, t.api, t.payload);
}
function stubReset(t) {
	return t.overallProgress && stubProgress;
}
function stubProgress() {
	this.agent.dirty(), this.getDownstream().dirty();
}
function stubOnDirty() {
	this.agent && this.agent.dirty();
}
function seriesTaskPlan(t) {
	return t.plan ? t.plan(t.model, t.ecModel, t.api, t.payload) : null;
}
function seriesTaskReset(t) {
	t.useClearVisual && t.data.clearAllVisual();
	var n = t.resetDefines = normalizeToArray(t.reset(t.model, t.ecModel, t.api, t.payload));
	return n.length > 1 ? map(n, function(t, n) {
		return makeSeriesTaskProgress(n);
	}) : singleSeriesTaskProgress;
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
function makeSeriesTaskProgress(t) {
	return function(n, r) {
		var a = r.data, o = r.resetDefines[t];
		if (o && o.dataEach) for (var s = n.start; s < n.end; s++) o.dataEach(a, s);
		else o && o.progress && o.progress(n, a);
	};
}
function seriesTaskCount(t) {
	return t.data.count();
}
function detectSeriseType(t) {
	seriesType = null;
	try {
		t(ecModelMock, apiMock);
	} catch {}
	return seriesType;
}
var ecModelMock = {}, apiMock = {}, seriesType;
mockMethods(ecModelMock, Global_default), mockMethods(apiMock, ExtensionAPI_default), ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(t) {
	seriesType = t;
}, ecModelMock.eachComponent = function(t) {
	t.mainType === "series" && t.subType && (seriesType = t.subType);
};
function mockMethods(t, n) {
	for (var r in n.prototype) t[r] = noop;
}
var Scheduler_default = Scheduler, colorAll = [
	"#37A2DA",
	"#32C5E9",
	"#67E0E3",
	"#9FE6B8",
	"#FFDB5C",
	"#ff9f7f",
	"#fb7293",
	"#E062AE",
	"#E690D1",
	"#e7bcf3",
	"#9d96f5",
	"#8378EA",
	"#96BFFF"
], light_default = {
	color: colorAll,
	colorLayer: [
		[
			"#37A2DA",
			"#ffd85c",
			"#fd7b5f"
		],
		[
			"#37A2DA",
			"#67E0E3",
			"#FFDB5C",
			"#ff9f7f",
			"#E062AE",
			"#9d96f5"
		],
		[
			"#37A2DA",
			"#32C5E9",
			"#9FE6B8",
			"#FFDB5C",
			"#ff9f7f",
			"#fb7293",
			"#e7bcf3",
			"#8378EA",
			"#96BFFF"
		],
		colorAll
	]
}, contrastColor = "#B9B8CE", backgroundColor = "#100C2A", axisCommon = function() {
	return {
		axisLine: { lineStyle: { color: contrastColor } },
		splitLine: { lineStyle: { color: "#484753" } },
		splitArea: { areaStyle: { color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"] } },
		minorSplitLine: { lineStyle: { color: "#20203B" } }
	};
}, colorPalette = [
	"#4992ff",
	"#7cffb2",
	"#fddd60",
	"#ff6e76",
	"#58d9f9",
	"#05c091",
	"#ff8a45",
	"#8d48e3",
	"#dd79ff"
], theme = {
	darkMode: !0,
	color: colorPalette,
	backgroundColor,
	axisPointer: {
		lineStyle: { color: "#817f91" },
		crossStyle: { color: "#817f91" },
		label: { color: "#fff" }
	},
	legend: {
		textStyle: { color: contrastColor },
		pageTextStyle: { color: contrastColor }
	},
	textStyle: { color: contrastColor },
	title: {
		textStyle: { color: "#EEF1FA" },
		subtextStyle: { color: "#B9B8CE" }
	},
	toolbox: { iconStyle: { borderColor: contrastColor } },
	dataZoom: {
		borderColor: "#71708A",
		textStyle: { color: contrastColor },
		brushStyle: { color: "rgba(135,163,206,0.3)" },
		handleStyle: {
			color: "#353450",
			borderColor: "#C5CBE3"
		},
		moveHandleStyle: {
			color: "#B0B6C3",
			opacity: .3
		},
		fillerColor: "rgba(135,163,206,0.2)",
		emphasis: {
			handleStyle: {
				borderColor: "#91B7F2",
				color: "#4D587D"
			},
			moveHandleStyle: {
				color: "#636D9A",
				opacity: .7
			}
		},
		dataBackground: {
			lineStyle: {
				color: "#71708A",
				width: 1
			},
			areaStyle: { color: "#71708A" }
		},
		selectedDataBackground: {
			lineStyle: { color: "#87A3CE" },
			areaStyle: { color: "#87A3CE" }
		}
	},
	visualMap: { textStyle: { color: contrastColor } },
	timeline: {
		lineStyle: { color: contrastColor },
		label: { color: contrastColor },
		controlStyle: {
			color: contrastColor,
			borderColor: contrastColor
		}
	},
	calendar: {
		itemStyle: { color: backgroundColor },
		dayLabel: { color: contrastColor },
		monthLabel: { color: contrastColor },
		yearLabel: { color: contrastColor }
	},
	timeAxis: axisCommon(),
	logAxis: axisCommon(),
	valueAxis: axisCommon(),
	categoryAxis: axisCommon(),
	line: { symbol: "circle" },
	graph: { color: colorPalette },
	gauge: {
		title: { color: contrastColor },
		axisLine: { lineStyle: { color: [[1, "rgba(207,212,219,0.2)"]] } },
		axisLabel: { color: contrastColor },
		detail: { color: "#EEF1FA" }
	},
	candlestick: { itemStyle: {
		color: "#f64e56",
		color0: "#54ea92",
		borderColor: "#f64e56",
		borderColor0: "#54ea92"
	} }
};
theme.categoryAxis.splitLine.show = !1;
var dark_default = theme, ECEventProcessor = function() {
	function t() {}
	return t.prototype.normalizeQuery = function(t) {
		var n = {}, r = {}, a = {};
		if (isString(t)) {
			var o = parseClassType(t);
			n.mainType = o.main || null, n.subType = o.sub || null;
		} else {
			var s = [
				"Index",
				"Name",
				"Id"
			], c = {
				name: 1,
				dataIndex: 1,
				dataType: 1
			};
			each(t, function(t, o) {
				for (var l = !1, u = 0; u < s.length; u++) {
					var d = s[u], f = o.lastIndexOf(d);
					if (f > 0 && f === o.length - d.length) {
						var p = o.slice(0, f);
						p !== "data" && (n.mainType = p, n[d.toLowerCase()] = t, l = !0);
					}
				}
				c.hasOwnProperty(o) && (r[o] = t, l = !0), l || (a[o] = t);
			});
		}
		return {
			cptQuery: n,
			dataQuery: r,
			otherQuery: a
		};
	}, t.prototype.filter = function(t, n) {
		var r = this.eventInfo;
		if (!r) return !0;
		var a = r.targetEl, o = r.packedEvent, s = r.model, c = r.view;
		if (!s || !c) return !0;
		var l = n.cptQuery, u = n.dataQuery;
		return d(l, s, "mainType") && d(l, s, "subType") && d(l, s, "index", "componentIndex") && d(l, s, "name") && d(l, s, "id") && d(u, o, "name") && d(u, o, "dataIndex") && d(u, o, "dataType") && (!c.filterForExposedEvent || c.filterForExposedEvent(t, n.otherQuery, a, o));
		function d(t, n, r, a) {
			return t[r] == null || n[a || r] === t[r];
		}
	}, t.prototype.afterTrigger = function() {
		this.eventInfo = null;
	}, t;
}(), SYMBOL_PROPS_WITH_CB = [
	"symbol",
	"symbolSize",
	"symbolRotate",
	"symbolOffset"
], SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(["symbolKeepAspect"]), seriesSymbolTask = {
	createOnAllSeries: !0,
	performRawSeries: !0,
	reset: function(t, n) {
		var r = t.getData();
		if (t.legendIcon && r.setVisual("legendIcon", t.legendIcon), !t.hasSymbolVisual) return;
		for (var a = {}, o = {}, s = !1, c = 0; c < SYMBOL_PROPS_WITH_CB.length; c++) {
			var l = SYMBOL_PROPS_WITH_CB[c], u = t.get(l);
			isFunction(u) ? (s = !0, o[l] = u) : a[l] = u;
		}
		if (a.symbol = a.symbol || t.defaultSymbol, r.setVisual(extend({
			legendIcon: t.legendIcon || a.symbol,
			symbolKeepAspect: t.get("symbolKeepAspect")
		}, a)), n.isSeriesFiltered(t)) return;
		var d = keys(o);
		function f(n, r) {
			for (var a = t.getRawValue(r), s = t.getDataParams(r), c = 0; c < d.length; c++) {
				var l = d[c];
				n.setItemVisual(r, l, o[l](a, s));
			}
		}
		return { dataEach: s ? f : null };
	}
}, dataSymbolTask = {
	createOnAllSeries: !0,
	performRawSeries: !0,
	reset: function(t, n) {
		if (!t.hasSymbolVisual || n.isSeriesFiltered(t)) return;
		var r = t.getData();
		function a(t, n) {
			for (var r = t.getItemModel(n), a = 0; a < SYMBOL_PROPS.length; a++) {
				var o = SYMBOL_PROPS[a], s = r.getShallow(o, !0);
				s != null && t.setItemVisual(n, o, s);
			}
		}
		return { dataEach: r.hasItemOption ? a : null };
	}
};
init_dist$2();
function getItemVisualFromData(t, n, r) {
	switch (r) {
		case "color": return t.getItemVisual(n, "style")[t.getVisual("drawType")];
		case "opacity": return t.getItemVisual(n, "style").opacity;
		case "symbol":
		case "symbolSize":
		case "liftZ": return t.getItemVisual(n, r);
		default: process$1.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + r);
	}
}
function getVisualFromData(t, n) {
	switch (n) {
		case "color": return t.getVisual("style")[t.getVisual("drawType")];
		case "opacity": return t.getVisual("style").opacity;
		case "symbol":
		case "symbolSize":
		case "liftZ": return t.getVisual(n);
		default: process$1.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + n);
	}
}
function setItemVisualFromData(t, n, r, a) {
	switch (r) {
		case "color":
			var o = t.ensureUniqueItemVisual(n, "style");
			o[t.getVisual("drawType")] = a, t.setItemVisual(n, "colorFromPalette", !1);
			break;
		case "opacity":
			t.ensureUniqueItemVisual(n, "style").opacity = a;
			break;
		case "symbol":
		case "symbolSize":
		case "liftZ":
			t.setItemVisual(n, r, a);
			break;
		default: process$1.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + r);
	}
}
init_dist$2();
function createLegacyDataSelectAction(t, n) {
	function r(n, r) {
		var a = [];
		return n.eachComponent({
			mainType: "series",
			subType: t,
			query: r
		}, function(t) {
			a.push(t.seriesIndex);
		}), a;
	}
	each([
		[t + "ToggleSelect", "toggleSelect"],
		[t + "Select", "select"],
		[t + "UnSelect", "unselect"]
	], function(t) {
		n(t[0], function(n, a, o) {
			n = extend({}, n), process$1.env.NODE_ENV !== "production" && deprecateReplaceLog(n.type, t[1]), o.dispatchAction(extend(n, {
				type: t[1],
				seriesIndex: r(a, n)
			}));
		});
	});
}
function handleSeriesLegacySelectEvents(t, n, r, a, o) {
	var c = t + n;
	r.isSilent(c) || (process$1.env.NODE_ENV !== "production" && deprecateLog("event " + c + " is deprecated."), a.eachComponent({
		mainType: "series",
		subType: "pie"
	}, function(t) {
		for (var n = t.seriesIndex, a = t.option.selectedMap, s = o.selected, l = 0; l < s.length; l++) if (s[l].seriesIndex === n) {
			var u = t.getData(), d = queryDataIndex(u, o.fromActionPayload);
			r.trigger(c, {
				type: c,
				seriesId: t.id,
				name: isArray(d) ? u.getName(d[0]) : u.getName(d),
				selected: isString(a) ? a : extend({}, a)
			});
		}
	}));
}
function handleLegacySelectEvents(t, n, r) {
	t.on("selectchanged", function(t) {
		var a = r.getModel();
		t.isFromClick ? (handleSeriesLegacySelectEvents("map", "selectchanged", n, a, t), handleSeriesLegacySelectEvents("pie", "selectchanged", n, a, t)) : t.fromAction === "select" ? (handleSeriesLegacySelectEvents("map", "selected", n, a, t), handleSeriesLegacySelectEvents("pie", "selected", n, a, t)) : t.fromAction === "unselect" && (handleSeriesLegacySelectEvents("map", "unselected", n, a, t), handleSeriesLegacySelectEvents("pie", "unselected", n, a, t));
	});
}
function findEventDispatcher(t, n, r) {
	for (var a; t && !(n(t) && (a = t, r));) t = t.__hostTarget || t.parent;
	return a;
}
var wmUniqueIndex = Math.round(Math.random() * 9), supportDefineProperty = typeof Object.defineProperty == "function", WeakMap_default = function() {
	function t() {
		this._id = "__ec_inner_" + wmUniqueIndex++;
	}
	return t.prototype.get = function(t) {
		return this._guard(t)[this._id];
	}, t.prototype.set = function(t, n) {
		var r = this._guard(t);
		return supportDefineProperty ? Object.defineProperty(r, this._id, {
			value: n,
			enumerable: !1,
			configurable: !0
		}) : r[this._id] = n, this;
	}, t.prototype.delete = function(t) {
		return this.has(t) ? (delete this._guard(t)[this._id], !0) : !1;
	}, t.prototype.has = function(t) {
		return !!this._guard(t)[this._id];
	}, t.prototype._guard = function(t) {
		if (t !== Object(t)) throw TypeError("Value of WeakMap is not a non-null object.");
		return t;
	}, t;
}(), Triangle = Path_default.extend({
	type: "triangle",
	shape: {
		cx: 0,
		cy: 0,
		width: 0,
		height: 0
	},
	buildPath: function(t, n) {
		var r = n.cx, a = n.cy, o = n.width / 2, s = n.height / 2;
		t.moveTo(r, a - s), t.lineTo(r + o, a + s), t.lineTo(r - o, a + s), t.closePath();
	}
}), symbolCtors = {
	line: Line_default$1,
	rect: Rect_default,
	roundRect: Rect_default,
	square: Rect_default,
	circle: Circle_default,
	diamond: Path_default.extend({
		type: "diamond",
		shape: {
			cx: 0,
			cy: 0,
			width: 0,
			height: 0
		},
		buildPath: function(t, n) {
			var r = n.cx, a = n.cy, o = n.width / 2, s = n.height / 2;
			t.moveTo(r, a - s), t.lineTo(r + o, a), t.lineTo(r, a + s), t.lineTo(r - o, a), t.closePath();
		}
	}),
	pin: Path_default.extend({
		type: "pin",
		shape: {
			x: 0,
			y: 0,
			width: 0,
			height: 0
		},
		buildPath: function(t, n) {
			var r = n.x, a = n.y, o = n.width / 5 * 3, s = Math.max(o, n.height), c = o / 2, l = c * c / (s - c), u = a - s + c + l, d = Math.asin(l / c), f = Math.cos(d) * c, p = Math.sin(d), h = Math.cos(d), g = c * .6, _ = c * .7;
			t.moveTo(r - f, u + l), t.arc(r, u, c, Math.PI - d, Math.PI * 2 + d), t.bezierCurveTo(r + f - p * g, u + l + h * g, r, a - _, r, a), t.bezierCurveTo(r, a - _, r - f + p * g, u + l + h * g, r - f, u + l), t.closePath();
		}
	}),
	arrow: Path_default.extend({
		type: "arrow",
		shape: {
			x: 0,
			y: 0,
			width: 0,
			height: 0
		},
		buildPath: function(t, n) {
			var r = n.height, a = n.width, o = n.x, s = n.y, c = a / 3 * 2;
			t.moveTo(o, s), t.lineTo(o + c, s + r), t.lineTo(o, s + r / 4 * 3), t.lineTo(o - c, s + r), t.lineTo(o, s), t.closePath();
		}
	}),
	triangle: Triangle
}, symbolShapeMakers = {
	line: function(t, n, r, a, o) {
		o.x1 = t, o.y1 = n + a / 2, o.x2 = t + r, o.y2 = n + a / 2;
	},
	rect: function(t, n, r, a, o) {
		o.x = t, o.y = n, o.width = r, o.height = a;
	},
	roundRect: function(t, n, r, a, o) {
		o.x = t, o.y = n, o.width = r, o.height = a, o.r = Math.min(r, a) / 4;
	},
	square: function(t, n, r, a, o) {
		var s = Math.min(r, a);
		o.x = t, o.y = n, o.width = s, o.height = s;
	},
	circle: function(t, n, r, a, o) {
		o.cx = t + r / 2, o.cy = n + a / 2, o.r = Math.min(r, a) / 2;
	},
	diamond: function(t, n, r, a, o) {
		o.cx = t + r / 2, o.cy = n + a / 2, o.width = r, o.height = a;
	},
	pin: function(t, n, r, a, o) {
		o.x = t + r / 2, o.y = n + a / 2, o.width = r, o.height = a;
	},
	arrow: function(t, n, r, a, o) {
		o.x = t + r / 2, o.y = n + a / 2, o.width = r, o.height = a;
	},
	triangle: function(t, n, r, a, o) {
		o.cx = t + r / 2, o.cy = n + a / 2, o.width = r, o.height = a;
	}
}, symbolBuildProxies = {};
each(symbolCtors, function(t, n) {
	symbolBuildProxies[n] = new t();
});
var SymbolClz = Path_default.extend({
	type: "symbol",
	shape: {
		symbolType: "",
		x: 0,
		y: 0,
		width: 0,
		height: 0
	},
	calculateTextPosition: function(t, n, r) {
		var a = calculateTextPosition(t, n, r), o = this.shape;
		return o && o.symbolType === "pin" && n.position === "inside" && (a.y = r.y + r.height * .4), a;
	},
	buildPath: function(t, n, r) {
		var a = n.symbolType;
		if (a !== "none") {
			var o = symbolBuildProxies[a];
			o ||= (a = "rect", symbolBuildProxies[a]), symbolShapeMakers[a](n.x, n.y, n.width, n.height, o.shape), o.buildPath(t, o.shape, r);
		}
	}
});
function symbolPathSetColor(t, n) {
	if (this.type !== "image") {
		var r = this.style;
		this.__isEmptyBrush ? (r.stroke = t, r.fill = n || "#fff", r.lineWidth = 2) : this.shape.symbolType === "line" ? r.stroke = t : r.fill = t, this.markRedraw();
	}
}
function createSymbol(t, n, r, a, o, s, c) {
	var l = t.indexOf("empty") === 0;
	l && (t = t.substr(5, 1).toLowerCase() + t.substr(6));
	var u = t.indexOf("image://") === 0 ? makeImage(t.slice(8), new BoundingRect_default(n, r, a, o), c ? "center" : "cover") : t.indexOf("path://") === 0 ? makePath(t.slice(7), {}, new BoundingRect_default(n, r, a, o), c ? "center" : "cover") : new SymbolClz({ shape: {
		symbolType: t,
		x: n,
		y: r,
		width: a,
		height: o
	} });
	return u.__isEmptyBrush = l, u.setColor = symbolPathSetColor, s && u.setColor(s), u;
}
function normalizeSymbolSize(t) {
	return isArray(t) || (t = [+t, +t]), [t[0] || 0, t[1] || 0];
}
function normalizeSymbolOffset(t, n) {
	if (t != null) return isArray(t) || (t = [t, t]), [parsePercent$1(t[0], n[0]) || 0, parsePercent$1(retrieve2(t[1], t[0]), n[1]) || 0];
}
function isSafeNum(t) {
	return isFinite(t);
}
function createLinearGradient(t, n, r) {
	var a = n.x == null ? 0 : n.x, o = n.x2 == null ? 1 : n.x2, s = n.y == null ? 0 : n.y, c = n.y2 == null ? 0 : n.y2;
	return n.global || (a = a * r.width + r.x, o = o * r.width + r.x, s = s * r.height + r.y, c = c * r.height + r.y), a = isSafeNum(a) ? a : 0, o = isSafeNum(o) ? o : 1, s = isSafeNum(s) ? s : 0, c = isSafeNum(c) ? c : 0, t.createLinearGradient(a, s, o, c);
}
function createRadialGradient(t, n, r) {
	var a = r.width, o = r.height, s = Math.min(a, o), c = n.x == null ? .5 : n.x, l = n.y == null ? .5 : n.y, u = n.r == null ? .5 : n.r;
	return n.global || (c = c * a + r.x, l = l * o + r.y, u *= s), c = isSafeNum(c) ? c : .5, l = isSafeNum(l) ? l : .5, u = u >= 0 && isSafeNum(u) ? u : .5, t.createRadialGradient(c, l, 0, c, l, u);
}
function getCanvasGradient(t, n, r) {
	for (var a = n.type === "radial" ? createRadialGradient(t, n, r) : createLinearGradient(t, n, r), o = n.colorStops, s = 0; s < o.length; s++) a.addColorStop(o[s].offset, o[s].color);
	return a;
}
function isClipPathChanged(t, n) {
	if (t === n || !t && !n) return !1;
	if (!t || !n || t.length !== n.length) return !0;
	for (var r = 0; r < t.length; r++) if (t[r] !== n[r]) return !0;
	return !1;
}
function parseInt10(t) {
	return parseInt(t, 10);
}
function getSize$1(t, n, r) {
	var a = ["width", "height"][n], o = ["clientWidth", "clientHeight"][n], s = ["paddingLeft", "paddingTop"][n], c = ["paddingRight", "paddingBottom"][n];
	if (r[a] != null && r[a] !== "auto") return parseFloat(r[a]);
	var l = document.defaultView.getComputedStyle(t);
	return (t[o] || parseInt10(l[a]) || parseInt10(t.style[a])) - (parseInt10(l[s]) || 0) - (parseInt10(l[c]) || 0) | 0;
}
function normalizeLineDash(t, n) {
	return !t || t === "solid" || !(n > 0) ? null : t === "dashed" ? [4 * n, 2 * n] : t === "dotted" ? [n] : isNumber(t) ? [t] : isArray(t) ? t : null;
}
function getLineDash(t) {
	var n = t.style, r = n.lineDash && n.lineWidth > 0 && normalizeLineDash(n.lineDash, n.lineWidth), a = n.lineDashOffset;
	if (r) {
		var o = n.strokeNoScale && t.getLineScale ? t.getLineScale() : 1;
		o && o !== 1 && (r = map(r, function(t) {
			return t / o;
		}), a /= o);
	}
	return [r, a];
}
var pathProxyForDraw = new PathProxy_default(!0);
function styleHasStroke(t) {
	var n = t.stroke;
	return !(n == null || n === "none" || !(t.lineWidth > 0));
}
function isValidStrokeFillStyle(t) {
	return typeof t == "string" && t !== "none";
}
function styleHasFill(t) {
	var n = t.fill;
	return n != null && n !== "none";
}
function doFillPath(t, n) {
	if (n.fillOpacity != null && n.fillOpacity !== 1) {
		var r = t.globalAlpha;
		t.globalAlpha = n.fillOpacity * n.opacity, t.fill(), t.globalAlpha = r;
	} else t.fill();
}
function doStrokePath(t, n) {
	if (n.strokeOpacity != null && n.strokeOpacity !== 1) {
		var r = t.globalAlpha;
		t.globalAlpha = n.strokeOpacity * n.opacity, t.stroke(), t.globalAlpha = r;
	} else t.stroke();
}
function createCanvasPattern(t, n, r) {
	var a = createOrUpdateImage(n.image, n.__image, r);
	if (isImageReady(a)) {
		var o = t.createPattern(a, n.repeat || "repeat");
		if (typeof DOMMatrix == "function" && o && o.setTransform) {
			var s = new DOMMatrix();
			s.translateSelf(n.x || 0, n.y || 0), s.rotateSelf(0, 0, (n.rotation || 0) * RADIAN_TO_DEGREE), s.scaleSelf(n.scaleX || 1, n.scaleY || 1), o.setTransform(s);
		}
		return o;
	}
}
function brushPath(t, n, r, a) {
	var o, s = styleHasStroke(r), c = styleHasFill(r), l = r.strokePercent, u = l < 1, d = !n.path;
	(!n.silent || u) && d && n.createPathProxy();
	var f = n.path || pathProxyForDraw, p = n.__dirty;
	if (!a) {
		var h = r.fill, g = r.stroke, _ = c && !!h.colorStops, v = s && !!g.colorStops, y = c && !!h.image, b = s && !!g.image, x = void 0, S = void 0, C = void 0, w = void 0, T = void 0;
		(_ || v) && (T = n.getBoundingRect()), _ && (x = p ? getCanvasGradient(t, h, T) : n.__canvasFillGradient, n.__canvasFillGradient = x), v && (S = p ? getCanvasGradient(t, g, T) : n.__canvasStrokeGradient, n.__canvasStrokeGradient = S), y && (C = p || !n.__canvasFillPattern ? createCanvasPattern(t, h, n) : n.__canvasFillPattern, n.__canvasFillPattern = C), b && (w = p || !n.__canvasStrokePattern ? createCanvasPattern(t, g, n) : n.__canvasStrokePattern, n.__canvasStrokePattern = C), _ ? t.fillStyle = x : y && (C ? t.fillStyle = C : c = !1), v ? t.strokeStyle = S : b && (w ? t.strokeStyle = w : s = !1);
	}
	var E = n.getGlobalScale();
	f.setScale(E[0], E[1], n.segmentIgnoreThreshold);
	var D, O;
	t.setLineDash && r.lineDash && (o = getLineDash(n), D = o[0], O = o[1]);
	var A = !0;
	(d || p & 4) && (f.setDPR(t.dpr), u ? f.setContext(null) : (f.setContext(t), A = !1), f.reset(), n.buildPath(f, n.shape, a), f.toStatic(), n.pathUpdated()), A && f.rebuildPath(t, u ? l : 1), D && (t.setLineDash(D), t.lineDashOffset = O), a || (r.strokeFirst ? (s && doStrokePath(t, r), c && doFillPath(t, r)) : (c && doFillPath(t, r), s && doStrokePath(t, r))), D && t.setLineDash([]);
}
function brushImage(t, n, r) {
	var a = n.__image = createOrUpdateImage(r.image, n.__image, n, n.onload);
	if (!(!a || !isImageReady(a))) {
		var o = r.x || 0, s = r.y || 0, c = n.getWidth(), l = n.getHeight(), u = a.width / a.height;
		if (c == null && l != null ? c = l * u : l == null && c != null ? l = c / u : c == null && l == null && (c = a.width, l = a.height), r.sWidth && r.sHeight) {
			var d = r.sx || 0, f = r.sy || 0;
			t.drawImage(a, d, f, r.sWidth, r.sHeight, o, s, c, l);
		} else if (r.sx && r.sy) {
			var d = r.sx, f = r.sy, p = c - d, h = l - f;
			t.drawImage(a, d, f, p, h, o, s, c, l);
		} else t.drawImage(a, o, s, c, l);
	}
}
function brushText(t, n, r) {
	var a, o = r.text;
	if (o != null && (o += ""), o) {
		t.font = r.font || "12px sans-serif", t.textAlign = r.textAlign, t.textBaseline = r.textBaseline;
		var s = void 0, c = void 0;
		t.setLineDash && r.lineDash && (a = getLineDash(n), s = a[0], c = a[1]), s && (t.setLineDash(s), t.lineDashOffset = c), r.strokeFirst ? (styleHasStroke(r) && t.strokeText(o, r.x, r.y), styleHasFill(r) && t.fillText(o, r.x, r.y)) : (styleHasFill(r) && t.fillText(o, r.x, r.y), styleHasStroke(r) && t.strokeText(o, r.x, r.y)), s && t.setLineDash([]);
	}
}
var SHADOW_NUMBER_PROPS = [
	"shadowBlur",
	"shadowOffsetX",
	"shadowOffsetY"
], STROKE_PROPS = [
	["lineCap", "butt"],
	["lineJoin", "miter"],
	["miterLimit", 10]
];
function bindCommonProps(t, n, r, a, o) {
	var s = !1;
	if (!a && (r ||= {}, n === r)) return !1;
	if (a || n.opacity !== r.opacity) {
		flushPathDrawn(t, o), s = !0;
		var c = Math.max(Math.min(n.opacity, 1), 0);
		t.globalAlpha = isNaN(c) ? DEFAULT_COMMON_STYLE.opacity : c;
	}
	(a || n.blend !== r.blend) && (s ||= (flushPathDrawn(t, o), !0), t.globalCompositeOperation = n.blend || DEFAULT_COMMON_STYLE.blend);
	for (var l = 0; l < SHADOW_NUMBER_PROPS.length; l++) {
		var u = SHADOW_NUMBER_PROPS[l];
		(a || n[u] !== r[u]) && (s ||= (flushPathDrawn(t, o), !0), t[u] = t.dpr * (n[u] || 0));
	}
	return (a || n.shadowColor !== r.shadowColor) && (s ||= (flushPathDrawn(t, o), !0), t.shadowColor = n.shadowColor || DEFAULT_COMMON_STYLE.shadowColor), s;
}
function bindPathAndTextCommonStyle(t, n, r, a, o) {
	var s = getStyle(n, o.inHover), c = a ? null : r && getStyle(r, o.inHover) || {};
	if (s === c) return !1;
	var l = bindCommonProps(t, s, c, a, o);
	if ((a || s.fill !== c.fill) && (l ||= (flushPathDrawn(t, o), !0), isValidStrokeFillStyle(s.fill) && (t.fillStyle = s.fill)), (a || s.stroke !== c.stroke) && (l ||= (flushPathDrawn(t, o), !0), isValidStrokeFillStyle(s.stroke) && (t.strokeStyle = s.stroke)), (a || s.opacity !== c.opacity) && (l ||= (flushPathDrawn(t, o), !0), t.globalAlpha = s.opacity == null ? 1 : s.opacity), n.hasStroke()) {
		var u = s.lineWidth / (s.strokeNoScale && n.getLineScale ? n.getLineScale() : 1);
		t.lineWidth !== u && (l ||= (flushPathDrawn(t, o), !0), t.lineWidth = u);
	}
	for (var d = 0; d < STROKE_PROPS.length; d++) {
		var f = STROKE_PROPS[d], p = f[0];
		(a || s[p] !== c[p]) && (l ||= (flushPathDrawn(t, o), !0), t[p] = s[p] || f[1]);
	}
	return l;
}
function bindImageStyle(t, n, r, a, o) {
	return bindCommonProps(t, getStyle(n, o.inHover), r && getStyle(r, o.inHover), a, o);
}
function setContextTransform(t, n) {
	var r = n.transform, a = t.dpr || 1;
	r ? t.setTransform(a * r[0], a * r[1], a * r[2], a * r[3], a * r[4], a * r[5]) : t.setTransform(a, 0, 0, a, 0, 0);
}
function updateClipStatus(t, n, r) {
	for (var a = !1, o = 0; o < t.length; o++) {
		var s = t[o];
		a ||= s.isZeroArea(), setContextTransform(n, s), n.beginPath(), s.buildPath(n, s.shape), n.clip();
	}
	r.allClipped = a;
}
function isTransformChanged(t, n) {
	return t && n ? t[0] !== n[0] || t[1] !== n[1] || t[2] !== n[2] || t[3] !== n[3] || t[4] !== n[4] || t[5] !== n[5] : !(!t && !n);
}
var DRAW_TYPE_PATH = 1, DRAW_TYPE_IMAGE = 2, DRAW_TYPE_TEXT = 3, DRAW_TYPE_INCREMENTAL = 4;
function canPathBatch(t) {
	var n = styleHasFill(t), r = styleHasStroke(t);
	return !(t.lineDash || !(n ^ +r) || n && typeof t.fill != "string" || r && typeof t.stroke != "string" || t.strokePercent < 1 || t.strokeOpacity < 1 || t.fillOpacity < 1);
}
function flushPathDrawn(t, n) {
	n.batchFill && t.fill(), n.batchStroke && t.stroke(), n.batchFill = "", n.batchStroke = "";
}
function getStyle(t, n) {
	return n && t.__hoverStyle || t.style;
}
function brushSingle(t, n) {
	brush(t, n, {
		inHover: !1,
		viewWidth: 0,
		viewHeight: 0
	}, !0);
}
function brush(t, n, r, a) {
	var o = n.transform;
	if (!n.shouldBePainted(r.viewWidth, r.viewHeight, !1, !1)) {
		n.__dirty &= -2, n.__isRendered = !1;
		return;
	}
	var s = n.__clipPaths, c = r.prevElClipPaths, l = !1, u = !1;
	if ((!c || isClipPathChanged(s, c)) && (c && c.length && (flushPathDrawn(t, r), t.restore(), u = l = !0, r.prevElClipPaths = null, r.allClipped = !1, r.prevEl = null), s && s.length && (flushPathDrawn(t, r), t.save(), updateClipStatus(s, t, r), l = !0), r.prevElClipPaths = s), r.allClipped) {
		n.__isRendered = !1;
		return;
	}
	n.beforeBrush && n.beforeBrush(), n.innerBeforeBrush();
	var d = r.prevEl;
	d || (u = l = !0);
	var f = n instanceof Path_default && n.autoBatch && canPathBatch(n.style);
	l || isTransformChanged(o, d.transform) ? (flushPathDrawn(t, r), setContextTransform(t, n)) : f || flushPathDrawn(t, r);
	var p = getStyle(n, r.inHover);
	n instanceof Path_default ? (r.lastDrawType !== DRAW_TYPE_PATH && (u = !0, r.lastDrawType = DRAW_TYPE_PATH), bindPathAndTextCommonStyle(t, n, d, u, r), (!f || !r.batchFill && !r.batchStroke) && t.beginPath(), brushPath(t, n, p, f), f && (r.batchFill = p.fill || "", r.batchStroke = p.stroke || "")) : n instanceof TSpan_default ? (r.lastDrawType !== DRAW_TYPE_TEXT && (u = !0, r.lastDrawType = DRAW_TYPE_TEXT), bindPathAndTextCommonStyle(t, n, d, u, r), brushText(t, n, p)) : n instanceof Image_default ? (r.lastDrawType !== DRAW_TYPE_IMAGE && (u = !0, r.lastDrawType = DRAW_TYPE_IMAGE), bindImageStyle(t, n, d, u, r), brushImage(t, n, p)) : n.getTemporalDisplayables && (r.lastDrawType !== DRAW_TYPE_INCREMENTAL && (u = !0, r.lastDrawType = DRAW_TYPE_INCREMENTAL), brushIncremental(t, n, r)), f && a && flushPathDrawn(t, r), n.innerAfterBrush(), n.afterBrush && n.afterBrush(), r.prevEl = n, n.__dirty = 0, n.__isRendered = !0;
}
function brushIncremental(t, n, r) {
	var a = n.getDisplayables(), o = n.getTemporalDisplayables();
	t.save();
	var s = {
		prevElClipPaths: null,
		prevEl: null,
		allClipped: !1,
		viewWidth: r.viewWidth,
		viewHeight: r.viewHeight,
		inHover: r.inHover
	}, c, l;
	for (c = n.getCursor(), l = a.length; c < l; c++) {
		var u = a[c];
		u.beforeBrush && u.beforeBrush(), u.innerBeforeBrush(), brush(t, u, s, c === l - 1), u.innerAfterBrush(), u.afterBrush && u.afterBrush(), s.prevEl = u;
	}
	for (var d = 0, f = o.length; d < f; d++) {
		var u = o[d];
		u.beforeBrush && u.beforeBrush(), u.innerBeforeBrush(), brush(t, u, s, d === f - 1), u.innerAfterBrush(), u.afterBrush && u.afterBrush(), s.prevEl = u;
	}
	n.clearTemporalDisplayables(), n.notClear = !0, t.restore();
}
init_dist$2();
var decalMap = new WeakMap_default(), decalCache = new LRU_default(100), decalKeys = [
	"symbol",
	"symbolSize",
	"symbolKeepAspect",
	"color",
	"backgroundColor",
	"dashArrayX",
	"dashArrayY",
	"maxTileWidth",
	"maxTileHeight"
];
function createOrUpdatePatternFromDecal(t, n) {
	if (t === "none") return null;
	var r = n.getDevicePixelRatio(), a = n.getZr(), o = a.painter.type === "svg";
	t.dirty && decalMap.delete(t);
	var c = decalMap.get(t);
	if (c) return c;
	var l = defaults(t, {
		symbol: "rect",
		symbolSize: 1,
		symbolKeepAspect: !0,
		color: "rgba(0, 0, 0, 0.2)",
		backgroundColor: null,
		dashArrayX: 5,
		dashArrayY: 5,
		rotation: 0,
		maxTileWidth: 512,
		maxTileHeight: 512
	});
	l.backgroundColor === "none" && (l.backgroundColor = null);
	var u = { repeat: "repeat" };
	return d(u), u.rotation = l.rotation, u.scaleX = u.scaleY = o ? 1 : 1 / r, decalMap.set(t, u), t.dirty = !1, u;
	function d(t) {
		for (var n = [r], c = !0, u = 0; u < decalKeys.length; ++u) {
			var d = l[decalKeys[u]];
			if (d != null && !isArray(d) && !isString(d) && !isNumber(d) && typeof d != "boolean") {
				c = !1;
				break;
			}
			n.push(d);
		}
		var f;
		if (c) {
			f = n.join(",") + (o ? "-svg" : "");
			var p = decalCache.get(f);
			p && (o ? t.svgElement = p : t.image = p);
		}
		var h = normalizeDashArrayX(l.dashArrayX), g = normalizeDashArrayY(l.dashArrayY), _ = normalizeSymbolArray(l.symbol), v = getLineBlockLengthX(h), y = getLineBlockLengthY(g), b = !o && platformApi.createCanvas(), x = o && {
			tag: "g",
			attrs: {},
			key: "dcl",
			children: []
		}, C = T(), w;
		b && (b.width = C.width * r, b.height = C.height * r, w = b.getContext("2d")), E(), c && decalCache.put(f, b || x), t.image = b, t.svgElement = x, t.svgWidth = C.width, t.svgHeight = C.height;
		function T() {
			for (var t = 1, n = 0, r = v.length; n < r; ++n) t = getLeastCommonMultiple(t, v[n]);
			for (var a = 1, n = 0, r = _.length; n < r; ++n) a = getLeastCommonMultiple(a, _[n].length);
			t *= a;
			var o = y * v.length * _.length;
			if (process$1.env.NODE_ENV !== "production") {
				var c = function(t) {
					console.warn("Calculated decal size is greater than " + t + " due to decal option settings so " + t + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + t + " to be larger to avoid incontinuity.");
				};
				t > l.maxTileWidth && c("maxTileWidth"), o > l.maxTileHeight && c("maxTileHeight");
			}
			return {
				width: Math.max(1, Math.min(t, l.maxTileWidth)),
				height: Math.max(1, Math.min(o, l.maxTileHeight))
			};
		}
		function E() {
			w && (w.clearRect(0, 0, b.width, b.height), l.backgroundColor && (w.fillStyle = l.backgroundColor, w.fillRect(0, 0, b.width, b.height)));
			for (var t = 0, n = 0; n < g.length; ++n) t += g[n];
			if (t <= 0) return;
			for (var s = -y, c = 0, u = 0, d = 0; s < C.height;) {
				if (c % 2 == 0) {
					for (var f = u / 2 % _.length, p = 0, v = 0, S = 0; p < C.width * 2;) {
						for (var T = 0, n = 0; n < h[d].length; ++n) T += h[d][n];
						if (T <= 0) break;
						if (v % 2 == 0) {
							var E = (1 - l.symbolSize) * .5, D = p + h[d][v] * E, O = s + g[c] * E, A = h[d][v] * l.symbolSize, j = g[c] * l.symbolSize, M = S / 2 % _[f].length;
							N(D, O, A, j, _[f][M]);
						}
						p += h[d][v], ++S, ++v, v === h[d].length && (v = 0);
					}
					++d, d === h.length && (d = 0);
				}
				s += g[c], ++u, ++c, c === g.length && (c = 0);
			}
			function N(t, n, s, c, u) {
				var d = o ? 1 : r, f = createSymbol(u, t * d, n * d, s * d, c * d, l.color, l.symbolKeepAspect);
				if (o) {
					var p = a.painter.renderOneToVNode(f);
					p && x.children.push(p);
				} else brushSingle(w, f);
			}
		}
	}
}
function normalizeSymbolArray(t) {
	if (!t || t.length === 0) return [["rect"]];
	if (isString(t)) return [[t]];
	for (var n = !0, r = 0; r < t.length; ++r) if (!isString(t[r])) {
		n = !1;
		break;
	}
	if (n) return normalizeSymbolArray([t]);
	for (var a = [], r = 0; r < t.length; ++r) isString(t[r]) ? a.push([t[r]]) : a.push(t[r]);
	return a;
}
function normalizeDashArrayX(t) {
	if (!t || t.length === 0) return [[0, 0]];
	if (isNumber(t)) {
		var n = Math.ceil(t);
		return [[n, n]];
	}
	for (var r = !0, a = 0; a < t.length; ++a) if (!isNumber(t[a])) {
		r = !1;
		break;
	}
	if (r) return normalizeDashArrayX([t]);
	for (var o = [], a = 0; a < t.length; ++a) if (isNumber(t[a])) {
		var n = Math.ceil(t[a]);
		o.push([n, n]);
	} else {
		var n = map(t[a], function(t) {
			return Math.ceil(t);
		});
		n.length % 2 == 1 ? o.push(n.concat(n)) : o.push(n);
	}
	return o;
}
function normalizeDashArrayY(t) {
	if (!t || typeof t == "object" && t.length === 0) return [0, 0];
	if (isNumber(t)) {
		var n = Math.ceil(t);
		return [n, n];
	}
	var r = map(t, function(t) {
		return Math.ceil(t);
	});
	return t.length % 2 ? r.concat(r) : r;
}
function getLineBlockLengthX(t) {
	return map(t, function(t) {
		return getLineBlockLengthY(t);
	});
}
function getLineBlockLengthY(t) {
	for (var n = 0, r = 0; r < t.length; ++r) n += t[r];
	return t.length % 2 == 1 ? n * 2 : n;
}
function decalVisual(t, n) {
	t.eachRawSeries(function(r) {
		if (!t.isSeriesFiltered(r)) {
			var a = r.getData();
			a.hasItemVisual() && a.each(function(t) {
				var r = a.getItemVisual(t, "decal");
				if (r) {
					var o = a.ensureUniqueItemVisual(t, "style");
					o.decal = createOrUpdatePatternFromDecal(r, n);
				}
			});
			var o = a.getVisual("decal");
			if (o) {
				var s = a.getVisual("style");
				s.decal = createOrUpdatePatternFromDecal(o, n);
			}
		}
	});
}
var lifecycle_default = new Eventful_default();
init_dist$2();
var implsStore = {};
function registerImpl(t, n) {
	process$1.env.NODE_ENV !== "production" && implsStore[t] && error("Already has an implementation of " + t + "."), implsStore[t] = n;
}
function getImpl(t) {
	return process$1.env.NODE_ENV !== "production" && (implsStore[t] || error("Implementation of " + t + " doesn't exists.")), implsStore[t];
}
init_dist$2();
var version = "5.6.0", dependencies = { zrender: "5.6.1" }, TEST_FRAME_REMAIN_TIME = 1, PRIORITY_PROCESSOR_SERIES_FILTER = 800, PRIORITY_PROCESSOR_DATASTACK = 900, PRIORITY_PROCESSOR_FILTER = 1e3, PRIORITY_PROCESSOR_DEFAULT = 2e3, PRIORITY_PROCESSOR_STATISTIC = 5e3, PRIORITY_VISUAL_LAYOUT = 1e3, PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100, PRIORITY_VISUAL_GLOBAL = 2e3, PRIORITY_VISUAL_CHART = 3e3, PRIORITY_VISUAL_COMPONENT = 4e3, PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500, PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600, PRIORITY_VISUAL_BRUSH = 5e3, PRIORITY_VISUAL_ARIA = 6e3, PRIORITY_VISUAL_DECAL = 7e3, PRIORITY = {
	PROCESSOR: {
		FILTER: PRIORITY_PROCESSOR_FILTER,
		SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
		STATISTIC: PRIORITY_PROCESSOR_STATISTIC
	},
	VISUAL: {
		LAYOUT: PRIORITY_VISUAL_LAYOUT,
		PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
		GLOBAL: PRIORITY_VISUAL_GLOBAL,
		CHART: PRIORITY_VISUAL_CHART,
		POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
		COMPONENT: PRIORITY_VISUAL_COMPONENT,
		BRUSH: PRIORITY_VISUAL_BRUSH,
		CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
		ARIA: PRIORITY_VISUAL_ARIA,
		DECAL: PRIORITY_VISUAL_DECAL
	}
}, IN_MAIN_PROCESS_KEY = "__flagInMainProcess", PENDING_UPDATE = "__pendingUpdate", STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus", ACTION_REG = /^[a-zA-Z0-9_]+$/, CONNECT_STATUS_KEY = "__connectUpdateStatus", CONNECT_STATUS_PENDING = 0, CONNECT_STATUS_UPDATING = 1, CONNECT_STATUS_UPDATED = 2;
function createRegisterEventWithLowercaseECharts(t) {
	return function() {
		var n = [...arguments];
		if (this.isDisposed()) {
			disposedWarning(this.id);
			return;
		}
		return toLowercaseNameAndCallEventful(this, t, n);
	};
}
function createRegisterEventWithLowercaseMessageCenter(t) {
	return function() {
		return toLowercaseNameAndCallEventful(this, t, [...arguments]);
	};
}
function toLowercaseNameAndCallEventful(t, n, r) {
	return r[0] = r[0] && r[0].toLowerCase(), Eventful_default.prototype[n].apply(t, r);
}
var MessageCenter = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n;
}(Eventful_default), messageCenterProto = MessageCenter.prototype;
messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on"), messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
var prepare, prepareView, updateDirectly, updateMethods, doConvertPixel, updateStreamModes, doDispatchAction, flushPendingActions, triggerUpdatedEvent, bindRenderedEvent, bindMouseEvent, render, renderComponents, renderSeries, createExtensionAPI, enableConnect, markStatusToUpdate, applyChangedStates, ECharts = function(t) {
	__extends(n, t);
	function n(n, a, o) {
		var c = t.call(this, new ECEventProcessor()) || this;
		c._chartsViews = [], c._chartsMap = {}, c._componentsViews = [], c._componentsMap = {}, c._pendingActions = [], o ||= {}, isString(a) && (a = themeStorage[a]), c._dom = n;
		var l = "canvas", u = "auto", d = !1;
		if (process$1.env.NODE_ENV !== "production") {
			var f = env_default.hasGlobalWindow ? window : global;
			f && (l = retrieve2(f.__ECHARTS__DEFAULT__RENDERER__, l), u = retrieve2(f.__ECHARTS__DEFAULT__COARSE_POINTER, u), d = retrieve2(f.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, d));
		}
		o.ssr && registerSSRDataGetter(function(t) {
			var n = getECData(t), r = n.dataIndex;
			if (r != null) {
				var a = createHashMap();
				return a.set("series_index", n.seriesIndex), a.set("data_index", r), n.ssrType && a.set("ssr_type", n.ssrType), a;
			}
		});
		var p = c._zr = init$2(n, {
			renderer: o.renderer || l,
			devicePixelRatio: o.devicePixelRatio,
			width: o.width,
			height: o.height,
			ssr: o.ssr,
			useDirtyRect: retrieve2(o.useDirtyRect, d),
			useCoarsePointer: retrieve2(o.useCoarsePointer, u),
			pointerSize: o.pointerSize
		});
		c._ssr = o.ssr, c._throttledZrFlush = throttle(bind(p.flush, p), 17), a = clone$1(a), a && globalBackwardCompat(a, !0), c._theme = a, c._locale = createLocaleObject(o.locale || SYSTEM_LANG), c._coordSysMgr = new CoordinateSystem_default();
		var g = c._api = createExtensionAPI(c);
		function _(t, n) {
			return t.__prio - n.__prio;
		}
		return sort$2(visualFuncs, _), sort$2(dataProcessorFuncs, _), c._scheduler = new Scheduler_default(c, g, dataProcessorFuncs, visualFuncs), c._messageCenter = new MessageCenter(), c._initEvents(), c.resize = bind(c.resize, c), p.animation.on("frame", c._onframe, c), bindRenderedEvent(p, c), bindMouseEvent(p, c), setAsPrimitive(c), c;
	}
	return n.prototype._onframe = function() {
		if (!this._disposed) {
			applyChangedStates(this);
			var t = this._scheduler;
			if (this[PENDING_UPDATE]) {
				var n = this[PENDING_UPDATE].silent;
				this[IN_MAIN_PROCESS_KEY] = !0;
				try {
					prepare(this), updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
				} catch (t) {
					throw this[IN_MAIN_PROCESS_KEY] = !1, this[PENDING_UPDATE] = null, t;
				}
				this._zr.flush(), this[IN_MAIN_PROCESS_KEY] = !1, this[PENDING_UPDATE] = null, flushPendingActions.call(this, n), triggerUpdatedEvent.call(this, n);
			} else if (t.unfinished) {
				var r = TEST_FRAME_REMAIN_TIME, a = this._model, o = this._api;
				t.unfinished = !1;
				do {
					var s = +/* @__PURE__ */ new Date();
					t.performSeriesTasks(a), t.performDataProcessorTasks(a), updateStreamModes(this, a), t.performVisualTasks(a), renderSeries(this, this._model, o, "remain", {}), r -= +/* @__PURE__ */ new Date() - s;
				} while (r > 0 && t.unfinished);
				t.unfinished || this._zr.flush();
			}
		}
	}, n.prototype.getDom = function() {
		return this._dom;
	}, n.prototype.getId = function() {
		return this.id;
	}, n.prototype.getZr = function() {
		return this._zr;
	}, n.prototype.isSSR = function() {
		return this._ssr;
	}, n.prototype.setOption = function(t, n, r) {
		if (this[IN_MAIN_PROCESS_KEY]) {
			process$1.env.NODE_ENV !== "production" && error("`setOption` should not be called during main process.");
			return;
		}
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var a, o, c;
		if (isObject(n) && (r = n.lazyUpdate, a = n.silent, o = n.replaceMerge, c = n.transition, n = n.notMerge), this[IN_MAIN_PROCESS_KEY] = !0, !this._model || n) {
			var l = new OptionManager_default(this._api), u = this._theme, d = this._model = new Global_default();
			d.scheduler = this._scheduler, d.ssr = this._ssr, d.init(null, null, null, u, this._locale, l);
		}
		this._model.setOption(t, { replaceMerge: o }, optionPreprocessorFuncs);
		var f = {
			seriesTransition: c,
			optionChanged: !0
		};
		if (r) this[PENDING_UPDATE] = {
			silent: a,
			updateParams: f
		}, this[IN_MAIN_PROCESS_KEY] = !1, this.getZr().wakeUp();
		else {
			try {
				prepare(this), updateMethods.update.call(this, null, f);
			} catch (t) {
				throw this[PENDING_UPDATE] = null, this[IN_MAIN_PROCESS_KEY] = !1, t;
			}
			this._ssr || this._zr.flush(), this[PENDING_UPDATE] = null, this[IN_MAIN_PROCESS_KEY] = !1, flushPendingActions.call(this, a), triggerUpdatedEvent.call(this, a);
		}
	}, n.prototype.setTheme = function() {
		deprecateLog("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
	}, n.prototype.getModel = function() {
		return this._model;
	}, n.prototype.getOption = function() {
		return this._model && this._model.getOption();
	}, n.prototype.getWidth = function() {
		return this._zr.getWidth();
	}, n.prototype.getHeight = function() {
		return this._zr.getHeight();
	}, n.prototype.getDevicePixelRatio = function() {
		return this._zr.painter.dpr || env_default.hasGlobalWindow && window.devicePixelRatio || 1;
	}, n.prototype.getRenderedCanvas = function(t) {
		return process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(t);
	}, n.prototype.renderToCanvas = function(t) {
		t ||= {};
		var n = this._zr.painter;
		if (process$1.env.NODE_ENV !== "production" && n.type !== "canvas") throw Error("renderToCanvas can only be used in the canvas renderer.");
		return n.getRenderedCanvas({
			backgroundColor: t.backgroundColor || this._model.get("backgroundColor"),
			pixelRatio: t.pixelRatio || this.getDevicePixelRatio()
		});
	}, n.prototype.renderToSVGString = function(t) {
		t ||= {};
		var n = this._zr.painter;
		if (process$1.env.NODE_ENV !== "production" && n.type !== "svg") throw Error("renderToSVGString can only be used in the svg renderer.");
		return n.renderToString({ useViewBox: t.useViewBox });
	}, n.prototype.getSvgDataURL = function() {
		if (env_default.svgSupported) {
			var t = this._zr;
			return each(t.storage.getDisplayList(), function(t) {
				t.stopAnimation(null, !0);
			}), t.painter.toDataURL();
		}
	}, n.prototype.getDataURL = function(t) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		t ||= {};
		var n = t.excludeComponents, r = this._model, a = [], o = this;
		each(n, function(t) {
			r.eachComponent({ mainType: t }, function(t) {
				var n = o._componentsMap[t.__viewId];
				n.group.ignore || (a.push(n), n.group.ignore = !0);
			});
		});
		var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(t).toDataURL("image/" + (t && t.type || "png"));
		return each(a, function(t) {
			t.group.ignore = !1;
		}), s;
	}, n.prototype.getConnectedDataURL = function(t) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var n = t.type === "svg", r = this.group, a = Math.min, o = Math.max, s = Infinity;
		if (connectedGroups[r]) {
			var c = s, l = s, u = -s, d = -s, f = [], p = t && t.pixelRatio || this.getDevicePixelRatio();
			each(instances, function(s, p) {
				if (s.group === r) {
					var h = n ? s.getZr().painter.getSvgDom().innerHTML : s.renderToCanvas(clone$1(t)), g = s.getDom().getBoundingClientRect();
					c = a(g.left, c), l = a(g.top, l), u = o(g.right, u), d = o(g.bottom, d), f.push({
						dom: h,
						left: g.left,
						top: g.top
					});
				}
			}), c *= p, l *= p, u *= p, d *= p;
			var h = u - c, g = d - l, _ = platformApi.createCanvas(), v = init$2(_, { renderer: n ? "svg" : "canvas" });
			if (v.resize({
				width: h,
				height: g
			}), n) {
				var y = "";
				return each(f, function(t) {
					var n = t.left - c, r = t.top - l;
					y += "<g transform=\"translate(" + n + "," + r + ")\">" + t.dom + "</g>";
				}), v.painter.getSvgRoot().innerHTML = y, t.connectedBackgroundColor && v.painter.setBackgroundColor(t.connectedBackgroundColor), v.refreshImmediately(), v.painter.toDataURL();
			} else return t.connectedBackgroundColor && v.add(new Rect_default({
				shape: {
					x: 0,
					y: 0,
					width: h,
					height: g
				},
				style: { fill: t.connectedBackgroundColor }
			})), each(f, function(t) {
				var n = new Image_default({ style: {
					x: t.left * p - c,
					y: t.top * p - l,
					image: t.dom
				} });
				v.add(n);
			}), v.refreshImmediately(), _.toDataURL("image/" + (t && t.type || "png"));
		} else return this.getDataURL(t);
	}, n.prototype.convertToPixel = function(t, n) {
		return doConvertPixel(this, "convertToPixel", t, n);
	}, n.prototype.convertFromPixel = function(t, n) {
		return doConvertPixel(this, "convertFromPixel", t, n);
	}, n.prototype.containPixel = function(t, n) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var r = this._model, a;
		return each(parseFinder(r, t), function(t, r) {
			r.indexOf("Models") >= 0 && each(t, function(t) {
				var o = t.coordinateSystem;
				if (o && o.containPoint) a ||= !!o.containPoint(n);
				else if (r === "seriesModels") {
					var c = this._chartsMap[t.__viewId];
					c && c.containPoint ? a ||= c.containPoint(n, t) : process$1.env.NODE_ENV !== "production" && warn(r + ": " + (c ? "The found component do not support containPoint." : "No view mapping to the found component."));
				} else process$1.env.NODE_ENV !== "production" && warn(r + ": containPoint is not supported");
			}, this);
		}, this), !!a;
	}, n.prototype.getVisual = function(t, n) {
		var r = this._model, a = parseFinder(r, t, { defaultMainType: "series" }), o = a.seriesModel;
		process$1.env.NODE_ENV !== "production" && (o || warn("There is no specified series model"));
		var c = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? c.indexOfRawIndex(a.dataIndex) : null;
		return l == null ? getVisualFromData(c, n) : getItemVisualFromData(c, l, n);
	}, n.prototype.getViewOfComponentModel = function(t) {
		return this._componentsMap[t.__viewId];
	}, n.prototype.getViewOfSeriesModel = function(t) {
		return this._chartsMap[t.__viewId];
	}, n.prototype._initEvents = function() {
		var t = this;
		each(MOUSE_EVENT_NAMES, function(n) {
			var r = function(r) {
				var a = t.getModel(), o = r.target, c, l = n === "globalout";
				if (l ? c = {} : o && findEventDispatcher(o, function(t) {
					var n = getECData(t);
					if (n && n.dataIndex != null) {
						var r = n.dataModel || a.getSeriesByIndex(n.seriesIndex);
						return c = r && r.getDataParams(n.dataIndex, n.dataType, o) || {}, !0;
					} else if (n.eventData) return c = extend({}, n.eventData), !0;
				}, !0), c) {
					var u = c.componentType, d = c.componentIndex;
					(u === "markLine" || u === "markPoint" || u === "markArea") && (u = "series", d = c.seriesIndex);
					var f = u && d != null && a.getComponent(u, d), p = f && t[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
					process$1.env.NODE_ENV !== "production" && !l && !(f && p) && warn("model or view can not be found by params"), c.event = r, c.type = n, t._$eventProcessor.eventInfo = {
						targetEl: o,
						packedEvent: c,
						model: f,
						view: p
					}, t.trigger(n, c);
				}
			};
			r.zrEventfulCallAtLast = !0, t._zr.on(n, r, t);
		}), each(eventActionMap, function(n, r) {
			t._messageCenter.on(r, function(t) {
				this.trigger(r, t);
			}, t);
		}), each(["selectchanged"], function(n) {
			t._messageCenter.on(n, function(t) {
				this.trigger(n, t);
			}, t);
		}), handleLegacySelectEvents(this._messageCenter, this, this._api);
	}, n.prototype.isDisposed = function() {
		return this._disposed;
	}, n.prototype.clear = function() {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		this.setOption({ series: [] }, !0);
	}, n.prototype.dispose = function() {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		this._disposed = !0, this.getDom() && setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
		var t = this, n = t._api, r = t._model;
		each(t._componentsViews, function(t) {
			t.dispose(r, n);
		}), each(t._chartsViews, function(t) {
			t.dispose(r, n);
		}), t._zr.dispose(), t._dom = t._model = t._chartsMap = t._componentsMap = t._chartsViews = t._componentsViews = t._scheduler = t._api = t._zr = t._throttledZrFlush = t._theme = t._coordSysMgr = t._messageCenter = null, delete instances[t.id];
	}, n.prototype.resize = function(t) {
		if (this[IN_MAIN_PROCESS_KEY]) {
			process$1.env.NODE_ENV !== "production" && error("`resize` should not be called during main process.");
			return;
		}
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		this._zr.resize(t);
		var n = this._model;
		if (this._loadingFX && this._loadingFX.resize(), n) {
			var r = n.resetOption("media"), a = t && t.silent;
			this[PENDING_UPDATE] && (a ??= this[PENDING_UPDATE].silent, r = !0, this[PENDING_UPDATE] = null), this[IN_MAIN_PROCESS_KEY] = !0;
			try {
				r && prepare(this), updateMethods.update.call(this, {
					type: "resize",
					animation: extend({ duration: 0 }, t && t.animation)
				});
			} catch (t) {
				throw this[IN_MAIN_PROCESS_KEY] = !1, t;
			}
			this[IN_MAIN_PROCESS_KEY] = !1, flushPendingActions.call(this, a), triggerUpdatedEvent.call(this, a);
		}
	}, n.prototype.showLoading = function(t, n) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		if (isObject(t) && (n = t, t = ""), t ||= "default", this.hideLoading(), !loadingEffects[t]) {
			process$1.env.NODE_ENV !== "production" && warn("Loading effects " + t + " not exists.");
			return;
		}
		var r = loadingEffects[t](this._api, n), a = this._zr;
		this._loadingFX = r, a.add(r);
	}, n.prototype.hideLoading = function() {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
	}, n.prototype.makeActionFromEvent = function(t) {
		var n = extend({}, t);
		return n.type = eventActionMap[t.type], n;
	}, n.prototype.dispatchAction = function(t, n) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		if (isObject(n) || (n = { silent: !!n }), actions[t.type] && this._model) {
			if (this[IN_MAIN_PROCESS_KEY]) {
				this._pendingActions.push(t);
				return;
			}
			var r = n.silent;
			doDispatchAction.call(this, t, r);
			var a = n.flush;
			a ? this._zr.flush() : a !== !1 && env_default.browser.weChat && this._throttledZrFlush(), flushPendingActions.call(this, r), triggerUpdatedEvent.call(this, r);
		}
	}, n.prototype.updateLabelLayout = function() {
		lifecycle_default.trigger("series:layoutlabels", this._model, this._api, { updatedSeries: [] });
	}, n.prototype.appendData = function(t) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var n = t.seriesIndex, r = this.getModel().getSeriesByIndex(n);
		process$1.env.NODE_ENV !== "production" && assert(t.data && r), r.appendData(t), this._scheduler.unfinished = !0, this.getZr().wakeUp();
	}, n.internalField = function() {
		prepare = function(t) {
			var n = t._scheduler;
			n.restorePipelines(t._model), n.prepareStageTasks(), prepareView(t, !0), prepareView(t, !1), n.plan();
		}, prepareView = function(t, n) {
			for (var r = t._model, a = t._scheduler, o = n ? t._componentsViews : t._chartsViews, c = n ? t._componentsMap : t._chartsMap, l = t._zr, u = t._api, d = 0; d < o.length; d++) o[d].__alive = !1;
			n ? r.eachComponent(function(t, n) {
				t !== "series" && f(n);
			}) : r.eachSeries(f);
			function f(t) {
				var d = t.__requireNewView;
				t.__requireNewView = !1;
				var f = "_ec_" + t.id + "_" + t.type, p = !d && c[f];
				if (!p) {
					var h = parseClassType(t.type), g = n ? Component_default$1.getClass(h.main, h.sub) : Chart_default.getClass(h.sub);
					process$1.env.NODE_ENV !== "production" && assert(g, h.sub + " does not exist."), p = new g(), p.init(r, u), c[f] = p, o.push(p), l.add(p.group);
				}
				t.__viewId = p.__id = f, p.__alive = !0, p.__model = t, p.group.__ecComponentInfo = {
					mainType: t.mainType,
					index: t.componentIndex
				}, !n && a.prepareView(p, t, r, u);
			}
			for (var d = 0; d < o.length;) {
				var p = o[d];
				p.__alive ? d++ : (!n && p.renderTask.dispose(), l.remove(p.group), p.dispose(r, u), o.splice(d, 1), c[p.__id] === p && delete c[p.__id], p.__id = p.group.__ecComponentInfo = null);
			}
		}, updateDirectly = function(t, n, r, a, o) {
			var s = t._model;
			if (s.setUpdatePayload(r), !a) {
				each([].concat(t._componentsViews, t._chartsViews), f);
				return;
			}
			var c = {};
			c[a + "Id"] = r[a + "Id"], c[a + "Index"] = r[a + "Index"], c[a + "Name"] = r[a + "Name"];
			var l = {
				mainType: a,
				query: c
			};
			o && (l.subType = o);
			var u = r.excludeSeriesId, d;
			u != null && (d = createHashMap(), each(normalizeToArray(u), function(t) {
				var n = convertOptionIdName(t, null);
				n != null && d.set(n, !0);
			})), s && s.eachComponent(l, function(n) {
				if (!(d && d.get(n.id) != null)) if (isHighDownPayload(r)) if (n instanceof Series_default) r.type === "highlight" && !r.notBlur && !n.get(["emphasis", "disabled"]) && blurSeriesFromHighlightPayload(n, r, t._api);
				else {
					var a = findComponentHighDownDispatchers(n.mainType, n.componentIndex, r.name, t._api), o = a.focusSelf, s = a.dispatchers;
					r.type === "highlight" && o && !r.notBlur && blurComponent(n.mainType, n.componentIndex, t._api), s && each(s, function(t) {
						r.type === "highlight" ? enterEmphasis(t) : leaveEmphasis(t);
					});
				}
				else isSelectChangePayload(r) && n instanceof Series_default && (toggleSelectionFromPayload(n, r, t._api), updateSeriesElementSelection(n), markStatusToUpdate(t));
			}, t), s && s.eachComponent(l, function(n) {
				d && d.get(n.id) != null || f(t[a === "series" ? "_chartsMap" : "_componentsMap"][n.__viewId]);
			}, t);
			function f(a) {
				a && a.__alive && a[n] && a[n](a.__model, s, t._api, r);
			}
		}, updateMethods = {
			prepareAndUpdate: function(t) {
				prepare(this), updateMethods.update.call(this, t, { optionChanged: t.newOption != null });
			},
			update: function(n, r) {
				var a = this._model, o = this._api, s = this._zr, c = this._coordSysMgr, l = this._scheduler;
				if (a) {
					a.setUpdatePayload(n), l.restoreData(a, n), l.performSeriesTasks(a), c.create(a, o), l.performDataProcessorTasks(a, n), updateStreamModes(this, a), c.update(a, o), t(a), l.performVisualTasks(a, n), render(this, a, o, n, r);
					var u = a.get("backgroundColor") || "transparent", d = a.get("darkMode");
					s.setBackgroundColor(u), d != null && d !== "auto" && s.setDarkMode(d), lifecycle_default.trigger("afterupdate", a, o);
				}
			},
			updateTransform: function(n) {
				var r = this, a = this._model, o = this._api;
				if (a) {
					a.setUpdatePayload(n);
					var s = [];
					a.eachComponent(function(t, c) {
						if (t !== "series") {
							var l = r.getViewOfComponentModel(c);
							if (l && l.__alive) if (l.updateTransform) {
								var u = l.updateTransform(c, a, o, n);
								u && u.update && s.push(l);
							} else s.push(l);
						}
					});
					var c = createHashMap();
					a.eachSeries(function(t) {
						var s = r._chartsMap[t.__viewId];
						if (s.updateTransform) {
							var l = s.updateTransform(t, a, o, n);
							l && l.update && c.set(t.uid, 1);
						} else c.set(t.uid, 1);
					}), t(a), this._scheduler.performVisualTasks(a, n, {
						setDirty: !0,
						dirtyMap: c
					}), renderSeries(this, a, o, n, {}, c), lifecycle_default.trigger("afterupdate", a, o);
				}
			},
			updateView: function(n) {
				var r = this._model;
				r && (r.setUpdatePayload(n), Chart_default.markUpdateMethod(n, "updateView"), t(r), this._scheduler.performVisualTasks(r, n, { setDirty: !0 }), render(this, r, this._api, n, {}), lifecycle_default.trigger("afterupdate", r, this._api));
			},
			updateVisual: function(n) {
				var r = this, a = this._model;
				a && (a.setUpdatePayload(n), a.eachSeries(function(t) {
					t.getData().clearAllVisual();
				}), Chart_default.markUpdateMethod(n, "updateVisual"), t(a), this._scheduler.performVisualTasks(a, n, {
					visualType: "visual",
					setDirty: !0
				}), a.eachComponent(function(t, o) {
					if (t !== "series") {
						var s = r.getViewOfComponentModel(o);
						s && s.__alive && s.updateVisual(o, a, r._api, n);
					}
				}), a.eachSeries(function(t) {
					r._chartsMap[t.__viewId].updateVisual(t, a, r._api, n);
				}), lifecycle_default.trigger("afterupdate", a, this._api));
			},
			updateLayout: function(t) {
				updateMethods.update.call(this, t);
			}
		}, doConvertPixel = function(t, n, r, a) {
			if (t._disposed) {
				disposedWarning(t.id);
				return;
			}
			for (var o = t._model, c = t._coordSysMgr.getCoordinateSystems(), l, u = parseFinder(o, r), d = 0; d < c.length; d++) {
				var f = c[d];
				if (f[n] && (l = f[n](o, u, a)) != null) return l;
			}
			process$1.env.NODE_ENV !== "production" && warn("No coordinate system that supports " + n + " found by the given finder.");
		}, updateStreamModes = function(t, n) {
			var r = t._chartsMap, a = t._scheduler;
			n.eachSeries(function(t) {
				a.updateStreamModes(t, r[t.__viewId]);
			});
		}, doDispatchAction = function(t, n) {
			var r = this, a = this.getModel(), o = t.type, s = t.escapeConnect, c = actions[o], l = c.actionInfo, u = (l.update || "update").split(":"), d = u.pop(), f = u[0] != null && parseClassType(u[0]);
			this[IN_MAIN_PROCESS_KEY] = !0;
			var p = [t], h = !1;
			t.batch && (h = !0, p = map(t.batch, function(n) {
				return n = defaults(extend({}, n), t), n.batch = null, n;
			}));
			var g = [], _, v = isSelectChangePayload(t), y = isHighDownPayload(t);
			if (y && allLeaveBlur(this._api), each(p, function(n) {
				if (_ = c.action(n, r._model, r._api), _ ||= extend({}, n), _.type = l.event || _.type, g.push(_), y) {
					var a = preParseFinder(t), o = a.queryOptionMap, s = a.mainTypeSpecified ? o.keys()[0] : "series";
					updateDirectly(r, d, n, s), markStatusToUpdate(r);
				} else v ? (updateDirectly(r, d, n, "series"), markStatusToUpdate(r)) : f && updateDirectly(r, d, n, f.main, f.sub);
			}), d !== "none" && !y && !v && !f) try {
				this[PENDING_UPDATE] ? (prepare(this), updateMethods.update.call(this, t), this[PENDING_UPDATE] = null) : updateMethods[d].call(this, t);
			} catch (t) {
				throw this[IN_MAIN_PROCESS_KEY] = !1, t;
			}
			if (_ = h ? {
				type: l.event || o,
				escapeConnect: s,
				batch: g
			} : g[0], this[IN_MAIN_PROCESS_KEY] = !1, !n) {
				var b = this._messageCenter;
				if (b.trigger(_.type, _), v) {
					var x = {
						type: "selectchanged",
						escapeConnect: s,
						selected: getAllSelectedIndices(a),
						isFromClick: t.isFromClick || !1,
						fromAction: t.type,
						fromActionPayload: t
					};
					b.trigger(x.type, x);
				}
			}
		}, flushPendingActions = function(t) {
			for (var n = this._pendingActions; n.length;) {
				var r = n.shift();
				doDispatchAction.call(this, r, t);
			}
		}, triggerUpdatedEvent = function(t) {
			!t && this.trigger("updated");
		}, bindRenderedEvent = function(t, n) {
			t.on("rendered", function(r) {
				n.trigger("rendered", r), t.animation.isFinished() && !n[PENDING_UPDATE] && !n._scheduler.unfinished && !n._pendingActions.length && n.trigger("finished");
			});
		}, bindMouseEvent = function(t, n) {
			t.on("mouseover", function(t) {
				var r = t.target, a = findEventDispatcher(r, isHighDownDispatcher);
				a && (handleGlobalMouseOverForHighDown(a, t, n._api), markStatusToUpdate(n));
			}).on("mouseout", function(t) {
				var r = t.target, a = findEventDispatcher(r, isHighDownDispatcher);
				a && (handleGlobalMouseOutForHighDown(a, t, n._api), markStatusToUpdate(n));
			}).on("click", function(t) {
				var r = t.target, a = findEventDispatcher(r, function(t) {
					return getECData(t).dataIndex != null;
				}, !0);
				if (a) {
					var o = a.selected ? "unselect" : "select", s = getECData(a);
					n._api.dispatchAction({
						type: o,
						dataType: s.dataType,
						dataIndexInside: s.dataIndex,
						seriesIndex: s.seriesIndex,
						isFromClick: !0
					});
				}
			});
		};
		function t(t) {
			t.clearColorPalette(), t.eachSeries(function(t) {
				t.clearColorPalette();
			});
		}
		function n(t) {
			var n = [], r = [], a = !1;
			if (t.eachComponent(function(t, o) {
				var s = o.get("zlevel") || 0, c = o.get("z") || 0, l = o.getZLevelKey();
				a ||= !!l, (t === "series" ? r : n).push({
					zlevel: s,
					z: c,
					idx: o.componentIndex,
					type: t,
					key: l
				});
			}), a) {
				var o = n.concat(r), s, c;
				sort$2(o, function(t, n) {
					return t.zlevel === n.zlevel ? t.z - n.z : t.zlevel - n.zlevel;
				}), each(o, function(n) {
					var r = t.getComponent(n.type, n.idx), a = n.zlevel, o = n.key;
					s != null && (a = Math.max(s, a)), o ? (a === s && o !== c && a++, c = o) : c &&= (a === s && a++, ""), s = a, r.setZLevel(a);
				});
			}
		}
		render = function(t, r, a, o, s) {
			n(r), renderComponents(t, r, a, o, s), each(t._chartsViews, function(t) {
				t.__alive = !1;
			}), renderSeries(t, r, a, o, s), each(t._chartsViews, function(t) {
				t.__alive || t.remove(r, a);
			});
		}, renderComponents = function(t, n, r, a, o, s) {
			each(s || t._componentsViews, function(t) {
				var o = t.__model;
				d(o, t), t.render(o, n, r, a), c(o, t), f(o, t);
			});
		}, renderSeries = function(t, n, r, s, l, u) {
			var p = t._scheduler;
			l = extend(l || {}, { updatedSeries: n.getSeries() }), lifecycle_default.trigger("series:beforeupdate", n, r, l);
			var h = !1;
			n.eachSeries(function(n) {
				var r = t._chartsMap[n.__viewId];
				r.__alive = !0;
				var a = r.renderTask;
				p.updatePayload(a, s), d(n, r), u && u.get(n.uid) && a.dirty(), a.perform(p.getPerformArgs(a)) && (h = !0), r.group.silent = !!n.get("silent"), o(n, r), updateSeriesElementSelection(n);
			}), p.unfinished = h || p.unfinished, lifecycle_default.trigger("series:layoutlabels", n, r, l), lifecycle_default.trigger("series:transition", n, r, l), n.eachSeries(function(n) {
				var r = t._chartsMap[n.__viewId];
				c(n, r), f(n, r);
			}), a(t, n), lifecycle_default.trigger("series:afterupdate", n, r, l);
		}, markStatusToUpdate = function(t) {
			t[STATUS_NEEDS_UPDATE_KEY] = !0, t.getZr().wakeUp();
		}, applyChangedStates = function(t) {
			t[STATUS_NEEDS_UPDATE_KEY] && (t.getZr().storage.traverse(function(t) {
				isElementRemoved(t) || r(t);
			}), t[STATUS_NEEDS_UPDATE_KEY] = !1);
		};
		function r(t) {
			for (var n = [], r = t.currentStates, a = 0; a < r.length; a++) {
				var o = r[a];
				o === "emphasis" || o === "blur" || o === "select" || n.push(o);
			}
			t.selected && t.states.select && n.push("select"), t.hoverState === 2 && t.states.emphasis ? n.push("emphasis") : t.hoverState === 1 && t.states.blur && n.push("blur"), t.useStates(n);
		}
		function a(t, n) {
			var r = t._zr.storage, a = 0;
			r.traverse(function(t) {
				t.isGroup || a++;
			}), a > n.get("hoverLayerThreshold") && !env_default.node && !env_default.worker && n.eachSeries(function(n) {
				if (!n.preventUsingHoverLayer) {
					var r = t._chartsMap[n.__viewId];
					r.__alive && r.eachRendered(function(t) {
						t.states.emphasis && (t.states.emphasis.hoverLayer = !0);
					});
				}
			});
		}
		function o(t, n) {
			var r = t.get("blendMode") || null;
			n.eachRendered(function(t) {
				t.isGroup || (t.style.blend = r);
			});
		}
		function c(t, n) {
			if (!t.preventAutoZ) {
				var r = t.get("z") || 0, a = t.get("zlevel") || 0;
				n.eachRendered(function(t) {
					return l(t, r, a, -Infinity), !0;
				});
			}
		}
		function l(t, n, r, a) {
			var o = t.getTextContent(), s = t.getTextGuideLine();
			if (t.isGroup) for (var c = t.childrenRef(), u = 0; u < c.length; u++) a = Math.max(l(c[u], n, r, a), a);
			else t.z = n, t.zlevel = r, a = Math.max(t.z2, a);
			if (o && (o.z = n, o.zlevel = r, isFinite(a) && (o.z2 = a + 2)), s) {
				var d = t.textGuideLineConfig;
				s.z = n, s.zlevel = r, isFinite(a) && (s.z2 = a + (d && d.showAbove ? 1 : -1));
			}
			return a;
		}
		function d(t, n) {
			n.eachRendered(function(t) {
				if (!isElementRemoved(t)) {
					var n = t.getTextContent(), r = t.getTextGuideLine();
					t.stateTransition &&= null, n && n.stateTransition && (n.stateTransition = null), r && r.stateTransition && (r.stateTransition = null), t.hasState() ? (t.prevStates = t.currentStates, t.clearStates()) : t.prevStates &&= null;
				}
			});
		}
		function f(t, n) {
			var a = t.getModel("stateAnimation"), o = t.isAnimationEnabled(), s = a.get("duration"), c = s > 0 ? {
				duration: s,
				delay: a.get("delay"),
				easing: a.get("easing")
			} : null;
			n.eachRendered(function(t) {
				if (t.states && t.states.emphasis) {
					if (isElementRemoved(t)) return;
					if (t instanceof Path_default && savePathStates(t), t.__dirty) {
						var n = t.prevStates;
						n && t.useStates(n);
					}
					if (o) {
						t.stateTransition = c;
						var a = t.getTextContent(), s = t.getTextGuideLine();
						a && (a.stateTransition = c), s && (s.stateTransition = c);
					}
					t.__dirty && r(t);
				}
			});
		}
		createExtensionAPI = function(t) {
			return new (function(n) {
				__extends(r, n);
				function r() {
					return n !== null && n.apply(this, arguments) || this;
				}
				return r.prototype.getCoordinateSystems = function() {
					return t._coordSysMgr.getCoordinateSystems();
				}, r.prototype.getComponentByElement = function(n) {
					for (; n;) {
						var r = n.__ecComponentInfo;
						if (r != null) return t._model.getComponent(r.mainType, r.index);
						n = n.parent;
					}
				}, r.prototype.enterEmphasis = function(n, r) {
					enterEmphasis(n, r), markStatusToUpdate(t);
				}, r.prototype.leaveEmphasis = function(n, r) {
					leaveEmphasis(n, r), markStatusToUpdate(t);
				}, r.prototype.enterBlur = function(n) {
					enterBlur(n), markStatusToUpdate(t);
				}, r.prototype.leaveBlur = function(n) {
					leaveBlur(n), markStatusToUpdate(t);
				}, r.prototype.enterSelect = function(n) {
					enterSelect(n), markStatusToUpdate(t);
				}, r.prototype.leaveSelect = function(n) {
					leaveSelect(n), markStatusToUpdate(t);
				}, r.prototype.getModel = function() {
					return t.getModel();
				}, r.prototype.getViewOfComponentModel = function(n) {
					return t.getViewOfComponentModel(n);
				}, r.prototype.getViewOfSeriesModel = function(n) {
					return t.getViewOfSeriesModel(n);
				}, r;
			}(ExtensionAPI_default))(t);
		}, enableConnect = function(t) {
			function n(t, n) {
				for (var r = 0; r < t.length; r++) {
					var a = t[r];
					a[CONNECT_STATUS_KEY] = n;
				}
			}
			each(eventActionMap, function(r, a) {
				t._messageCenter.on(a, function(r) {
					if (connectedGroups[t.group] && t[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
						if (r && r.escapeConnect) return;
						var a = t.makeActionFromEvent(r), o = [];
						each(instances, function(n) {
							n !== t && n.group === t.group && o.push(n);
						}), n(o, CONNECT_STATUS_PENDING), each(o, function(t) {
							t[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING && t.dispatchAction(a);
						}), n(o, CONNECT_STATUS_UPDATED);
					}
				});
			});
		};
	}(), n;
}(Eventful_default), echartsProto = ECharts.prototype;
echartsProto.on = createRegisterEventWithLowercaseECharts("on"), echartsProto.off = createRegisterEventWithLowercaseECharts("off"), echartsProto.one = function(t, n, r) {
	var a = this;
	deprecateLog("ECharts#one is deprecated.");
	function o() {
		var r = [...arguments];
		n && n.apply && n.apply(this, r), a.off(t, o);
	}
	this.on.call(this, t, o, r);
};
var MOUSE_EVENT_NAMES = [
	"click",
	"dblclick",
	"mouseover",
	"mouseout",
	"mousemove",
	"mousedown",
	"mouseup",
	"globalout",
	"contextmenu"
];
function disposedWarning(t) {
	process$1.env.NODE_ENV !== "production" && warn("Instance " + t + " has been disposed");
}
var actions = {}, eventActionMap = {}, dataProcessorFuncs = [], optionPreprocessorFuncs = [], visualFuncs = [], themeStorage = {}, loadingEffects = {}, instances = {}, connectedGroups = {}, idBase = /* @__PURE__ */ new Date() - 0, groupIdBase = /* @__PURE__ */ new Date() - 0, DOM_ATTRIBUTE_KEY = "_echarts_instance_";
function init(t, n, r) {
	var a = !(r && r.ssr);
	if (a) {
		if (process$1.env.NODE_ENV !== "production" && !t) throw Error("Initialize failed: invalid dom.");
		var o = getInstanceByDom(t);
		if (o) return process$1.env.NODE_ENV !== "production" && warn("There is a chart instance already initialized on the dom."), o;
		process$1.env.NODE_ENV !== "production" && isDom(t) && t.nodeName.toUpperCase() !== "CANVAS" && (!t.clientWidth && (!r || r.width == null) || !t.clientHeight && (!r || r.height == null)) && warn("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
	}
	var c = new ECharts(t, n, r);
	return c.id = "ec_" + idBase++, instances[c.id] = c, a && setAttribute(t, DOM_ATTRIBUTE_KEY, c.id), enableConnect(c), lifecycle_default.trigger("afterinit", c), c;
}
function connect(t) {
	if (isArray(t)) {
		var n = t;
		t = null, each(n, function(n) {
			n.group != null && (t = n.group);
		}), t ||= "g_" + groupIdBase++, each(n, function(n) {
			n.group = t;
		});
	}
	return connectedGroups[t] = !0, t;
}
function disconnect(t) {
	connectedGroups[t] = !1;
}
var disConnect = disconnect;
function dispose(t) {
	isString(t) ? t = instances[t] : t instanceof ECharts || (t = getInstanceByDom(t)), t instanceof ECharts && !t.isDisposed() && t.dispose();
}
function getInstanceByDom(t) {
	return instances[getAttribute(t, DOM_ATTRIBUTE_KEY)];
}
function getInstanceById(t) {
	return instances[t];
}
function registerTheme(t, n) {
	themeStorage[t] = n;
}
function registerPreprocessor(t) {
	indexOf(optionPreprocessorFuncs, t) < 0 && optionPreprocessorFuncs.push(t);
}
function registerProcessor(t, n) {
	normalizeRegister(dataProcessorFuncs, t, n, PRIORITY_PROCESSOR_DEFAULT);
}
function registerPostInit(t) {
	registerUpdateLifecycle("afterinit", t);
}
function registerPostUpdate(t) {
	registerUpdateLifecycle("afterupdate", t);
}
function registerUpdateLifecycle(t, n) {
	lifecycle_default.on(t, n);
}
function registerAction(t, n, r) {
	isFunction(n) && (r = n, n = "");
	var a = isObject(t) ? t.type : [t, t = { event: n }][0];
	t.event = (t.event || a).toLowerCase(), n = t.event, !eventActionMap[n] && (assert(ACTION_REG.test(a) && ACTION_REG.test(n)), actions[a] || (actions[a] = {
		action: r,
		actionInfo: t
	}), eventActionMap[n] = a);
}
function registerCoordinateSystem(t, n) {
	CoordinateSystem_default.register(t, n);
}
function getCoordinateSystemDimensions(t) {
	var n = CoordinateSystem_default.get(t);
	if (n) return n.getDimensionsInfo ? n.getDimensionsInfo() : n.dimensions.slice();
}
function registerLayout(t, n) {
	normalizeRegister(visualFuncs, t, n, PRIORITY_VISUAL_LAYOUT, "layout");
}
function registerVisual(t, n) {
	normalizeRegister(visualFuncs, t, n, PRIORITY_VISUAL_CHART, "visual");
}
var registeredTasks = [];
function normalizeRegister(t, n, r, a, o) {
	if ((isFunction(n) || isObject(n)) && (r = n, n = a), process$1.env.NODE_ENV !== "production") {
		if (isNaN(n) || n == null) throw Error("Illegal priority");
		each(t, function(t) {
			assert(t.__raw !== r);
		});
	}
	if (!(indexOf(registeredTasks, r) >= 0)) {
		registeredTasks.push(r);
		var c = Scheduler_default.wrapStageHandler(r, o);
		c.__prio = n, c.__raw = r, t.push(c);
	}
}
function registerLoading(t, n) {
	loadingEffects[t] = n;
}
function setCanvasCreator(t) {
	process$1.env.NODE_ENV !== "production" && deprecateLog("setCanvasCreator is deprecated. Use setPlatformAPI({ createCanvas }) instead."), setPlatformAPI({ createCanvas: t });
}
function registerMap(t, n, r) {
	var a = getImpl("registerMap");
	a && a(t, n, r);
}
function getMap(t) {
	var n = getImpl("getMap");
	return n && n(t);
}
var registerTransform = registerExternalTransform;
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask), registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask), registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask), registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask), registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask), registerVisual(PRIORITY_VISUAL_DECAL, decalVisual), registerPreprocessor(globalBackwardCompat), registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack$1), registerLoading("default", defaultLoading), registerAction({
	type: HIGHLIGHT_ACTION_TYPE,
	event: HIGHLIGHT_ACTION_TYPE,
	update: HIGHLIGHT_ACTION_TYPE
}, noop), registerAction({
	type: DOWNPLAY_ACTION_TYPE,
	event: DOWNPLAY_ACTION_TYPE,
	update: DOWNPLAY_ACTION_TYPE
}, noop), registerAction({
	type: SELECT_ACTION_TYPE,
	event: SELECT_ACTION_TYPE,
	update: SELECT_ACTION_TYPE
}, noop), registerAction({
	type: UNSELECT_ACTION_TYPE,
	event: UNSELECT_ACTION_TYPE,
	update: UNSELECT_ACTION_TYPE
}, noop), registerAction({
	type: TOGGLE_SELECT_ACTION_TYPE,
	event: TOGGLE_SELECT_ACTION_TYPE,
	update: TOGGLE_SELECT_ACTION_TYPE
}, noop), registerTheme("light", light_default), registerTheme("dark", dark_default);
var dataTool = {}, extensions = [], extensionRegisters = {
	registerPreprocessor,
	registerProcessor,
	registerPostInit,
	registerPostUpdate,
	registerUpdateLifecycle,
	registerAction,
	registerCoordinateSystem,
	registerLayout,
	registerVisual,
	registerTransform,
	registerLoading,
	registerMap,
	registerImpl,
	PRIORITY,
	ComponentModel: Component_default,
	ComponentView: Component_default$1,
	SeriesModel: Series_default,
	ChartView: Chart_default,
	registerComponentModel: function(t) {
		Component_default.registerClass(t);
	},
	registerComponentView: function(t) {
		Component_default$1.registerClass(t);
	},
	registerSeriesModel: function(t) {
		Series_default.registerClass(t);
	},
	registerChartView: function(t) {
		Chart_default.registerClass(t);
	},
	registerSubTypeDefaulter: function(t, n) {
		Component_default.registerSubTypeDefaulter(t, n);
	},
	registerPainter: function(t, n) {
		registerPainter(t, n);
	}
};
function use(t) {
	if (isArray(t)) {
		each(t, function(t) {
			use(t);
		});
		return;
	}
	indexOf(extensions, t) >= 0 || (extensions.push(t), isFunction(t) && (t = { install: t }), t.install(extensionRegisters));
}
function dataIndexMapValueLength(t) {
	return t == null ? 0 : t.length || 1;
}
function defaultKeyGetter(t) {
	return t;
}
var DataDiffer_default = function() {
	function t(t, n, r, a, o, s) {
		this._old = t, this._new = n, this._oldKeyGetter = r || defaultKeyGetter, this._newKeyGetter = a || defaultKeyGetter, this.context = o, this._diffModeMultiple = s === "multiple";
	}
	return t.prototype.add = function(t) {
		return this._add = t, this;
	}, t.prototype.update = function(t) {
		return this._update = t, this;
	}, t.prototype.updateManyToOne = function(t) {
		return this._updateManyToOne = t, this;
	}, t.prototype.updateOneToMany = function(t) {
		return this._updateOneToMany = t, this;
	}, t.prototype.updateManyToMany = function(t) {
		return this._updateManyToMany = t, this;
	}, t.prototype.remove = function(t) {
		return this._remove = t, this;
	}, t.prototype.execute = function() {
		this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
	}, t.prototype._executeOneToOne = function() {
		var t = this._old, n = this._new, r = {}, a = Array(t.length), o = Array(n.length);
		this._initIndexMap(t, null, a, "_oldKeyGetter"), this._initIndexMap(n, r, o, "_newKeyGetter");
		for (var s = 0; s < t.length; s++) {
			var c = a[s], l = r[c], u = dataIndexMapValueLength(l);
			if (u > 1) {
				var d = l.shift();
				l.length === 1 && (r[c] = l[0]), this._update && this._update(d, s);
			} else u === 1 ? (r[c] = null, this._update && this._update(l, s)) : this._remove && this._remove(s);
		}
		this._performRestAdd(o, r);
	}, t.prototype._executeMultiple = function() {
		var t = this._old, n = this._new, r = {}, a = {}, o = [], s = [];
		this._initIndexMap(t, r, o, "_oldKeyGetter"), this._initIndexMap(n, a, s, "_newKeyGetter");
		for (var c = 0; c < o.length; c++) {
			var l = o[c], u = r[l], d = a[l], f = dataIndexMapValueLength(u), p = dataIndexMapValueLength(d);
			if (f > 1 && p === 1) this._updateManyToOne && this._updateManyToOne(d, u), a[l] = null;
			else if (f === 1 && p > 1) this._updateOneToMany && this._updateOneToMany(d, u), a[l] = null;
			else if (f === 1 && p === 1) this._update && this._update(d, u), a[l] = null;
			else if (f > 1 && p > 1) this._updateManyToMany && this._updateManyToMany(d, u), a[l] = null;
			else if (f > 1) for (var h = 0; h < f; h++) this._remove && this._remove(u[h]);
			else this._remove && this._remove(u);
		}
		this._performRestAdd(s, a);
	}, t.prototype._performRestAdd = function(t, n) {
		for (var r = 0; r < t.length; r++) {
			var a = t[r], o = n[a], s = dataIndexMapValueLength(o);
			if (s > 1) for (var c = 0; c < s; c++) this._add && this._add(o[c]);
			else s === 1 && this._add && this._add(o);
			n[a] = null;
		}
	}, t.prototype._initIndexMap = function(t, n, r, a) {
		for (var o = this._diffModeMultiple, s = 0; s < t.length; s++) {
			var c = "_ec_" + this[a](t[s], s);
			if (o || (r[s] = c), n) {
				var l = n[c], u = dataIndexMapValueLength(l);
				u === 0 ? (n[c] = s, o && r.push(c)) : u === 1 ? n[c] = [l, s] : l.push(s);
			}
		}
	}, t;
}();
init_dist$2();
var DimensionUserOuput = function() {
	function t(t, n) {
		this._encode = t, this._schema = n;
	}
	return t.prototype.get = function() {
		return {
			fullDimensions: this._getFullDimensionNames(),
			encode: this._encode
		};
	}, t.prototype._getFullDimensionNames = function() {
		return this._cachedDimNames ||= this._schema ? this._schema.makeOutputDimensionNames() : [], this._cachedDimNames;
	}, t;
}();
function summarizeDimensions(t, n) {
	var r = {}, a = r.encode = {}, o = createHashMap(), c = [], l = [], u = {};
	each(t.dimensions, function(n) {
		var r = t.getDimensionInfo(n), d = r.coordDim;
		if (d) {
			process$1.env.NODE_ENV !== "production" && assert(VISUAL_DIMENSIONS.get(d) == null);
			var f = r.coordDimIndex;
			getOrCreateEncodeArr(a, d)[f] = n, r.isExtraCoord || (o.set(d, 1), mayLabelDimType(r.type) && (c[0] = n), getOrCreateEncodeArr(u, d)[f] = t.getDimensionIndex(r.name)), r.defaultTooltip && l.push(n);
		}
		VISUAL_DIMENSIONS.each(function(t, n) {
			var o = getOrCreateEncodeArr(a, n), s = r.otherDims[n];
			s != null && s !== !1 && (o[s] = r.name);
		});
	});
	var d = [], f = {};
	o.each(function(t, n) {
		var r = a[n];
		f[n] = r[0], d = d.concat(r);
	}), r.dataDimsOnCoord = d, r.dataDimIndicesOnCoord = map(d, function(n) {
		return t.getDimensionInfo(n).storeDimIndex;
	}), r.encodeFirstDimNotExtra = f;
	var p = a.label;
	p && p.length && (c = p.slice());
	var h = a.tooltip;
	return h && h.length ? l = h.slice() : l.length || (l = c.slice()), a.defaultedLabel = c, a.defaultedTooltip = l, r.userOutput = new DimensionUserOuput(u, n), r;
}
function getOrCreateEncodeArr(t, n) {
	return t.hasOwnProperty(n) || (t[n] = []), t[n];
}
function getDimensionTypeByAxis(t) {
	return t === "category" ? "ordinal" : t === "time" ? "time" : "float";
}
function mayLabelDimType(t) {
	return !(t === "ordinal" || t === "time");
}
var SeriesDimensionDefine_default = function() {
	function t(t) {
		this.otherDims = {}, t != null && extend(this, t);
	}
	return t;
}(), inner$17 = makeInner(), dimTypeShort = {
	float: "f",
	int: "i",
	ordinal: "o",
	number: "n",
	time: "t"
}, SeriesDataSchema = function() {
	function t(t) {
		this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted);
	}
	return t.prototype.isDimensionOmitted = function() {
		return this._dimOmitted;
	}, t.prototype._updateDimOmitted = function(t) {
		this._dimOmitted = t, t && (this._dimNameMap ||= ensureSourceDimNameMap(this.source));
	}, t.prototype.getSourceDimensionIndex = function(t) {
		return retrieve2(this._dimNameMap.get(t), -1);
	}, t.prototype.getSourceDimension = function(t) {
		var n = this.source.dimensionsDefine;
		if (n) return n[t];
	}, t.prototype.makeStoreSchema = function() {
		for (var t = this._fullDimCount, n = shouldRetrieveDataByName(this.source), r = !shouldOmitUnusedDimensions(t), a = "", o = [], s = 0, c = 0; s < t; s++) {
			var l = void 0, u = void 0, d = void 0, f = this.dimensions[c];
			if (f && f.storeDimIndex === s) l = n ? f.name : null, u = f.type, d = f.ordinalMeta, c++;
			else {
				var p = this.getSourceDimension(s);
				p && (l = n ? p.name : null, u = p.type);
			}
			o.push({
				property: l,
				type: u,
				ordinalMeta: d
			}), n && l != null && (!f || !f.isCalculationCoord) && (a += r ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), a += "$", a += dimTypeShort[u] || "f", d && (a += d.uid), a += "$";
		}
		var h = this.source;
		return {
			dimensions: o,
			hash: [
				h.seriesLayoutBy,
				h.startIndex,
				a
			].join("$$")
		};
	}, t.prototype.makeOutputDimensionNames = function() {
		for (var t = [], n = 0, r = 0; n < this._fullDimCount; n++) {
			var a = void 0, o = this.dimensions[r];
			if (o && o.storeDimIndex === n) o.isCalculationCoord || (a = o.name), r++;
			else {
				var s = this.getSourceDimension(n);
				s && (a = s.name);
			}
			t.push(a);
		}
		return t;
	}, t.prototype.appendCalculationDimension = function(t) {
		this.dimensions.push(t), t.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
	}, t;
}();
function isSeriesDataSchema(t) {
	return t instanceof SeriesDataSchema;
}
function createDimNameMap(t) {
	for (var n = createHashMap(), r = 0; r < (t || []).length; r++) {
		var a = t[r], o = isObject(a) ? a.name : a;
		o != null && n.get(o) == null && n.set(o, r);
	}
	return n;
}
function ensureSourceDimNameMap(t) {
	var n = inner$17(t);
	return n.dimNameMap ||= createDimNameMap(t.dimensionsDefine);
}
function shouldOmitUnusedDimensions(t) {
	return t > 30;
}
init_dist$2();
var isObject$2 = isObject, map$1 = map, CtorInt32Array$1 = typeof Int32Array > "u" ? Array : Int32Array, ID_PREFIX = "e\0\0", INDEX_NOT_FOUND = -1, TRANSFERABLE_PROPERTIES = [
	"hasItemOption",
	"_nameList",
	"_idList",
	"_invertedIndicesMap",
	"_dimSummary",
	"userOutput",
	"_rawData",
	"_dimValueGetter",
	"_nameDimIdx",
	"_idDimIdx",
	"_nameRepeatCount"
], CLONE_PROPERTIES = ["_approximateExtent"], prepareInvertedIndex, getId, getIdNameFromStore, normalizeDimensions, transferProperties, cloneListForMapAndSample, makeIdFromName, SeriesData_default = function() {
	function t(t, n) {
		this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = [
			"cloneShallow",
			"downSample",
			"minmaxDownSample",
			"lttbDownSample",
			"map"
		], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = [
			"downSample",
			"minmaxDownSample",
			"lttbDownSample"
		];
		var r, a = !1;
		isSeriesDataSchema(t) ? (r = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (a = !0, r = t), r ||= ["x", "y"];
		for (var o = {}, c = [], l = {}, u = !1, d = {}, f = 0; f < r.length; f++) {
			var p = r[f], h = isString(p) ? new SeriesDimensionDefine_default({ name: p }) : p instanceof SeriesDimensionDefine_default ? p : new SeriesDimensionDefine_default(p), g = h.name;
			h.type = h.type || "float", h.coordDim || (h.coordDim = g, h.coordDimIndex = 0);
			var _ = h.otherDims = h.otherDims || {};
			c.push(g), o[g] = h, d[g] != null && (u = !0), h.createInvertedIndices && (l[g] = []), _.itemName === 0 && (this._nameDimIdx = f), _.itemId === 0 && (this._idDimIdx = f), process$1.env.NODE_ENV !== "production" && assert(a || h.storeDimIndex >= 0), a && (h.storeDimIndex = f);
		}
		if (this.dimensions = c, this._dimInfos = o, this._initGetDimensionInfo(u), this.hostModel = n, this._invertedIndicesMap = l, this._dimOmitted) {
			var v = this._dimIdxToName = createHashMap();
			each(c, function(t) {
				v.set(o[t].storeDimIndex, t);
			});
		}
	}
	return t.prototype.getDimension = function(t) {
		var n = this._recognizeDimIndex(t);
		if (n == null) return t;
		if (n = t, !this._dimOmitted) return this.dimensions[n];
		var r = this._dimIdxToName.get(n);
		if (r != null) return r;
		var a = this._schema.getSourceDimension(n);
		if (a) return a.name;
	}, t.prototype.getDimensionIndex = function(t) {
		var n = this._recognizeDimIndex(t);
		if (n != null) return n;
		if (t == null) return -1;
		var r = this._getDimInfo(t);
		return r ? r.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1;
	}, t.prototype._recognizeDimIndex = function(t) {
		if (isNumber(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0)) return +t;
	}, t.prototype._getStoreDimIndex = function(t) {
		var n = this.getDimensionIndex(t);
		if (process$1.env.NODE_ENV !== "production" && n == null) throw Error("Unknown dimension " + t);
		return n;
	}, t.prototype.getDimensionInfo = function(t) {
		return this._getDimInfo(this.getDimension(t));
	}, t.prototype._initGetDimensionInfo = function(t) {
		var n = this._dimInfos;
		this._getDimInfo = t ? function(t) {
			return n.hasOwnProperty(t) ? n[t] : void 0;
		} : function(t) {
			return n[t];
		};
	}, t.prototype.getDimensionsOnCoord = function() {
		return this._dimSummary.dataDimsOnCoord.slice();
	}, t.prototype.mapDimension = function(t, n) {
		var r = this._dimSummary;
		if (n == null) return r.encodeFirstDimNotExtra[t];
		var a = r.encode[t];
		return a ? a[n] : null;
	}, t.prototype.mapDimensionsAll = function(t) {
		return (this._dimSummary.encode[t] || []).slice();
	}, t.prototype.getStore = function() {
		return this._store;
	}, t.prototype.initData = function(t, n, r) {
		var a = this, o;
		if (t instanceof DataStore_default && (o = t), !o) {
			var s = this.dimensions, c = isSourceInstance(t) || isArrayLike(t) ? new DefaultDataProvider(t, s.length) : t;
			o = new DataStore_default();
			var l = map$1(s, function(t) {
				return {
					type: a._dimInfos[t].type,
					property: t
				};
			});
			o.initData(c, l, r);
		}
		this._store = o, this._nameList = (n || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, o.count()), this._dimSummary = summarizeDimensions(this, this._schema), this.userOutput = this._dimSummary.userOutput;
	}, t.prototype.appendData = function(t) {
		var n = this._store.appendData(t);
		this._doInit(n[0], n[1]);
	}, t.prototype.appendValues = function(t, n) {
		var r = this._store.appendValues(t, n && n.length), a = r.start, o = r.end, s = this._shouldMakeIdFromName();
		if (this._updateOrdinalMeta(), n) for (var c = a; c < o; c++) {
			var l = c - a;
			this._nameList[c] = n[l], s && makeIdFromName(this, c);
		}
	}, t.prototype._updateOrdinalMeta = function() {
		for (var t = this._store, n = this.dimensions, r = 0; r < n.length; r++) {
			var a = this._dimInfos[n[r]];
			a.ordinalMeta && t.collectOrdinalMeta(a.storeDimIndex, a.ordinalMeta);
		}
	}, t.prototype._shouldMakeIdFromName = function() {
		var t = this._store.getProvider();
		return this._idDimIdx == null && t.getSource().sourceFormat !== "typedArray" && !t.fillStorage;
	}, t.prototype._doInit = function(t, n) {
		if (!(t >= n)) {
			var r = this._store.getProvider();
			this._updateOrdinalMeta();
			var a = this._nameList, o = this._idList;
			if (r.getSource().sourceFormat === "original" && !r.pure) for (var s = [], c = t; c < n; c++) {
				var l = r.getItem(c, s);
				if (!this.hasItemOption && isDataItemOption(l) && (this.hasItemOption = !0), l) {
					var u = l.name;
					a[c] == null && u != null && (a[c] = convertOptionIdName(u, null));
					var d = l.id;
					o[c] == null && d != null && (o[c] = convertOptionIdName(d, null));
				}
			}
			if (this._shouldMakeIdFromName()) for (var c = t; c < n; c++) makeIdFromName(this, c);
			prepareInvertedIndex(this);
		}
	}, t.prototype.getApproximateExtent = function(t) {
		return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t));
	}, t.prototype.setApproximateExtent = function(t, n) {
		n = this.getDimension(n), this._approximateExtent[n] = t.slice();
	}, t.prototype.getCalculationInfo = function(t) {
		return this._calculationInfo[t];
	}, t.prototype.setCalculationInfo = function(t, n) {
		isObject$2(t) ? extend(this._calculationInfo, t) : this._calculationInfo[t] = n;
	}, t.prototype.getName = function(t) {
		var n = this.getRawIndex(t), r = this._nameList[n];
		return r == null && this._nameDimIdx != null && (r = getIdNameFromStore(this, this._nameDimIdx, n)), r ??= "", r;
	}, t.prototype._getCategory = function(t, n) {
		var r = this._store.get(t, n), a = this._store.getOrdinalMeta(t);
		return a ? a.categories[r] : r;
	}, t.prototype.getId = function(t) {
		return getId(this, this.getRawIndex(t));
	}, t.prototype.count = function() {
		return this._store.count();
	}, t.prototype.get = function(t, n) {
		var r = this._store, a = this._dimInfos[t];
		if (a) return r.get(a.storeDimIndex, n);
	}, t.prototype.getByRawIndex = function(t, n) {
		var r = this._store, a = this._dimInfos[t];
		if (a) return r.getByRawIndex(a.storeDimIndex, n);
	}, t.prototype.getIndices = function() {
		return this._store.getIndices();
	}, t.prototype.getDataExtent = function(t) {
		return this._store.getDataExtent(this._getStoreDimIndex(t));
	}, t.prototype.getSum = function(t) {
		return this._store.getSum(this._getStoreDimIndex(t));
	}, t.prototype.getMedian = function(t) {
		return this._store.getMedian(this._getStoreDimIndex(t));
	}, t.prototype.getValues = function(t, n) {
		var r = this, a = this._store;
		return isArray(t) ? a.getValues(map$1(t, function(t) {
			return r._getStoreDimIndex(t);
		}), n) : a.getValues(t);
	}, t.prototype.hasValue = function(t) {
		for (var n = this._dimSummary.dataDimIndicesOnCoord, r = 0, a = n.length; r < a; r++) if (isNaN(this._store.get(n[r], t))) return !1;
		return !0;
	}, t.prototype.indexOfName = function(t) {
		for (var n = 0, r = this._store.count(); n < r; n++) if (this.getName(n) === t) return n;
		return -1;
	}, t.prototype.getRawIndex = function(t) {
		return this._store.getRawIndex(t);
	}, t.prototype.indexOfRawIndex = function(t) {
		return this._store.indexOfRawIndex(t);
	}, t.prototype.rawIndexOf = function(t, n) {
		var r = t && this._invertedIndicesMap[t];
		if (process$1.env.NODE_ENV !== "production" && !r) throw Error("Do not supported yet");
		var a = r && r[n];
		return a == null || isNaN(a) ? INDEX_NOT_FOUND : a;
	}, t.prototype.indicesOfNearest = function(t, n, r) {
		return this._store.indicesOfNearest(this._getStoreDimIndex(t), n, r);
	}, t.prototype.each = function(t, n, r) {
		isFunction(t) && (r = n, n = t, t = []);
		var a = r || this, o = map$1(normalizeDimensions(t), this._getStoreDimIndex, this);
		this._store.each(o, a ? bind(n, a) : n);
	}, t.prototype.filterSelf = function(t, n, r) {
		isFunction(t) && (r = n, n = t, t = []);
		var a = r || this, o = map$1(normalizeDimensions(t), this._getStoreDimIndex, this);
		return this._store = this._store.filter(o, a ? bind(n, a) : n), this;
	}, t.prototype.selectRange = function(t) {
		var n = this, r = {}, a = keys(t), o = [];
		return each(a, function(a) {
			var s = n._getStoreDimIndex(a);
			r[s] = t[a], o.push(s);
		}), this._store = this._store.selectRange(r), this;
	}, t.prototype.mapArray = function(t, n, r) {
		isFunction(t) && (r = n, n = t, t = []), r ||= this;
		var a = [];
		return this.each(t, function() {
			a.push(n && n.apply(this, arguments));
		}, r), a;
	}, t.prototype.map = function(t, n, r, a) {
		var o = r || a || this, s = map$1(normalizeDimensions(t), this._getStoreDimIndex, this), c = cloneListForMapAndSample(this);
		return c._store = this._store.map(s, o ? bind(n, o) : n), c;
	}, t.prototype.modify = function(t, n, r, a) {
		var o = this, c = r || a || this;
		process$1.env.NODE_ENV !== "production" && each(normalizeDimensions(t), function(t) {
			o.getDimensionInfo(t).isCalculationCoord || console.error("Danger: only stack dimension can be modified");
		});
		var l = map$1(normalizeDimensions(t), this._getStoreDimIndex, this);
		this._store.modify(l, c ? bind(n, c) : n);
	}, t.prototype.downSample = function(t, n, r, a) {
		var o = cloneListForMapAndSample(this);
		return o._store = this._store.downSample(this._getStoreDimIndex(t), n, r, a), o;
	}, t.prototype.minmaxDownSample = function(t, n) {
		var r = cloneListForMapAndSample(this);
		return r._store = this._store.minmaxDownSample(this._getStoreDimIndex(t), n), r;
	}, t.prototype.lttbDownSample = function(t, n) {
		var r = cloneListForMapAndSample(this);
		return r._store = this._store.lttbDownSample(this._getStoreDimIndex(t), n), r;
	}, t.prototype.getRawDataItem = function(t) {
		return this._store.getRawDataItem(t);
	}, t.prototype.getItemModel = function(t) {
		var n = this.hostModel;
		return new Model_default(this.getRawDataItem(t), n, n && n.ecModel);
	}, t.prototype.diff = function(t) {
		var n = this;
		return new DataDiffer_default(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function(n) {
			return getId(t, n);
		}, function(t) {
			return getId(n, t);
		});
	}, t.prototype.getVisual = function(t) {
		var n = this._visual;
		return n && n[t];
	}, t.prototype.setVisual = function(t, n) {
		this._visual = this._visual || {}, isObject$2(t) ? extend(this._visual, t) : this._visual[t] = n;
	}, t.prototype.getItemVisual = function(t, n) {
		var r = this._itemVisuals[t];
		return (r && r[n]) ?? this.getVisual(n);
	}, t.prototype.hasItemVisual = function() {
		return this._itemVisuals.length > 0;
	}, t.prototype.ensureUniqueItemVisual = function(t, n) {
		var r = this._itemVisuals, a = r[t];
		a ||= r[t] = {};
		var o = a[n];
		return o ?? (o = this.getVisual(n), isArray(o) ? o = o.slice() : isObject$2(o) && (o = extend({}, o)), a[n] = o), o;
	}, t.prototype.setItemVisual = function(t, n, r) {
		var a = this._itemVisuals[t] || {};
		this._itemVisuals[t] = a, isObject$2(n) ? extend(a, n) : a[n] = r;
	}, t.prototype.clearAllVisual = function() {
		this._visual = {}, this._itemVisuals = [];
	}, t.prototype.setLayout = function(t, n) {
		isObject$2(t) ? extend(this._layout, t) : this._layout[t] = n;
	}, t.prototype.getLayout = function(t) {
		return this._layout[t];
	}, t.prototype.getItemLayout = function(t) {
		return this._itemLayouts[t];
	}, t.prototype.setItemLayout = function(t, n, r) {
		this._itemLayouts[t] = r ? extend(this._itemLayouts[t] || {}, n) : n;
	}, t.prototype.clearItemLayouts = function() {
		this._itemLayouts.length = 0;
	}, t.prototype.setItemGraphicEl = function(t, n) {
		setCommonECData(this.hostModel && this.hostModel.seriesIndex, this.dataType, t, n), this._graphicEls[t] = n;
	}, t.prototype.getItemGraphicEl = function(t) {
		return this._graphicEls[t];
	}, t.prototype.eachItemGraphicEl = function(t, n) {
		each(this._graphicEls, function(r, a) {
			r && t && t.call(n, r, a);
		});
	}, t.prototype.cloneShallow = function(n) {
		return n ||= new t(this._schema ? this._schema : map$1(this.dimensions, this._getDimInfo, this), this.hostModel), transferProperties(n, this), n._store = this._store, n;
	}, t.prototype.wrapMethod = function(t, n) {
		var r = this[t];
		isFunction(r) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
			var t = r.apply(this, arguments);
			return n.apply(this, [t].concat(slice(arguments)));
		});
	}, t.internalField = function() {
		prepareInvertedIndex = function(t) {
			var n = t._invertedIndicesMap;
			each(n, function(r, a) {
				var o = t._dimInfos[a], s = o.ordinalMeta, c = t._store;
				if (s) {
					r = n[a] = new CtorInt32Array$1(s.categories.length);
					for (var l = 0; l < r.length; l++) r[l] = INDEX_NOT_FOUND;
					for (var l = 0; l < c.count(); l++) r[c.get(o.storeDimIndex, l)] = l;
				}
			});
		}, getIdNameFromStore = function(t, n, r) {
			return convertOptionIdName(t._getCategory(n, r), null);
		}, getId = function(t, n) {
			var r = t._idList[n];
			return r == null && t._idDimIdx != null && (r = getIdNameFromStore(t, t._idDimIdx, n)), r ??= ID_PREFIX + n, r;
		}, normalizeDimensions = function(t) {
			return isArray(t) || (t = t == null ? [] : [t]), t;
		}, cloneListForMapAndSample = function(n) {
			var r = new t(n._schema ? n._schema : map$1(n.dimensions, n._getDimInfo, n), n.hostModel);
			return transferProperties(r, n), r;
		}, transferProperties = function(t, n) {
			each(TRANSFERABLE_PROPERTIES.concat(n.__wrappedMethods || []), function(r) {
				n.hasOwnProperty(r) && (t[r] = n[r]);
			}), t.__wrappedMethods = n.__wrappedMethods, each(CLONE_PROPERTIES, function(r) {
				t[r] = clone$1(n[r]);
			}), t._calculationInfo = extend({}, n._calculationInfo);
		}, makeIdFromName = function(t, n) {
			var r = t._nameList, a = t._idList, o = t._nameDimIdx, s = t._idDimIdx, c = r[n], l = a[n];
			if (c == null && o != null && (r[n] = c = getIdNameFromStore(t, o, n)), l == null && s != null && (a[n] = l = getIdNameFromStore(t, s, n)), l == null && c != null) {
				var u = t._nameRepeatCount, d = u[c] = (u[c] || 0) + 1;
				l = c, d > 1 && (l += "__ec__" + d), a[n] = l;
			}
		};
	}(), t;
}();
function createDimensions(t, n) {
	return prepareSeriesDataSchema(t, n).dimensions;
}
function prepareSeriesDataSchema(t, n) {
	isSourceInstance(t) || (t = createSourceFromSeriesDataOption(t)), n ||= {};
	var r = n.coordDimensions || [], a = n.dimensionsDefine || t.dimensionsDefine || [], o = createHashMap(), s = [], c = getDimCount(t, r, a, n.dimensionsCount), l = n.canOmitUnusedDimensions && shouldOmitUnusedDimensions(c), u = a === t.dimensionsDefine, d = u ? ensureSourceDimNameMap(t) : createDimNameMap(a), f = n.encodeDefine;
	!f && n.encodeDefaulter && (f = n.encodeDefaulter(t, c));
	for (var p = createHashMap(f), h = new CtorInt32Array(c), g = 0; g < h.length; g++) h[g] = -1;
	function _(t) {
		var n = h[t];
		if (n < 0) {
			var r = a[t], o = isObject(r) ? r : { name: r }, c = new SeriesDimensionDefine_default(), l = o.name;
			return l != null && d.get(l) != null && (c.name = c.displayName = l), o.type != null && (c.type = o.type), o.displayName != null && (c.displayName = o.displayName), h[t] = s.length, c.storeDimIndex = t, s.push(c), c;
		}
		return s[n];
	}
	if (!l) for (var g = 0; g < c; g++) _(g);
	p.each(function(t, n) {
		var r = normalizeToArray(t).slice();
		if (r.length === 1 && !isString(r[0]) && r[0] < 0) {
			p.set(n, !1);
			return;
		}
		var a = p.set(n, []);
		each(r, function(t, r) {
			var o = isString(t) ? d.get(t) : t;
			o != null && o < c && (a[r] = o, y(_(o), n, r));
		});
	});
	var v = 0;
	each(r, function(t) {
		var n, r, a, o;
		if (isString(t)) n = t, o = {};
		else {
			o = t, n = o.name;
			var s = o.ordinalMeta;
			o.ordinalMeta = null, o = extend({}, o), o.ordinalMeta = s, r = o.dimsDef, a = o.otherDims, o.name = o.coordDim = o.coordDimIndex = o.dimsDef = o.otherDims = null;
		}
		var l = p.get(n);
		if (l !== !1) {
			if (l = normalizeToArray(l), !l.length) for (var d = 0; d < (r && r.length || 1); d++) {
				for (; v < c && _(v).coordDim != null;) v++;
				v < c && l.push(v++);
			}
			each(l, function(t, s) {
				var c = _(t);
				if (u && o.type != null && (c.type = o.type), y(defaults(c, o), n, s), c.name == null && r) {
					var l = r[s];
					!isObject(l) && (l = { name: l }), c.name = c.displayName = l.name, c.defaultTooltip = l.defaultTooltip;
				}
				a && defaults(c.otherDims, a);
			});
		}
	});
	function y(t, n, r) {
		VISUAL_DIMENSIONS.get(n) == null ? (t.coordDim = n, t.coordDimIndex = r, o.set(n, !0)) : t.otherDims[n] = r;
	}
	var b = n.generateCoord, x = n.generateCoordCount, S = x != null;
	x = b ? x || 1 : 0;
	var C = b || "value";
	function w(t) {
		t.name ??= t.coordDim;
	}
	if (l) each(s, function(t) {
		w(t);
	}), s.sort(function(t, n) {
		return t.storeDimIndex - n.storeDimIndex;
	});
	else for (var T = 0; T < c; T++) {
		var E = _(T);
		E.coordDim ?? (E.coordDim = genCoordDimName(C, o, S), E.coordDimIndex = 0, (!b || x <= 0) && (E.isExtraCoord = !0), x--), w(E), E.type == null && (guessOrdinal(t, T) === BE_ORDINAL.Must || E.isExtraCoord && (E.otherDims.itemName != null || E.otherDims.seriesName != null)) && (E.type = "ordinal");
	}
	return removeDuplication(s), new SeriesDataSchema({
		source: t,
		dimensions: s,
		fullDimensionCount: c,
		dimensionOmitted: l
	});
}
function removeDuplication(t) {
	for (var n = createHashMap(), r = 0; r < t.length; r++) {
		var a = t[r], o = a.name, s = n.get(o) || 0;
		s > 0 && (a.name = o + (s - 1)), s++, n.set(o, s);
	}
}
function getDimCount(t, n, r, a) {
	var o = Math.max(t.dimensionsDetectedCount || 1, n.length, r.length, a || 0);
	return each(n, function(t) {
		var n;
		isObject(t) && (n = t.dimsDef) && (o = Math.max(o, n.length));
	}), o;
}
function genCoordDimName(t, n, r) {
	if (r || n.hasKey(t)) {
		for (var a = 0; n.hasKey(t + a);) a++;
		t += a;
	}
	return n.set(t, !0), t;
}
init_dist$2();
var CoordSysInfo = function() {
	function t(t) {
		this.coordSysDims = [], this.axisMap = createHashMap(), this.categoryAxisMap = createHashMap(), this.coordSysName = t;
	}
	return t;
}();
function getCoordSysInfoBySeries(t) {
	var n = t.get("coordinateSystem"), r = new CoordSysInfo(n), a = fetchers[n];
	if (a) return a(t, r, r.axisMap, r.categoryAxisMap), r;
}
var fetchers = {
	cartesian2d: function(t, n, r, a) {
		var o = t.getReferringComponents("xAxis", SINGLE_REFERRING).models[0], c = t.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
		if (process$1.env.NODE_ENV !== "production") {
			if (!o) throw Error("xAxis \"" + retrieve(t.get("xAxisIndex"), t.get("xAxisId"), 0) + "\" not found");
			if (!c) throw Error("yAxis \"" + retrieve(t.get("xAxisIndex"), t.get("yAxisId"), 0) + "\" not found");
		}
		n.coordSysDims = ["x", "y"], r.set("x", o), r.set("y", c), isCategory(o) && (a.set("x", o), n.firstCategoryDimIndex = 0), isCategory(c) && (a.set("y", c), n.firstCategoryDimIndex ??= 1);
	},
	singleAxis: function(t, n, r, a) {
		var o = t.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
		if (process$1.env.NODE_ENV !== "production" && !o) throw Error("singleAxis should be specified.");
		n.coordSysDims = ["single"], r.set("single", o), isCategory(o) && (a.set("single", o), n.firstCategoryDimIndex = 0);
	},
	polar: function(t, n, r, a) {
		var o = t.getReferringComponents("polar", SINGLE_REFERRING).models[0], c = o.findAxisModel("radiusAxis"), l = o.findAxisModel("angleAxis");
		if (process$1.env.NODE_ENV !== "production") {
			if (!l) throw Error("angleAxis option not found");
			if (!c) throw Error("radiusAxis option not found");
		}
		n.coordSysDims = ["radius", "angle"], r.set("radius", c), r.set("angle", l), isCategory(c) && (a.set("radius", c), n.firstCategoryDimIndex = 0), isCategory(l) && (a.set("angle", l), n.firstCategoryDimIndex ??= 1);
	},
	geo: function(t, n, r, a) {
		n.coordSysDims = ["lng", "lat"];
	},
	parallel: function(t, n, r, a) {
		var o = t.ecModel, s = o.getComponent("parallel", t.get("parallelIndex")), c = n.coordSysDims = s.dimensions.slice();
		each(s.parallelAxisIndex, function(t, s) {
			var l = o.getComponent("parallelAxis", t), u = c[s];
			r.set(u, l), isCategory(l) && (a.set(u, l), n.firstCategoryDimIndex ??= s);
		});
	}
};
function isCategory(t) {
	return t.get("type") === "category";
}
function enableDataStack(t, n, r) {
	r ||= {};
	var a = r.byIndex, o = r.stackedCoordDimension, s, c, l;
	isLegacyDimensionsInput(n) ? s = n : (c = n.schema, s = c.dimensions, l = n.store);
	var u = !!(t && t.get("stack")), d, f, p, h;
	if (each(s, function(t, n) {
		isString(t) && (s[n] = t = { name: t }), u && !t.isExtraCoord && (!a && !d && t.ordinalMeta && (d = t), !f && t.type !== "ordinal" && t.type !== "time" && (!o || o === t.coordDim) && (f = t));
	}), f && !a && !d && (a = !0), f) {
		p = "__\0ecstackresult_" + t.id, h = "__\0ecstackedover_" + t.id, d && (d.createInvertedIndices = !0);
		var g = f.coordDim, _ = f.type, v = 0;
		each(s, function(t) {
			t.coordDim === g && v++;
		});
		var y = {
			name: p,
			coordDim: g,
			coordDimIndex: v,
			type: _,
			isExtraCoord: !0,
			isCalculationCoord: !0,
			storeDimIndex: s.length
		}, b = {
			name: h,
			coordDim: h,
			coordDimIndex: v + 1,
			type: _,
			isExtraCoord: !0,
			isCalculationCoord: !0,
			storeDimIndex: s.length + 1
		};
		c ? (l && (y.storeDimIndex = l.ensureCalculationDimension(h, _), b.storeDimIndex = l.ensureCalculationDimension(p, _)), c.appendCalculationDimension(y), c.appendCalculationDimension(b)) : (s.push(y), s.push(b));
	}
	return {
		stackedDimension: f && f.name,
		stackedByDimension: d && d.name,
		isStackedByIndex: a,
		stackedOverDimension: h,
		stackResultDimension: p
	};
}
function isLegacyDimensionsInput(t) {
	return !isSeriesDataSchema(t.schema);
}
function isDimensionStacked(t, n) {
	return !!n && n === t.getCalculationInfo("stackedDimension");
}
function getStackedDimension(t, n) {
	return isDimensionStacked(t, n) ? t.getCalculationInfo("stackResultDimension") : n;
}
function getCoordSysDimDefs(t, n) {
	var r = t.get("coordinateSystem"), a = CoordinateSystem_default.get(r), o;
	return n && n.coordSysDims && (o = map(n.coordSysDims, function(t) {
		var r = { name: t }, a = n.axisMap.get(t);
		return a && (r.type = getDimensionTypeByAxis(a.get("type"))), r;
	})), o ||= a && (a.getDimensionsInfo ? a.getDimensionsInfo() : a.dimensions.slice()) || ["x", "y"], o;
}
function injectOrdinalMeta(t, n, r) {
	var a, o;
	return r && each(t, function(t, s) {
		var c = t.coordDim, l = r.categoryAxisMap.get(c);
		l && (a ??= s, t.ordinalMeta = l.getOrdinalMeta(), n && (t.createInvertedIndices = !0)), t.otherDims.itemName != null && (o = !0);
	}), !o && a != null && (t[a].otherDims.itemName = 0), a;
}
function createSeriesData(t, n, r) {
	r ||= {};
	var a = n.getSourceManager(), o, s = !1;
	t ? (s = !0, o = createSourceFromSeriesDataOption(t)) : (o = a.getSource(), s = o.sourceFormat === SOURCE_FORMAT_ORIGINAL);
	var c = getCoordSysInfoBySeries(n), l = getCoordSysDimDefs(n, c), u = r.useEncodeDefaulter, d = isFunction(u) ? u : u ? curry(makeSeriesEncodeForAxisCoordSys, l, n) : null, f = {
		coordDimensions: l,
		generateCoord: r.generateCoord,
		encodeDefine: n.getEncode(),
		encodeDefaulter: d,
		canOmitUnusedDimensions: !s
	}, p = prepareSeriesDataSchema(o, f), h = injectOrdinalMeta(p.dimensions, r.createInvertedIndices, c), g = s ? null : a.getSharedDataStore(p), _ = enableDataStack(n, {
		schema: p,
		store: g
	}), v = new SeriesData_default(p, n);
	v.setCalculationInfo(_);
	var y = h != null && isNeedCompleteOrdinalData(o) ? function(t, n, r, a) {
		return a === h ? r : this.defaultDimValueGetter(t, n, r, a);
	} : null;
	return v.hasItemOption = !1, v.initData(s ? o : g, null, y), v;
}
function isNeedCompleteOrdinalData(t) {
	if (t.sourceFormat === "original") return !isArray(getDataItemValue(firstDataNotNull(t.data || [])));
}
function firstDataNotNull(t) {
	for (var n = 0; n < t.length && t[n] == null;) n++;
	return t[n];
}
var createSeriesData_default = createSeriesData, Scale = function() {
	function t(t) {
		this._setting = t || {}, this._extent = [Infinity, -Infinity];
	}
	return t.prototype.getSetting = function(t) {
		return this._setting[t];
	}, t.prototype.unionExtent = function(t) {
		var n = this._extent;
		t[0] < n[0] && (n[0] = t[0]), t[1] > n[1] && (n[1] = t[1]);
	}, t.prototype.unionExtentFromData = function(t, n) {
		this.unionExtent(t.getApproximateExtent(n));
	}, t.prototype.getExtent = function() {
		return this._extent.slice();
	}, t.prototype.setExtent = function(t, n) {
		var r = this._extent;
		isNaN(t) || (r[0] = t), isNaN(n) || (r[1] = n);
	}, t.prototype.isInExtentRange = function(t) {
		return this._extent[0] <= t && this._extent[1] >= t;
	}, t.prototype.isBlank = function() {
		return this._isBlank;
	}, t.prototype.setBlank = function(t) {
		this._isBlank = t;
	}, t;
}();
enableClassManagement(Scale);
var Scale_default = Scale, uidBase = 0, OrdinalMeta = function() {
	function t(t) {
		this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this.uid = ++uidBase;
	}
	return t.createByAxisModel = function(n) {
		var r = n.option, a = r.data, o = a && map(a, getName);
		return new t({
			categories: o,
			needCollect: !o,
			deduplication: r.dedplication !== !1
		});
	}, t.prototype.getOrdinal = function(t) {
		return this._getOrCreateMap().get(t);
	}, t.prototype.parseAndCollect = function(t) {
		var n, r = this._needCollect;
		if (!isString(t) && !r) return t;
		if (r && !this._deduplication) return n = this.categories.length, this.categories[n] = t, n;
		var a = this._getOrCreateMap();
		return n = a.get(t), n ?? (r ? (n = this.categories.length, this.categories[n] = t, a.set(t, n)) : n = NaN), n;
	}, t.prototype._getOrCreateMap = function() {
		return this._map ||= createHashMap(this.categories);
	}, t;
}();
function getName(t) {
	return isObject(t) && t.value != null ? t.value : t + "";
}
var OrdinalMeta_default = OrdinalMeta;
function isValueNice(t) {
	var n = 10 ** quantityExponent(Math.abs(t)), r = Math.abs(t / n);
	return r === 0 || r === 1 || r === 2 || r === 3 || r === 5;
}
function isIntervalOrLogScale(t) {
	return t.type === "interval" || t.type === "log";
}
function intervalScaleNiceTicks(t, n, r, a) {
	var o = {}, s = o.interval = nice((t[1] - t[0]) / n, !0);
	r != null && s < r && (s = o.interval = r), a != null && s > a && (s = o.interval = a);
	var c = o.intervalPrecision = getIntervalPrecision(s);
	return fixExtent(o.niceTickExtent = [round$1(Math.ceil(t[0] / s) * s, c), round$1(Math.floor(t[1] / s) * s, c)], t), o;
}
function increaseInterval(t) {
	var n = 10 ** quantityExponent(t), r = t / n;
	return r ? r === 2 ? r = 3 : r === 3 ? r = 5 : r *= 2 : r = 1, round$1(r * n);
}
function getIntervalPrecision(t) {
	return getPrecision(t) + 2;
}
function clamp(t, n, r) {
	t[n] = Math.max(Math.min(t[n], r[1]), r[0]);
}
function fixExtent(t, n) {
	!isFinite(t[0]) && (t[0] = n[0]), !isFinite(t[1]) && (t[1] = n[1]), clamp(t, 0, n), clamp(t, 1, n), t[0] > t[1] && (t[0] = t[1]);
}
function contain$1(t, n) {
	return t >= n[0] && t <= n[1];
}
function normalize$2(t, n) {
	return n[1] === n[0] ? .5 : (t - n[0]) / (n[1] - n[0]);
}
function scale(t, n) {
	return t * (n[1] - n[0]) + n[0];
}
var OrdinalScale = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this, n) || this;
		r.type = "ordinal";
		var a = r.getSetting("ordinalMeta");
		return a ||= new OrdinalMeta_default({}), isArray(a) && (a = new OrdinalMeta_default({ categories: map(a, function(t) {
			return isObject(t) ? t.value : t;
		}) })), r._ordinalMeta = a, r._extent = r.getSetting("extent") || [0, a.categories.length - 1], r;
	}
	return n.prototype.parse = function(t) {
		return t == null ? NaN : isString(t) ? this._ordinalMeta.getOrdinal(t) : Math.round(t);
	}, n.prototype.contain = function(t) {
		return t = this.parse(t), contain$1(t, this._extent) && this._ordinalMeta.categories[t] != null;
	}, n.prototype.normalize = function(t) {
		return t = this._getTickNumber(this.parse(t)), normalize$2(t, this._extent);
	}, n.prototype.scale = function(t) {
		return t = Math.round(scale(t, this._extent)), this.getRawOrdinalNumber(t);
	}, n.prototype.getTicks = function() {
		for (var t = [], n = this._extent, r = n[0]; r <= n[1];) t.push({ value: r }), r++;
		return t;
	}, n.prototype.getMinorTicks = function(t) {}, n.prototype.setSortInfo = function(t) {
		if (t == null) {
			this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
			return;
		}
		for (var n = t.ordinalNumbers, r = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], o = 0, s = this._ordinalMeta.categories.length, c = Math.min(s, n.length); o < c; ++o) {
			var l = n[o];
			r[o] = l, a[l] = o;
		}
		for (var u = 0; o < s; ++o) {
			for (; a[u] != null;) u++;
			r.push(u), a[u] = o;
		}
	}, n.prototype._getTickNumber = function(t) {
		var n = this._ticksByOrdinalNumber;
		return n && t >= 0 && t < n.length ? n[t] : t;
	}, n.prototype.getRawOrdinalNumber = function(t) {
		var n = this._ordinalNumbersByTick;
		return n && t >= 0 && t < n.length ? n[t] : t;
	}, n.prototype.getLabel = function(t) {
		if (!this.isBlank()) {
			var n = this.getRawOrdinalNumber(t.value), r = this._ordinalMeta.categories[n];
			return r == null ? "" : r + "";
		}
	}, n.prototype.count = function() {
		return this._extent[1] - this._extent[0] + 1;
	}, n.prototype.unionExtentFromData = function(t, n) {
		this.unionExtent(t.getApproximateExtent(n));
	}, n.prototype.isInExtentRange = function(t) {
		return t = this._getTickNumber(t), this._extent[0] <= t && this._extent[1] >= t;
	}, n.prototype.getOrdinalMeta = function() {
		return this._ordinalMeta;
	}, n.prototype.calcNiceTicks = function() {}, n.prototype.calcNiceExtent = function() {}, n.type = "ordinal", n;
}(Scale_default);
Scale_default.registerClass(OrdinalScale);
var Ordinal_default = OrdinalScale, roundNumber = round$1, IntervalScale = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n.type = "interval", n._interval = 0, n._intervalPrecision = 2, n;
	}
	return n.prototype.parse = function(t) {
		return t;
	}, n.prototype.contain = function(t) {
		return contain$1(t, this._extent);
	}, n.prototype.normalize = function(t) {
		return normalize$2(t, this._extent);
	}, n.prototype.scale = function(t) {
		return scale(t, this._extent);
	}, n.prototype.setExtent = function(t, n) {
		var r = this._extent;
		isNaN(t) || (r[0] = parseFloat(t)), isNaN(n) || (r[1] = parseFloat(n));
	}, n.prototype.unionExtent = function(t) {
		var n = this._extent;
		t[0] < n[0] && (n[0] = t[0]), t[1] > n[1] && (n[1] = t[1]), this.setExtent(n[0], n[1]);
	}, n.prototype.getInterval = function() {
		return this._interval;
	}, n.prototype.setInterval = function(t) {
		this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = getIntervalPrecision(t);
	}, n.prototype.getTicks = function(t) {
		var n = this._interval, r = this._extent, a = this._niceExtent, o = this._intervalPrecision, s = [];
		if (!n) return s;
		var c = 1e4;
		r[0] < a[0] && (t ? s.push({ value: roundNumber(a[0] - n, o) }) : s.push({ value: r[0] }));
		for (var l = a[0]; l <= a[1] && (s.push({ value: l }), l = roundNumber(l + n, o), l !== s[s.length - 1].value);) if (s.length > c) return [];
		var u = s.length ? s[s.length - 1].value : a[1];
		return r[1] > u && (t ? s.push({ value: roundNumber(u + n, o) }) : s.push({ value: r[1] })), s;
	}, n.prototype.getMinorTicks = function(t) {
		for (var n = this.getTicks(!0), r = [], a = this.getExtent(), o = 1; o < n.length; o++) {
			for (var s = n[o], c = n[o - 1], l = 0, u = [], d = (s.value - c.value) / t; l < t - 1;) {
				var f = roundNumber(c.value + (l + 1) * d);
				f > a[0] && f < a[1] && u.push(f), l++;
			}
			r.push(u);
		}
		return r;
	}, n.prototype.getLabel = function(t, n) {
		if (t == null) return "";
		var r = n && n.precision;
		return r == null ? r = getPrecision(t.value) || 0 : r === "auto" && (r = this._intervalPrecision), addCommas(roundNumber(t.value, r, !0));
	}, n.prototype.calcNiceTicks = function(t, n, r) {
		t ||= 5;
		var a = this._extent, o = a[1] - a[0];
		if (isFinite(o)) {
			o < 0 && (o = -o, a.reverse());
			var s = intervalScaleNiceTicks(a, t, n, r);
			this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
		}
	}, n.prototype.calcNiceExtent = function(t) {
		var n = this._extent;
		if (n[0] === n[1]) if (n[0] !== 0) {
			var r = Math.abs(n[0]);
			t.fixMax || (n[1] += r / 2), n[0] -= r / 2;
		} else n[1] = 1;
		var a = n[1] - n[0];
		isFinite(a) || (n[0] = 0, n[1] = 1), this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
		var o = this._interval;
		t.fixMin || (n[0] = roundNumber(Math.floor(n[0] / o) * o)), t.fixMax || (n[1] = roundNumber(Math.ceil(n[1] / o) * o));
	}, n.prototype.setNiceExtent = function(t, n) {
		this._niceExtent = [t, n];
	}, n.type = "interval", n;
}(Scale_default);
Scale_default.registerClass(IntervalScale);
var Interval_default = IntervalScale, supportFloat32Array = typeof Float32Array < "u", Float32ArrayCtor = supportFloat32Array ? Float32Array : Array;
function createFloat32Array(t) {
	return isArray(t) ? supportFloat32Array ? new Float32Array(t) : t : new Float32ArrayCtor(t);
}
var STACK_PREFIX = "__ec_stack_";
function getSeriesStackId$1(t) {
	return t.get("stack") || STACK_PREFIX + t.seriesIndex;
}
function getAxisKey$1(t) {
	return t.dim + t.index;
}
function getLayoutOnAxis(t) {
	var n = [], r = t.axis, a = "axis0";
	if (r.type === "category") {
		for (var o = r.getBandWidth(), s = 0; s < t.count; s++) n.push(defaults({
			bandWidth: o,
			axisKey: a,
			stackId: STACK_PREFIX + s
		}, t));
		for (var c = doCalBarWidthAndOffset(n), l = [], s = 0; s < t.count; s++) {
			var u = c[a][STACK_PREFIX + s];
			u.offsetCenter = u.offset + u.width / 2, l.push(u);
		}
		return l;
	}
}
function prepareLayoutBarSeries(t, n) {
	var r = [];
	return n.eachSeriesByType(t, function(t) {
		isOnCartesian(t) && r.push(t);
	}), r;
}
function getValueAxesMinGaps(t) {
	var n = {};
	each(t, function(t) {
		var r = t.coordinateSystem.getBaseAxis();
		if (!(r.type !== "time" && r.type !== "value")) for (var a = t.getData(), o = r.dim + "_" + r.index, s = a.getDimensionIndex(a.mapDimension(r.dim)), c = a.getStore(), l = 0, u = c.count(); l < u; ++l) {
			var d = c.get(s, l);
			n[o] ? n[o].push(d) : n[o] = [d];
		}
	});
	var r = {};
	for (var a in n) if (n.hasOwnProperty(a)) {
		var o = n[a];
		if (o) {
			o.sort(function(t, n) {
				return t - n;
			});
			for (var s = null, c = 1; c < o.length; ++c) {
				var l = o[c] - o[c - 1];
				l > 0 && (s = s === null ? l : Math.min(s, l));
			}
			r[a] = s;
		}
	}
	return r;
}
function makeColumnLayout(t) {
	var n = getValueAxesMinGaps(t), r = [];
	return each(t, function(t) {
		var a = t.coordinateSystem.getBaseAxis(), o = a.getExtent(), s;
		if (a.type === "category") s = a.getBandWidth();
		else if (a.type === "value" || a.type === "time") {
			var c = n[a.dim + "_" + a.index], l = Math.abs(o[1] - o[0]), u = a.scale.getExtent(), d = Math.abs(u[1] - u[0]);
			s = c ? l / d * c : l;
		} else {
			var f = t.getData();
			s = Math.abs(o[1] - o[0]) / f.count();
		}
		var p = parsePercent$1(t.get("barWidth"), s), h = parsePercent$1(t.get("barMaxWidth"), s), g = parsePercent$1(t.get("barMinWidth") || (isInLargeMode(t) ? .5 : 1), s), _ = t.get("barGap"), v = t.get("barCategoryGap");
		r.push({
			bandWidth: s,
			barWidth: p,
			barMaxWidth: h,
			barMinWidth: g,
			barGap: _,
			barCategoryGap: v,
			axisKey: getAxisKey$1(a),
			stackId: getSeriesStackId$1(t)
		});
	}), doCalBarWidthAndOffset(r);
}
function doCalBarWidthAndOffset(t) {
	var n = {};
	each(t, function(t, r) {
		var a = t.axisKey, o = t.bandWidth, s = n[a] || {
			bandWidth: o,
			remainedWidth: o,
			autoWidthCount: 0,
			categoryGap: null,
			gap: "20%",
			stacks: {}
		}, c = s.stacks;
		n[a] = s;
		var l = t.stackId;
		c[l] || s.autoWidthCount++, c[l] = c[l] || {
			width: 0,
			maxWidth: 0
		};
		var u = t.barWidth;
		u && !c[l].width && (c[l].width = u, u = Math.min(s.remainedWidth, u), s.remainedWidth -= u);
		var d = t.barMaxWidth;
		d && (c[l].maxWidth = d);
		var f = t.barMinWidth;
		f && (c[l].minWidth = f);
		var p = t.barGap;
		p != null && (s.gap = p);
		var h = t.barCategoryGap;
		h != null && (s.categoryGap = h);
	});
	var r = {};
	return each(n, function(t, n) {
		r[n] = {};
		var a = t.stacks, o = t.bandWidth, s = t.categoryGap;
		if (s == null) {
			var c = keys(a).length;
			s = Math.max(35 - c * 4, 15) + "%";
		}
		var l = parsePercent$1(s, o), u = parsePercent$1(t.gap, 1), d = t.remainedWidth, f = t.autoWidthCount, p = (d - l) / (f + (f - 1) * u);
		p = Math.max(p, 0), each(a, function(t) {
			var n = t.maxWidth, r = t.minWidth;
			if (t.width) {
				var a = t.width;
				n && (a = Math.min(a, n)), r && (a = Math.max(a, r)), t.width = a, d -= a + u * a, f--;
			} else {
				var a = p;
				n && n < a && (a = Math.min(n, d)), r && r > a && (a = r), a !== p && (t.width = a, d -= a + u * a, f--);
			}
		}), p = (d - l) / (f + (f - 1) * u), p = Math.max(p, 0);
		var h = 0, g;
		each(a, function(t, n) {
			t.width ||= p, g = t, h += t.width * (1 + u);
		}), g && (h -= g.width * u);
		var _ = -h / 2;
		each(a, function(t, a) {
			r[n][a] = r[n][a] || {
				bandWidth: o,
				offset: _,
				width: t.width
			}, _ += t.width * (1 + u);
		});
	}), r;
}
function retrieveColumnLayout(t, n, r) {
	if (t && n) {
		var a = t[getAxisKey$1(n)];
		return a != null && r != null ? a[getSeriesStackId$1(r)] : a;
	}
}
function layout$2(t, n) {
	var r = prepareLayoutBarSeries(t, n), a = makeColumnLayout(r);
	each(r, function(t) {
		var n = t.getData(), r = t.coordinateSystem.getBaseAxis(), o = getSeriesStackId$1(t), s = a[getAxisKey$1(r)][o], c = s.offset, l = s.width;
		n.setLayout({
			bandWidth: s.bandWidth,
			offset: c,
			size: l
		});
	});
}
function createProgressiveLayout(t) {
	return {
		seriesType: t,
		plan: createRenderPlanner(),
		reset: function(t) {
			if (isOnCartesian(t)) {
				var n = t.getData(), r = t.coordinateSystem, a = r.getBaseAxis(), o = r.getOtherAxis(a), s = n.getDimensionIndex(n.mapDimension(o.dim)), c = n.getDimensionIndex(n.mapDimension(a.dim)), l = t.get("showBackground", !0), u = n.mapDimension(o.dim), d = n.getCalculationInfo("stackResultDimension"), f = isDimensionStacked(n, u) && !!n.getCalculationInfo("stackedOnSeries"), p = o.isHorizontal(), h = getValueAxisStart(a, o), g = isInLargeMode(t), _ = t.get("barMinHeight") || 0, v = d && n.getDimensionIndex(d), y = n.getLayout("size"), b = n.getLayout("offset");
				return { progress: function(t, n) {
					for (var a = t.count, o = g && createFloat32Array(a * 3), u = g && l && createFloat32Array(a * 3), d = g && createFloat32Array(a), x = r.master.getRect(), S = p ? x.width : x.height, C, w = n.getStore(), T = 0; (C = t.next()) != null;) {
						var E = w.get(f ? v : s, C), D = w.get(c, C), O = h, A = void 0;
						f && (A = +E - w.get(s, C));
						var j = void 0, M = void 0, N = void 0, P = void 0;
						if (p) {
							var F = r.dataToPoint([E, D]);
							if (f) {
								var I = r.dataToPoint([A, D]);
								O = I[0];
							}
							j = O, M = F[1] + b, N = F[0] - O, P = y, Math.abs(N) < _ && (N = (N < 0 ? -1 : 1) * _);
						} else {
							var F = r.dataToPoint([D, E]);
							if (f) {
								var I = r.dataToPoint([D, A]);
								O = I[1];
							}
							j = F[0] + b, M = O, N = y, P = F[1] - O, Math.abs(P) < _ && (P = (P <= 0 ? -1 : 1) * _);
						}
						g ? (o[T] = j, o[T + 1] = M, o[T + 2] = p ? N : P, u && (u[T] = p ? x.x : j, u[T + 1] = p ? M : x.y, u[T + 2] = S), d[C] = C) : n.setItemLayout(C, {
							x: j,
							y: M,
							width: N,
							height: P
						}), T += 3;
					}
					g && n.setLayout({
						largePoints: o,
						largeDataIndices: d,
						largeBackgroundPoints: u,
						valueAxisHorizontal: p
					});
				} };
			}
		}
	};
}
function isOnCartesian(t) {
	return t.coordinateSystem && t.coordinateSystem.type === "cartesian2d";
}
function isInLargeMode(t) {
	return t.pipelineContext && t.pipelineContext.large;
}
function getValueAxisStart(t, n) {
	var r = n.model.get("startValue");
	return r ||= 0, n.toGlobalCoord(n.dataToCoord(n.type === "log" ? r > 0 ? r : 1 : r));
}
init_dist$2();
var bisect = function(t, n, r, a) {
	for (; r < a;) {
		var o = r + a >>> 1;
		t[o][1] < n ? r = o + 1 : a = o;
	}
	return r;
}, TimeScale = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this, n) || this;
		return r.type = "time", r;
	}
	return n.prototype.getLabel = function(t) {
		var n = this.getSetting("useUTC");
		return format(t.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, n, this.getSetting("locale"));
	}, n.prototype.getFormattedLabel = function(t, n, r) {
		var a = this.getSetting("useUTC");
		return leveledFormat(t, n, r, this.getSetting("locale"), a);
	}, n.prototype.getTicks = function() {
		var t = this._interval, n = this._extent, r = [];
		if (!t) return r;
		r.push({
			value: n[0],
			level: 0
		});
		var a = this.getSetting("useUTC"), o = getIntervalTicks(this._minLevelUnit, this._approxInterval, a, n);
		return r = r.concat(o), r.push({
			value: n[1],
			level: 0
		}), r;
	}, n.prototype.calcNiceExtent = function(t) {
		var n = this._extent;
		if (n[0] === n[1] && (n[0] -= ONE_DAY, n[1] += ONE_DAY), n[1] === -Infinity && n[0] === Infinity) {
			var r = /* @__PURE__ */ new Date();
			n[1] = +new Date(r.getFullYear(), r.getMonth(), r.getDate()), n[0] = n[1] - ONE_DAY;
		}
		this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
	}, n.prototype.calcNiceTicks = function(t, n, r) {
		t ||= 10;
		var a = this._extent;
		this._approxInterval = (a[1] - a[0]) / t, n != null && this._approxInterval < n && (this._approxInterval = n), r != null && this._approxInterval > r && (this._approxInterval = r);
		var o = scaleIntervals.length, s = Math.min(bisect(scaleIntervals, this._approxInterval, 0, o), o - 1);
		this._interval = scaleIntervals[s][1], this._minLevelUnit = scaleIntervals[Math.max(s - 1, 0)][0];
	}, n.prototype.parse = function(t) {
		return isNumber(t) ? t : +parseDate(t);
	}, n.prototype.contain = function(t) {
		return contain$1(this.parse(t), this._extent);
	}, n.prototype.normalize = function(t) {
		return normalize$2(this.parse(t), this._extent);
	}, n.prototype.scale = function(t) {
		return scale(t, this._extent);
	}, n.type = "time", n;
}(Interval_default), scaleIntervals = [
	["second", ONE_SECOND],
	["minute", ONE_MINUTE],
	["hour", ONE_HOUR],
	["quarter-day", ONE_HOUR * 6],
	["half-day", ONE_HOUR * 12],
	["day", ONE_DAY * 1.2],
	["half-week", ONE_DAY * 3.5],
	["week", ONE_DAY * 7],
	["month", ONE_DAY * 31],
	["quarter", ONE_DAY * 95],
	["half-year", ONE_YEAR / 2],
	["year", ONE_YEAR]
];
function isUnitValueSame(t, n, r, a) {
	var o = parseDate(n), s = parseDate(r), c = function(t) {
		return getUnitValue(o, t, a) === getUnitValue(s, t, a);
	}, l = function() {
		return c("year");
	}, u = function() {
		return l() && c("month");
	}, d = function() {
		return u() && c("day");
	}, f = function() {
		return d() && c("hour");
	}, p = function() {
		return f() && c("minute");
	}, h = function() {
		return p() && c("second");
	}, g = function() {
		return h() && c("millisecond");
	};
	switch (t) {
		case "year": return l();
		case "month": return u();
		case "day": return d();
		case "hour": return f();
		case "minute": return p();
		case "second": return h();
		case "millisecond": return g();
	}
}
function getDateInterval(t, n) {
	return t /= ONE_DAY, t > 16 ? 16 : t > 7.5 ? 7 : t > 3.5 ? 4 : t > 1.5 ? 2 : 1;
}
function getMonthInterval(t) {
	var n = 30 * ONE_DAY;
	return t /= n, t > 6 ? 6 : t > 3 ? 3 : t > 2 ? 2 : 1;
}
function getHourInterval(t) {
	return t /= ONE_HOUR, t > 12 ? 12 : t > 6 ? 6 : t > 3.5 ? 4 : t > 2 ? 2 : 1;
}
function getMinutesAndSecondsInterval(t, n) {
	return t /= n ? ONE_MINUTE : ONE_SECOND, t > 30 ? 30 : t > 20 ? 20 : t > 15 ? 15 : t > 10 ? 10 : t > 5 ? 5 : t > 2 ? 2 : 1;
}
function getMillisecondsInterval(t) {
	return nice(t, !0);
}
function getFirstTimestampOfUnit(t, n, r) {
	var a = new Date(t);
	switch (getPrimaryTimeUnit(n)) {
		case "year":
		case "month": a[monthSetterName(r)](0);
		case "day": a[dateSetterName(r)](1);
		case "hour": a[hoursSetterName(r)](0);
		case "minute": a[minutesSetterName(r)](0);
		case "second": a[secondsSetterName(r)](0), a[millisecondsSetterName(r)](0);
	}
	return a.getTime();
}
function getIntervalTicks(t, n, r, a) {
	var o = 1e4, c = timeUnits, l = 0;
	function u(t, n, r, o, s, c, l) {
		for (var u = new Date(n), d = n, f = u[o](); d < r && d <= a[1];) l.push({ value: d }), f += t, u[s](f), d = u.getTime();
		l.push({
			value: d,
			notAdd: !0
		});
	}
	function d(t, o, s) {
		var c = [], l = !o.length;
		if (!isUnitValueSame(getPrimaryTimeUnit(t), a[0], a[1], r)) {
			l && (o = [{ value: getFirstTimestampOfUnit(new Date(a[0]), t, r) }, { value: a[1] }]);
			for (var d = 0; d < o.length - 1; d++) {
				var f = o[d].value, p = o[d + 1].value;
				if (f !== p) {
					var h = void 0, g = void 0, _ = void 0, v = !1;
					switch (t) {
						case "year":
							h = Math.max(1, Math.round(n / ONE_DAY / 365)), g = fullYearGetterName(r), _ = fullYearSetterName(r);
							break;
						case "half-year":
						case "quarter":
						case "month":
							h = getMonthInterval(n), g = monthGetterName(r), _ = monthSetterName(r);
							break;
						case "week":
						case "half-week":
						case "day":
							h = getDateInterval(n, 31), g = dateGetterName(r), _ = dateSetterName(r), v = !0;
							break;
						case "half-day":
						case "quarter-day":
						case "hour":
							h = getHourInterval(n), g = hoursGetterName(r), _ = hoursSetterName(r);
							break;
						case "minute":
							h = getMinutesAndSecondsInterval(n, !0), g = minutesGetterName(r), _ = minutesSetterName(r);
							break;
						case "second":
							h = getMinutesAndSecondsInterval(n, !1), g = secondsGetterName(r), _ = secondsSetterName(r);
							break;
						case "millisecond":
							h = getMillisecondsInterval(n), g = millisecondsGetterName(r), _ = millisecondsSetterName(r);
							break;
					}
					u(h, f, p, g, _, v, c), t === "year" && s.length > 1 && d === 0 && s.unshift({ value: s[0].value - h });
				}
			}
			for (var d = 0; d < c.length; d++) s.push(c[d]);
			return c;
		}
	}
	for (var f = [], p = [], h = 0, g = 0, _ = 0; _ < c.length && l++ < o; ++_) {
		var v = getPrimaryTimeUnit(c[_]);
		if (isPrimaryTimeUnit(c[_]) && (d(c[_], f[f.length - 1] || [], p), v !== (c[_ + 1] ? getPrimaryTimeUnit(c[_ + 1]) : null))) {
			if (p.length) {
				g = h, p.sort(function(t, n) {
					return t.value - n.value;
				});
				for (var y = [], b = 0; b < p.length; ++b) {
					var x = p[b].value;
					(b === 0 || p[b - 1].value !== x) && (y.push(p[b]), x >= a[0] && x <= a[1] && h++);
				}
				var S = (a[1] - a[0]) / n;
				if (h > S * 1.5 && g > S / 1.5 || (f.push(y), h > S || t === c[_])) break;
			}
			p = [];
		}
	}
	process$1.env.NODE_ENV !== "production" && l >= o && warn("Exceed safe limit.");
	for (var C = filter(map(f, function(t) {
		return filter(t, function(t) {
			return t.value >= a[0] && t.value <= a[1] && !t.notAdd;
		});
	}), function(t) {
		return t.length > 0;
	}), w = [], T = C.length - 1, _ = 0; _ < C.length; ++_) for (var E = C[_], D = 0; D < E.length; ++D) w.push({
		value: E[D].value,
		level: T - _
	});
	w.sort(function(t, n) {
		return t.value - n.value;
	});
	for (var O = [], _ = 0; _ < w.length; ++_) (_ === 0 || w[_].value !== w[_ - 1].value) && O.push(w[_]);
	return O;
}
Scale_default.registerClass(TimeScale);
var Time_default = TimeScale, scaleProto = Scale_default.prototype, intervalScaleProto = Interval_default.prototype, roundingErrorFix = round$1, mathFloor$1 = Math.floor, mathCeil$1 = Math.ceil, mathPow$1 = Math.pow, mathLog$1 = Math.log, LogScale = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n.type = "log", n.base = 10, n._originalScale = new Interval_default(), n._interval = 0, n;
	}
	return n.prototype.getTicks = function(t) {
		var n = this._originalScale, r = this._extent, a = n.getExtent();
		return map(intervalScaleProto.getTicks.call(this, t), function(t) {
			var n = t.value, o = round$1(mathPow$1(this.base, n));
			return o = n === r[0] && this._fixMin ? fixRoundingError(o, a[0]) : o, o = n === r[1] && this._fixMax ? fixRoundingError(o, a[1]) : o, { value: o };
		}, this);
	}, n.prototype.setExtent = function(t, n) {
		var r = mathLog$1(this.base);
		t = mathLog$1(Math.max(0, t)) / r, n = mathLog$1(Math.max(0, n)) / r, intervalScaleProto.setExtent.call(this, t, n);
	}, n.prototype.getExtent = function() {
		var t = this.base, n = scaleProto.getExtent.call(this);
		n[0] = mathPow$1(t, n[0]), n[1] = mathPow$1(t, n[1]);
		var r = this._originalScale.getExtent();
		return this._fixMin && (n[0] = fixRoundingError(n[0], r[0])), this._fixMax && (n[1] = fixRoundingError(n[1], r[1])), n;
	}, n.prototype.unionExtent = function(t) {
		this._originalScale.unionExtent(t);
		var n = this.base;
		t[0] = mathLog$1(t[0]) / mathLog$1(n), t[1] = mathLog$1(t[1]) / mathLog$1(n), scaleProto.unionExtent.call(this, t);
	}, n.prototype.unionExtentFromData = function(t, n) {
		this.unionExtent(t.getApproximateExtent(n));
	}, n.prototype.calcNiceTicks = function(t) {
		t ||= 10;
		var n = this._extent, r = n[1] - n[0];
		if (!(r === Infinity || r <= 0)) {
			var a = quantity(r);
			for (t / r * a <= .5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0;) a *= 10;
			var o = [round$1(mathCeil$1(n[0] / a) * a), round$1(mathFloor$1(n[1] / a) * a)];
			this._interval = a, this._niceExtent = o;
		}
	}, n.prototype.calcNiceExtent = function(t) {
		intervalScaleProto.calcNiceExtent.call(this, t), this._fixMin = t.fixMin, this._fixMax = t.fixMax;
	}, n.prototype.parse = function(t) {
		return t;
	}, n.prototype.contain = function(t) {
		return t = mathLog$1(t) / mathLog$1(this.base), contain$1(t, this._extent);
	}, n.prototype.normalize = function(t) {
		return t = mathLog$1(t) / mathLog$1(this.base), normalize$2(t, this._extent);
	}, n.prototype.scale = function(t) {
		return t = scale(t, this._extent), mathPow$1(this.base, t);
	}, n.type = "log", n;
}(Scale_default), proto = LogScale.prototype;
proto.getMinorTicks = intervalScaleProto.getMinorTicks, proto.getLabel = intervalScaleProto.getLabel;
function fixRoundingError(t, n) {
	return roundingErrorFix(t, getPrecision(n));
}
Scale_default.registerClass(LogScale);
var Log_default = LogScale;
init_dist$2();
var ScaleRawExtentInfo = function() {
	function t(t, n, r) {
		this._prepareParams(t, n, r);
	}
	return t.prototype._prepareParams = function(t, n, r) {
		r[1] < r[0] && (r = [NaN, NaN]), this._dataMin = r[0], this._dataMax = r[1];
		var a = this._isOrdinal = t.type === "ordinal";
		this._needCrossZero = t.type === "interval" && n.getNeedCrossZero && n.getNeedCrossZero();
		var o = n.get("min", !0);
		o ??= n.get("startValue", !0);
		var c = this._modelMinRaw = o;
		isFunction(c) ? this._modelMinNum = parseAxisModelMinMax(t, c({
			min: r[0],
			max: r[1]
		})) : c !== "dataMin" && (this._modelMinNum = parseAxisModelMinMax(t, c));
		var l = this._modelMaxRaw = n.get("max", !0);
		if (isFunction(l) ? this._modelMaxNum = parseAxisModelMinMax(t, l({
			min: r[0],
			max: r[1]
		})) : l !== "dataMax" && (this._modelMaxNum = parseAxisModelMinMax(t, l)), a) this._axisDataLen = n.getCategories().length;
		else {
			var u = n.get("boundaryGap"), d = isArray(u) ? u : [u || 0, u || 0];
			typeof d[0] == "boolean" || typeof d[1] == "boolean" ? (process$1.env.NODE_ENV !== "production" && console.warn("Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., \"20%\". Currently, boundaryGap is set to be 0."), this._boundaryGapInner = [0, 0]) : this._boundaryGapInner = [parsePercent(d[0], 1), parsePercent(d[1], 1)];
		}
	}, t.prototype.calculate = function() {
		var t = this._isOrdinal, n = this._dataMin, r = this._dataMax, a = this._axisDataLen, o = this._boundaryGapInner, s = t ? null : r - n || Math.abs(n), c = this._modelMinRaw === "dataMin" ? n : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? r : this._modelMaxNum, u = c != null, d = l != null;
		c ??= t ? a ? 0 : NaN : n - o[0] * s, l ??= t ? a ? a - 1 : NaN : r + o[1] * s, (c == null || !isFinite(c)) && (c = NaN), (l == null || !isFinite(l)) && (l = NaN);
		var f = eqNaN(c) || eqNaN(l) || t && !a;
		this._needCrossZero && (c > 0 && l > 0 && !u && (c = 0), c < 0 && l < 0 && !d && (l = 0));
		var p = this._determinedMin, h = this._determinedMax;
		return p != null && (c = p, u = !0), h != null && (l = h, d = !0), {
			min: c,
			max: l,
			minFixed: u,
			maxFixed: d,
			isBlank: f
		};
	}, t.prototype.modifyDataMinMax = function(t, n) {
		process$1.env.NODE_ENV !== "production" && assert(!this.frozen), this[DATA_MIN_MAX_ATTR[t]] = n;
	}, t.prototype.setDeterminedMinMax = function(t, n) {
		var r = DETERMINED_MIN_MAX_ATTR[t];
		process$1.env.NODE_ENV !== "production" && assert(!this.frozen && this[r] == null), this[r] = n;
	}, t.prototype.freeze = function() {
		this.frozen = !0;
	}, t;
}(), DETERMINED_MIN_MAX_ATTR = {
	min: "_determinedMin",
	max: "_determinedMax"
}, DATA_MIN_MAX_ATTR = {
	min: "_dataMin",
	max: "_dataMax"
};
function ensureScaleRawExtentInfo(t, n, r) {
	var a = t.rawExtentInfo;
	return a || (a = new ScaleRawExtentInfo(t, n, r), t.rawExtentInfo = a, a);
}
function parseAxisModelMinMax(t, n) {
	return n == null ? null : eqNaN(n) ? NaN : t.parse(n);
}
function getScaleExtent(t, n) {
	var r = t.type, a = ensureScaleRawExtentInfo(t, n, t.getExtent()).calculate();
	t.setBlank(a.isBlank);
	var o = a.min, s = a.max, c = n.ecModel;
	if (c && r === "time") {
		var l = prepareLayoutBarSeries("bar", c), u = !1;
		if (each(l, function(t) {
			u ||= t.getBaseAxis() === n.axis;
		}), u) {
			var d = makeColumnLayout(l), f = adjustScaleForOverflow(o, s, n, d);
			o = f.min, s = f.max;
		}
	}
	return {
		extent: [o, s],
		fixMin: a.minFixed,
		fixMax: a.maxFixed
	};
}
function adjustScaleForOverflow(t, n, r, a) {
	var o = r.axis.getExtent(), s = Math.abs(o[1] - o[0]), c = retrieveColumnLayout(a, r.axis);
	if (c === void 0) return {
		min: t,
		max: n
	};
	var l = Infinity;
	each(c, function(t) {
		l = Math.min(t.offset, l);
	});
	var u = -Infinity;
	each(c, function(t) {
		u = Math.max(t.offset + t.width, u);
	}), l = Math.abs(l), u = Math.abs(u);
	var d = l + u, f = n - t, p = f / (1 - (l + u) / s) - f;
	return n += p * (u / d), t -= p * (l / d), {
		min: t,
		max: n
	};
}
function niceScaleExtent(t, n) {
	var r = n, a = getScaleExtent(t, r), o = a.extent, s = r.get("splitNumber");
	t instanceof Log_default && (t.base = r.get("logBase"));
	var c = t.type, l = r.get("interval"), u = c === "interval" || c === "time";
	t.setExtent(o[0], o[1]), t.calcNiceExtent({
		splitNumber: s,
		fixMin: a.fixMin,
		fixMax: a.fixMax,
		minInterval: u ? r.get("minInterval") : null,
		maxInterval: u ? r.get("maxInterval") : null
	}), l != null && t.setInterval && t.setInterval(l);
}
function createScaleByModel$1(t, n) {
	if (n ||= t.get("type"), n) switch (n) {
		case "category": return new Ordinal_default({
			ordinalMeta: t.getOrdinalMeta ? t.getOrdinalMeta() : t.getCategories(),
			extent: [Infinity, -Infinity]
		});
		case "time": return new Time_default({
			locale: t.ecModel.getLocaleModel(),
			useUTC: t.ecModel.get("useUTC")
		});
		default: return new ((Scale_default.getClass(n)) || Interval_default)();
	}
}
function ifAxisCrossZero(t) {
	var n = t.scale.getExtent(), r = n[0], a = n[1];
	return !(r > 0 && a > 0 || r < 0 && a < 0);
}
function makeLabelFormatter(t) {
	var n = t.getLabelModel().get("formatter"), r = t.type === "category" ? t.scale.getExtent()[0] : null;
	return t.scale.type === "time" ? function(n) {
		return function(r, a) {
			return t.scale.getFormattedLabel(r, a, n);
		};
	}(n) : isString(n) ? function(n) {
		return function(r) {
			var a = t.scale.getLabel(r);
			return n.replace("{value}", a ?? "");
		};
	}(n) : isFunction(n) ? function(n) {
		return function(a, o) {
			return r != null && (o = a.value - r), n(getAxisRawValue(t, a), o, a.level == null ? null : { level: a.level });
		};
	}(n) : function(n) {
		return t.scale.getLabel(n);
	};
}
function getAxisRawValue(t, n) {
	return t.type === "category" ? t.scale.getLabel(n) : n.value;
}
function estimateLabelUnionRect(t) {
	var n = t.model, r = t.scale;
	if (!(!n.get(["axisLabel", "show"]) || r.isBlank())) {
		var a, o, s = r.getExtent();
		r instanceof Ordinal_default ? o = r.count() : (a = r.getTicks(), o = a.length);
		var c = t.getLabelModel(), l = makeLabelFormatter(t), u, d = 1;
		o > 40 && (d = Math.ceil(o / 40));
		for (var f = 0; f < o; f += d) {
			var p = l(a ? a[f] : { value: s[0] + f }, f), h = rotateTextRect(c.getTextRect(p), c.get("rotate") || 0);
			u ? u.union(h) : u = h;
		}
		return u;
	}
}
function rotateTextRect(t, n) {
	var r = n * Math.PI / 180, a = t.width, o = t.height, s = a * Math.abs(Math.cos(r)) + Math.abs(o * Math.sin(r)), c = a * Math.abs(Math.sin(r)) + Math.abs(o * Math.cos(r));
	return new BoundingRect_default(t.x, t.y, s, c);
}
function getOptionCategoryInterval(t) {
	return t.get("interval") ?? "auto";
}
function shouldShowAllLabels(t) {
	return t.type === "category" && getOptionCategoryInterval(t.getLabelModel()) === 0;
}
function getDataDimensionsOnAxis(t, n) {
	var r = {};
	return each(t.mapDimensionsAll(n), function(n) {
		r[getStackedDimension(t, n)] = !0;
	}), keys(r);
}
function unionAxisExtentFromData(t, n, r) {
	n && each(getDataDimensionsOnAxis(n, r), function(r) {
		var a = n.getApproximateExtent(r);
		a[0] < t[0] && (t[0] = a[0]), a[1] > t[1] && (t[1] = a[1]);
	});
}
var AxisModelCommonMixin = function() {
	function t() {}
	return t.prototype.getNeedCrossZero = function() {
		return !this.option.scale;
	}, t.prototype.getCoordSysModel = function() {}, t;
}(), helper_exports = /* @__PURE__ */ __export({
	createDimensions: () => createDimensions,
	createList: () => createList$2,
	createScale: () => createScale,
	createSymbol: () => createSymbol,
	createTextStyle: () => createTextStyle$1,
	dataStack: () => dataStack,
	enableHoverEmphasis: () => enableHoverEmphasis,
	getECData: () => getECData,
	getLayoutRect: () => getLayoutRect,
	mixinAxisModelCommonMethods: () => mixinAxisModelCommonMethods
});
function createList$2(t) {
	return createSeriesData_default(null, t);
}
var dataStack = {
	isDimensionStacked,
	enableDataStack,
	getStackedDimension
};
function createScale(t, n) {
	var r = n;
	n instanceof Model_default || (r = new Model_default(n));
	var a = createScaleByModel$1(r);
	return a.setExtent(t[0], t[1]), niceScaleExtent(a, r), a;
}
function mixinAxisModelCommonMethods(t) {
	mixin(t, AxisModelCommonMixin);
}
function createTextStyle$1(t, n) {
	return n ||= {}, createTextStyle(t, null, null, n.state !== "normal");
}
var EPSILON = 1e-8;
function isAroundEqual(t, n) {
	return Math.abs(t - n) < EPSILON;
}
function contain(t, n, r) {
	var a = 0, o = t[0];
	if (!o) return !1;
	for (var s = 1; s < t.length; s++) {
		var c = t[s];
		a += windingLine(o[0], o[1], c[0], c[1], n, r), o = c;
	}
	var l = t[0];
	return (!isAroundEqual(o[0], l[0]) || !isAroundEqual(o[1], l[1])) && (a += windingLine(o[0], o[1], l[0], l[1], n, r)), a !== 0;
}
var TMP_TRANSFORM = [];
function transformPoints(t, n) {
	for (var r = 0; r < t.length; r++) applyTransform(t[r], t[r], n);
}
function updateBBoxFromPoints(t, n, r, a) {
	for (var o = 0; o < t.length; o++) {
		var s = t[o];
		a && (s = a.project(s)), s && isFinite(s[0]) && isFinite(s[1]) && (min(n, n, s), max(r, r, s));
	}
}
function centroid$1(t) {
	for (var n = 0, r = 0, a = 0, o = t.length, s = t[o - 1][0], c = t[o - 1][1], l = 0; l < o; l++) {
		var u = t[l][0], d = t[l][1], f = s * d - u * c;
		n += f, r += (s + u) * f, a += (c + d) * f, s = u, c = d;
	}
	return n ? [
		r / n / 3,
		a / n / 3,
		n
	] : [t[0][0] || 0, t[0][1] || 0];
}
var Region = function() {
	function t(t) {
		this.name = t;
	}
	return t.prototype.setCenter = function(t) {
		this._center = t;
	}, t.prototype.getCenter = function() {
		var t = this._center;
		return t ||= this._center = this.calcCenter(), t;
	}, t;
}(), GeoJSONPolygonGeometry = function() {
	function t(t, n) {
		this.type = "polygon", this.exterior = t, this.interiors = n;
	}
	return t;
}(), GeoJSONLineStringGeometry = function() {
	function t(t) {
		this.type = "linestring", this.points = t;
	}
	return t;
}(), GeoJSONRegion = function(t) {
	__extends(n, t);
	function n(n, r, a) {
		var o = t.call(this, n) || this;
		return o.type = "geoJSON", o.geometries = r, o._center = a && [a[0], a[1]], o;
	}
	return n.prototype.calcCenter = function() {
		for (var t = this.geometries, n, r = 0, a = 0; a < t.length; a++) {
			var o = t[a], s = o.exterior, c = s && s.length;
			c > r && (n = o, r = c);
		}
		if (n) return centroid$1(n.exterior);
		var l = this.getBoundingRect();
		return [l.x + l.width / 2, l.y + l.height / 2];
	}, n.prototype.getBoundingRect = function(t) {
		var n = this._rect;
		if (n && !t) return n;
		var r = [Infinity, Infinity], a = [-Infinity, -Infinity], o = this.geometries;
		return each(o, function(n) {
			n.type === "polygon" ? updateBBoxFromPoints(n.exterior, r, a, t) : each(n.points, function(n) {
				updateBBoxFromPoints(n, r, a, t);
			});
		}), isFinite(r[0]) && isFinite(r[1]) && isFinite(a[0]) && isFinite(a[1]) || (r[0] = r[1] = a[0] = a[1] = 0), n = new BoundingRect_default(r[0], r[1], a[0] - r[0], a[1] - r[1]), t || (this._rect = n), n;
	}, n.prototype.contain = function(t) {
		var n = this.getBoundingRect(), r = this.geometries;
		if (!n.contain(t[0], t[1])) return !1;
		loopGeo: for (var a = 0, o = r.length; a < o; a++) {
			var s = r[a];
			if (s.type === "polygon") {
				var c = s.exterior, l = s.interiors;
				if (contain(c, t[0], t[1])) {
					for (var u = 0; u < (l ? l.length : 0); u++) if (contain(l[u], t[0], t[1])) continue loopGeo;
					return !0;
				}
			}
		}
		return !1;
	}, n.prototype.transformTo = function(t, n, r, a) {
		var o = this.getBoundingRect(), s = o.width / o.height;
		r ? a ||= r / s : r = s * a;
		for (var c = new BoundingRect_default(t, n, r, a), l = o.calculateTransform(c), u = this.geometries, d = 0; d < u.length; d++) {
			var f = u[d];
			f.type === "polygon" ? (transformPoints(f.exterior, l), each(f.interiors, function(t) {
				transformPoints(t, l);
			})) : each(f.points, function(t) {
				transformPoints(t, l);
			});
		}
		o = this._rect, o.copy(c), this._center = [o.x + o.width / 2, o.y + o.height / 2];
	}, n.prototype.cloneShallow = function(t) {
		t ??= this.name;
		var r = new n(t, this.geometries, this._center);
		return r._rect = this._rect, r.transformTo = null, r;
	}, n;
}(Region), GeoSVGRegion = function(t) {
	__extends(n, t);
	function n(n, r) {
		var a = t.call(this, n) || this;
		return a.type = "geoSVG", a._elOnlyForCalculate = r, a;
	}
	return n.prototype.calcCenter = function() {
		for (var t = this._elOnlyForCalculate, n = t.getBoundingRect(), r = [n.x + n.width / 2, n.y + n.height / 2], a = identity(TMP_TRANSFORM), o = t; o && !o.isGeoSVGGraphicRoot;) mul(a, o.getLocalTransform(), a), o = o.parent;
		return invert(a, a), applyTransform(r, r, a), r;
	}, n;
}(Region);
function decode(t) {
	if (!t.UTF8Encoding) return t;
	var n = t, r = n.UTF8Scale;
	r ??= 1024;
	var a = n.features;
	return each(a, function(t) {
		var n = t.geometry, a = n.encodeOffsets, o = n.coordinates;
		if (a) switch (n.type) {
			case "LineString":
				n.coordinates = decodeRing(o, a, r);
				break;
			case "Polygon":
				decodeRings(o, a, r);
				break;
			case "MultiLineString":
				decodeRings(o, a, r);
				break;
			case "MultiPolygon": each(o, function(t, n) {
				return decodeRings(t, a[n], r);
			});
		}
	}), n.UTF8Encoding = !1, n;
}
function decodeRings(t, n, r) {
	for (var a = 0; a < t.length; a++) t[a] = decodeRing(t[a], n[a], r);
}
function decodeRing(t, n, r) {
	for (var a = [], o = n[0], s = n[1], c = 0; c < t.length; c += 2) {
		var l = t.charCodeAt(c) - 64, u = t.charCodeAt(c + 1) - 64;
		l = l >> 1 ^ -(l & 1), u = u >> 1 ^ -(u & 1), l += o, u += s, o = l, s = u, a.push([l / r, u / r]);
	}
	return a;
}
function parseGeoJSON(t, n) {
	return t = decode(t), map(filter(t.features, function(t) {
		return t.geometry && t.properties && t.geometry.coordinates.length > 0;
	}), function(t) {
		var r = t.properties, a = t.geometry, o = [];
		switch (a.type) {
			case "Polygon":
				var s = a.coordinates;
				o.push(new GeoJSONPolygonGeometry(s[0], s.slice(1)));
				break;
			case "MultiPolygon":
				each(a.coordinates, function(t) {
					t[0] && o.push(new GeoJSONPolygonGeometry(t[0], t.slice(1)));
				});
				break;
			case "LineString":
				o.push(new GeoJSONLineStringGeometry([a.coordinates]));
				break;
			case "MultiLineString": o.push(new GeoJSONLineStringGeometry(a.coordinates));
		}
		var c = new GeoJSONRegion(r[n || "name"], o, r.cp);
		return c.properties = r, c;
	});
}
var number_exports = /* @__PURE__ */ __export({
	MAX_SAFE_INTEGER: () => MAX_SAFE_INTEGER,
	asc: () => asc$1,
	getPercentWithPrecision: () => getPercentWithPrecision,
	getPixelPrecision: () => getPixelPrecision,
	getPrecision: () => getPrecision,
	getPrecisionSafe: () => getPrecisionSafe,
	isNumeric: () => isNumeric,
	isRadianAroundZero: () => isRadianAroundZero,
	linearMap: () => linearMap$2,
	nice: () => nice,
	numericToNumber: () => numericToNumber,
	parseDate: () => parseDate,
	quantile: () => quantile,
	quantity: () => quantity,
	quantityExponent: () => quantityExponent,
	reformIntervals: () => reformIntervals,
	remRadian: () => remRadian,
	round: () => round$1
}), time_exports = /* @__PURE__ */ __export({
	format: () => format,
	parse: () => parseDate
}), graphic_exports = /* @__PURE__ */ __export({
	Arc: () => Arc_default,
	BezierCurve: () => BezierCurve_default,
	BoundingRect: () => BoundingRect_default,
	Circle: () => Circle_default,
	CompoundPath: () => CompoundPath_default,
	Ellipse: () => Ellipse_default,
	Group: () => Group_default,
	Image: () => Image_default,
	IncrementalDisplayable: () => IncrementalDisplayable_default,
	Line: () => Line_default$1,
	LinearGradient: () => LinearGradient_default,
	Polygon: () => Polygon_default,
	Polyline: () => Polyline_default$1,
	RadialGradient: () => RadialGradient_default,
	Rect: () => Rect_default,
	Ring: () => Ring_default,
	Sector: () => Sector_default,
	Text: () => Text_default,
	clipPointsByRect: () => clipPointsByRect,
	clipRectByRect: () => clipRectByRect,
	createIcon: () => createIcon,
	extendPath: () => extendPath,
	extendShape: () => extendShape,
	getShapeClass: () => getShapeClass,
	getTransform: () => getTransform$1,
	initProps: () => initProps,
	makeImage: () => makeImage,
	makePath: () => makePath,
	mergePath: () => mergePath,
	registerShape: () => registerShape,
	resizePath: () => resizePath,
	updateProps: () => updateProps
}), format_exports = /* @__PURE__ */ __export({
	addCommas: () => addCommas,
	capitalFirst: () => capitalFirst,
	encodeHTML: () => encodeHTML,
	formatTime: () => formatTime,
	formatTpl: () => formatTpl,
	getTextRect: () => getTextRect,
	getTooltipMarker: () => getTooltipMarker,
	normalizeCssArray: () => normalizeCssArray,
	toCamelCase: () => toCamelCase,
	truncateText: () => truncateText
}), util_exports = /* @__PURE__ */ __export({
	bind: () => bind,
	clone: () => clone$1,
	curry: () => curry,
	defaults: () => defaults,
	each: () => each,
	extend: () => extend,
	filter: () => filter,
	indexOf: () => indexOf,
	inherits: () => inherits,
	isArray: () => isArray,
	isFunction: () => isFunction,
	isObject: () => isObject,
	isString: () => isString,
	map: () => map,
	merge: () => merge,
	reduce: () => reduce
}), inner$16 = makeInner();
function tickValuesToNumbers(t, n) {
	var r = map(n, function(n) {
		return t.scale.parse(n);
	});
	return t.type === "time" && r.length > 0 && (r.sort(), r.unshift(r[0]), r.push(r[r.length - 1])), r;
}
function createAxisLabels(t) {
	var n = t.getLabelModel().get("customValues");
	if (n) {
		var r = makeLabelFormatter(t), a = t.scale.getExtent();
		return { labels: map(filter(tickValuesToNumbers(t, n), function(t) {
			return t >= a[0] && t <= a[1];
		}), function(n) {
			var a = { value: n };
			return {
				formattedLabel: r(a),
				rawLabel: t.scale.getLabel(a),
				tickValue: n
			};
		}) };
	}
	return t.type === "category" ? makeCategoryLabels(t) : makeRealNumberLabels(t);
}
function createAxisTicks(t, n) {
	var r = t.getTickModel().get("customValues");
	if (r) {
		var a = t.scale.getExtent();
		return { ticks: filter(tickValuesToNumbers(t, r), function(t) {
			return t >= a[0] && t <= a[1];
		}) };
	}
	return t.type === "category" ? makeCategoryTicks(t, n) : { ticks: map(t.scale.getTicks(), function(t) {
		return t.value;
	}) };
}
function makeCategoryLabels(t) {
	var n = t.getLabelModel(), r = makeCategoryLabelsActually(t, n);
	return !n.get("show") || t.scale.isBlank() ? {
		labels: [],
		labelCategoryInterval: r.labelCategoryInterval
	} : r;
}
function makeCategoryLabelsActually(t, n) {
	var r = getListCache(t, "labels"), a = getOptionCategoryInterval(n), o = listCacheGet(r, a);
	if (o) return o;
	var s, c;
	return isFunction(a) ? s = makeLabelsByCustomizedCategoryInterval(t, a) : (c = a === "auto" ? makeAutoCategoryInterval(t) : a, s = makeLabelsByNumericCategoryInterval(t, c)), listCacheSet(r, a, {
		labels: s,
		labelCategoryInterval: c
	});
}
function makeCategoryTicks(t, n) {
	var r = getListCache(t, "ticks"), a = getOptionCategoryInterval(n), o = listCacheGet(r, a);
	if (o) return o;
	var s, c;
	if ((!n.get("show") || t.scale.isBlank()) && (s = []), isFunction(a)) s = makeLabelsByCustomizedCategoryInterval(t, a, !0);
	else if (a === "auto") {
		var l = makeCategoryLabelsActually(t, t.getLabelModel());
		c = l.labelCategoryInterval, s = map(l.labels, function(t) {
			return t.tickValue;
		});
	} else c = a, s = makeLabelsByNumericCategoryInterval(t, c, !0);
	return listCacheSet(r, a, {
		ticks: s,
		tickCategoryInterval: c
	});
}
function makeRealNumberLabels(t) {
	var n = t.scale.getTicks(), r = makeLabelFormatter(t);
	return { labels: map(n, function(n, a) {
		return {
			level: n.level,
			formattedLabel: r(n, a),
			rawLabel: t.scale.getLabel(n),
			tickValue: n.value
		};
	}) };
}
function getListCache(t, n) {
	return inner$16(t)[n] || (inner$16(t)[n] = []);
}
function listCacheGet(t, n) {
	for (var r = 0; r < t.length; r++) if (t[r].key === n) return t[r].value;
}
function listCacheSet(t, n, r) {
	return t.push({
		key: n,
		value: r
	}), r;
}
function makeAutoCategoryInterval(t) {
	return inner$16(t).autoInterval ?? (inner$16(t).autoInterval = t.calculateCategoryInterval());
}
function calculateCategoryInterval(t) {
	var n = fetchAutoCategoryIntervalCalculationParams(t), r = makeLabelFormatter(t), a = (n.axisRotate - n.labelRotate) / 180 * Math.PI, o = t.scale, s = o.getExtent(), c = o.count();
	if (s[1] - s[0] < 1) return 0;
	var l = 1;
	c > 40 && (l = Math.max(1, Math.floor(c / 40)));
	for (var u = s[0], d = t.dataToCoord(u + 1) - t.dataToCoord(u), f = Math.abs(d * Math.cos(a)), p = Math.abs(d * Math.sin(a)), h = 0, g = 0; u <= s[1]; u += l) {
		var _ = 0, v = 0, y = getBoundingRect(r({ value: u }), n.font, "center", "top");
		_ = y.width * 1.3, v = y.height * 1.3, h = Math.max(h, _, 7), g = Math.max(g, v, 7);
	}
	var b = h / f, x = g / p;
	isNaN(b) && (b = Infinity), isNaN(x) && (x = Infinity);
	var S = Math.max(0, Math.floor(Math.min(b, x))), C = inner$16(t.model), w = t.getExtent(), T = C.lastAutoInterval, E = C.lastTickCount;
	return T != null && E != null && Math.abs(T - S) <= 1 && Math.abs(E - c) <= 1 && T > S && C.axisExtent0 === w[0] && C.axisExtent1 === w[1] ? S = T : (C.lastTickCount = c, C.lastAutoInterval = S, C.axisExtent0 = w[0], C.axisExtent1 = w[1]), S;
}
function fetchAutoCategoryIntervalCalculationParams(t) {
	var n = t.getLabelModel();
	return {
		axisRotate: t.getRotate ? t.getRotate() : t.isHorizontal && !t.isHorizontal() ? 90 : 0,
		labelRotate: n.get("rotate") || 0,
		font: n.getFont()
	};
}
function makeLabelsByNumericCategoryInterval(t, n, r) {
	var a = makeLabelFormatter(t), o = t.scale, s = o.getExtent(), c = t.getLabelModel(), l = [], u = Math.max((n || 0) + 1, 1), d = s[0], f = o.count();
	d !== 0 && u > 1 && f / u > 2 && (d = Math.round(Math.ceil(d / u) * u));
	var p = shouldShowAllLabels(t), h = c.get("showMinLabel") || p, g = c.get("showMaxLabel") || p;
	h && d !== s[0] && v(s[0]);
	for (var _ = d; _ <= s[1]; _ += u) v(_);
	g && _ - u !== s[1] && v(s[1]);
	function v(t) {
		var n = { value: t };
		l.push(r ? t : {
			formattedLabel: a(n),
			rawLabel: o.getLabel(n),
			tickValue: t
		});
	}
	return l;
}
function makeLabelsByCustomizedCategoryInterval(t, n, r) {
	var a = t.scale, o = makeLabelFormatter(t), s = [];
	return each(a.getTicks(), function(t) {
		var c = a.getLabel(t), l = t.value;
		n(t.value, c) && s.push(r ? l : {
			formattedLabel: o(t),
			rawLabel: c,
			tickValue: l
		});
	}), s;
}
var NORMALIZED_EXTENT = [0, 1], Axis = function() {
	function t(t, n, r) {
		this.onBand = !1, this.inverse = !1, this.dim = t, this.scale = n, this._extent = r || [0, 0];
	}
	return t.prototype.contain = function(t) {
		var n = this._extent, r = Math.min(n[0], n[1]), a = Math.max(n[0], n[1]);
		return t >= r && t <= a;
	}, t.prototype.containData = function(t) {
		return this.scale.contain(t);
	}, t.prototype.getExtent = function() {
		return this._extent.slice();
	}, t.prototype.getPixelPrecision = function(t) {
		return getPixelPrecision(t || this.scale.getExtent(), this._extent);
	}, t.prototype.setExtent = function(t, n) {
		var r = this._extent;
		r[0] = t, r[1] = n;
	}, t.prototype.dataToCoord = function(t, n) {
		var r = this._extent, a = this.scale;
		return t = a.normalize(t), this.onBand && a.type === "ordinal" && (r = r.slice(), fixExtentWithBands(r, a.count())), linearMap$2(t, NORMALIZED_EXTENT, r, n);
	}, t.prototype.coordToData = function(t, n) {
		var r = this._extent, a = this.scale;
		this.onBand && a.type === "ordinal" && (r = r.slice(), fixExtentWithBands(r, a.count()));
		var o = linearMap$2(t, r, NORMALIZED_EXTENT, n);
		return this.scale.scale(o);
	}, t.prototype.pointToData = function(t, n) {}, t.prototype.getTicksCoords = function(t) {
		t ||= {};
		var n = t.tickModel || this.getTickModel(), r = createAxisTicks(this, n).ticks, a = map(r, function(t) {
			return {
				coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(t) : t),
				tickValue: t
			};
		}, this), o = n.get("alignWithLabel");
		return fixOnBandTicksCoords(this, a, o, t.clamp), a;
	}, t.prototype.getMinorTicksCoords = function() {
		if (this.scale.type === "ordinal") return [];
		var t = this.model.getModel("minorTick").get("splitNumber");
		return t > 0 && t < 100 || (t = 5), map(this.scale.getMinorTicks(t), function(t) {
			return map(t, function(t) {
				return {
					coord: this.dataToCoord(t),
					tickValue: t
				};
			}, this);
		}, this);
	}, t.prototype.getViewLabels = function() {
		return createAxisLabels(this).labels;
	}, t.prototype.getLabelModel = function() {
		return this.model.getModel("axisLabel");
	}, t.prototype.getTickModel = function() {
		return this.model.getModel("axisTick");
	}, t.prototype.getBandWidth = function() {
		var t = this._extent, n = this.scale.getExtent(), r = n[1] - n[0] + (this.onBand ? 1 : 0);
		r === 0 && (r = 1);
		var a = Math.abs(t[1] - t[0]);
		return Math.abs(a) / r;
	}, t.prototype.calculateCategoryInterval = function() {
		return calculateCategoryInterval(this);
	}, t;
}();
function fixExtentWithBands(t, n) {
	var r = (t[1] - t[0]) / n / 2;
	t[0] += r, t[1] -= r;
}
function fixOnBandTicksCoords(t, n, r, a) {
	var o = n.length;
	if (!t.onBand || r || !o) return;
	var s = t.getExtent(), c, l;
	if (o === 1) n[0].coord = s[0], c = n[1] = {
		coord: s[1],
		tickValue: n[0].tickValue
	};
	else {
		var u = n[o - 1].tickValue - n[0].tickValue, d = (n[o - 1].coord - n[0].coord) / u;
		each(n, function(t) {
			t.coord -= d / 2;
		});
		var f = t.scale.getExtent();
		l = 1 + f[1] - n[o - 1].tickValue, c = {
			coord: n[o - 1].coord + d * l,
			tickValue: f[1] + 1
		}, n.push(c);
	}
	var p = s[0] > s[1];
	h(n[0].coord, s[0]) && (a ? n[0].coord = s[0] : n.shift()), a && h(s[0], n[0].coord) && n.unshift({ coord: s[0] }), h(s[1], c.coord) && (a ? c.coord = s[1] : n.pop()), a && h(c.coord, s[1]) && n.push({ coord: s[1] });
	function h(t, n) {
		return t = round$1(t), n = round$1(n), p ? t > n : t < n;
	}
}
var Axis_default = Axis;
function extendComponentModel(t) {
	var n = Component_default.extend(t);
	return Component_default.registerClass(n), n;
}
function extendComponentView(t) {
	var n = Component_default$1.extend(t);
	return Component_default$1.registerClass(n), n;
}
function extendSeriesModel(t) {
	var n = Series_default.extend(t);
	return Series_default.registerClass(n), n;
}
function extendChartView(t) {
	var n = Chart_default.extend(t);
	return Chart_default.registerClass(n), n;
}
var PI2$2 = Math.PI * 2, CMD$1 = PathProxy_default.CMD, DEFAULT_SEARCH_SPACE = [
	"top",
	"right",
	"bottom",
	"left"
];
function getCandidateAnchor(t, n, r, a, o) {
	var s = r.width, c = r.height;
	switch (t) {
		case "top":
			a.set(r.x + s / 2, r.y - n), o.set(0, -1);
			break;
		case "bottom":
			a.set(r.x + s / 2, r.y + c + n), o.set(0, 1);
			break;
		case "left":
			a.set(r.x - n, r.y + c / 2), o.set(-1, 0);
			break;
		case "right":
			a.set(r.x + s + n, r.y + c / 2), o.set(1, 0);
			break;
	}
}
function projectPointToArc(t, n, r, a, o, s, c, l, u) {
	c -= t, l -= n;
	var d = Math.sqrt(c * c + l * l);
	c /= d, l /= d;
	var f = c * r + t, p = l * r + n;
	if (Math.abs(a - o) % PI2$2 < 1e-4) return u[0] = f, u[1] = p, d - r;
	if (s) {
		var h = a;
		a = normalizeRadian(o), o = normalizeRadian(h);
	} else a = normalizeRadian(a), o = normalizeRadian(o);
	a > o && (o += PI2$2);
	var g = Math.atan2(l, c);
	if (g < 0 && (g += PI2$2), g >= a && g <= o || g + PI2$2 >= a && g + PI2$2 <= o) return u[0] = f, u[1] = p, d - r;
	var _ = r * Math.cos(a) + t, v = r * Math.sin(a) + n, y = r * Math.cos(o) + t, b = r * Math.sin(o) + n, x = (_ - c) * (_ - c) + (v - l) * (v - l), S = (y - c) * (y - c) + (b - l) * (b - l);
	return x < S ? (u[0] = _, u[1] = v, Math.sqrt(x)) : (u[0] = y, u[1] = b, Math.sqrt(S));
}
function projectPointToLine(t, n, r, a, o, s, c, l) {
	var u = o - t, d = s - n, f = r - t, p = a - n, h = Math.sqrt(f * f + p * p);
	f /= h, p /= h;
	var g = (u * f + d * p) / h;
	l && (g = Math.min(Math.max(g, 0), 1)), g *= h;
	var _ = c[0] = t + g * f, v = c[1] = n + g * p;
	return Math.sqrt((_ - o) * (_ - o) + (v - s) * (v - s));
}
function projectPointToRect(t, n, r, a, o, s, c) {
	r < 0 && (t += r, r = -r), a < 0 && (n += a, a = -a);
	var l = t + r, u = n + a, d = c[0] = Math.min(Math.max(o, t), l), f = c[1] = Math.min(Math.max(s, n), u);
	return Math.sqrt((d - o) * (d - o) + (f - s) * (f - s));
}
var tmpPt = [];
function nearestPointOnRect(t, n, r) {
	var a = projectPointToRect(n.x, n.y, n.width, n.height, t.x, t.y, tmpPt);
	return r.set(tmpPt[0], tmpPt[1]), a;
}
function nearestPointOnPath(t, n, r) {
	for (var a = 0, o = 0, s = 0, c = 0, l, u, d = Infinity, f = n.data, p = t.x, h = t.y, g = 0; g < f.length;) {
		var _ = f[g++];
		g === 1 && (a = f[g], o = f[g + 1], s = a, c = o);
		var v = d;
		switch (_) {
			case CMD$1.M:
				s = f[g++], c = f[g++], a = s, o = c;
				break;
			case CMD$1.L:
				v = projectPointToLine(a, o, f[g], f[g + 1], p, h, tmpPt, !0), a = f[g++], o = f[g++];
				break;
			case CMD$1.C:
				v = cubicProjectPoint(a, o, f[g++], f[g++], f[g++], f[g++], f[g], f[g + 1], p, h, tmpPt), a = f[g++], o = f[g++];
				break;
			case CMD$1.Q:
				v = quadraticProjectPoint(a, o, f[g++], f[g++], f[g], f[g + 1], p, h, tmpPt), a = f[g++], o = f[g++];
				break;
			case CMD$1.A:
				var y = f[g++], b = f[g++], x = f[g++], S = f[g++], C = f[g++], w = f[g++];
				g += 1;
				var T = !!(1 - f[g++]);
				l = Math.cos(C) * x + y, u = Math.sin(C) * S + b, g <= 1 && (s = l, c = u);
				var E = (p - y) * S / x + y;
				v = projectPointToArc(y, b, S, C, C + w, T, E, h, tmpPt), a = Math.cos(C + w) * x + y, o = Math.sin(C + w) * S + b;
				break;
			case CMD$1.R:
				s = a = f[g++], c = o = f[g++];
				var D = f[g++], O = f[g++];
				v = projectPointToRect(s, c, D, O, p, h, tmpPt);
				break;
			case CMD$1.Z:
				v = projectPointToLine(a, o, s, c, p, h, tmpPt, !0), a = s, o = c;
				break;
		}
		v < d && (d = v, r.set(tmpPt[0], tmpPt[1]));
	}
	return d;
}
var pt0 = new Point_default(), pt1 = new Point_default(), pt2 = new Point_default(), dir = new Point_default(), dir2 = new Point_default();
function updateLabelLinePoints(t, n) {
	if (t) {
		var r = t.getTextGuideLine(), a = t.getTextContent();
		if (a && r) {
			var o = t.textGuideLineConfig || {}, s = [
				[0, 0],
				[0, 0],
				[0, 0]
			], c = o.candidates || DEFAULT_SEARCH_SPACE, l = a.getBoundingRect().clone();
			l.applyTransform(a.getComputedTransform());
			var u = Infinity, d = o.anchor, f = t.getComputedTransform(), p = f && invert([], f), h = n.get("length2") || 0;
			d && pt2.copy(d);
			for (var g = 0; g < c.length; g++) {
				var _ = c[g];
				getCandidateAnchor(_, 0, l, pt0, dir), Point_default.scaleAndAdd(pt1, pt0, dir, h), pt1.transform(p);
				var v = t.getBoundingRect(), y = d ? d.distance(pt1) : t instanceof Path_default ? nearestPointOnPath(pt1, t.path, pt2) : nearestPointOnRect(pt1, v, pt2);
				y < u && (u = y, pt1.transform(f), pt2.transform(f), pt2.toArray(s[0]), pt1.toArray(s[1]), pt0.toArray(s[2]));
			}
			limitTurnAngle(s, n.get("minTurnAngle")), r.setShape({ points: s });
		}
	}
}
var tmpArr = [], tmpProjPoint = new Point_default();
function limitTurnAngle(t, n) {
	if (n <= 180 && n > 0) {
		n = n / 180 * Math.PI, pt0.fromArray(t[0]), pt1.fromArray(t[1]), pt2.fromArray(t[2]), Point_default.sub(dir, pt0, pt1), Point_default.sub(dir2, pt2, pt1);
		var r = dir.len(), a = dir2.len();
		if (!(r < .001 || a < .001)) {
			dir.scale(1 / r), dir2.scale(1 / a);
			var o = dir.dot(dir2);
			if (Math.cos(n) < o) {
				var s = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, !1);
				tmpProjPoint.fromArray(tmpArr), tmpProjPoint.scaleAndAdd(dir2, s / Math.tan(Math.PI - n));
				var c = pt2.x === pt1.x ? (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y) : (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x);
				if (isNaN(c)) return;
				c < 0 ? Point_default.copy(tmpProjPoint, pt1) : c > 1 && Point_default.copy(tmpProjPoint, pt2), tmpProjPoint.toArray(t[1]);
			}
		}
	}
}
function limitSurfaceAngle(t, n, r) {
	if (r <= 180 && r > 0) {
		r = r / 180 * Math.PI, pt0.fromArray(t[0]), pt1.fromArray(t[1]), pt2.fromArray(t[2]), Point_default.sub(dir, pt1, pt0), Point_default.sub(dir2, pt2, pt1);
		var a = dir.len(), o = dir2.len();
		if (!(a < .001 || o < .001) && (dir.scale(1 / a), dir2.scale(1 / o), dir.dot(n) < Math.cos(r))) {
			var s = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, !1);
			tmpProjPoint.fromArray(tmpArr);
			var c = Math.PI / 2, l = c + Math.acos(dir2.dot(n)) - r;
			if (l >= c) Point_default.copy(tmpProjPoint, pt2);
			else {
				tmpProjPoint.scaleAndAdd(dir2, s / Math.tan(Math.PI / 2 - l));
				var u = pt2.x === pt1.x ? (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y) : (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x);
				if (isNaN(u)) return;
				u < 0 ? Point_default.copy(tmpProjPoint, pt1) : u > 1 && Point_default.copy(tmpProjPoint, pt2);
			}
			tmpProjPoint.toArray(t[1]);
		}
	}
}
function setLabelLineState(t, n, r, a) {
	var o = r === "normal", s = o ? t : t.ensureState(r);
	s.ignore = n;
	var c = a.get("smooth");
	c && c === !0 && (c = .3), s.shape = s.shape || {}, c > 0 && (s.shape.smooth = c);
	var l = a.getModel("lineStyle").getLineStyle();
	o ? t.useStyle(l) : s.style = l;
}
function buildLabelLinePath(t, n) {
	var r = n.smooth, a = n.points;
	if (a) if (t.moveTo(a[0][0], a[0][1]), r > 0 && a.length >= 3) {
		var o = dist$1(a[0], a[1]), s = dist$1(a[1], a[2]);
		if (!o || !s) {
			t.lineTo(a[1][0], a[1][1]), t.lineTo(a[2][0], a[2][1]);
			return;
		}
		var c = Math.min(o, s) * r, l = lerp([], a[1], a[0], c / o), u = lerp([], a[1], a[2], c / s), d = lerp([], l, u, .5);
		t.bezierCurveTo(l[0], l[1], l[0], l[1], d[0], d[1]), t.bezierCurveTo(u[0], u[1], u[0], u[1], a[2][0], a[2][1]);
	} else for (var f = 1; f < a.length; f++) t.lineTo(a[f][0], a[f][1]);
}
function setLabelLineStyle(t, n, r) {
	var a = t.getTextGuideLine(), o = t.getTextContent();
	if (!o) {
		a && t.removeTextGuideLine();
		return;
	}
	for (var s = n.normal, c = s.get("show"), l = o.ignore, u = 0; u < DISPLAY_STATES.length; u++) {
		var d = DISPLAY_STATES[u], f = n[d], p = d === "normal";
		if (f) {
			var h = f.get("show");
			if ((p ? l : retrieve2(o.states[d] && o.states[d].ignore, l)) || !retrieve2(h, c)) {
				var g = p ? a : a && a.states[d];
				g && (g.ignore = !0), a && setLabelLineState(a, !0, d, f);
				continue;
			}
			a || (a = new Polyline_default$1(), t.setTextGuideLine(a), !p && (l || !c) && setLabelLineState(a, !0, "normal", n.normal), t.stateProxy && (a.stateProxy = t.stateProxy)), setLabelLineState(a, !1, d, f);
		}
	}
	if (a) {
		defaults(a.style, r), a.style.fill = null;
		var _ = s.get("showAbove"), v = t.textGuideLineConfig = t.textGuideLineConfig || {};
		v.showAbove = _ || !1, a.buildPath = buildLabelLinePath;
	}
}
function getLabelLineStatesModels(t, n) {
	n ||= "labelLine";
	for (var r = { normal: t.getModel(n) }, a = 0; a < SPECIAL_STATES.length; a++) {
		var o = SPECIAL_STATES[a];
		r[o] = t.getModel([o, n]);
	}
	return r;
}
function prepareLayoutList(t) {
	for (var n = [], r = 0; r < t.length; r++) {
		var a = t[r];
		if (!a.defaultAttr.ignore) {
			var o = a.label, s = o.getComputedTransform(), c = o.getBoundingRect(), l = !s || s[1] < 1e-5 && s[2] < 1e-5, u = o.style.margin || 0, d = c.clone();
			d.applyTransform(s), d.x -= u / 2, d.y -= u / 2, d.width += u, d.height += u;
			var f = l ? new OrientedBoundingRect_default(c, s) : null;
			n.push({
				label: o,
				labelLine: a.labelLine,
				rect: d,
				localRect: c,
				obb: f,
				priority: a.priority,
				defaultAttr: a.defaultAttr,
				layoutOption: a.computedLayoutOption,
				axisAligned: l,
				transform: s
			});
		}
	}
	return n;
}
function shiftLayout(t, n, r, a, o, s) {
	var c = t.length;
	if (c < 2) return;
	t.sort(function(t, r) {
		return t.rect[n] - r.rect[n];
	});
	for (var l = 0, u, d = !1, f = [], p = 0, h = 0; h < c; h++) {
		var g = t[h], _ = g.rect;
		u = _[n] - l, u < 0 && (_[n] -= u, g.label[n] -= u, d = !0);
		var v = Math.max(-u, 0);
		f.push(v), p += v, l = _[n] + _[r];
	}
	p > 0 && s && T(-p / c, 0, c);
	var y = t[0], b = t[c - 1], x, S;
	C(), x < 0 && E(-x, .8), S < 0 && E(S, .8), C(), w(x, S, 1), w(S, x, -1), C(), x < 0 && D(-x), S < 0 && D(S);
	function C() {
		x = y.rect[n] - a, S = o - b.rect[n] - b.rect[r];
	}
	function w(t, n, r) {
		if (t < 0) {
			var a = Math.min(n, -t);
			if (a > 0) {
				T(a * r, 0, c);
				var o = a + t;
				o < 0 && E(-o * r, 1);
			} else E(-t * r, 1);
		}
	}
	function T(r, a, o) {
		r !== 0 && (d = !0);
		for (var s = a; s < o; s++) {
			var c = t[s], l = c.rect;
			l[n] += r, c.label[n] += r;
		}
	}
	function E(a, o) {
		for (var s = [], l = 0, u = 1; u < c; u++) {
			var d = t[u - 1].rect, f = Math.max(t[u].rect[n] - d[n] - d[r], 0);
			s.push(f), l += f;
		}
		if (l) {
			var p = Math.min(Math.abs(a) / l, o);
			if (a > 0) for (var u = 0; u < c - 1; u++) {
				var h = s[u] * p;
				T(h, 0, u + 1);
			}
			else for (var u = c - 1; u > 0; u--) {
				var h = s[u - 1] * p;
				T(-h, u, c);
			}
		}
	}
	function D(t) {
		var n = t < 0 ? -1 : 1;
		t = Math.abs(t);
		for (var r = Math.ceil(t / (c - 1)), a = 0; a < c - 1; a++) if (n > 0 ? T(r, 0, a + 1) : T(-r, c - a - 1, c), t -= r, t <= 0) return;
	}
	return d;
}
function shiftLayoutOnX(t, n, r, a) {
	return shiftLayout(t, "x", "width", n, r, a);
}
function shiftLayoutOnY(t, n, r, a) {
	return shiftLayout(t, "y", "height", n, r, a);
}
function hideOverlap(t) {
	var n = [];
	t.sort(function(t, n) {
		return n.priority - t.priority;
	});
	var r = new BoundingRect_default(0, 0, 0, 0);
	function a(t) {
		if (!t.ignore) {
			var n = t.ensureState("emphasis");
			n.ignore ??= !1;
		}
		t.ignore = !0;
	}
	for (var o = 0; o < t.length; o++) {
		var s = t[o], c = s.axisAligned, l = s.localRect, u = s.transform, d = s.label, f = s.labelLine;
		r.copy(s.rect), r.width -= .1, r.height -= .1, r.x += .05, r.y += .05;
		for (var p = s.obb, h = !1, g = 0; g < n.length; g++) {
			var _ = n[g];
			if (r.intersect(_.rect)) {
				if (c && _.axisAligned) {
					h = !0;
					break;
				}
				if (_.obb ||= new OrientedBoundingRect_default(_.localRect, _.transform), p ||= new OrientedBoundingRect_default(l, u), p.intersect(_.obb)) {
					h = !0;
					break;
				}
			}
		}
		h ? (a(d), f && a(f)) : (d.attr("ignore", s.defaultAttr.ignore), f && f.attr("ignore", s.defaultAttr.labelGuideIgnore), n.push(s));
	}
}
function cloneArr(t) {
	if (t) {
		for (var n = [], r = 0; r < t.length; r++) n.push(t[r].slice());
		return n;
	}
}
function prepareLayoutCallbackParams(t, n) {
	var r = t.label, a = n && n.getTextGuideLine();
	return {
		dataIndex: t.dataIndex,
		dataType: t.dataType,
		seriesIndex: t.seriesModel.seriesIndex,
		text: t.label.style.text,
		rect: t.hostRect,
		labelRect: t.rect,
		align: r.style.align,
		verticalAlign: r.style.verticalAlign,
		labelLinePoints: cloneArr(a && a.shape.points)
	};
}
var LABEL_OPTION_TO_STYLE_KEYS = [
	"align",
	"verticalAlign",
	"width",
	"height",
	"fontSize"
], dummyTransformable = new Transformable_default(), labelLayoutInnerStore = makeInner(), labelLineAnimationStore = makeInner();
function extendWithKeys(t, n, r) {
	for (var a = 0; a < r.length; a++) {
		var o = r[a];
		n[o] != null && (t[o] = n[o]);
	}
}
var LABEL_LAYOUT_PROPS = [
	"x",
	"y",
	"rotation"
], LabelManager_default = function() {
	function t() {
		this._labelList = [], this._chartViewList = [];
	}
	return t.prototype.clearLabels = function() {
		this._labelList = [], this._chartViewList = [];
	}, t.prototype._addLabel = function(t, n, r, a, o) {
		var s = a.style, c = a.__hostTarget.textConfig || {}, l = a.getComputedTransform(), u = a.getBoundingRect().plain();
		BoundingRect_default.applyTransform(u, u, l), l ? dummyTransformable.setLocalTransform(l) : (dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0, dummyTransformable.scaleX = dummyTransformable.scaleY = 1), dummyTransformable.rotation = normalizeRadian(dummyTransformable.rotation);
		var d = a.__hostTarget, f;
		if (d) {
			f = d.getBoundingRect().plain();
			var p = d.getComputedTransform();
			BoundingRect_default.applyTransform(f, f, p);
		}
		var h = f && d.getTextGuideLine();
		this._labelList.push({
			label: a,
			labelLine: h,
			seriesModel: r,
			dataIndex: t,
			dataType: n,
			layoutOption: o,
			computedLayoutOption: null,
			rect: u,
			hostRect: f,
			priority: f ? f.width * f.height : 0,
			defaultAttr: {
				ignore: a.ignore,
				labelGuideIgnore: h && h.ignore,
				x: dummyTransformable.x,
				y: dummyTransformable.y,
				scaleX: dummyTransformable.scaleX,
				scaleY: dummyTransformable.scaleY,
				rotation: dummyTransformable.rotation,
				style: {
					x: s.x,
					y: s.y,
					align: s.align,
					verticalAlign: s.verticalAlign,
					width: s.width,
					height: s.height,
					fontSize: s.fontSize
				},
				cursor: a.cursor,
				attachedPos: c.position,
				attachedRot: c.rotation
			}
		});
	}, t.prototype.addLabelsOfSeries = function(t) {
		var n = this;
		this._chartViewList.push(t);
		var r = t.__model, a = r.get("labelLayout");
		(isFunction(a) || keys(a).length) && t.group.traverse(function(t) {
			if (t.ignore) return !0;
			var o = t.getTextContent(), s = getECData(t);
			o && !o.disableLabelLayout && n._addLabel(s.dataIndex, s.dataType, r, o, a);
		});
	}, t.prototype.updateLayoutConfig = function(t) {
		var n = t.getWidth(), r = t.getHeight();
		function a(t, n) {
			return function() {
				updateLabelLinePoints(t, n);
			};
		}
		for (var o = 0; o < this._labelList.length; o++) {
			var s = this._labelList[o], c = s.label, l = c.__hostTarget, u = s.defaultAttr, d = void 0;
			d = isFunction(s.layoutOption) ? s.layoutOption(prepareLayoutCallbackParams(s, l)) : s.layoutOption, d ||= {}, s.computedLayoutOption = d;
			var f = Math.PI / 180;
			l && l.setTextConfig({
				local: !1,
				position: d.x != null || d.y != null ? null : u.attachedPos,
				rotation: d.rotate == null ? u.attachedRot : d.rotate * f,
				offset: [d.dx || 0, d.dy || 0]
			});
			var p = !1;
			if (d.x == null ? (c.x = u.x, c.setStyle("x", u.style.x)) : (c.x = parsePercent$1(d.x, n), c.setStyle("x", 0), p = !0), d.y == null ? (c.y = u.y, c.setStyle("y", u.style.y)) : (c.y = parsePercent$1(d.y, r), c.setStyle("y", 0), p = !0), d.labelLinePoints) {
				var h = l.getTextGuideLine();
				h && (h.setShape({ points: d.labelLinePoints }), p = !1);
			}
			var g = labelLayoutInnerStore(c);
			g.needsUpdateLabelLine = p, c.rotation = d.rotate == null ? u.rotation : d.rotate * f, c.scaleX = u.scaleX, c.scaleY = u.scaleY;
			for (var _ = 0; _ < LABEL_OPTION_TO_STYLE_KEYS.length; _++) {
				var v = LABEL_OPTION_TO_STYLE_KEYS[_];
				c.setStyle(v, d[v] == null ? u.style[v] : d[v]);
			}
			if (d.draggable) {
				if (c.draggable = !0, c.cursor = "move", l) {
					var y = s.seriesModel;
					s.dataIndex != null && (y = s.seriesModel.getData(s.dataType).getItemModel(s.dataIndex)), c.on("drag", a(l, y.getModel("labelLine")));
				}
			} else c.off("drag"), c.cursor = u.cursor;
		}
	}, t.prototype.layout = function(t) {
		var n = t.getWidth(), r = t.getHeight(), a = prepareLayoutList(this._labelList), o = filter(a, function(t) {
			return t.layoutOption.moveOverlap === "shiftX";
		}), s = filter(a, function(t) {
			return t.layoutOption.moveOverlap === "shiftY";
		});
		shiftLayoutOnX(o, 0, n), shiftLayoutOnY(s, 0, r), hideOverlap(filter(a, function(t) {
			return t.layoutOption.hideOverlap;
		}));
	}, t.prototype.processLabelsOverall = function() {
		var t = this;
		each(this._chartViewList, function(n) {
			var r = n.__model, a = n.ignoreLabelLineUpdate, o = r.isAnimationEnabled();
			n.group.traverse(function(n) {
				if (n.ignore && !n.forceLabelAnimation) return !0;
				var s = !a, c = n.getTextContent();
				!s && c && (s = labelLayoutInnerStore(c).needsUpdateLabelLine), s && t._updateLabelLine(n, r), o && t._animateLabels(n, r);
			});
		});
	}, t.prototype._updateLabelLine = function(t, n) {
		var r = t.getTextContent(), a = getECData(t), o = a.dataIndex;
		if (r && o != null) {
			var s = n.getData(a.dataType), c = s.getItemModel(o), l = {}, u = s.getItemVisual(o, "style");
			u && (l.stroke = u[s.getVisual("drawType")]);
			var d = c.getModel("labelLine");
			setLabelLineStyle(t, getLabelLineStatesModels(c), l), updateLabelLinePoints(t, d);
		}
	}, t.prototype._animateLabels = function(t, n) {
		var r = t.getTextContent(), a = t.getTextGuideLine();
		if (r && (t.forceLabelAnimation || !r.ignore && !r.invisible && !t.disableLabelAnimation && !isElementRemoved(t))) {
			var o = labelLayoutInnerStore(r), s = o.oldLayout, c = getECData(t), l = c.dataIndex, u = {
				x: r.x,
				y: r.y,
				rotation: r.rotation
			}, d = n.getData(c.dataType);
			if (s) {
				r.attr(s);
				var f = t.prevStates;
				f && (indexOf(f, "select") >= 0 && r.attr(o.oldLayoutSelect), indexOf(f, "emphasis") >= 0 && r.attr(o.oldLayoutEmphasis)), updateProps(r, u, n, l);
			} else if (r.attr(u), !labelInner(r).valueAnimation) {
				var p = retrieve2(r.style.opacity, 1);
				r.style.opacity = 0, initProps(r, { style: { opacity: p } }, n, l);
			}
			if (o.oldLayout = u, r.states.select) {
				var h = o.oldLayoutSelect = {};
				extendWithKeys(h, u, LABEL_LAYOUT_PROPS), extendWithKeys(h, r.states.select, LABEL_LAYOUT_PROPS);
			}
			if (r.states.emphasis) {
				var g = o.oldLayoutEmphasis = {};
				extendWithKeys(g, u, LABEL_LAYOUT_PROPS), extendWithKeys(g, r.states.emphasis, LABEL_LAYOUT_PROPS);
			}
			animateLabelValue(r, l, d, n, n);
		}
		if (a && !a.ignore && !a.invisible) {
			var o = labelLineAnimationStore(a), s = o.oldLayout, _ = { points: a.shape.points };
			s ? (a.attr({ shape: s }), updateProps(a, { shape: _ }, n)) : (a.setShape(_), a.style.strokePercent = 0, initProps(a, { style: { strokePercent: 1 } }, n)), o.oldLayout = _;
		}
	}, t;
}(), getLabelManager = makeInner();
function installLabelLayout(t) {
	t.registerUpdateLifecycle("series:beforeupdate", function(t, n, r) {
		var a = getLabelManager(n).labelManager;
		a ||= getLabelManager(n).labelManager = new LabelManager_default(), a.clearLabels();
	}), t.registerUpdateLifecycle("series:layoutlabels", function(t, n, r) {
		var a = getLabelManager(n).labelManager;
		r.updatedSeries.forEach(function(t) {
			a.addLabelsOfSeries(n.getViewOfSeriesModel(t));
		}), a.updateLayoutConfig(n), a.layout(n), a.processLabelsOverall();
	});
}
var mathSin = Math.sin, mathCos = Math.cos, PI$4 = Math.PI, PI2$1 = Math.PI * 2, degree = 180 / PI$4, SVGPathRebuilder_default = function() {
	function t() {}
	return t.prototype.reset = function(t) {
		this._start = !0, this._d = [], this._str = "", this._p = 10 ** (t || 4);
	}, t.prototype.moveTo = function(t, n) {
		this._add("M", t, n);
	}, t.prototype.lineTo = function(t, n) {
		this._add("L", t, n);
	}, t.prototype.bezierCurveTo = function(t, n, r, a, o, s) {
		this._add("C", t, n, r, a, o, s);
	}, t.prototype.quadraticCurveTo = function(t, n, r, a) {
		this._add("Q", t, n, r, a);
	}, t.prototype.arc = function(t, n, r, a, o, s) {
		this.ellipse(t, n, r, r, 0, a, o, s);
	}, t.prototype.ellipse = function(t, n, r, a, o, s, c, l) {
		var u = c - s, d = !l, f = Math.abs(u), p = isAroundZero(f - PI2$1) || (d ? u >= PI2$1 : -u >= PI2$1), h = u > 0 ? u % PI2$1 : u % PI2$1 + PI2$1, g = !1;
		g = p ? !0 : isAroundZero(f) ? !1 : h >= PI$4 == !!d;
		var _ = t + r * mathCos(s), v = n + a * mathSin(s);
		this._start && this._add("M", _, v);
		var y = Math.round(o * degree);
		if (p) {
			var b = 1 / this._p, x = (d ? 1 : -1) * (PI2$1 - b);
			this._add("A", r, a, y, 1, +d, t + r * mathCos(s + x), n + a * mathSin(s + x)), b > .01 && this._add("A", r, a, y, 0, +d, _, v);
		} else {
			var S = t + r * mathCos(c), C = n + a * mathSin(c);
			this._add("A", r, a, y, +g, +d, S, C);
		}
	}, t.prototype.rect = function(t, n, r, a) {
		this._add("M", t, n), this._add("l", r, 0), this._add("l", 0, a), this._add("l", -r, 0), this._add("Z");
	}, t.prototype.closePath = function() {
		this._d.length > 0 && this._add("Z");
	}, t.prototype._add = function(t, n, r, a, o, s, c, l, u) {
		for (var d = [], f = this._p, p = 1; p < arguments.length; p++) {
			var h = arguments[p];
			if (isNaN(h)) {
				this._invalid = !0;
				return;
			}
			d.push(Math.round(h * f) / f);
		}
		this._d.push(t + d.join(" ")), this._start = t === "Z";
	}, t.prototype.generateStr = function() {
		this._str = this._invalid ? "" : this._d.join(""), this._d = [];
	}, t.prototype.getStr = function() {
		return this._str;
	}, t;
}(), NONE = "none", mathRound = Math.round;
function pathHasFill(t) {
	var n = t.fill;
	return n != null && n !== NONE;
}
function pathHasStroke(t) {
	var n = t.stroke;
	return n != null && n !== NONE;
}
var strokeProps = [
	"lineCap",
	"miterLimit",
	"lineJoin"
], svgStrokeProps = map(strokeProps, function(t) {
	return "stroke-" + t.toLowerCase();
});
function mapStyleToAttrs(t, n, r, a) {
	var o = n.opacity == null ? 1 : n.opacity;
	if (r instanceof Image_default) {
		t("opacity", o);
		return;
	}
	if (pathHasFill(n)) {
		var s = normalizeColor(n.fill);
		t("fill", s.color);
		var c = n.fillOpacity == null ? s.opacity * o : n.fillOpacity * s.opacity * o;
		(a || c < 1) && t("fill-opacity", c);
	} else t("fill", NONE);
	if (pathHasStroke(n)) {
		var l = normalizeColor(n.stroke);
		t("stroke", l.color);
		var u = n.strokeNoScale ? r.getLineScale() : 1, d = u ? (n.lineWidth || 0) / u : 0, f = n.strokeOpacity == null ? l.opacity * o : n.strokeOpacity * l.opacity * o, p = n.strokeFirst;
		if ((a || d !== 1) && t("stroke-width", d), (a || p) && t("paint-order", p ? "stroke" : "fill"), (a || f < 1) && t("stroke-opacity", f), n.lineDash) {
			var h = getLineDash(r), g = h[0], _ = h[1];
			g && (_ = mathRound(_ || 0), t("stroke-dasharray", g.join(",")), (_ || a) && t("stroke-dashoffset", _));
		} else a && t("stroke-dasharray", NONE);
		for (var v = 0; v < strokeProps.length; v++) {
			var y = strokeProps[v];
			if (a || n[y] !== DEFAULT_PATH_STYLE[y]) {
				var b = n[y] || DEFAULT_PATH_STYLE[y];
				b && t(svgStrokeProps[v], b);
			}
		}
	} else a && t("stroke", NONE);
}
var SVGNS = "http://www.w3.org/2000/svg", XLINKNS = "http://www.w3.org/1999/xlink", XMLNS = "http://www.w3.org/2000/xmlns/", XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace", META_DATA_PREFIX = "ecmeta_";
function createElement(t) {
	return document.createElementNS(SVGNS, t);
}
function createVNode(t, n, r, a, o) {
	return {
		tag: t,
		attrs: r || {},
		children: a,
		text: o,
		key: n
	};
}
function createElementOpen(t, n) {
	var r = [];
	if (n) for (var a in n) {
		var o = n[a], s = a;
		o !== !1 && (o !== !0 && o != null && (s += "=\"" + o + "\""), r.push(s));
	}
	return "<" + t + " " + r.join(" ") + ">";
}
function createElementClose(t) {
	return "</" + t + ">";
}
function vNodeToString(t, n) {
	n ||= {};
	var r = n.newline ? "\n" : "";
	function a(t) {
		var n = t.children, o = t.tag, s = t.attrs, c = t.text;
		return createElementOpen(o, s) + (o === "style" ? c || "" : encodeHTML(c)) + (n ? "" + r + map(n, function(t) {
			return a(t);
		}).join(r) + r : "") + createElementClose(o);
	}
	return a(t);
}
function getCssString(t, n, r) {
	r ||= {};
	var a = r.newline ? "\n" : "", o = " {" + a, s = a + "}", c = map(keys(t), function(n) {
		return n + o + map(keys(t[n]), function(r) {
			return r + ":" + t[n][r] + ";";
		}).join(a) + s;
	}).join(a), l = map(keys(n), function(t) {
		return "@keyframes " + t + o + map(keys(n[t]), function(r) {
			return r + o + map(keys(n[t][r]), function(a) {
				var o = n[t][r][a];
				return a === "d" && (o = "path(\"" + o + "\")"), a + ":" + o + ";";
			}).join(a) + s;
		}).join(a) + s;
	}).join(a);
	return !c && !l ? "" : [
		"<![CDATA[",
		c,
		l,
		"]]>"
	].join(a);
}
function createBrushScope(t) {
	return {
		zrId: t,
		shadowCache: {},
		patternCache: {},
		gradientCache: {},
		clipPathCache: {},
		defs: {},
		cssNodes: {},
		cssAnims: {},
		cssStyleCache: {},
		cssAnimIdx: 0,
		shadowIdx: 0,
		gradientIdx: 0,
		patternIdx: 0,
		clipPathIdx: 0
	};
}
function createSVGVNode(t, n, r, a) {
	return createVNode("svg", "root", {
		width: t,
		height: n,
		xmlns: SVGNS,
		"xmlns:xlink": XLINKNS,
		version: "1.1",
		baseProfile: "full",
		viewBox: a ? "0 0 " + t + " " + n : !1
	}, r);
}
var cssClassIdx = 0;
function getClassId() {
	return cssClassIdx++;
}
var EASING_MAP = {
	cubicIn: "0.32,0,0.67,0",
	cubicOut: "0.33,1,0.68,1",
	cubicInOut: "0.65,0,0.35,1",
	quadraticIn: "0.11,0,0.5,0",
	quadraticOut: "0.5,1,0.89,1",
	quadraticInOut: "0.45,0,0.55,1",
	quarticIn: "0.5,0,0.75,0",
	quarticOut: "0.25,1,0.5,1",
	quarticInOut: "0.76,0,0.24,1",
	quinticIn: "0.64,0,0.78,0",
	quinticOut: "0.22,1,0.36,1",
	quinticInOut: "0.83,0,0.17,1",
	sinusoidalIn: "0.12,0,0.39,0",
	sinusoidalOut: "0.61,1,0.88,1",
	sinusoidalInOut: "0.37,0,0.63,1",
	exponentialIn: "0.7,0,0.84,0",
	exponentialOut: "0.16,1,0.3,1",
	exponentialInOut: "0.87,0,0.13,1",
	circularIn: "0.55,0,1,0.45",
	circularOut: "0,0.55,0.45,1",
	circularInOut: "0.85,0,0.15,1"
}, transformOriginKey = "transform-origin";
function buildPathString(t, n, r) {
	var a = extend({}, t.shape);
	extend(a, n), t.buildPath(r, a);
	var o = new SVGPathRebuilder_default();
	return o.reset(getPathPrecision(t)), r.rebuildPath(o, 1), o.generateStr(), o.getStr();
}
function setTransformOrigin(t, n) {
	var r = n.originX, a = n.originY;
	(r || a) && (t[transformOriginKey] = r + "px " + a + "px");
}
var ANIMATE_STYLE_MAP = {
	fill: "fill",
	opacity: "opacity",
	lineWidth: "stroke-width",
	lineDashOffset: "stroke-dashoffset"
};
function addAnimation(t, n) {
	var r = n.zrId + "-ani-" + n.cssAnimIdx++;
	return n.cssAnims[r] = t, r;
}
function createCompoundPathCSSAnimation(t, n, r) {
	var a = t.shape.paths, o = {}, s, c;
	if (each(a, function(t) {
		var n = createBrushScope(r.zrId);
		n.animation = !0, createCSSAnimation(t, {}, n, !0);
		var a = n.cssAnims, l = n.cssNodes, u = keys(a), d = u.length;
		if (d) {
			c = u[d - 1];
			var f = a[c];
			for (var p in f) {
				var h = f[p];
				o[p] = o[p] || { d: "" }, o[p].d += h.d || "";
			}
			for (var g in l) {
				var _ = l[g].animation;
				_.indexOf(c) >= 0 && (s = _);
			}
		}
	}), s) {
		n.d = !1;
		var l = addAnimation(o, r);
		return s.replace(c, l);
	}
}
function getEasingFunc(t) {
	return isString(t) ? EASING_MAP[t] ? "cubic-bezier(" + EASING_MAP[t] + ")" : createCubicEasingFunc(t) ? t : "" : "";
}
function createCSSAnimation(t, n, r, a) {
	var o = t.animators, s = o.length, c = [];
	if (t instanceof CompoundPath_default) {
		var l = createCompoundPathCSSAnimation(t, n, r);
		if (l) c.push(l);
		else if (!s) return;
	} else if (!s) return;
	for (var u = {}, d = 0; d < s; d++) {
		var f = o[d], p = [f.getMaxTime() / 1e3 + "s"], h = getEasingFunc(f.getClip().easing), g = f.getDelay();
		h ? p.push(h) : p.push("linear"), g && p.push(g / 1e3 + "s"), f.getLoop() && p.push("infinite");
		var _ = p.join(" ");
		u[_] = u[_] || [_, []], u[_][1].push(f);
	}
	function v(o) {
		var s = o[1], c = s.length, l = {}, u = {}, d = {}, f = "animation-timing-function";
		function p(t, n, r) {
			for (var a = t.getTracks(), o = t.getMaxTime(), s = 0; s < a.length; s++) {
				var c = a[s];
				if (c.needsAnimate()) {
					var l = c.keyframes, u = c.propName;
					if (r && (u = r(u)), u) for (var d = 0; d < l.length; d++) {
						var p = l[d], h = Math.round(p.time / o * 100) + "%", g = getEasingFunc(p.easing), _ = p.rawValue;
						(isString(_) || isNumber(_)) && (n[h] = n[h] || {}, n[h][u] = p.rawValue, g && (n[h][f] = g));
					}
				}
			}
		}
		for (var h = 0; h < c; h++) {
			var g = s[h], _ = g.targetName;
			_ ? _ === "shape" && p(g, u) : !a && p(g, l);
		}
		for (var v in l) {
			var y = {};
			copyTransform(y, t), extend(y, l[v]);
			var b = getSRTTransformString(y), x = l[v][f];
			d[v] = b ? { transform: b } : {}, setTransformOrigin(d[v], y), x && (d[v][f] = x);
		}
		var S, C = !0;
		for (var v in u) {
			d[v] = d[v] || {};
			var w = !S, x = u[v][f];
			w && (S = new PathProxy_default());
			var T = S.len();
			S.reset(), d[v].d = buildPathString(t, u[v], S);
			var E = S.len();
			if (!w && T !== E) {
				C = !1;
				break;
			}
			x && (d[v][f] = x);
		}
		if (!C) for (var v in d) delete d[v].d;
		if (!a) for (var h = 0; h < c; h++) {
			var g = s[h], _ = g.targetName;
			_ === "style" && p(g, d, function(t) {
				return ANIMATE_STYLE_MAP[t];
			});
		}
		for (var D = keys(d), O = !0, A, h = 1; h < D.length; h++) {
			var j = D[h - 1], M = D[h];
			if (d[j][transformOriginKey] !== d[M][transformOriginKey]) {
				O = !1;
				break;
			}
			A = d[j][transformOriginKey];
		}
		if (O && A) {
			for (var v in d) d[v][transformOriginKey] && delete d[v][transformOriginKey];
			n[transformOriginKey] = A;
		}
		if (filter(D, function(t) {
			return keys(d[t]).length > 0;
		}).length) return addAnimation(d, r) + " " + o[0] + " both";
	}
	for (var y in u) {
		var l = v(u[y]);
		l && c.push(l);
	}
	if (c.length) {
		var b = r.zrId + "-cls-" + getClassId();
		r.cssNodes["." + b] = { animation: c.join(",") }, n.class = b;
	}
}
function createCSSEmphasis(t, n, r) {
	if (!t.ignore) if (t.isSilent()) {
		var a = { "pointer-events": "none" };
		setClassAttribute(a, n, r, !0);
	} else {
		var o = t.states.emphasis && t.states.emphasis.style ? t.states.emphasis.style : {}, s = o.fill;
		if (!s) {
			var c = t.style && t.style.fill, l = t.states.select && t.states.select.style && t.states.select.style.fill, u = t.currentStates.indexOf("select") >= 0 && l || c;
			u && (s = liftColor(u));
		}
		var d = o.lineWidth;
		if (d) {
			var f = !o.strokeNoScale && t.transform ? t.transform[0] : 1;
			d /= f;
		}
		var a = { cursor: "pointer" };
		s && (a.fill = s), o.stroke && (a.stroke = o.stroke), d && (a["stroke-width"] = d), setClassAttribute(a, n, r, !0);
	}
}
function setClassAttribute(t, n, r, a) {
	var o = JSON.stringify(t), s = r.cssStyleCache[o];
	s || (s = r.zrId + "-cls-" + getClassId(), r.cssStyleCache[o] = s, r.cssNodes["." + s + (a ? ":hover" : "")] = t), n.class = n.class ? n.class + " " + s : s;
}
init_dist$2();
var round$2 = Math.round;
function isImageLike(t) {
	return t && isString(t.src);
}
function isCanvasLike(t) {
	return t && isFunction(t.toDataURL);
}
function setStyleAttrs(t, n, r, a) {
	mapStyleToAttrs(function(o, s) {
		var c = o === "fill" || o === "stroke";
		c && isGradient(s) ? setGradient(n, t, o, a) : c && isPattern(s) ? setPattern(r, t, o, a) : t[o] = s, c && a.ssr && s === "none" && (t["pointer-events"] = "visible");
	}, n, r, !1), setShadow(r, t, a);
}
function setMetaData(t, n) {
	var r = getElementSSRData(n);
	r && (r.each(function(n, r) {
		n != null && (t[("ecmeta_" + r).toLowerCase()] = n + "");
	}), n.isSilent() && (t[META_DATA_PREFIX + "silent"] = "true"));
}
function noRotateScale(t) {
	return isAroundZero(t[0] - 1) && isAroundZero(t[1]) && isAroundZero(t[2]) && isAroundZero(t[3] - 1);
}
function noTranslate(t) {
	return isAroundZero(t[4]) && isAroundZero(t[5]);
}
function setTransform(t, n, r) {
	if (n && !(noTranslate(n) && noRotateScale(n))) {
		var a = r ? 10 : 1e4;
		t.transform = noRotateScale(n) ? "translate(" + round$2(n[4] * a) / a + " " + round$2(n[5] * a) / a + ")" : getMatrixStr(n);
	}
}
function convertPolyShape(t, n, r) {
	for (var a = t.points, o = [], s = 0; s < a.length; s++) o.push(round$2(a[s][0] * r) / r), o.push(round$2(a[s][1] * r) / r);
	n.points = o.join(" ");
}
function validatePolyShape(t) {
	return !t.smooth;
}
function createAttrsConvert(t) {
	var n = map(t, function(t) {
		return typeof t == "string" ? [t, t] : t;
	});
	return function(t, r, a) {
		for (var o = 0; o < n.length; o++) {
			var s = n[o], c = t[s[0]];
			c != null && (r[s[1]] = round$2(c * a) / a);
		}
	};
}
var builtinShapesDef = {
	circle: [createAttrsConvert([
		"cx",
		"cy",
		"r"
	])],
	polyline: [convertPolyShape, validatePolyShape],
	polygon: [convertPolyShape, validatePolyShape]
};
function hasShapeAnimation(t) {
	for (var n = t.animators, r = 0; r < n.length; r++) if (n[r].targetName === "shape") return !0;
	return !1;
}
function brushSVGPath(t, n) {
	var r = t.style, a = t.shape, o = builtinShapesDef[t.type], s = {}, c = n.animation, l = "path", u = t.style.strokePercent, d = n.compress && getPathPrecision(t) || 4;
	if (o && !n.willUpdate && !(o[1] && !o[1](a)) && !(c && hasShapeAnimation(t)) && !(u < 1)) {
		l = t.type;
		var f = 10 ** d;
		o[0](a, s, f);
	} else {
		var p = !t.path || t.shapeChanged();
		t.path || t.createPathProxy();
		var h = t.path;
		p && (h.beginPath(), t.buildPath(h, t.shape), t.pathUpdated());
		var g = h.getVersion(), _ = t, v = _.__svgPathBuilder;
		(_.__svgPathVersion !== g || !v || u !== _.__svgPathStrokePercent) && (v ||= _.__svgPathBuilder = new SVGPathRebuilder_default(), v.reset(d), h.rebuildPath(v, u), v.generateStr(), _.__svgPathVersion = g, _.__svgPathStrokePercent = u), s.d = v.getStr();
	}
	return setTransform(s, t.transform), setStyleAttrs(s, r, t, n), setMetaData(s, t), n.animation && createCSSAnimation(t, s, n), n.emphasis && createCSSEmphasis(t, s, n), createVNode(l, t.id + "", s);
}
function brushSVGImage(t, n) {
	var r = t.style, a = r.image;
	if (a && !isString(a) && (isImageLike(a) ? a = a.src : isCanvasLike(a) && (a = a.toDataURL())), a) {
		var o = r.x || 0, s = r.y || 0, c = r.width, l = r.height, u = {
			href: a,
			width: c,
			height: l
		};
		return o && (u.x = o), s && (u.y = s), setTransform(u, t.transform), setStyleAttrs(u, r, t, n), setMetaData(u, t), n.animation && createCSSAnimation(t, u, n), createVNode("image", t.id + "", u);
	}
}
function brushSVGTSpan(t, n) {
	var r = t.style, a = r.text;
	if (a != null && (a += ""), !(!a || isNaN(r.x) || isNaN(r.y))) {
		var o = r.font || "12px sans-serif", s = r.x || 0, c = adjustTextY(r.y || 0, getLineHeight(o), r.textBaseline), l = TEXT_ALIGN_TO_ANCHOR[r.textAlign] || r.textAlign, u = {
			"dominant-baseline": "central",
			"text-anchor": l
		};
		if (hasSeparateFont(r)) {
			var d = "", f = r.fontStyle, p = parseFontSize(r.fontSize);
			if (!parseFloat(p)) return;
			var h = r.fontFamily || "sans-serif", g = r.fontWeight;
			d += "font-size:" + p + ";font-family:" + h + ";", f && f !== "normal" && (d += "font-style:" + f + ";"), g && g !== "normal" && (d += "font-weight:" + g + ";"), u.style = d;
		} else u.style = "font: " + o;
		return a.match(/\s/) && (u["xml:space"] = "preserve"), s && (u.x = s), c && (u.y = c), setTransform(u, t.transform), setStyleAttrs(u, r, t, n), setMetaData(u, t), n.animation && createCSSAnimation(t, u, n), createVNode("text", t.id + "", u, void 0, a);
	}
}
function brush$1(t, n) {
	if (t instanceof Path_default) return brushSVGPath(t, n);
	if (t instanceof Image_default) return brushSVGImage(t, n);
	if (t instanceof TSpan_default) return brushSVGTSpan(t, n);
}
function setShadow(t, n, r) {
	var a = t.style;
	if (hasShadow(a)) {
		var o = getShadowKey(t), s = r.shadowCache, c = s[o];
		if (!c) {
			var l = t.getGlobalScale(), u = l[0], d = l[1];
			if (!u || !d) return;
			var f = a.shadowOffsetX || 0, p = a.shadowOffsetY || 0, h = a.shadowBlur, g = normalizeColor(a.shadowColor), _ = g.opacity, v = g.color, y = h / 2 / u, b = h / 2 / d, x = y + " " + b;
			c = r.zrId + "-s" + r.shadowIdx++, r.defs[c] = createVNode("filter", c, {
				id: c,
				x: "-100%",
				y: "-100%",
				width: "300%",
				height: "300%"
			}, [createVNode("feDropShadow", "", {
				dx: f / u,
				dy: p / d,
				stdDeviation: x,
				"flood-color": v,
				"flood-opacity": _
			})]), s[o] = c;
		}
		n.filter = getIdURL(c);
	}
}
function setGradient(t, n, r, a) {
	var o = t[r], c, l = { gradientUnits: o.global ? "userSpaceOnUse" : "objectBoundingBox" };
	if (isLinearGradient(o)) c = "linearGradient", l.x1 = o.x, l.y1 = o.y, l.x2 = o.x2, l.y2 = o.y2;
	else if (isRadialGradient(o)) c = "radialGradient", l.cx = retrieve2(o.x, .5), l.cy = retrieve2(o.y, .5), l.r = retrieve2(o.r, .5);
	else {
		process$1.env.NODE_ENV !== "production" && logError("Illegal gradient type.");
		return;
	}
	for (var u = o.colorStops, d = [], f = 0, p = u.length; f < p; ++f) {
		var h = round4(u[f].offset) * 100 + "%", g = u[f].color, _ = normalizeColor(g), v = _.color, y = _.opacity, b = { offset: h };
		b["stop-color"] = v, y < 1 && (b["stop-opacity"] = y), d.push(createVNode("stop", f + "", b));
	}
	var x = vNodeToString(createVNode(c, "", l, d)), S = a.gradientCache, C = S[x];
	C || (C = a.zrId + "-g" + a.gradientIdx++, S[x] = C, l.id = C, a.defs[C] = createVNode(c, C, l, d)), n[r] = getIdURL(C);
}
function setPattern(t, n, r, a) {
	var o = t.style[r], s = t.getBoundingRect(), c = {}, l = o.repeat, u = l === "no-repeat", d = l === "repeat-x", f = l === "repeat-y", p;
	if (isImagePattern(o)) {
		var h = o.imageWidth, g = o.imageHeight, _ = void 0, v = o.image;
		if (isString(v) ? _ = v : isImageLike(v) ? _ = v.src : isCanvasLike(v) && (_ = v.toDataURL()), typeof Image > "u") {
			var y = "Image width/height must been given explictly in svg-ssr renderer.";
			assert(h, y), assert(g, y);
		} else if (h == null || g == null) {
			var b = function(t, n) {
				if (t) {
					var r = t.elm, a = h || n.width, o = g || n.height;
					t.tag === "pattern" && (d ? (o = 1, a /= s.width) : f && (a = 1, o /= s.height)), t.attrs.width = a, t.attrs.height = o, r && (r.setAttribute("width", a), r.setAttribute("height", o));
				}
			}, x = createOrUpdateImage(_, null, t, function(t) {
				u || b(T, t), b(p, t);
			});
			x && x.width && x.height && (h ||= x.width, g ||= x.height);
		}
		p = createVNode("image", "img", {
			href: _,
			width: h,
			height: g
		}), c.width = h, c.height = g;
	} else o.svgElement && (p = clone$1(o.svgElement), c.width = o.svgWidth, c.height = o.svgHeight);
	if (p) {
		var S, C;
		u ? S = C = 1 : d ? (C = 1, S = c.width / s.width) : f ? (S = 1, C = c.height / s.height) : c.patternUnits = "userSpaceOnUse", S != null && !isNaN(S) && (c.width = S), C != null && !isNaN(C) && (c.height = C);
		var w = getSRTTransformString(o);
		w && (c.patternTransform = w);
		var T = createVNode("pattern", "", c, [p]), E = vNodeToString(T), D = a.patternCache, O = D[E];
		O || (O = a.zrId + "-p" + a.patternIdx++, D[E] = O, c.id = O, T = a.defs[O] = createVNode("pattern", O, c, [p])), n[r] = getIdURL(O);
	}
}
function setClipPath(t, n, r) {
	var a = r.clipPathCache, o = r.defs, s = a[t.id];
	if (!s) {
		s = r.zrId + "-c" + r.clipPathIdx++;
		var c = { id: s };
		a[t.id] = s, o[s] = createVNode("clipPath", s, c, [brushSVGPath(t, r)]);
	}
	n["clip-path"] = getIdURL(s);
}
function createTextNode(t) {
	return document.createTextNode(t);
}
function insertBefore(t, n, r) {
	t.insertBefore(n, r);
}
function removeChild(t, n) {
	t.removeChild(n);
}
function appendChild(t, n) {
	t.appendChild(n);
}
function parentNode(t) {
	return t.parentNode;
}
function nextSibling(t) {
	return t.nextSibling;
}
function setTextContent(t, n) {
	t.textContent = n;
}
init_dist$2();
var colonChar = 58, xChar = 120, emptyNode = createVNode("", "");
function isUndef(t) {
	return t === void 0;
}
function isDef(t) {
	return t !== void 0;
}
function createKeyToOldIdx(t, n, r) {
	for (var a = {}, o = n; o <= r; ++o) {
		var c = t[o].key;
		c !== void 0 && (process$1.env.NODE_ENV !== "production" && a[c] != null && console.error("Duplicate key " + c), a[c] = o);
	}
	return a;
}
function sameVnode(t, n) {
	var r = t.key === n.key;
	return t.tag === n.tag && r;
}
function createElm(t) {
	var n, r = t.children, a = t.tag;
	if (isDef(a)) {
		var o = t.elm = createElement(a);
		if (updateAttrs(emptyNode, t), isArray(r)) for (n = 0; n < r.length; ++n) {
			var s = r[n];
			s != null && appendChild(o, createElm(s));
		}
		else isDef(t.text) && !isObject(t.text) && appendChild(o, createTextNode(t.text));
	} else t.elm = createTextNode(t.text);
	return t.elm;
}
function addVnodes(t, n, r, a, o) {
	for (; a <= o; ++a) {
		var s = r[a];
		s != null && insertBefore(t, createElm(s), n);
	}
}
function removeVnodes(t, n, r, a) {
	for (; r <= a; ++r) {
		var o = n[r];
		o != null && (isDef(o.tag) ? removeChild(parentNode(o.elm), o.elm) : removeChild(t, o.elm));
	}
}
function updateAttrs(t, n) {
	var r, a = n.elm, o = t && t.attrs || {}, s = n.attrs || {};
	if (o !== s) {
		for (r in s) {
			var c = s[r];
			o[r] !== c && (c === !0 ? a.setAttribute(r, "") : c === !1 ? a.removeAttribute(r) : r === "style" ? a.style.cssText = c : r.charCodeAt(0) === xChar ? r === "xmlns:xlink" || r === "xmlns" ? a.setAttributeNS(XMLNS, r, c) : r.charCodeAt(3) === colonChar ? a.setAttributeNS(XML_NAMESPACE, r, c) : r.charCodeAt(5) === colonChar ? a.setAttributeNS(XLINKNS, r, c) : a.setAttribute(r, c) : a.setAttribute(r, c));
		}
		for (r in o) r in s || a.removeAttribute(r);
	}
}
function updateChildren(t, n, r) {
	for (var a = 0, o = 0, s = n.length - 1, c = n[0], l = n[s], u = r.length - 1, d = r[0], f = r[u], p, h, g, _; a <= s && o <= u;) c == null ? c = n[++a] : l == null ? l = n[--s] : d == null ? d = r[++o] : f == null ? f = r[--u] : sameVnode(c, d) ? (patchVnode(c, d), c = n[++a], d = r[++o]) : sameVnode(l, f) ? (patchVnode(l, f), l = n[--s], f = r[--u]) : sameVnode(c, f) ? (patchVnode(c, f), insertBefore(t, c.elm, nextSibling(l.elm)), c = n[++a], f = r[--u]) : sameVnode(l, d) ? (patchVnode(l, d), insertBefore(t, l.elm, c.elm), l = n[--s], d = r[++o]) : (isUndef(p) && (p = createKeyToOldIdx(n, a, s)), h = p[d.key], isUndef(h) ? insertBefore(t, createElm(d), c.elm) : (g = n[h], g.tag === d.tag ? (patchVnode(g, d), n[h] = void 0, insertBefore(t, g.elm, c.elm)) : insertBefore(t, createElm(d), c.elm)), d = r[++o]);
	(a <= s || o <= u) && (a > s ? (_ = r[u + 1] == null ? null : r[u + 1].elm, addVnodes(t, _, r, o, u)) : removeVnodes(t, n, a, s));
}
function patchVnode(t, n) {
	var r = n.elm = t.elm, a = t.children, o = n.children;
	t !== n && (updateAttrs(t, n), isUndef(n.text) ? isDef(a) && isDef(o) ? a !== o && updateChildren(r, a, o) : isDef(o) ? (isDef(t.text) && setTextContent(r, ""), addVnodes(r, null, o, 0, o.length - 1)) : isDef(a) ? removeVnodes(r, a, 0, a.length - 1) : isDef(t.text) && setTextContent(r, "") : t.text !== n.text && (isDef(a) && removeVnodes(r, a, 0, a.length - 1), setTextContent(r, n.text)));
}
function patch(t, n) {
	if (sameVnode(t, n)) patchVnode(t, n);
	else {
		var r = t.elm, a = parentNode(r);
		createElm(n), a !== null && (insertBefore(a, n.elm, nextSibling(r)), removeVnodes(a, [t], 0, 0));
	}
	return n;
}
init_dist$2();
var svgId = 0, SVGPainter = function() {
	function t(t, n, r) {
		if (this.type = "svg", this.refreshHover = createMethodNotSupport("refreshHover"), this.configLayer = createMethodNotSupport("configLayer"), this.storage = n, this._opts = r = extend({}, r), this.root = t, this._id = "zr" + svgId++, this._oldVNode = createSVGVNode(r.width, r.height), t && !r.ssr) {
			var a = this._viewport = document.createElement("div");
			a.style.cssText = "position:relative;overflow:hidden";
			var o = this._svgDom = this._oldVNode.elm = createElement("svg");
			updateAttrs(null, this._oldVNode), a.appendChild(o), t.appendChild(a);
		}
		this.resize(r.width, r.height);
	}
	return t.prototype.getType = function() {
		return this.type;
	}, t.prototype.getViewportRoot = function() {
		return this._viewport;
	}, t.prototype.getViewportRootOffset = function() {
		var t = this.getViewportRoot();
		if (t) return {
			offsetLeft: t.offsetLeft || 0,
			offsetTop: t.offsetTop || 0
		};
	}, t.prototype.getSvgDom = function() {
		return this._svgDom;
	}, t.prototype.refresh = function() {
		if (this.root) {
			var t = this.renderToVNode({ willUpdate: !0 });
			t.attrs.style = "position:absolute;left:0;top:0;user-select:none", patch(this._oldVNode, t), this._oldVNode = t;
		}
	}, t.prototype.renderOneToVNode = function(t) {
		return brush$1(t, createBrushScope(this._id));
	}, t.prototype.renderToVNode = function(t) {
		t ||= {};
		var n = this.storage.getDisplayList(!0), r = this._width, a = this._height, o = createBrushScope(this._id);
		o.animation = t.animation, o.willUpdate = t.willUpdate, o.compress = t.compress, o.emphasis = t.emphasis, o.ssr = this._opts.ssr;
		var s = [], c = this._bgVNode = createBackgroundVNode(r, a, this._backgroundColor, o);
		c && s.push(c);
		var l = t.compress ? null : this._mainVNode = createVNode("g", "main", {}, []);
		this._paintList(n, o, l ? l.children : s), l && s.push(l);
		var u = map(keys(o.defs), function(t) {
			return o.defs[t];
		});
		if (u.length && s.push(createVNode("defs", "defs", {}, u)), t.animation) {
			var d = getCssString(o.cssNodes, o.cssAnims, { newline: !0 });
			if (d) {
				var f = createVNode("style", "stl", {}, [], d);
				s.push(f);
			}
		}
		return createSVGVNode(r, a, s, t.useViewBox);
	}, t.prototype.renderToString = function(t) {
		return t ||= {}, vNodeToString(this.renderToVNode({
			animation: retrieve2(t.cssAnimation, !0),
			emphasis: retrieve2(t.cssEmphasis, !0),
			willUpdate: !1,
			compress: !0,
			useViewBox: retrieve2(t.useViewBox, !0)
		}), { newline: !0 });
	}, t.prototype.setBackgroundColor = function(t) {
		this._backgroundColor = t;
	}, t.prototype.getSvgRoot = function() {
		return this._mainVNode && this._mainVNode.elm;
	}, t.prototype._paintList = function(t, n, r) {
		for (var a = t.length, o = [], s = 0, c, l, u = 0, d = 0; d < a; d++) {
			var f = t[d];
			if (!f.invisible) {
				var p = f.__clipPaths, h = p && p.length || 0, g = l && l.length || 0, _ = void 0;
				for (_ = Math.max(h - 1, g - 1); _ >= 0 && !(p && l && p[_] === l[_]); _--);
				for (var v = g - 1; v > _; v--) s--, c = o[s - 1];
				for (var y = _ + 1; y < h; y++) {
					var b = {};
					setClipPath(p[y], b, n);
					var x = createVNode("g", "clip-g-" + u++, b, []);
					(c ? c.children : r).push(x), o[s++] = x, c = x;
				}
				l = p;
				var S = brush$1(f, n);
				S && (c ? c.children : r).push(S);
			}
		}
	}, t.prototype.resize = function(t, n) {
		var r = this._opts, a = this.root, o = this._viewport;
		if (t != null && (r.width = t), n != null && (r.height = n), a && o && (o.style.display = "none", t = getSize$1(a, 0, r), n = getSize$1(a, 1, r), o.style.display = ""), this._width !== t || this._height !== n) {
			if (this._width = t, this._height = n, o) {
				var s = o.style;
				s.width = t + "px", s.height = n + "px";
			}
			if (isPattern(this._backgroundColor)) this.refresh();
			else {
				var c = this._svgDom;
				c && (c.setAttribute("width", t), c.setAttribute("height", n));
				var l = this._bgVNode && this._bgVNode.elm;
				l && (l.setAttribute("width", t), l.setAttribute("height", n));
			}
		}
	}, t.prototype.getWidth = function() {
		return this._width;
	}, t.prototype.getHeight = function() {
		return this._height;
	}, t.prototype.dispose = function() {
		this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
	}, t.prototype.clear = function() {
		this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
	}, t.prototype.toDataURL = function(t) {
		var n = this.renderToString(), r = "data:image/svg+xml;";
		return t ? (n = encodeBase64(n), n && r + "base64," + n) : r + "charset=UTF-8," + encodeURIComponent(n);
	}, t;
}();
function createMethodNotSupport(t) {
	return function() {
		process$1.env.NODE_ENV !== "production" && logError("In SVG mode painter not support method \"" + t + "\"");
	};
}
function createBackgroundVNode(t, n, r, a) {
	var o;
	if (r && r !== "none") if (o = createVNode("rect", "bg", {
		width: t,
		height: n,
		x: "0",
		y: "0"
	}), isGradient(r)) setGradient({ fill: r }, o.attrs, "fill", a);
	else if (isPattern(r)) setPattern({
		style: { fill: r },
		dirty: noop,
		getBoundingRect: function() {
			return {
				width: t,
				height: n
			};
		}
	}, o.attrs, "fill", a);
	else {
		var s = normalizeColor(r), c = s.color, l = s.opacity;
		o.attrs.fill = c, l < 1 && (o.attrs["fill-opacity"] = l);
	}
	return o;
}
var Painter_default$1 = SVGPainter;
function install(t) {
	t.registerPainter("svg", Painter_default$1);
}
function createDom(t, n, r) {
	var a = platformApi.createCanvas(), o = n.getWidth(), s = n.getHeight(), c = a.style;
	return c && (c.position = "absolute", c.left = "0", c.top = "0", c.width = o + "px", c.height = s + "px", a.setAttribute("data-zr-dom-id", t)), a.width = o * r, a.height = s * r, a;
}
var Layer_default = function(t) {
	__extends(n, t);
	function n(n, r, a) {
		var o = t.call(this) || this;
		o.motionBlur = !1, o.lastFrameAlpha = .7, o.dpr = 1, o.virtual = !1, o.config = {}, o.incremental = !1, o.zlevel = 0, o.maxRepaintRectCount = 5, o.__dirty = !0, o.__firstTimePaint = !0, o.__used = !1, o.__drawIndex = 0, o.__startIndex = 0, o.__endIndex = 0, o.__prevStartIndex = null, o.__prevEndIndex = null;
		var s;
		a ||= devicePixelRatio, typeof n == "string" ? s = createDom(n, r, a) : isObject(n) && (s = n, n = s.id), o.id = n, o.dom = s;
		var c = s.style;
		return c && (disableUserSelect(s), s.onselectstart = function() {
			return !1;
		}, c.padding = "0", c.margin = "0", c.borderWidth = "0"), o.painter = r, o.dpr = a, o;
	}
	return n.prototype.getElementCount = function() {
		return this.__endIndex - this.__startIndex;
	}, n.prototype.afterBrush = function() {
		this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
	}, n.prototype.initContext = function() {
		this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
	}, n.prototype.setUnpainted = function() {
		this.__firstTimePaint = !0;
	}, n.prototype.createBackBuffer = function() {
		var t = this.dpr;
		this.domBack = createDom("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), t !== 1 && this.ctxBack.scale(t, t);
	}, n.prototype.createRepaintRects = function(t, n, r, a) {
		if (this.__firstTimePaint) return this.__firstTimePaint = !1, null;
		var o = [], s = this.maxRepaintRectCount, c = !1, l = new BoundingRect_default(0, 0, 0, 0);
		function u(t) {
			if (!(!t.isFinite() || t.isZero())) if (o.length === 0) {
				var n = new BoundingRect_default(0, 0, 0, 0);
				n.copy(t), o.push(n);
			} else {
				for (var r = !1, a = Infinity, u = 0, d = 0; d < o.length; ++d) {
					var f = o[d];
					if (f.intersect(t)) {
						var p = new BoundingRect_default(0, 0, 0, 0);
						p.copy(f), p.union(t), o[d] = p, r = !0;
						break;
					} else if (c) {
						l.copy(t), l.union(f);
						var h = t.width * t.height, g = f.width * f.height, _ = l.width * l.height - h - g;
						_ < a && (a = _, u = d);
					}
				}
				if (c && (o[u].union(t), r = !0), !r) {
					var n = new BoundingRect_default(0, 0, 0, 0);
					n.copy(t), o.push(n);
				}
				c ||= o.length >= s;
			}
		}
		for (var d = this.__startIndex; d < this.__endIndex; ++d) {
			var f = t[d];
			if (f) {
				var p = f.shouldBePainted(r, a, !0, !0), h = f.__isRendered && (f.__dirty & 1 || !p) ? f.getPrevPaintRect() : null;
				h && u(h);
				var g = p && (f.__dirty & 1 || !f.__isRendered) ? f.getPaintRect() : null;
				g && u(g);
			}
		}
		for (var d = this.__prevStartIndex; d < this.__prevEndIndex; ++d) {
			var f = n[d], p = f && f.shouldBePainted(r, a, !0, !0);
			if (f && (!p || !f.__zr) && f.__isRendered) {
				var h = f.getPrevPaintRect();
				h && u(h);
			}
		}
		var _;
		do {
			_ = !1;
			for (var d = 0; d < o.length;) {
				if (o[d].isZero()) {
					o.splice(d, 1);
					continue;
				}
				for (var v = d + 1; v < o.length;) o[d].intersect(o[v]) ? (_ = !0, o[d].union(o[v]), o.splice(v, 1)) : v++;
				d++;
			}
		} while (_);
		return this._paintRects = o, o;
	}, n.prototype.debugGetPaintRects = function() {
		return (this._paintRects || []).slice();
	}, n.prototype.resize = function(t, n) {
		var r = this.dpr, a = this.dom, o = a.style, s = this.domBack;
		o && (o.width = t + "px", o.height = n + "px"), a.width = t * r, a.height = n * r, s && (s.width = t * r, s.height = n * r, r !== 1 && this.ctxBack.scale(r, r));
	}, n.prototype.clear = function(t, n, r) {
		var a = this.dom, o = this.ctx, s = a.width, c = a.height;
		n ||= this.clearColor;
		var l = this.motionBlur && !t, u = this.lastFrameAlpha, d = this.dpr, f = this;
		l && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / d, c / d));
		var p = this.domBack;
		function h(t, r, a, s) {
			if (o.clearRect(t, r, a, s), n && n !== "transparent") {
				var c = void 0;
				isGradientObject(n) ? (c = (n.global || n.__width === a && n.__height === s) && n.__canvasGradient || getCanvasGradient(o, n, {
					x: 0,
					y: 0,
					width: a,
					height: s
				}), n.__canvasGradient = c, n.__width = a, n.__height = s) : isImagePatternObject(n) && (n.scaleX = n.scaleX || d, n.scaleY = n.scaleY || d, c = createCanvasPattern(o, n, { dirty: function() {
					f.setUnpainted(), f.painter.refresh();
				} })), o.save(), o.fillStyle = c || n, o.fillRect(t, r, a, s), o.restore();
			}
			l && (o.save(), o.globalAlpha = u, o.drawImage(p, t, r, a, s), o.restore());
		}
		!r || l ? h(0, 0, s, c) : r.length && each(r, function(t) {
			h(t.x * d, t.y * d, t.width * d, t.height * d);
		});
	}, n;
}(Eventful_default);
init_dist$2();
var HOVER_LAYER_ZLEVEL = 1e5, CANVAS_ZLEVEL = 314159, EL_AFTER_INCREMENTAL_INC = .01, INCREMENTAL_INC = .001;
function isLayerValid(t) {
	return t ? t.__builtin__ ? !0 : !(typeof t.resize != "function" || typeof t.refresh != "function") : !1;
}
function createRoot(t, n) {
	var r = document.createElement("div");
	return r.style.cssText = [
		"position:relative",
		"width:" + t + "px",
		"height:" + n + "px",
		"padding:0",
		"margin:0",
		"border-width:0"
	].join(";") + ";", r;
}
var Painter_default = function() {
	function t(t, n, r, a) {
		this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
		var o = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
		this._opts = r = extend({}, r || {}), this.dpr = r.devicePixelRatio || devicePixelRatio, this._singleCanvas = o, this.root = t, t.style && (disableUserSelect(t), t.innerHTML = ""), this.storage = n;
		var s = this._zlevelList;
		this._prevDisplayList = [];
		var c = this._layers;
		if (o) {
			var l = t, u = l.width, d = l.height;
			r.width != null && (u = r.width), r.height != null && (d = r.height), this.dpr = r.devicePixelRatio || 1, l.width = u * this.dpr, l.height = d * this.dpr, this._width = u, this._height = d;
			var f = new Layer_default(l, this, this.dpr);
			f.__builtin__ = !0, f.initContext(), c[CANVAS_ZLEVEL] = f, f.zlevel = CANVAS_ZLEVEL, s.push(CANVAS_ZLEVEL), this._domRoot = t;
		} else {
			this._width = getSize$1(t, 0, r), this._height = getSize$1(t, 1, r);
			var p = this._domRoot = createRoot(this._width, this._height);
			t.appendChild(p);
		}
	}
	return t.prototype.getType = function() {
		return "canvas";
	}, t.prototype.isSingleCanvas = function() {
		return this._singleCanvas;
	}, t.prototype.getViewportRoot = function() {
		return this._domRoot;
	}, t.prototype.getViewportRootOffset = function() {
		var t = this.getViewportRoot();
		if (t) return {
			offsetLeft: t.offsetLeft || 0,
			offsetTop: t.offsetTop || 0
		};
	}, t.prototype.refresh = function(t) {
		var n = this.storage.getDisplayList(!0), r = this._prevDisplayList, a = this._zlevelList;
		this._redrawId = Math.random(), this._paintList(n, r, t, this._redrawId);
		for (var o = 0; o < a.length; o++) {
			var s = a[o], c = this._layers[s];
			if (!c.__builtin__ && c.refresh) {
				var l = o === 0 ? this._backgroundColor : null;
				c.refresh(l);
			}
		}
		return this._opts.useDirtyRect && (this._prevDisplayList = n.slice()), this;
	}, t.prototype.refreshHover = function() {
		this._paintHoverList(this.storage.getDisplayList(!1));
	}, t.prototype._paintHoverList = function(t) {
		var n = t.length, r = this._hoverlayer;
		if (r && r.clear(), n) {
			for (var a = {
				inHover: !0,
				viewWidth: this._width,
				viewHeight: this._height
			}, o, s = 0; s < n; s++) {
				var c = t[s];
				c.__inHover && (r ||= this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL), o || (o = r.ctx, o.save()), brush(o, c, a, s === n - 1));
			}
			o && o.restore();
		}
	}, t.prototype.getHoverLayer = function() {
		return this.getLayer(HOVER_LAYER_ZLEVEL);
	}, t.prototype.paintOne = function(t, n) {
		brushSingle(t, n);
	}, t.prototype._paintList = function(t, n, r, a) {
		if (this._redrawId === a) {
			r ||= !1, this._updateLayerStatus(t);
			var o = this._doPaintList(t, n, r), s = o.finished, c = o.needsRefreshHover;
			if (this._needsManuallyCompositing && this._compositeManually(), c && this._paintHoverList(t), s) this.eachLayer(function(t) {
				t.afterBrush && t.afterBrush();
			});
			else {
				var l = this;
				requestAnimationFrame_default(function() {
					l._paintList(t, n, r, a);
				});
			}
		}
	}, t.prototype._compositeManually = function() {
		var t = this.getLayer(CANVAS_ZLEVEL).ctx, n = this._domRoot.width, r = this._domRoot.height;
		t.clearRect(0, 0, n, r), this.eachBuiltinLayer(function(a) {
			a.virtual && t.drawImage(a.dom, 0, 0, n, r);
		});
	}, t.prototype._doPaintList = function(t, n, r) {
		for (var a = this, o = [], s = this._opts.useDirtyRect, c = 0; c < this._zlevelList.length; c++) {
			var l = this._zlevelList[c], u = this._layers[l];
			u.__builtin__ && u !== this._hoverlayer && (u.__dirty || r) && o.push(u);
		}
		for (var d = !0, f = !1, p = function(c) {
			var l = o[c], u = l.ctx, p = s && l.createRepaintRects(t, n, g._width, g._height), h = r ? l.__startIndex : l.__drawIndex, _ = !r && l.incremental && Date.now, v = _ && Date.now(), y = l.zlevel === g._zlevelList[0] ? g._backgroundColor : null;
			if (l.__startIndex === l.__endIndex) l.clear(!1, y, p);
			else if (h === l.__startIndex) {
				var b = t[h];
				(!b.incremental || !b.notClear || r) && l.clear(!1, y, p);
			}
			h === -1 && (console.error("For some unknown reason. drawIndex is -1"), h = l.__startIndex);
			var x, S = function(n) {
				var r = {
					inHover: !1,
					allClipped: !1,
					prevEl: null,
					viewWidth: a._width,
					viewHeight: a._height
				};
				for (x = h; x < l.__endIndex; x++) {
					var o = t[x];
					if (o.__inHover && (f = !0), a._doPaintEl(o, l, s, n, r, x === l.__endIndex - 1), _ && Date.now() - v > 15) break;
				}
				r.prevElClipPaths && u.restore();
			};
			if (p) if (p.length === 0) x = l.__endIndex;
			else for (var C = g.dpr, w = 0; w < p.length; ++w) {
				var T = p[w];
				u.save(), u.beginPath(), u.rect(T.x * C, T.y * C, T.width * C, T.height * C), u.clip(), S(T), u.restore();
			}
			else u.save(), S(), u.restore();
			l.__drawIndex = x, l.__drawIndex < l.__endIndex && (d = !1);
		}, g = this, _ = 0; _ < o.length; _++) p(_);
		return env_default.wxa && each(this._layers, function(t) {
			t && t.ctx && t.ctx.draw && t.ctx.draw();
		}), {
			finished: d,
			needsRefreshHover: f
		};
	}, t.prototype._doPaintEl = function(t, n, r, a, o, s) {
		var c = n.ctx;
		if (r) {
			var l = t.getPaintRect();
			(!a || l && l.intersect(a)) && (brush(c, t, o, s), t.setPrevPaintRect(l));
		} else brush(c, t, o, s);
	}, t.prototype.getLayer = function(t, n) {
		this._singleCanvas && !this._needsManuallyCompositing && (t = CANVAS_ZLEVEL);
		var r = this._layers[t];
		return r || (r = new Layer_default("zr_" + t, this, this.dpr), r.zlevel = t, r.__builtin__ = !0, this._layerConfig[t] ? merge(r, this._layerConfig[t], !0) : this._layerConfig[t - EL_AFTER_INCREMENTAL_INC] && merge(r, this._layerConfig[t - EL_AFTER_INCREMENTAL_INC], !0), n && (r.virtual = n), this.insertLayer(t, r), r.initContext()), r;
	}, t.prototype.insertLayer = function(t, n) {
		var r = this._layers, a = this._zlevelList, o = a.length, c = this._domRoot, l = null, u = -1;
		if (r[t]) {
			process$1.env.NODE_ENV !== "production" && logError("ZLevel " + t + " has been used already");
			return;
		}
		if (!isLayerValid(n)) {
			process$1.env.NODE_ENV !== "production" && logError("Layer of zlevel " + t + " is not valid");
			return;
		}
		if (o > 0 && t > a[0]) {
			for (u = 0; u < o - 1 && !(a[u] < t && a[u + 1] > t); u++);
			l = r[a[u]];
		}
		if (a.splice(u + 1, 0, t), r[t] = n, !n.virtual) if (l) {
			var d = l.dom;
			d.nextSibling ? c.insertBefore(n.dom, d.nextSibling) : c.appendChild(n.dom);
		} else c.firstChild ? c.insertBefore(n.dom, c.firstChild) : c.appendChild(n.dom);
		n.painter ||= this;
	}, t.prototype.eachLayer = function(t, n) {
		for (var r = this._zlevelList, a = 0; a < r.length; a++) {
			var o = r[a];
			t.call(n, this._layers[o], o);
		}
	}, t.prototype.eachBuiltinLayer = function(t, n) {
		for (var r = this._zlevelList, a = 0; a < r.length; a++) {
			var o = r[a], s = this._layers[o];
			s.__builtin__ && t.call(n, s, o);
		}
	}, t.prototype.eachOtherLayer = function(t, n) {
		for (var r = this._zlevelList, a = 0; a < r.length; a++) {
			var o = r[a], s = this._layers[o];
			s.__builtin__ || t.call(n, s, o);
		}
	}, t.prototype.getLayers = function() {
		return this._layers;
	}, t.prototype._updateLayerStatus = function(t) {
		this.eachBuiltinLayer(function(t, n) {
			t.__dirty = t.__used = !1;
		});
		function n(t) {
			o && (o.__endIndex !== t && (o.__dirty = !0), o.__endIndex = t);
		}
		if (this._singleCanvas) for (var r = 1; r < t.length; r++) {
			var a = t[r];
			if (a.zlevel !== t[r - 1].zlevel || a.incremental) {
				this._needsManuallyCompositing = !0;
				break;
			}
		}
		var o = null, s = 0, c, l;
		for (l = 0; l < t.length; l++) {
			var a = t[l], u = a.zlevel, d = void 0;
			c !== u && (c = u, s = 0), a.incremental ? (d = this.getLayer(u + INCREMENTAL_INC, this._needsManuallyCompositing), d.incremental = !0, s = 1) : d = this.getLayer(u + (s > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing), d.__builtin__ || logError("ZLevel " + u + " has been used by unkown layer " + d.id), d !== o && (d.__used = !0, d.__startIndex !== l && (d.__dirty = !0), d.__startIndex = l, d.incremental ? d.__drawIndex = -1 : d.__drawIndex = l, n(l), o = d), a.__dirty & 1 && !a.__inHover && (d.__dirty = !0, d.incremental && d.__drawIndex < 0 && (d.__drawIndex = l));
		}
		n(l), this.eachBuiltinLayer(function(t, n) {
			!t.__used && t.getElementCount() > 0 && (t.__dirty = !0, t.__startIndex = t.__endIndex = t.__drawIndex = 0), t.__dirty && t.__drawIndex < 0 && (t.__drawIndex = t.__startIndex);
		});
	}, t.prototype.clear = function() {
		return this.eachBuiltinLayer(this._clearLayer), this;
	}, t.prototype._clearLayer = function(t) {
		t.clear();
	}, t.prototype.setBackgroundColor = function(t) {
		this._backgroundColor = t, each(this._layers, function(t) {
			t.setUnpainted();
		});
	}, t.prototype.configLayer = function(t, n) {
		if (n) {
			var r = this._layerConfig;
			r[t] ? merge(r[t], n, !0) : r[t] = n;
			for (var a = 0; a < this._zlevelList.length; a++) {
				var o = this._zlevelList[a];
				if (o === t || o === t + EL_AFTER_INCREMENTAL_INC) {
					var s = this._layers[o];
					merge(s, r[t], !0);
				}
			}
		}
	}, t.prototype.delLayer = function(t) {
		var n = this._layers, r = this._zlevelList, a = n[t];
		a && (a.dom.parentNode.removeChild(a.dom), delete n[t], r.splice(indexOf(r, t), 1));
	}, t.prototype.resize = function(t, n) {
		if (this._domRoot.style) {
			var r = this._domRoot;
			r.style.display = "none";
			var a = this._opts, o = this.root;
			if (t != null && (a.width = t), n != null && (a.height = n), t = getSize$1(o, 0, a), n = getSize$1(o, 1, a), r.style.display = "", this._width !== t || n !== this._height) {
				for (var s in r.style.width = t + "px", r.style.height = n + "px", this._layers) this._layers.hasOwnProperty(s) && this._layers[s].resize(t, n);
				this.refresh(!0);
			}
			this._width = t, this._height = n;
		} else {
			if (t == null || n == null) return;
			this._width = t, this._height = n, this.getLayer(CANVAS_ZLEVEL).resize(t, n);
		}
		return this;
	}, t.prototype.clearLayer = function(t) {
		var n = this._layers[t];
		n && n.clear();
	}, t.prototype.dispose = function() {
		this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
	}, t.prototype.getRenderedCanvas = function(t) {
		if (t ||= {}, this._singleCanvas && !this._compositeManually) return this._layers[CANVAS_ZLEVEL].dom;
		var n = new Layer_default("image", this, t.pixelRatio || this.dpr);
		n.initContext(), n.clear(!1, t.backgroundColor || this._backgroundColor);
		var r = n.ctx;
		if (t.pixelRatio <= this.dpr) {
			this.refresh();
			var a = n.dom.width, o = n.dom.height;
			this.eachLayer(function(t) {
				t.__builtin__ ? r.drawImage(t.dom, 0, 0, a, o) : t.renderToCanvas && (r.save(), t.renderToCanvas(r), r.restore());
			});
		} else for (var s = {
			inHover: !1,
			viewWidth: this._width,
			viewHeight: this._height
		}, c = this.storage.getDisplayList(!0), l = 0, u = c.length; l < u; l++) {
			var d = c[l];
			brush(r, d, s, l === u - 1);
		}
		return n.dom;
	}, t.prototype.getWidth = function() {
		return this._width;
	}, t.prototype.getHeight = function() {
		return this._height;
	}, t;
}();
function install$1(t) {
	t.registerPainter("canvas", Painter_default);
}
init_dist$2();
var LineSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.hasSymbolVisual = !0, r;
	}
	return n.prototype.getInitialData = function(t) {
		if (process$1.env.NODE_ENV !== "production") {
			var n = t.coordinateSystem;
			if (n !== "polar" && n !== "cartesian2d") throw Error("Line not support coordinateSystem besides cartesian and polar");
		}
		return createSeriesData_default(null, this, { useEncodeDefaulter: !0 });
	}, n.prototype.getLegendIcon = function(t) {
		var n = new Group_default(), r = createSymbol("line", 0, t.itemHeight / 2, t.itemWidth, 0, t.lineStyle.stroke, !1);
		n.add(r), r.setStyle(t.lineStyle);
		var a = this.getData().getVisual("symbol"), o = this.getData().getVisual("symbolRotate"), s = a === "none" ? "circle" : a, c = t.itemHeight * .8, l = createSymbol(s, (t.itemWidth - c) / 2, (t.itemHeight - c) / 2, c, c, t.itemStyle.fill);
		return n.add(l), l.setStyle(t.itemStyle), l.rotation = (t.iconRotate === "inherit" ? o : t.iconRotate || 0) * Math.PI / 180, l.setOrigin([t.itemWidth / 2, t.itemHeight / 2]), s.indexOf("empty") > -1 && (l.style.stroke = l.style.fill, l.style.fill = "#fff", l.style.lineWidth = 2), n;
	}, n.type = "series.line", n.dependencies = ["grid", "polar"], n.defaultOption = {
		z: 3,
		coordinateSystem: "cartesian2d",
		legendHoverLink: !0,
		clip: !0,
		label: { position: "top" },
		endLabel: {
			show: !1,
			valueAnimation: !0,
			distance: 8
		},
		lineStyle: {
			width: 2,
			type: "solid"
		},
		emphasis: { scale: !0 },
		step: !1,
		smooth: !1,
		smoothMonotone: null,
		symbol: "emptyCircle",
		symbolSize: 4,
		symbolRotate: null,
		showSymbol: !0,
		showAllSymbol: "auto",
		connectNulls: !1,
		sampling: "none",
		animationEasing: "linear",
		progressive: 0,
		hoverLayerThreshold: Infinity,
		universalTransition: { divideShape: "clone" },
		triggerLineEvent: !1
	}, n;
}(Series_default);
function getDefaultLabel(t, n) {
	var r = t.mapDimensionsAll("defaultedLabel"), a = r.length;
	if (a === 1) {
		var o = retrieveRawValue(t, n, r[0]);
		return o == null ? null : o + "";
	} else if (a) {
		for (var s = [], c = 0; c < r.length; c++) s.push(retrieveRawValue(t, n, r[c]));
		return s.join(" ");
	}
}
function getDefaultInterpolatedLabel(t, n) {
	var r = t.mapDimensionsAll("defaultedLabel");
	if (!isArray(n)) return n + "";
	for (var a = [], o = 0; o < r.length; o++) {
		var s = t.getDimensionIndex(r[o]);
		s >= 0 && a.push(n[s]);
	}
	return a.join(" ");
}
var Symbol$1 = function(t) {
	__extends(n, t);
	function n(n, r, a, o) {
		var s = t.call(this) || this;
		return s.updateData(n, r, a, o), s;
	}
	return n.prototype._createSymbol = function(t, n, r, a, o) {
		this.removeAll();
		var s = createSymbol(t, -1, -1, 2, 2, null, o);
		s.attr({
			z2: 100,
			culling: !0,
			scaleX: a[0] / 2,
			scaleY: a[1] / 2
		}), s.drift = driftSymbol, this._symbolType = t, this.add(s);
	}, n.prototype.stopSymbolAnimation = function(t) {
		this.childAt(0).stopAnimation(null, t);
	}, n.prototype.getSymbolType = function() {
		return this._symbolType;
	}, n.prototype.getSymbolPath = function() {
		return this.childAt(0);
	}, n.prototype.highlight = function() {
		enterEmphasis(this.childAt(0));
	}, n.prototype.downplay = function() {
		leaveEmphasis(this.childAt(0));
	}, n.prototype.setZ = function(t, n) {
		var r = this.childAt(0);
		r.zlevel = t, r.z = n;
	}, n.prototype.setDraggable = function(t, n) {
		var r = this.childAt(0);
		r.draggable = t, r.cursor = !n && t ? "move" : r.cursor;
	}, n.prototype.updateData = function(t, r, a, o) {
		this.silent = !1;
		var s = t.getItemVisual(r, "symbol") || "circle", c = t.hostModel, l = n.getSymbolSize(t, r), u = s !== this._symbolType, d = o && o.disableAnimation;
		if (u) {
			var f = t.getItemVisual(r, "symbolKeepAspect");
			this._createSymbol(s, t, r, l, f);
		} else {
			var p = this.childAt(0);
			p.silent = !1;
			var h = {
				scaleX: l[0] / 2,
				scaleY: l[1] / 2
			};
			d ? p.attr(h) : updateProps(p, h, c, r), saveOldStyle(p);
		}
		if (this._updateCommon(t, r, l, a, o), u) {
			var p = this.childAt(0);
			if (!d) {
				var h = {
					scaleX: this._sizeX,
					scaleY: this._sizeY,
					style: { opacity: p.style.opacity }
				};
				p.scaleX = p.scaleY = 0, p.style.opacity = 0, initProps(p, h, c, r);
			}
		}
		d && this.childAt(0).stopAnimation("leave");
	}, n.prototype._updateCommon = function(t, n, r, a, o) {
		var s = this.childAt(0), c = t.hostModel, l, u, d, f, p, h, g, _, v;
		if (a && (l = a.emphasisItemStyle, u = a.blurItemStyle, d = a.selectItemStyle, f = a.focus, p = a.blurScope, g = a.labelStatesModels, _ = a.hoverScale, v = a.cursorStyle, h = a.emphasisDisabled), !a || t.hasItemOption) {
			var y = a && a.itemModel ? a.itemModel : t.getItemModel(n), b = y.getModel("emphasis");
			l = b.getModel("itemStyle").getItemStyle(), d = y.getModel(["select", "itemStyle"]).getItemStyle(), u = y.getModel(["blur", "itemStyle"]).getItemStyle(), f = b.get("focus"), p = b.get("blurScope"), h = b.get("disabled"), g = getLabelStatesModels(y), _ = b.getShallow("scale"), v = y.getShallow("cursor");
		}
		var x = t.getItemVisual(n, "symbolRotate");
		s.attr("rotation", (x || 0) * Math.PI / 180 || 0);
		var S = normalizeSymbolOffset(t.getItemVisual(n, "symbolOffset"), r);
		S && (s.x = S[0], s.y = S[1]), v && s.attr("cursor", v);
		var C = t.getItemVisual(n, "style"), w = C.fill;
		if (s instanceof Image_default) {
			var T = s.style;
			s.useStyle(extend({
				image: T.image,
				x: T.x,
				y: T.y,
				width: T.width,
				height: T.height
			}, C));
		} else s.__isEmptyBrush ? s.useStyle(extend({}, C)) : s.useStyle(C), s.style.decal = null, s.setColor(w, o && o.symbolInnerColor), s.style.strokeNoScale = !0;
		var E = t.getItemVisual(n, "liftZ"), D = this._z2;
		E == null ? D != null && (s.z2 = D, this._z2 = null) : D ?? (this._z2 = s.z2, s.z2 += E);
		var O = o && o.useNameLabel;
		setLabelStyle(s, g, {
			labelFetcher: c,
			labelDataIndex: n,
			defaultText: A,
			inheritColor: w,
			defaultOpacity: C.opacity
		});
		function A(n) {
			return O ? t.getName(n) : getDefaultLabel(t, n);
		}
		this._sizeX = r[0] / 2, this._sizeY = r[1] / 2;
		var j = s.ensureState("emphasis");
		j.style = l, s.ensureState("select").style = d, s.ensureState("blur").style = u;
		var M = _ == null || _ === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(_) && _ > 0 ? +_ : 1;
		j.scaleX = this._sizeX * M, j.scaleY = this._sizeY * M, this.setSymbolScale(1), toggleHoverEmphasis(this, f, p, h);
	}, n.prototype.setSymbolScale = function(t) {
		this.scaleX = this.scaleY = t;
	}, n.prototype.fadeOut = function(t, n, r) {
		var a = this.childAt(0), o = getECData(this).dataIndex, s = r && r.animation;
		if (this.silent = a.silent = !0, r && r.fadeLabel) {
			var c = a.getTextContent();
			c && removeElement(c, { style: { opacity: 0 } }, n, {
				dataIndex: o,
				removeOpt: s,
				cb: function() {
					a.removeTextContent();
				}
			});
		} else a.removeTextContent();
		removeElement(a, {
			style: { opacity: 0 },
			scaleX: 0,
			scaleY: 0
		}, n, {
			dataIndex: o,
			cb: t,
			removeOpt: s
		});
	}, n.getSymbolSize = function(t, n) {
		return normalizeSymbolSize(t.getItemVisual(n, "symbolSize"));
	}, n;
}(Group_default);
function driftSymbol(t, n) {
	this.parent.drift(t, n);
}
var Symbol_default = Symbol$1;
function symbolNeedsDraw$1(t, n, r, a) {
	return n && !isNaN(n[0]) && !isNaN(n[1]) && !(a.isIgnore && a.isIgnore(r)) && !(a.clipShape && !a.clipShape.contain(n[0], n[1])) && t.getItemVisual(r, "symbol") !== "none";
}
function normalizeUpdateOpt(t) {
	return t != null && !isObject(t) && (t = { isIgnore: t }), t || {};
}
function makeSeriesScope$2(t) {
	var n = t.hostModel, r = n.getModel("emphasis");
	return {
		emphasisItemStyle: r.getModel("itemStyle").getItemStyle(),
		blurItemStyle: n.getModel(["blur", "itemStyle"]).getItemStyle(),
		selectItemStyle: n.getModel(["select", "itemStyle"]).getItemStyle(),
		focus: r.get("focus"),
		blurScope: r.get("blurScope"),
		emphasisDisabled: r.get("disabled"),
		hoverScale: r.get("scale"),
		labelStatesModels: getLabelStatesModels(n),
		cursorStyle: n.get("cursor")
	};
}
var SymbolDraw_default = function() {
	function t(t) {
		this.group = new Group_default(), this._SymbolCtor = t || Symbol_default;
	}
	return t.prototype.updateData = function(t, n) {
		this._progressiveEls = null, n = normalizeUpdateOpt(n);
		var r = this.group, a = t.hostModel, o = this._data, s = this._SymbolCtor, c = n.disableAnimation, l = makeSeriesScope$2(t), u = { disableAnimation: c }, d = n.getSymbolPoint || function(n) {
			return t.getItemLayout(n);
		};
		o || r.removeAll(), t.diff(o).add(function(a) {
			var o = d(a);
			if (symbolNeedsDraw$1(t, o, a, n)) {
				var c = new s(t, a, l, u);
				c.setPosition(o), t.setItemGraphicEl(a, c), r.add(c);
			}
		}).update(function(f, p) {
			var h = o.getItemGraphicEl(p), g = d(f);
			if (!symbolNeedsDraw$1(t, g, f, n)) {
				r.remove(h);
				return;
			}
			var _ = t.getItemVisual(f, "symbol") || "circle", v = h && h.getSymbolType && h.getSymbolType();
			if (!h || v && v !== _) r.remove(h), h = new s(t, f, l, u), h.setPosition(g);
			else {
				h.updateData(t, f, l, u);
				var y = {
					x: g[0],
					y: g[1]
				};
				c ? h.attr(y) : updateProps(h, y, a);
			}
			r.add(h), t.setItemGraphicEl(f, h);
		}).remove(function(t) {
			var n = o.getItemGraphicEl(t);
			n && n.fadeOut(function() {
				r.remove(n);
			}, a);
		}).execute(), this._getSymbolPoint = d, this._data = t;
	}, t.prototype.updateLayout = function() {
		var t = this, n = this._data;
		n && n.eachItemGraphicEl(function(n, r) {
			var a = t._getSymbolPoint(r);
			n.setPosition(a), n.markRedraw();
		});
	}, t.prototype.incrementalPrepareUpdate = function(t) {
		this._seriesScope = makeSeriesScope$2(t), this._data = null, this.group.removeAll();
	}, t.prototype.incrementalUpdate = function(t, n, r) {
		this._progressiveEls = [], r = normalizeUpdateOpt(r);
		function a(t) {
			t.isGroup || (t.incremental = !0, t.ensureState("emphasis").hoverLayer = !0);
		}
		for (var o = t.start; o < t.end; o++) {
			var s = n.getItemLayout(o);
			if (symbolNeedsDraw$1(n, s, o, r)) {
				var c = new this._SymbolCtor(n, o, this._seriesScope);
				c.traverse(a), c.setPosition(s), this.group.add(c), n.setItemGraphicEl(o, c), this._progressiveEls.push(c);
			}
		}
	}, t.prototype.eachRendered = function(t) {
		traverseElements(this._progressiveEls || this.group, t);
	}, t.prototype.remove = function(t) {
		var n = this.group, r = this._data;
		r && t ? r.eachItemGraphicEl(function(t) {
			t.fadeOut(function() {
				n.remove(t);
			}, r.hostModel);
		}) : n.removeAll();
	}, t;
}();
function prepareDataCoordInfo(t, n, r) {
	var a = t.getBaseAxis(), o = t.getOtherAxis(a), s = getValueStart(o, r), c = a.dim, l = o.dim, u = n.mapDimension(l), d = n.mapDimension(c), f = l === "x" || l === "radius" ? 1 : 0, p = map(t.dimensions, function(t) {
		return n.mapDimension(t);
	}), h = !1, g = n.getCalculationInfo("stackResultDimension");
	return isDimensionStacked(n, p[0]) && (h = !0, p[0] = g), isDimensionStacked(n, p[1]) && (h = !0, p[1] = g), {
		dataDimsForPoint: p,
		valueStart: s,
		valueAxisDim: l,
		baseAxisDim: c,
		stacked: !!h,
		valueDim: u,
		baseDim: d,
		baseDataOffset: f,
		stackedOverDimension: n.getCalculationInfo("stackedOverDimension")
	};
}
function getValueStart(t, n) {
	var r = 0, a = t.scale.getExtent();
	return n === "start" ? r = a[0] : n === "end" ? r = a[1] : isNumber(n) && !isNaN(n) ? r = n : a[0] > 0 ? r = a[0] : a[1] < 0 && (r = a[1]), r;
}
function getStackedOnPoint(t, n, r, a) {
	var o = NaN;
	t.stacked && (o = r.get(r.getCalculationInfo("stackedOverDimension"), a)), isNaN(o) && (o = t.valueStart);
	var s = t.baseDataOffset, c = [];
	return c[s] = r.get(t.baseDim, a), c[1 - s] = o, n.dataToPoint(c);
}
function diffData(t, n) {
	var r = [];
	return n.diff(t).add(function(t) {
		r.push({
			cmd: "+",
			idx: t
		});
	}).update(function(t, n) {
		r.push({
			cmd: "=",
			idx: n,
			idx1: t
		});
	}).remove(function(t) {
		r.push({
			cmd: "-",
			idx: t
		});
	}).execute(), r;
}
function lineAnimationDiff(t, n, r, a, o, s, c, l) {
	for (var u = diffData(t, n), d = [], f = [], p = [], h = [], g = [], _ = [], v = [], y = prepareDataCoordInfo(o, n, c), b = t.getLayout("points") || [], x = n.getLayout("points") || [], S = 0; S < u.length; S++) {
		var C = u[S], w = !0, T = void 0, E = void 0;
		switch (C.cmd) {
			case "=":
				T = C.idx * 2, E = C.idx1 * 2;
				var D = b[T], O = b[T + 1], A = x[E], j = x[E + 1];
				(isNaN(D) || isNaN(O)) && (D = A, O = j), d.push(D, O), f.push(A, j), p.push(r[T], r[T + 1]), h.push(a[E], a[E + 1]), v.push(n.getRawIndex(C.idx1));
				break;
			case "+":
				var M = C.idx, N = y.dataDimsForPoint, P = o.dataToPoint([n.get(N[0], M), n.get(N[1], M)]);
				E = M * 2, d.push(P[0], P[1]), f.push(x[E], x[E + 1]);
				var F = getStackedOnPoint(y, o, n, M);
				p.push(F[0], F[1]), h.push(a[E], a[E + 1]), v.push(n.getRawIndex(M));
				break;
			case "-": w = !1;
		}
		w && (g.push(C), _.push(_.length));
	}
	_.sort(function(t, n) {
		return v[t] - v[n];
	});
	for (var I = d.length, L = createFloat32Array(I), R = createFloat32Array(I), z = createFloat32Array(I), B = createFloat32Array(I), V = [], S = 0; S < _.length; S++) {
		var H = _[S], U = S * 2, W = H * 2;
		L[U] = d[W], L[U + 1] = d[W + 1], R[U] = f[W], R[U + 1] = f[W + 1], z[U] = p[W], z[U + 1] = p[W + 1], B[U] = h[W], B[U + 1] = h[W + 1], V[S] = g[H];
	}
	return {
		current: L,
		next: R,
		stackedOnCurrent: z,
		stackedOnNext: B,
		status: V
	};
}
var mathMin$5 = Math.min, mathMax$5 = Math.max;
function isPointNull$1(t, n) {
	return isNaN(t) || isNaN(n);
}
function drawSegment(t, n, r, a, o, s, c, l, u) {
	for (var d, f, p, h, g, _, v = r, y = 0; y < a; y++) {
		var b = n[v * 2], x = n[v * 2 + 1];
		if (v >= o || v < 0) break;
		if (isPointNull$1(b, x)) {
			if (u) {
				v += s;
				continue;
			}
			break;
		}
		if (v === r) t[s > 0 ? "moveTo" : "lineTo"](b, x), p = b, h = x;
		else {
			var S = b - d, C = x - f;
			if (S * S + C * C < .5) {
				v += s;
				continue;
			}
			if (c > 0) {
				for (var w = v + s, T = n[w * 2], E = n[w * 2 + 1]; T === b && E === x && y < a;) y++, w += s, v += s, T = n[w * 2], E = n[w * 2 + 1], b = n[v * 2], x = n[v * 2 + 1], S = b - d, C = x - f;
				var D = y + 1;
				if (u) for (; isPointNull$1(T, E) && D < a;) D++, w += s, T = n[w * 2], E = n[w * 2 + 1];
				var O = .5, A = 0, j = 0, M = void 0, N = void 0;
				if (D >= a || isPointNull$1(T, E)) g = b, _ = x;
				else {
					A = T - d, j = E - f;
					var P = b - d, F = T - b, I = x - f, L = E - x, R = void 0, z = void 0;
					if (l === "x") {
						R = Math.abs(P), z = Math.abs(F);
						var B = A > 0 ? 1 : -1;
						g = b - B * R * c, _ = x, M = b + B * z * c, N = x;
					} else if (l === "y") {
						R = Math.abs(I), z = Math.abs(L);
						var V = j > 0 ? 1 : -1;
						g = b, _ = x - V * R * c, M = b, N = x + V * z * c;
					} else R = Math.sqrt(P * P + I * I), z = Math.sqrt(F * F + L * L), O = z / (z + R), g = b - A * c * (1 - O), _ = x - j * c * (1 - O), M = b + A * c * O, N = x + j * c * O, M = mathMin$5(M, mathMax$5(T, b)), N = mathMin$5(N, mathMax$5(E, x)), M = mathMax$5(M, mathMin$5(T, b)), N = mathMax$5(N, mathMin$5(E, x)), A = M - b, j = N - x, g = b - A * R / z, _ = x - j * R / z, g = mathMin$5(g, mathMax$5(d, b)), _ = mathMin$5(_, mathMax$5(f, x)), g = mathMax$5(g, mathMin$5(d, b)), _ = mathMax$5(_, mathMin$5(f, x)), A = b - g, j = x - _, M = b + A * z / R, N = x + j * z / R;
				}
				t.bezierCurveTo(p, h, g, _, b, x), p = M, h = N;
			} else t.lineTo(b, x);
		}
		d = b, f = x, v += s;
	}
	return y;
}
var ECPolylineShape = function() {
	function t() {
		this.smooth = 0, this.smoothConstraint = !0;
	}
	return t;
}(), ECPolyline = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this, n) || this;
		return r.type = "ec-polyline", r;
	}
	return n.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	}, n.prototype.getDefaultShape = function() {
		return new ECPolylineShape();
	}, n.prototype.buildPath = function(t, n) {
		var r = n.points, a = 0, o = r.length / 2;
		if (n.connectNulls) {
			for (; o > 0 && isPointNull$1(r[o * 2 - 2], r[o * 2 - 1]); o--);
			for (; a < o && isPointNull$1(r[a * 2], r[a * 2 + 1]); a++);
		}
		for (; a < o;) a += drawSegment(t, r, a, o, o, 1, n.smooth, n.smoothMonotone, n.connectNulls) + 1;
	}, n.prototype.getPointOn = function(t, n) {
		this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
		for (var r = this.path.data, a = PathProxy_default.CMD, o, s, c = n === "x", l = [], u = 0; u < r.length;) {
			var d = r[u++], f = void 0, p = void 0, h = void 0, g = void 0, _ = void 0, v = void 0, y = void 0;
			switch (d) {
				case a.M:
					o = r[u++], s = r[u++];
					break;
				case a.L:
					if (f = r[u++], p = r[u++], y = c ? (t - o) / (f - o) : (t - s) / (p - s), y <= 1 && y >= 0) {
						var b = c ? (p - s) * y + s : (f - o) * y + o;
						return c ? [t, b] : [b, t];
					}
					o = f, s = p;
					break;
				case a.C:
					f = r[u++], p = r[u++], h = r[u++], g = r[u++], _ = r[u++], v = r[u++];
					var x = c ? cubicRootAt(o, f, h, _, t, l) : cubicRootAt(s, p, g, v, t, l);
					if (x > 0) for (var S = 0; S < x; S++) {
						var C = l[S];
						if (C <= 1 && C >= 0) {
							var b = c ? cubicAt(s, p, g, v, C) : cubicAt(o, f, h, _, C);
							return c ? [t, b] : [b, t];
						}
					}
					o = _, s = v;
					break;
			}
		}
	}, n;
}(Path_default), ECPolygonShape = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n;
}(ECPolylineShape), ECPolygon = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this, n) || this;
		return r.type = "ec-polygon", r;
	}
	return n.prototype.getDefaultShape = function() {
		return new ECPolygonShape();
	}, n.prototype.buildPath = function(t, n) {
		var r = n.points, a = n.stackedOnPoints, o = 0, s = r.length / 2, c = n.smoothMonotone;
		if (n.connectNulls) {
			for (; s > 0 && isPointNull$1(r[s * 2 - 2], r[s * 2 - 1]); s--);
			for (; o < s && isPointNull$1(r[o * 2], r[o * 2 + 1]); o++);
		}
		for (; o < s;) {
			var l = drawSegment(t, r, o, s, s, 1, n.smooth, c, n.connectNulls);
			drawSegment(t, a, o + l - 1, l, s, -1, n.stackedOnSmooth, c, n.connectNulls), o += l + 1, t.closePath();
		}
	}, n;
}(Path_default);
function createGridClipPath(t, n, r, a, o) {
	var s = t.getArea(), c = s.x, l = s.y, u = s.width, d = s.height, f = r.get(["lineStyle", "width"]) || 0;
	c -= f / 2, l -= f / 2, u += f, d += f, u = Math.ceil(u), c !== Math.floor(c) && (c = Math.floor(c), u++);
	var p = new Rect_default({ shape: {
		x: c,
		y: l,
		width: u,
		height: d
	} });
	if (n) {
		var h = t.getBaseAxis(), g = h.isHorizontal(), _ = h.inverse;
		g ? (_ && (p.shape.x += u), p.shape.width = 0) : (_ || (p.shape.y += d), p.shape.height = 0);
		var v = isFunction(o) ? function(t) {
			o(t, p);
		} : null;
		initProps(p, { shape: {
			width: u,
			height: d,
			x: c,
			y: l
		} }, r, null, a, v);
	}
	return p;
}
function createPolarClipPath(t, n, r) {
	var a = t.getArea(), o = round$1(a.r0, 1), s = round$1(a.r, 1), c = new Sector_default({ shape: {
		cx: round$1(t.cx, 1),
		cy: round$1(t.cy, 1),
		r0: o,
		r: s,
		startAngle: a.startAngle,
		endAngle: a.endAngle,
		clockwise: a.clockwise
	} });
	return n && (t.getBaseAxis().dim === "angle" ? c.shape.endAngle = a.startAngle : c.shape.r = o, initProps(c, { shape: {
		endAngle: a.endAngle,
		r: s
	} }, r)), c;
}
function createClipPath(t, n, r, a, o) {
	if (t) {
		if (t.type === "polar") return createPolarClipPath(t, n, r);
		if (t.type === "cartesian2d") return createGridClipPath(t, n, r, a, o);
	} else return null;
	return null;
}
function isCoordinateSystemType(t, n) {
	return t.type === n;
}
init_dist$2();
function isPointsSame(t, n) {
	if (t.length === n.length) {
		for (var r = 0; r < t.length; r++) if (t[r] !== n[r]) return;
		return !0;
	}
}
function bboxFromPoints(t) {
	for (var n = Infinity, r = Infinity, a = -Infinity, o = -Infinity, s = 0; s < t.length;) {
		var c = t[s++], l = t[s++];
		isNaN(c) || (n = Math.min(c, n), a = Math.max(c, a)), isNaN(l) || (r = Math.min(l, r), o = Math.max(l, o));
	}
	return [[n, r], [a, o]];
}
function getBoundingDiff(t, n) {
	var r = bboxFromPoints(t), a = r[0], o = r[1], s = bboxFromPoints(n), c = s[0], l = s[1];
	return Math.max(Math.abs(a[0] - c[0]), Math.abs(a[1] - c[1]), Math.abs(o[0] - l[0]), Math.abs(o[1] - l[1]));
}
function getSmooth(t) {
	return isNumber(t) ? t : t ? .5 : 0;
}
function getStackedOnPoints(t, n, r) {
	if (!r.valueDim) return [];
	for (var a = n.count(), o = createFloat32Array(a * 2), s = 0; s < a; s++) {
		var c = getStackedOnPoint(r, t, n, s);
		o[s * 2] = c[0], o[s * 2 + 1] = c[1];
	}
	return o;
}
function turnPointsIntoStep(t, n, r, a, o) {
	var s = r.getBaseAxis(), c = s.dim === "x" || s.dim === "radius" ? 0 : 1, l = [], u = 0, d = [], f = [], p = [], h = [];
	if (o) {
		for (u = 0; u < t.length; u += 2) {
			var g = n || t;
			!isNaN(g[u]) && !isNaN(g[u + 1]) && h.push(t[u], t[u + 1]);
		}
		t = h;
	}
	for (u = 0; u < t.length - 2; u += 2) switch (p[0] = t[u + 2], p[1] = t[u + 3], f[0] = t[u], f[1] = t[u + 1], l.push(f[0], f[1]), a) {
		case "end":
			d[c] = p[c], d[1 - c] = f[1 - c], l.push(d[0], d[1]);
			break;
		case "middle":
			var _ = (f[c] + p[c]) / 2, v = [];
			d[c] = v[c] = _, d[1 - c] = f[1 - c], v[1 - c] = p[1 - c], l.push(d[0], d[1]), l.push(v[0], v[1]);
			break;
		default: d[c] = f[c], d[1 - c] = p[1 - c], l.push(d[0], d[1]);
	}
	return l.push(t[u++], t[u++]), l;
}
function clipColorStops(t, n) {
	var r = [], a = t.length, o, s;
	function c(t, n, r) {
		var a = t.coord;
		return {
			coord: r,
			color: lerp$1((r - a) / (n.coord - a), [t.color, n.color])
		};
	}
	for (var l = 0; l < a; l++) {
		var u = t[l], d = u.coord;
		if (d < 0) o = u;
		else if (d > n) {
			s ? r.push(c(s, u, n)) : o && r.push(c(o, u, 0), c(o, u, n));
			break;
		} else o &&= (r.push(c(o, u, 0)), null), r.push(u), s = u;
	}
	return r;
}
function getVisualGradient(t, n, r) {
	var a = t.getVisual("visualMeta");
	if (!(!a || !a.length || !t.count())) {
		if (n.type !== "cartesian2d") {
			process$1.env.NODE_ENV !== "production" && console.warn("Visual map on line style is only supported on cartesian2d.");
			return;
		}
		for (var o, c, l = a.length - 1; l >= 0; l--) {
			var u = t.getDimensionInfo(a[l].dimension);
			if (o = u && u.coordDim, o === "x" || o === "y") {
				c = a[l];
				break;
			}
		}
		if (!c) {
			process$1.env.NODE_ENV !== "production" && console.warn("Visual map on line style only support x or y dimension.");
			return;
		}
		var d = n.getAxis(o), f = map(c.stops, function(t) {
			return {
				coord: d.toGlobalCoord(d.dataToCoord(t.value)),
				color: t.color
			};
		}), p = f.length, h = c.outerColors.slice();
		p && f[0].coord > f[p - 1].coord && (f.reverse(), h.reverse());
		var g = clipColorStops(f, o === "x" ? r.getWidth() : r.getHeight()), _ = g.length;
		if (!_ && p) return f[0].coord < 0 ? h[1] ? h[1] : f[p - 1].color : h[0] ? h[0] : f[0].color;
		var v = 10, y = g[0].coord - v, b = g[_ - 1].coord + v, x = b - y;
		if (x < .001) return "transparent";
		each(g, function(t) {
			t.offset = (t.coord - y) / x;
		}), g.push({
			offset: _ ? g[_ - 1].offset : .5,
			color: h[1] || "transparent"
		}), g.unshift({
			offset: _ ? g[0].offset : .5,
			color: h[0] || "transparent"
		});
		var S = new LinearGradient_default(0, 0, 0, 0, g, !0);
		return S[o] = y, S[o + "2"] = b, S;
	}
}
function getIsIgnoreFunc(t, n, r) {
	var a = t.get("showAllSymbol"), o = a === "auto";
	if (!(a && !o)) {
		var s = r.getAxesByScale("ordinal")[0];
		if (s && !(o && canShowAllSymbolForCategory(s, n))) {
			var c = n.mapDimension(s.dim), l = {};
			return each(s.getViewLabels(), function(t) {
				var n = s.scale.getRawOrdinalNumber(t.tickValue);
				l[n] = 1;
			}), function(t) {
				return !l.hasOwnProperty(n.get(c, t));
			};
		}
	}
}
function canShowAllSymbolForCategory(t, n) {
	var r = t.getExtent(), a = Math.abs(r[1] - r[0]) / t.scale.count();
	isNaN(a) && (a = 0);
	for (var o = n.count(), s = Math.max(1, Math.round(o / 5)), c = 0; c < o; c += s) if (Symbol_default.getSymbolSize(n, c)[t.isHorizontal() ? 1 : 0] * 1.5 > a) return !1;
	return !0;
}
function isPointNull(t, n) {
	return isNaN(t) || isNaN(n);
}
function getLastIndexNotNull(t) {
	for (var n = t.length / 2; n > 0 && isPointNull(t[n * 2 - 2], t[n * 2 - 1]); n--);
	return n - 1;
}
function getPointAtIndex(t, n) {
	return [t[n * 2], t[n * 2 + 1]];
}
function getIndexRange(t, n, r) {
	for (var a = t.length / 2, o = r === "x" ? 0 : 1, s, c, l = 0, u = -1, d = 0; d < a; d++) if (c = t[d * 2 + o], !(isNaN(c) || isNaN(t[d * 2 + 1 - o]))) {
		if (d === 0) {
			s = c;
			continue;
		}
		if (s <= n && c >= n || s >= n && c <= n) {
			u = d;
			break;
		}
		l = d, s = c;
	}
	return {
		range: [l, u],
		t: (n - s) / (c - s)
	};
}
function anyStateShowEndLabel(t) {
	if (t.get(["endLabel", "show"])) return !0;
	for (var n = 0; n < SPECIAL_STATES.length; n++) if (t.get([
		SPECIAL_STATES[n],
		"endLabel",
		"show"
	])) return !0;
	return !1;
}
function createLineClipPath(t, n, r, a) {
	if (isCoordinateSystemType(n, "cartesian2d")) {
		var o = a.getModel("endLabel"), c = o.get("valueAnimation"), l = a.getData(), u = { lastFrameIndex: 0 }, d = anyStateShowEndLabel(a) ? function(r, a) {
			t._endLabelOnDuring(r, a, l, u, c, o, n);
		} : null, f = n.getBaseAxis().isHorizontal(), p = createGridClipPath(n, r, a, function() {
			var n = t._endLabel;
			n && r && u.originalX != null && n.attr({
				x: u.originalX,
				y: u.originalY
			});
		}, d);
		if (!a.get("clip", !0)) {
			var h = p.shape, g = Math.max(h.width, h.height);
			f ? (h.y -= g, h.height += g * 2) : (h.x -= g, h.width += g * 2);
		}
		return d && d(1, p), p;
	} else return process$1.env.NODE_ENV !== "production" && a.get(["endLabel", "show"]) && console.warn("endLabel is not supported for lines in polar systems."), createPolarClipPath(n, r, a);
}
function getEndLabelStateSpecified(t, n) {
	var r = n.getBaseAxis(), a = r.isHorizontal(), o = r.inverse, s = a ? o ? "right" : "left" : "center", c = a ? "middle" : o ? "top" : "bottom";
	return { normal: {
		align: t.get("align") || s,
		verticalAlign: t.get("verticalAlign") || c
	} };
}
var LineView_default = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.init = function() {
		var t = new Group_default(), n = new SymbolDraw_default();
		this.group.add(n.group), this._symbolDraw = n, this._lineGroup = t, this._changePolyState = bind(this._changePolyState, this);
	}, n.prototype.render = function(t, n, r) {
		var a = t.coordinateSystem, o = this.group, s = t.getData(), c = t.getModel("lineStyle"), l = t.getModel("areaStyle"), u = s.getLayout("points") || [], d = a.type === "polar", f = this._coordSys, p = this._symbolDraw, h = this._polyline, g = this._polygon, _ = this._lineGroup, v = !n.ssr && t.get("animation"), y = !l.isEmpty(), b = l.get("origin"), x = prepareDataCoordInfo(a, s, b), S = y && getStackedOnPoints(a, s, x), C = t.get("showSymbol"), w = t.get("connectNulls"), T = C && !d && getIsIgnoreFunc(t, s, a), E = this._data;
		E && E.eachItemGraphicEl(function(t, n) {
			t.__temp && (o.remove(t), E.setItemGraphicEl(n, null));
		}), C || p.remove(), o.add(_);
		var D = d ? !1 : t.get("step"), O;
		a && a.getArea && t.get("clip", !0) && (O = a.getArea(), O.width == null ? O.r0 && (O.r0 -= .5, O.r += .5) : (O.x -= .1, O.y -= .1, O.width += .2, O.height += .2)), this._clipShapeForSymbol = O;
		var A = getVisualGradient(s, a, r) || s.getVisual("style")[s.getVisual("drawType")];
		if (!(h && f.type === a.type && D === this._step)) C && p.updateData(s, {
			isIgnore: T,
			clipShape: O,
			disableAnimation: !0,
			getSymbolPoint: function(t) {
				return [u[t * 2], u[t * 2 + 1]];
			}
		}), v && this._initSymbolLabelAnimation(s, a, O), D && (S &&= turnPointsIntoStep(S, u, a, D, w), u = turnPointsIntoStep(u, null, a, D, w)), h = this._newPolyline(u), y ? g = this._newPolygon(u, S) : g &&= (_.remove(g), this._polygon = null), d || this._initOrUpdateEndLabel(t, a, convertToColorString(A)), _.setClipPath(createLineClipPath(this, a, !0, t));
		else {
			y && !g ? g = this._newPolygon(u, S) : g && !y && (_.remove(g), g = this._polygon = null), d || this._initOrUpdateEndLabel(t, a, convertToColorString(A));
			var j = _.getClipPath();
			j ? initProps(j, { shape: createLineClipPath(this, a, !1, t).shape }, t) : _.setClipPath(createLineClipPath(this, a, !0, t)), C && p.updateData(s, {
				isIgnore: T,
				clipShape: O,
				disableAnimation: !0,
				getSymbolPoint: function(t) {
					return [u[t * 2], u[t * 2 + 1]];
				}
			}), (!isPointsSame(this._stackedOnPoints, S) || !isPointsSame(this._points, u)) && (v ? this._doUpdateAnimation(s, S, a, r, D, b, w) : (D && (S &&= turnPointsIntoStep(S, u, a, D, w), u = turnPointsIntoStep(u, null, a, D, w)), h.setShape({ points: u }), g && g.setShape({
				points: u,
				stackedOnPoints: S
			})));
		}
		var M = t.getModel("emphasis"), N = M.get("focus"), P = M.get("blurScope"), F = M.get("disabled");
		if (h.useStyle(defaults(c.getLineStyle(), {
			fill: "none",
			stroke: A,
			lineJoin: "bevel"
		})), setStatesStylesFromModel(h, t, "lineStyle"), h.style.lineWidth > 0 && t.get([
			"emphasis",
			"lineStyle",
			"width"
		]) === "bolder") {
			var I = h.getState("emphasis").style;
			I.lineWidth = +h.style.lineWidth + 1;
		}
		getECData(h).seriesIndex = t.seriesIndex, toggleHoverEmphasis(h, N, P, F);
		var L = getSmooth(t.get("smooth")), R = t.get("smoothMonotone");
		if (h.setShape({
			smooth: L,
			smoothMonotone: R,
			connectNulls: w
		}), g) {
			var z = s.getCalculationInfo("stackedOnSeries"), B = 0;
			g.useStyle(defaults(l.getAreaStyle(), {
				fill: A,
				opacity: .7,
				lineJoin: "bevel",
				decal: s.getVisual("style").decal
			})), z && (B = getSmooth(z.get("smooth"))), g.setShape({
				smooth: L,
				stackedOnSmooth: B,
				smoothMonotone: R,
				connectNulls: w
			}), setStatesStylesFromModel(g, t, "areaStyle"), getECData(g).seriesIndex = t.seriesIndex, toggleHoverEmphasis(g, N, P, F);
		}
		var V = this._changePolyState;
		s.eachItemGraphicEl(function(t) {
			t && (t.onHoverStateChange = V);
		}), this._polyline.onHoverStateChange = V, this._data = s, this._coordSys = a, this._stackedOnPoints = S, this._points = u, this._step = D, this._valueOrigin = b, t.get("triggerLineEvent") && (this.packEventData(t, h), g && this.packEventData(t, g));
	}, n.prototype.packEventData = function(t, n) {
		getECData(n).eventData = {
			componentType: "series",
			componentSubType: "line",
			componentIndex: t.componentIndex,
			seriesIndex: t.seriesIndex,
			seriesName: t.name,
			seriesType: "line"
		};
	}, n.prototype.highlight = function(t, n, r, a) {
		var o = t.getData(), s = queryDataIndex(o, a);
		if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
			var c = o.getLayout("points"), l = o.getItemGraphicEl(s);
			if (!l) {
				var u = c[s * 2], d = c[s * 2 + 1];
				if (isNaN(u) || isNaN(d) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(u, d)) return;
				var f = t.get("zlevel") || 0, p = t.get("z") || 0;
				l = new Symbol_default(o, s), l.x = u, l.y = d, l.setZ(f, p);
				var h = l.getSymbolPath().getTextContent();
				h && (h.zlevel = f, h.z = p, h.z2 = this._polyline.z2 + 1), l.__temp = !0, o.setItemGraphicEl(s, l), l.stopSymbolAnimation(!0), this.group.add(l);
			}
			l.highlight();
		} else Chart_default.prototype.highlight.call(this, t, n, r, a);
	}, n.prototype.downplay = function(t, n, r, a) {
		var o = t.getData(), s = queryDataIndex(o, a);
		if (this._changePolyState("normal"), s != null && s >= 0) {
			var c = o.getItemGraphicEl(s);
			c && (c.__temp ? (o.setItemGraphicEl(s, null), this.group.remove(c)) : c.downplay());
		} else Chart_default.prototype.downplay.call(this, t, n, r, a);
	}, n.prototype._changePolyState = function(t) {
		var n = this._polygon;
		setStatesFlag(this._polyline, t), n && setStatesFlag(n, t);
	}, n.prototype._newPolyline = function(t) {
		var n = this._polyline;
		return n && this._lineGroup.remove(n), n = new ECPolyline({
			shape: { points: t },
			segmentIgnoreThreshold: 2,
			z2: 10
		}), this._lineGroup.add(n), this._polyline = n, n;
	}, n.prototype._newPolygon = function(t, n) {
		var r = this._polygon;
		return r && this._lineGroup.remove(r), r = new ECPolygon({
			shape: {
				points: t,
				stackedOnPoints: n
			},
			segmentIgnoreThreshold: 2
		}), this._lineGroup.add(r), this._polygon = r, r;
	}, n.prototype._initSymbolLabelAnimation = function(t, n, r) {
		var a, o, s = n.getBaseAxis(), c = s.inverse;
		n.type === "cartesian2d" ? (a = s.isHorizontal(), o = !1) : n.type === "polar" && (a = s.dim === "angle", o = !0);
		var l = t.hostModel, u = l.get("animationDuration");
		isFunction(u) && (u = u(null));
		var d = l.get("animationDelay") || 0, f = isFunction(d) ? d(null) : d;
		t.eachItemGraphicEl(function(t, s) {
			var l = t;
			if (l) {
				var p = [t.x, t.y], h = void 0, g = void 0, _ = void 0;
				if (r) if (o) {
					var v = r, y = n.pointToCoord(p);
					a ? (h = v.startAngle, g = v.endAngle, _ = -y[1] / 180 * Math.PI) : (h = v.r0, g = v.r, _ = y[0]);
				} else {
					var b = r;
					a ? (h = b.x, g = b.x + b.width, _ = t.x) : (h = b.y + b.height, g = b.y, _ = t.y);
				}
				var x = g === h ? 0 : (_ - h) / (g - h);
				c && (x = 1 - x);
				var S = isFunction(d) ? d(s) : u * x + f, C = l.getSymbolPath(), w = C.getTextContent();
				l.attr({
					scaleX: 0,
					scaleY: 0
				}), l.animateTo({
					scaleX: 1,
					scaleY: 1
				}, {
					duration: 200,
					setToFinal: !0,
					delay: S
				}), w && w.animateFrom({ style: { opacity: 0 } }, {
					duration: 300,
					delay: S
				}), C.disableLabelAnimation = !0;
			}
		});
	}, n.prototype._initOrUpdateEndLabel = function(t, n, r) {
		var a = t.getModel("endLabel");
		if (anyStateShowEndLabel(t)) {
			var o = t.getData(), s = this._polyline, c = o.getLayout("points");
			if (!c) {
				s.removeTextContent(), this._endLabel = null;
				return;
			}
			var l = this._endLabel;
			l || (l = this._endLabel = new Text_default({ z2: 200 }), l.ignoreClip = !0, s.setTextContent(this._endLabel), s.disableLabelAnimation = !0);
			var u = getLastIndexNotNull(c);
			u >= 0 && (setLabelStyle(s, getLabelStatesModels(t, "endLabel"), {
				inheritColor: r,
				labelFetcher: t,
				labelDataIndex: u,
				defaultText: function(t, n, r) {
					return r == null ? getDefaultLabel(o, t) : getDefaultInterpolatedLabel(o, r);
				},
				enableTextSetter: !0
			}, getEndLabelStateSpecified(a, n)), s.textConfig.position = null);
		} else this._endLabel &&= (this._polyline.removeTextContent(), null);
	}, n.prototype._endLabelOnDuring = function(t, n, r, a, o, s, c) {
		var l = this._endLabel, u = this._polyline;
		if (l) {
			t < 1 && a.originalX == null && (a.originalX = l.x, a.originalY = l.y);
			var d = r.getLayout("points"), f = r.hostModel, p = f.get("connectNulls"), h = s.get("precision"), g = s.get("distance") || 0, _ = c.getBaseAxis(), v = _.isHorizontal(), y = _.inverse, b = n.shape, x = y ? v ? b.x : b.y + b.height : v ? b.x + b.width : b.y, S = (v ? g : 0) * (y ? -1 : 1), C = (v ? 0 : -g) * (y ? -1 : 1), w = v ? "x" : "y", T = getIndexRange(d, x, w), E = T.range, D = E[1] - E[0], O = void 0;
			if (D >= 1) {
				if (D > 1 && !p) {
					var A = getPointAtIndex(d, E[0]);
					l.attr({
						x: A[0] + S,
						y: A[1] + C
					}), o && (O = f.getRawValue(E[0]));
				} else {
					var A = u.getPointOn(x, w);
					A && l.attr({
						x: A[0] + S,
						y: A[1] + C
					});
					var j = f.getRawValue(E[0]), M = f.getRawValue(E[1]);
					o && (O = interpolateRawValues(r, h, j, M, T.t));
				}
				a.lastFrameIndex = E[0];
			} else {
				var N = t === 1 || a.lastFrameIndex > 0 ? E[0] : 0, A = getPointAtIndex(d, N);
				o && (O = f.getRawValue(N)), l.attr({
					x: A[0] + S,
					y: A[1] + C
				});
			}
			if (o) {
				var P = labelInner(l);
				typeof P.setLabelText == "function" && P.setLabelText(O);
			}
		}
	}, n.prototype._doUpdateAnimation = function(t, n, r, a, o, s, c) {
		var l = this._polyline, u = this._polygon, d = t.hostModel, f = lineAnimationDiff(this._data, t, this._stackedOnPoints, n, this._coordSys, r, this._valueOrigin, s), p = f.current, h = f.stackedOnCurrent, g = f.next, _ = f.stackedOnNext;
		if (o && (h = turnPointsIntoStep(f.stackedOnCurrent, f.current, r, o, c), p = turnPointsIntoStep(f.current, null, r, o, c), _ = turnPointsIntoStep(f.stackedOnNext, f.next, r, o, c), g = turnPointsIntoStep(f.next, null, r, o, c)), getBoundingDiff(p, g) > 3e3 || u && getBoundingDiff(h, _) > 3e3) {
			l.stopAnimation(), l.setShape({ points: g }), u && (u.stopAnimation(), u.setShape({
				points: g,
				stackedOnPoints: _
			}));
			return;
		}
		l.shape.__points = f.current, l.shape.points = p;
		var v = { shape: { points: g } };
		f.current !== p && (v.shape.__points = f.next), l.stopAnimation(), updateProps(l, v, d), u && (u.setShape({
			points: p,
			stackedOnPoints: h
		}), u.stopAnimation(), updateProps(u, { shape: { stackedOnPoints: _ } }, d), l.shape.points !== u.shape.points && (u.shape.points = l.shape.points));
		for (var y = [], b = f.status, x = 0; x < b.length; x++) if (b[x].cmd === "=") {
			var S = t.getItemGraphicEl(b[x].idx1);
			S && y.push({
				el: S,
				ptIdx: x
			});
		}
		l.animators && l.animators.length && l.animators[0].during(function() {
			u && u.dirtyShape();
			for (var t = l.shape.__points, n = 0; n < y.length; n++) {
				var r = y[n].el, a = y[n].ptIdx * 2;
				r.x = t[a], r.y = t[a + 1], r.markRedraw();
			}
		});
	}, n.prototype.remove = function(t) {
		var n = this.group, r = this._data;
		this._lineGroup.removeAll(), this._symbolDraw.remove(!0), r && r.eachItemGraphicEl(function(t, a) {
			t.__temp && (n.remove(t), r.setItemGraphicEl(a, null));
		}), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
	}, n.type = "line", n;
}(Chart_default);
function pointsLayout(t, n) {
	return {
		seriesType: t,
		plan: createRenderPlanner(),
		reset: function(t) {
			var r = t.getData(), a = t.coordinateSystem, o = t.pipelineContext, s = n || o.large;
			if (a) {
				var c = map(a.dimensions, function(t) {
					return r.mapDimension(t);
				}).slice(0, 2), l = c.length, u = r.getCalculationInfo("stackResultDimension");
				isDimensionStacked(r, c[0]) && (c[0] = u), isDimensionStacked(r, c[1]) && (c[1] = u);
				var d = r.getStore(), f = r.getDimensionIndex(c[0]), p = r.getDimensionIndex(c[1]);
				return l && { progress: function(t, n) {
					for (var r = t.end - t.start, o = s && createFloat32Array(r * l), c = [], u = [], h = t.start, g = 0; h < t.end; h++) {
						var _ = void 0;
						if (l === 1) {
							var v = d.get(f, h);
							_ = a.dataToPoint(v, null, u);
						} else c[0] = d.get(f, h), c[1] = d.get(p, h), _ = a.dataToPoint(c, null, u);
						s ? (o[g++] = _[0], o[g++] = _[1]) : n.setItemLayout(h, _.slice());
					}
					s && n.setLayout("points", o);
				} };
			}
		}
	};
}
var samplers = {
	average: function(t) {
		for (var n = 0, r = 0, a = 0; a < t.length; a++) isNaN(t[a]) || (n += t[a], r++);
		return r === 0 ? NaN : n / r;
	},
	sum: function(t) {
		for (var n = 0, r = 0; r < t.length; r++) n += t[r] || 0;
		return n;
	},
	max: function(t) {
		for (var n = -Infinity, r = 0; r < t.length; r++) t[r] > n && (n = t[r]);
		return isFinite(n) ? n : NaN;
	},
	min: function(t) {
		for (var n = Infinity, r = 0; r < t.length; r++) t[r] < n && (n = t[r]);
		return isFinite(n) ? n : NaN;
	},
	nearest: function(t) {
		return t[0];
	}
}, indexSampler = function(t) {
	return Math.round(t.length / 2);
};
function dataSample(t) {
	return {
		seriesType: t,
		reset: function(t, n, r) {
			var a = t.getData(), o = t.get("sampling"), s = t.coordinateSystem, c = a.count();
			if (c > 10 && s.type === "cartesian2d" && o) {
				var l = s.getBaseAxis(), u = s.getOtherAxis(l), d = l.getExtent(), f = r.getDevicePixelRatio(), p = Math.abs(d[1] - d[0]) * (f || 1), h = Math.round(c / p);
				if (isFinite(h) && h > 1) {
					o === "lttb" ? t.setData(a.lttbDownSample(a.mapDimension(u.dim), 1 / h)) : o === "minmax" && t.setData(a.minmaxDownSample(a.mapDimension(u.dim), 1 / h));
					var g = void 0;
					isString(o) ? g = samplers[o] : isFunction(o) && (g = o), g && t.setData(a.downSample(a.mapDimension(u.dim), 1 / h, g, indexSampler));
				}
			}
		}
	};
}
function install$2(t) {
	t.registerChartView(LineView_default), t.registerSeriesModel(LineSeries_default), t.registerLayout(pointsLayout("line", !0)), t.registerVisual({
		seriesType: "line",
		reset: function(t) {
			var n = t.getData(), r = t.getModel("lineStyle").getLineStyle();
			r && !r.stroke && (r.stroke = n.getVisual("style").fill), n.setVisual("legendLineStyle", r);
		}
	}), t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
}
var BaseBarSeriesModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.getInitialData = function(t, n) {
		return createSeriesData_default(null, this, { useEncodeDefaulter: !0 });
	}, n.prototype.getMarkerPosition = function(t, n, r) {
		var a = this.coordinateSystem;
		if (a && a.clampData) {
			var o = a.clampData(t), s = a.dataToPoint(o);
			if (r) each(a.getAxes(), function(t, r) {
				if (t.type === "category" && n != null) {
					var a = t.getTicksCoords(), c = t.getTickModel().get("alignWithLabel"), l = o[r], u = n[r] === "x1" || n[r] === "y1";
					if (u && !c && (l += 1), a.length < 2) return;
					if (a.length === 2) {
						s[r] = t.toGlobalCoord(t.getExtent()[u ? 1 : 0]);
						return;
					}
					for (var d = void 0, f = void 0, p = 1, h = 0; h < a.length; h++) {
						var g = a[h].coord, _ = h === a.length - 1 ? a[h - 1].tickValue + p : a[h].tickValue;
						if (_ === l) {
							f = g;
							break;
						} else if (_ < l) d = g;
						else if (d != null && _ > l) {
							f = (g + d) / 2;
							break;
						}
						h === 1 && (p = _ - a[0].tickValue);
					}
					f ?? (d ? d && (f = a[a.length - 1].coord) : f = a[0].coord), s[r] = t.toGlobalCoord(f);
				}
			});
			else {
				var c = this.getData(), l = c.getLayout("offset"), u = c.getLayout("size"), d = a.getBaseAxis().isHorizontal() ? 0 : 1;
				s[d] += l + u / 2;
			}
			return s;
		}
		return [NaN, NaN];
	}, n.type = "series.__base_bar__", n.defaultOption = {
		z: 2,
		coordinateSystem: "cartesian2d",
		legendHoverLink: !0,
		barMinHeight: 0,
		barMinAngle: 0,
		large: !1,
		largeThreshold: 400,
		progressive: 3e3,
		progressiveChunkMode: "mod"
	}, n;
}(Series_default);
Series_default.registerClass(BaseBarSeriesModel);
var BaseBarSeries_default = BaseBarSeriesModel, BarSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.getInitialData = function() {
		return createSeriesData_default(null, this, {
			useEncodeDefaulter: !0,
			createInvertedIndices: !!this.get("realtimeSort", !0) || null
		});
	}, n.prototype.getProgressive = function() {
		return this.get("large") ? this.get("progressive") : !1;
	}, n.prototype.getProgressiveThreshold = function() {
		var t = this.get("progressiveThreshold"), n = this.get("largeThreshold");
		return n > t && (t = n), t;
	}, n.prototype.brushSelector = function(t, n, r) {
		return r.rect(n.getItemLayout(t));
	}, n.type = "series.bar", n.dependencies = ["grid", "polar"], n.defaultOption = inheritDefaultOption(BaseBarSeries_default.defaultOption, {
		clip: !0,
		roundCap: !1,
		showBackground: !1,
		backgroundStyle: {
			color: "rgba(180, 180, 180, 0.2)",
			borderColor: null,
			borderWidth: 0,
			borderType: "solid",
			borderRadius: 0,
			shadowBlur: 0,
			shadowColor: null,
			shadowOffsetX: 0,
			shadowOffsetY: 0,
			opacity: 1
		},
		select: { itemStyle: { borderColor: "#212121" } },
		realtimeSort: !1
	}), n;
}(BaseBarSeries_default), SausageShape = function() {
	function t() {
		this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
	}
	return t;
}(), sausage_default = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this, n) || this;
		return r.type = "sausage", r;
	}
	return n.prototype.getDefaultShape = function() {
		return new SausageShape();
	}, n.prototype.buildPath = function(t, n) {
		var r = n.cx, a = n.cy, o = Math.max(n.r0 || 0, 0), s = Math.max(n.r, 0), c = (s - o) * .5, l = o + c, u = n.startAngle, d = n.endAngle, f = n.clockwise, p = Math.PI * 2, h = f ? d - u < p : u - d < p;
		h || (u = d - (f ? p : -p));
		var g = Math.cos(u), _ = Math.sin(u), v = Math.cos(d), y = Math.sin(d);
		h ? (t.moveTo(g * o + r, _ * o + a), t.arc(g * l + r, _ * l + a, c, -Math.PI + u, u, !f)) : t.moveTo(g * s + r, _ * s + a), t.arc(r, a, s, u, d, !f), t.arc(v * l + r, y * l + a, c, d - Math.PI * 2, d - Math.PI, !f), o !== 0 && t.arc(r, a, o, d, u, f);
	}, n;
}(Path_default);
function createSectorCalculateTextPosition(t, n) {
	n ||= {};
	var r = n.isRoundCap;
	return function(n, a, o) {
		var s = a.position;
		if (!s || s instanceof Array) return calculateTextPosition(n, a, o);
		var c = t(s), l = a.distance == null ? 5 : a.distance, u = this.shape, d = u.cx, f = u.cy, p = u.r, h = u.r0, g = (p + h) / 2, _ = u.startAngle, v = u.endAngle, y = (_ + v) / 2, b = r ? Math.abs(p - h) / 2 : 0, x = Math.cos, S = Math.sin, C = d + p * x(_), w = f + p * S(_), T = "left", E = "top";
		switch (c) {
			case "startArc":
				C = d + (h - l) * x(y), w = f + (h - l) * S(y), T = "center", E = "top";
				break;
			case "insideStartArc":
				C = d + (h + l) * x(y), w = f + (h + l) * S(y), T = "center", E = "bottom";
				break;
			case "startAngle":
				C = d + g * x(_) + adjustAngleDistanceX(_, l + b, !1), w = f + g * S(_) + adjustAngleDistanceY(_, l + b, !1), T = "right", E = "middle";
				break;
			case "insideStartAngle":
				C = d + g * x(_) + adjustAngleDistanceX(_, -l + b, !1), w = f + g * S(_) + adjustAngleDistanceY(_, -l + b, !1), T = "left", E = "middle";
				break;
			case "middle":
				C = d + g * x(y), w = f + g * S(y), T = "center", E = "middle";
				break;
			case "endArc":
				C = d + (p + l) * x(y), w = f + (p + l) * S(y), T = "center", E = "bottom";
				break;
			case "insideEndArc":
				C = d + (p - l) * x(y), w = f + (p - l) * S(y), T = "center", E = "top";
				break;
			case "endAngle":
				C = d + g * x(v) + adjustAngleDistanceX(v, l + b, !0), w = f + g * S(v) + adjustAngleDistanceY(v, l + b, !0), T = "left", E = "middle";
				break;
			case "insideEndAngle":
				C = d + g * x(v) + adjustAngleDistanceX(v, -l + b, !0), w = f + g * S(v) + adjustAngleDistanceY(v, -l + b, !0), T = "right", E = "middle";
				break;
			default: return calculateTextPosition(n, a, o);
		}
		return n ||= {}, n.x = C, n.y = w, n.align = T, n.verticalAlign = E, n;
	};
}
function setSectorTextRotation(t, n, r, a) {
	if (isNumber(a)) {
		t.setTextConfig({ rotation: a });
		return;
	} else if (isArray(n)) {
		t.setTextConfig({ rotation: 0 });
		return;
	}
	var o = t.shape, s = o.clockwise ? o.startAngle : o.endAngle, c = o.clockwise ? o.endAngle : o.startAngle, l = (s + c) / 2, u, d = r(n);
	switch (d) {
		case "startArc":
		case "insideStartArc":
		case "middle":
		case "insideEndArc":
		case "endArc":
			u = l;
			break;
		case "startAngle":
		case "insideStartAngle":
			u = s;
			break;
		case "endAngle":
		case "insideEndAngle":
			u = c;
			break;
		default:
			t.setTextConfig({ rotation: 0 });
			return;
	}
	var f = Math.PI * 1.5 - u;
	d === "middle" && f > Math.PI / 2 && f < Math.PI * 1.5 && (f -= Math.PI), t.setTextConfig({ rotation: f });
}
function adjustAngleDistanceX(t, n, r) {
	return n * Math.sin(t) * (r ? -1 : 1);
}
function adjustAngleDistanceY(t, n, r) {
	return n * Math.cos(t) * (r ? 1 : -1);
}
function getSectorCornerRadius(t, n, r) {
	var a = t.get("borderRadius");
	if (a == null) return r ? { cornerRadius: 0 } : null;
	isArray(a) || (a = [
		a,
		a,
		a,
		a
	]);
	var o = Math.abs(n.r || 0 - n.r0 || 0);
	return { cornerRadius: map(a, function(t) {
		return parsePercent(t, o);
	}) };
}
init_dist$2();
var mathMax$4 = Math.max, mathMin$4 = Math.min;
function getClipArea(t, n) {
	var r = t.getArea && t.getArea();
	if (isCoordinateSystemType(t, "cartesian2d")) {
		var a = t.getBaseAxis();
		if (a.type !== "category" || !a.onBand) {
			var o = n.getLayout("bandWidth");
			a.isHorizontal() ? (r.x -= o, r.width += o * 2) : (r.y -= o, r.height += o * 2);
		}
	}
	return r;
}
var BarView = function(t) {
	__extends(n, t);
	function n() {
		var r = t.call(this) || this;
		return r.type = n.type, r._isFirstFrame = !0, r;
	}
	return n.prototype.render = function(t, n, r, a) {
		this._model = t, this._removeOnRenderedListener(r), this._updateDrawMode(t);
		var o = t.get("coordinateSystem");
		o === "cartesian2d" || o === "polar" ? (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(t, n, r) : this._renderNormal(t, n, r, a)) : process$1.env.NODE_ENV !== "production" && warn("Only cartesian2d and polar supported for bar.");
	}, n.prototype.incrementalPrepareRender = function(t) {
		this._clear(), this._updateDrawMode(t), this._updateLargeClip(t);
	}, n.prototype.incrementalRender = function(t, n) {
		this._progressiveEls = [], this._incrementalRenderLarge(t, n);
	}, n.prototype.eachRendered = function(t) {
		traverseElements(this._progressiveEls || this.group, t);
	}, n.prototype._updateDrawMode = function(t) {
		var n = t.pipelineContext.large;
		(this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
	}, n.prototype._renderNormal = function(t, n, r, a) {
		var o = this.group, s = t.getData(), c = this._data, l = t.coordinateSystem, u = l.getBaseAxis(), d;
		l.type === "cartesian2d" ? d = u.isHorizontal() : l.type === "polar" && (d = u.dim === "angle");
		var f = t.isAnimationEnabled() ? t : null, p = shouldRealtimeSort(t, l);
		p && this._enableRealtimeSort(p, s, r);
		var h = t.get("clip", !0) || p, g = getClipArea(l, s);
		o.removeClipPath();
		var _ = t.get("roundCap", !0), v = t.get("showBackground", !0), y = t.getModel("backgroundStyle"), b = y.get("borderRadius") || 0, x = [], S = this._backgroundEls, C = a && a.isInitSort, w = a && a.type === "changeAxisOrder";
		function T(t) {
			var n = getLayout[l.type](s, t), r = createBackgroundEl(l, d, n);
			return r.useStyle(y.getItemStyle()), l.type === "cartesian2d" ? r.setShape("r", b) : r.setShape("cornerRadius", b), x[t] = r, r;
		}
		s.diff(c).add(function(n) {
			var r = s.getItemModel(n), a = getLayout[l.type](s, n, r);
			if (v && T(n), !(!s.hasValue(n) || !isValidLayout[l.type](a))) {
				var c = !1;
				h && (c = clip[l.type](g, a));
				var y = elementCreator[l.type](t, s, n, a, d, f, u.model, !1, _);
				p && (y.forceLabelAnimation = !0), updateStyle(y, s, n, r, a, t, d, l.type === "polar"), C ? y.attr({ shape: a }) : p ? updateRealtimeAnimation(p, f, y, a, n, d, !1, !1) : initProps(y, { shape: a }, t, n), s.setItemGraphicEl(n, y), o.add(y), y.ignore = c;
			}
		}).update(function(n, r) {
			var a = s.getItemModel(n), E = getLayout[l.type](s, n, a);
			if (v) {
				var D = void 0;
				S.length === 0 ? D = T(r) : (D = S[r], D.useStyle(y.getItemStyle()), l.type === "cartesian2d" ? D.setShape("r", b) : D.setShape("cornerRadius", b), x[n] = D);
				var O = getLayout[l.type](s, n), A = createBackgroundShape(d, O, l);
				updateProps(D, { shape: A }, f, n);
			}
			var j = c.getItemGraphicEl(r);
			if (!s.hasValue(n) || !isValidLayout[l.type](E)) {
				o.remove(j);
				return;
			}
			var M = !1;
			if (h && (M = clip[l.type](g, E), M && o.remove(j)), j ? saveOldStyle(j) : j = elementCreator[l.type](t, s, n, E, d, f, u.model, !!j, _), p && (j.forceLabelAnimation = !0), w) {
				var N = j.getTextContent();
				if (N) {
					var P = labelInner(N);
					P.prevValue != null && (P.prevValue = P.value);
				}
			} else updateStyle(j, s, n, a, E, t, d, l.type === "polar");
			C ? j.attr({ shape: E }) : p ? updateRealtimeAnimation(p, f, j, E, n, d, !0, w) : updateProps(j, { shape: E }, t, n, null), s.setItemGraphicEl(n, j), j.ignore = M, o.add(j);
		}).remove(function(n) {
			var r = c.getItemGraphicEl(n);
			r && removeElementWithFadeOut(r, t, n);
		}).execute();
		var E = this._backgroundGroup ||= new Group_default();
		E.removeAll();
		for (var D = 0; D < x.length; ++D) E.add(x[D]);
		o.add(E), this._backgroundEls = x, this._data = s;
	}, n.prototype._renderLarge = function(t, n, r) {
		this._clear(), createLarge$1(t, this.group), this._updateLargeClip(t);
	}, n.prototype._incrementalRenderLarge = function(t, n) {
		this._removeBackground(), createLarge$1(n, this.group, this._progressiveEls, !0);
	}, n.prototype._updateLargeClip = function(t) {
		var n = t.get("clip", !0) && createClipPath(t.coordinateSystem, !1, t), r = this.group;
		n ? r.setClipPath(n) : r.removeClipPath();
	}, n.prototype._enableRealtimeSort = function(t, n, r) {
		var a = this;
		if (n.count()) {
			var o = t.baseAxis;
			if (this._isFirstFrame) this._dispatchInitSort(n, t, r), this._isFirstFrame = !1;
			else {
				var s = function(t) {
					var r = n.getItemGraphicEl(t), a = r && r.shape;
					return a && Math.abs(o.isHorizontal() ? a.height : a.width) || 0;
				};
				this._onRendered = function() {
					a._updateSortWithinSameData(n, s, o, r);
				}, r.getZr().on("rendered", this._onRendered);
			}
		}
	}, n.prototype._dataSort = function(t, n, r) {
		var a = [];
		return t.each(t.mapDimension(n.dim), function(t, n) {
			var o = r(n);
			o ??= NaN, a.push({
				dataIndex: n,
				mappedValue: o,
				ordinalNumber: t
			});
		}), a.sort(function(t, n) {
			return n.mappedValue - t.mappedValue;
		}), { ordinalNumbers: map(a, function(t) {
			return t.ordinalNumber;
		}) };
	}, n.prototype._isOrderChangedWithinSameData = function(t, n, r) {
		for (var a = r.scale, o = t.mapDimension(r.dim), s = Number.MAX_VALUE, c = 0, l = a.getOrdinalMeta().categories.length; c < l; ++c) {
			var u = t.rawIndexOf(o, a.getRawOrdinalNumber(c)), d = u < 0 ? Number.MIN_VALUE : n(t.indexOfRawIndex(u));
			if (d > s) return !0;
			s = d;
		}
		return !1;
	}, n.prototype._isOrderDifferentInView = function(t, n) {
		for (var r = n.scale, a = r.getExtent(), o = Math.max(0, a[0]), s = Math.min(a[1], r.getOrdinalMeta().categories.length - 1); o <= s; ++o) if (t.ordinalNumbers[o] !== r.getRawOrdinalNumber(o)) return !0;
	}, n.prototype._updateSortWithinSameData = function(t, n, r, a) {
		if (this._isOrderChangedWithinSameData(t, n, r)) {
			var o = this._dataSort(t, r, n);
			this._isOrderDifferentInView(o, r) && (this._removeOnRenderedListener(a), a.dispatchAction({
				type: "changeAxisOrder",
				componentType: r.dim + "Axis",
				axisId: r.index,
				sortInfo: o
			}));
		}
	}, n.prototype._dispatchInitSort = function(t, n, r) {
		var a = n.baseAxis, o = this._dataSort(t, a, function(r) {
			return t.get(t.mapDimension(n.otherAxis.dim), r);
		});
		r.dispatchAction({
			type: "changeAxisOrder",
			componentType: a.dim + "Axis",
			isInitSort: !0,
			axisId: a.index,
			sortInfo: o
		});
	}, n.prototype.remove = function(t, n) {
		this._clear(this._model), this._removeOnRenderedListener(n);
	}, n.prototype.dispose = function(t, n) {
		this._removeOnRenderedListener(n);
	}, n.prototype._removeOnRenderedListener = function(t) {
		this._onRendered &&= (t.getZr().off("rendered", this._onRendered), null);
	}, n.prototype._clear = function(t) {
		var n = this.group, r = this._data;
		t && t.isAnimationEnabled() && r && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], r.eachItemGraphicEl(function(n) {
			removeElementWithFadeOut(n, t, getECData(n).dataIndex);
		})) : n.removeAll(), this._data = null, this._isFirstFrame = !0;
	}, n.prototype._removeBackground = function() {
		this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
	}, n.type = "bar", n;
}(Chart_default), clip = {
	cartesian2d: function(t, n) {
		var r = n.width < 0 ? -1 : 1, a = n.height < 0 ? -1 : 1;
		r < 0 && (n.x += n.width, n.width = -n.width), a < 0 && (n.y += n.height, n.height = -n.height);
		var o = t.x + t.width, s = t.y + t.height, c = mathMax$4(n.x, t.x), l = mathMin$4(n.x + n.width, o), u = mathMax$4(n.y, t.y), d = mathMin$4(n.y + n.height, s), f = l < c, p = d < u;
		return n.x = f && c > o ? l : c, n.y = p && u > s ? d : u, n.width = f ? 0 : l - c, n.height = p ? 0 : d - u, r < 0 && (n.x += n.width, n.width = -n.width), a < 0 && (n.y += n.height, n.height = -n.height), f || p;
	},
	polar: function(t, n) {
		var r = n.r0 <= n.r ? 1 : -1;
		if (r < 0) {
			var a = n.r;
			n.r = n.r0, n.r0 = a;
		}
		var o = mathMin$4(n.r, t.r), s = mathMax$4(n.r0, t.r0);
		n.r = o, n.r0 = s;
		var c = o - s < 0;
		if (r < 0) {
			var a = n.r;
			n.r = n.r0, n.r0 = a;
		}
		return c;
	}
}, elementCreator = {
	cartesian2d: function(t, n, r, a, o, s, c, l, u) {
		var d = new Rect_default({
			shape: extend({}, a),
			z2: 1
		});
		if (d.__dataIndex = r, d.name = "item", s) {
			var f = d.shape, p = o ? "height" : "width";
			f[p] = 0;
		}
		return d;
	},
	polar: function(t, n, r, a, o, s, c, l, u) {
		var d = !o && u ? sausage_default : Sector_default, f = new d({
			shape: a,
			z2: 1
		});
		if (f.name = "item", f.calculateTextPosition = createSectorCalculateTextPosition(createPolarPositionMapping(o), { isRoundCap: d === sausage_default }), s) {
			var p = f.shape, h = o ? "r" : "endAngle", g = {};
			p[h] = o ? a.r0 : a.startAngle, g[h] = a[h], (l ? updateProps : initProps)(f, { shape: g }, s);
		}
		return f;
	}
};
function shouldRealtimeSort(t, n) {
	var r = t.get("realtimeSort", !0), a = n.getBaseAxis();
	if (process$1.env.NODE_ENV !== "production" && r && (a.type !== "category" && warn("`realtimeSort` will not work because this bar series is not based on a category axis."), n.type !== "cartesian2d" && warn("`realtimeSort` will not work because this bar series is not on cartesian2d.")), r && a.type === "category" && n.type === "cartesian2d") return {
		baseAxis: a,
		otherAxis: n.getOtherAxis(a)
	};
}
function updateRealtimeAnimation(t, n, r, a, o, s, c, l) {
	var u, d;
	s ? (d = {
		x: a.x,
		width: a.width
	}, u = {
		y: a.y,
		height: a.height
	}) : (d = {
		y: a.y,
		height: a.height
	}, u = {
		x: a.x,
		width: a.width
	}), l || (c ? updateProps : initProps)(r, { shape: u }, n, o, null);
	var f = n ? t.baseAxis.model : null;
	(c ? updateProps : initProps)(r, { shape: d }, f, o);
}
function checkPropertiesNotValid(t, n) {
	for (var r = 0; r < n.length; r++) if (!isFinite(t[n[r]])) return !0;
	return !1;
}
var rectPropties = [
	"x",
	"y",
	"width",
	"height"
], polarPropties = [
	"cx",
	"cy",
	"r",
	"startAngle",
	"endAngle"
], isValidLayout = {
	cartesian2d: function(t) {
		return !checkPropertiesNotValid(t, rectPropties);
	},
	polar: function(t) {
		return !checkPropertiesNotValid(t, polarPropties);
	}
}, getLayout = {
	cartesian2d: function(t, n, r) {
		var a = t.getItemLayout(n), o = r ? getLineWidth(r, a) : 0, s = a.width > 0 ? 1 : -1, c = a.height > 0 ? 1 : -1;
		return {
			x: a.x + s * o / 2,
			y: a.y + c * o / 2,
			width: a.width - s * o,
			height: a.height - c * o
		};
	},
	polar: function(t, n, r) {
		var a = t.getItemLayout(n);
		return {
			cx: a.cx,
			cy: a.cy,
			r0: a.r0,
			r: a.r,
			startAngle: a.startAngle,
			endAngle: a.endAngle,
			clockwise: a.clockwise
		};
	}
};
function isZeroOnPolar(t) {
	return t.startAngle != null && t.endAngle != null && t.startAngle === t.endAngle;
}
function createPolarPositionMapping(t) {
	return function(t) {
		var n = t ? "Arc" : "Angle";
		return function(t) {
			switch (t) {
				case "start":
				case "insideStart":
				case "end":
				case "insideEnd": return t + n;
				default: return t;
			}
		};
	}(t);
}
function updateStyle(t, n, r, a, o, s, c, l) {
	var u = n.getItemVisual(r, "style");
	if (l) {
		if (!s.get("roundCap")) {
			var d = t.shape;
			extend(d, getSectorCornerRadius(a.getModel("itemStyle"), d, !0)), t.setShape(d);
		}
	} else {
		var f = a.get(["itemStyle", "borderRadius"]) || 0;
		t.setShape("r", f);
	}
	t.useStyle(u);
	var p = a.getShallow("cursor");
	p && t.attr("cursor", p);
	var h = l ? c ? o.r >= o.r0 ? "endArc" : "startArc" : o.endAngle >= o.startAngle ? "endAngle" : "startAngle" : c ? o.height >= 0 ? "bottom" : "top" : o.width >= 0 ? "right" : "left", g = getLabelStatesModels(a);
	setLabelStyle(t, g, {
		labelFetcher: s,
		labelDataIndex: r,
		defaultText: getDefaultLabel(s.getData(), r),
		inheritColor: u.fill,
		defaultOpacity: u.opacity,
		defaultOutsidePosition: h
	});
	var _ = t.getTextContent();
	if (l && _) {
		var v = a.get(["label", "position"]);
		t.textConfig.inside = v === "middle" ? !0 : null, setSectorTextRotation(t, v === "outside" ? h : v, createPolarPositionMapping(c), a.get(["label", "rotate"]));
	}
	setLabelValueAnimation(_, g, s.getRawValue(r), function(t) {
		return getDefaultInterpolatedLabel(n, t);
	});
	var y = a.getModel(["emphasis"]);
	toggleHoverEmphasis(t, y.get("focus"), y.get("blurScope"), y.get("disabled")), setStatesStylesFromModel(t, a), isZeroOnPolar(o) && (t.style.fill = "none", t.style.stroke = "none", each(t.states, function(t) {
		t.style && (t.style.fill = t.style.stroke = "none");
	}));
}
function getLineWidth(t, n) {
	var r = t.get(["itemStyle", "borderColor"]);
	if (!r || r === "none") return 0;
	var a = t.get(["itemStyle", "borderWidth"]) || 0, o = isNaN(n.width) ? Number.MAX_VALUE : Math.abs(n.width), s = isNaN(n.height) ? Number.MAX_VALUE : Math.abs(n.height);
	return Math.min(a, o, s);
}
var LagePathShape = function() {
	function t() {}
	return t;
}(), LargePath = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this, n) || this;
		return r.type = "largeBar", r;
	}
	return n.prototype.getDefaultShape = function() {
		return new LagePathShape();
	}, n.prototype.buildPath = function(t, n) {
		for (var r = n.points, a = this.baseDimIdx, o = 1 - this.baseDimIdx, s = [], c = [], l = this.barWidth, u = 0; u < r.length; u += 3) c[a] = l, c[o] = r[u + 2], s[a] = r[u + a], s[o] = r[u + o], t.rect(s[0], s[1], c[0], c[1]);
	}, n;
}(Path_default);
function createLarge$1(t, n, r, a) {
	var o = t.getData(), s = o.getLayout("valueAxisHorizontal") ? 1 : 0, c = o.getLayout("largeDataIndices"), l = o.getLayout("size"), u = t.getModel("backgroundStyle"), d = o.getLayout("largeBackgroundPoints");
	if (d) {
		var f = new LargePath({
			shape: { points: d },
			incremental: !!a,
			silent: !0,
			z2: 0
		});
		f.baseDimIdx = s, f.largeDataIndices = c, f.barWidth = l, f.useStyle(u.getItemStyle()), n.add(f), r && r.push(f);
	}
	var p = new LargePath({
		shape: { points: o.getLayout("largePoints") },
		incremental: !!a,
		ignoreCoarsePointer: !0,
		z2: 1
	});
	p.baseDimIdx = s, p.largeDataIndices = c, p.barWidth = l, n.add(p), p.useStyle(o.getVisual("style")), p.style.stroke = null, getECData(p).seriesIndex = t.seriesIndex, t.get("silent") || (p.on("mousedown", largePathUpdateDataIndex), p.on("mousemove", largePathUpdateDataIndex)), r && r.push(p);
}
var largePathUpdateDataIndex = throttle(function(t) {
	var n = this, r = largePathFindDataIndex(n, t.offsetX, t.offsetY);
	getECData(n).dataIndex = r >= 0 ? r : null;
}, 30, !1);
function largePathFindDataIndex(t, n, r) {
	for (var a = t.baseDimIdx, o = 1 - a, s = t.shape.points, c = t.largeDataIndices, l = [], u = [], d = t.barWidth, f = 0, p = s.length / 3; f < p; f++) {
		var h = f * 3;
		if (u[a] = d, u[o] = s[h + 2], l[a] = s[h + a], l[o] = s[h + o], u[o] < 0 && (l[o] += u[o], u[o] = -u[o]), n >= l[0] && n <= l[0] + u[0] && r >= l[1] && r <= l[1] + u[1]) return c[f];
	}
	return -1;
}
function createBackgroundShape(t, n, r) {
	if (isCoordinateSystemType(r, "cartesian2d")) {
		var a = n, o = r.getArea();
		return {
			x: t ? a.x : o.x,
			y: t ? o.y : a.y,
			width: t ? a.width : o.width,
			height: t ? o.height : a.height
		};
	} else {
		var o = r.getArea(), s = n;
		return {
			cx: o.cx,
			cy: o.cy,
			r0: t ? o.r0 : s.r0,
			r: t ? o.r : s.r,
			startAngle: t ? s.startAngle : 0,
			endAngle: t ? s.endAngle : Math.PI * 2
		};
	}
}
function createBackgroundEl(t, n, r) {
	return new (t.type === "polar" ? Sector_default : Rect_default)({
		shape: createBackgroundShape(n, r, t),
		silent: !0,
		z2: 0
	});
}
var BarView_default = BarView;
function install$3(t) {
	t.registerChartView(BarView_default), t.registerSeriesModel(BarSeries_default), t.registerLayout(t.PRIORITY.VISUAL.LAYOUT, curry(layout$2, "bar")), t.registerLayout(t.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("bar")), t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC, dataSample("bar")), t.registerAction({
		type: "changeAxisOrder",
		event: "changeAxisOrder",
		update: "update"
	}, function(t, n) {
		var r = t.componentType || "series";
		n.eachComponent({
			mainType: r,
			query: t
		}, function(n) {
			t.sortInfo && n.axis.setCategorySortInfo(t.sortInfo);
		});
	});
}
var PI2 = Math.PI * 2, RADIAN$2 = Math.PI / 180;
function getViewRect$5(t, n) {
	return getLayoutRect(t.getBoxLayoutParams(), {
		width: n.getWidth(),
		height: n.getHeight()
	});
}
function getBasicPieLayout(t, n) {
	var r = getViewRect$5(t, n), a = t.get("center"), o = t.get("radius");
	isArray(o) || (o = [0, o]);
	var s = parsePercent$1(r.width, n.getWidth()), c = parsePercent$1(r.height, n.getHeight()), l = Math.min(s, c), u = parsePercent$1(o[0], l / 2), d = parsePercent$1(o[1], l / 2), f, p, h = t.coordinateSystem;
	if (h) {
		var g = h.dataToPoint(a);
		f = g[0] || 0, p = g[1] || 0;
	} else isArray(a) || (a = [a, a]), f = parsePercent$1(a[0], s) + r.x, p = parsePercent$1(a[1], c) + r.y;
	return {
		cx: f,
		cy: p,
		r0: u,
		r: d
	};
}
function pieLayout(t, n, r) {
	n.eachSeriesByType(t, function(t) {
		var n = t.getData(), a = n.mapDimension("value"), o = getViewRect$5(t, r), s = getBasicPieLayout(t, r), c = s.cx, l = s.cy, u = s.r, d = s.r0, f = -t.get("startAngle") * RADIAN$2, p = t.get("endAngle"), h = t.get("padAngle") * RADIAN$2;
		p = p === "auto" ? f - PI2 : -p * RADIAN$2;
		var g = t.get("minAngle") * RADIAN$2 + h, _ = 0;
		n.each(a, function(t) {
			!isNaN(t) && _++;
		});
		var v = n.getSum(a), y = Math.PI / (v || _) * 2, b = t.get("clockwise"), x = t.get("roseType"), S = t.get("stillShowZeroSum"), C = n.getDataExtent(a);
		C[0] = 0;
		var w = b ? 1 : -1, T = [f, p], E = w * h / 2;
		normalizeArcAngles(T, !b), f = T[0], p = T[1];
		var D = getSeriesLayoutData(t);
		D.startAngle = f, D.endAngle = p, D.clockwise = b;
		var O = Math.abs(p - f), A = O, j = 0, M = f;
		if (n.setLayout({
			viewRect: o,
			r: u
		}), n.each(a, function(t, r) {
			var a;
			if (isNaN(t)) {
				n.setItemLayout(r, {
					angle: NaN,
					startAngle: NaN,
					endAngle: NaN,
					clockwise: b,
					cx: c,
					cy: l,
					r0: d,
					r: x ? NaN : u
				});
				return;
			}
			a = x === "area" ? O / _ : v === 0 && S ? y : t * y, a < g ? (a = g, A -= g) : j += t;
			var o = M + w * a, s = 0, f = 0;
			h > a ? (s = M + w * a / 2, f = s) : (s = M + E, f = o - E), n.setItemLayout(r, {
				angle: a,
				startAngle: s,
				endAngle: f,
				clockwise: b,
				cx: c,
				cy: l,
				r0: d,
				r: x ? linearMap$2(t, C, [d, u]) : u
			}), M = o;
		}), A < PI2 && _) if (A <= .001) {
			var N = O / _;
			n.each(a, function(t, r) {
				if (!isNaN(t)) {
					var a = n.getItemLayout(r);
					a.angle = N;
					var o = 0, s = 0;
					N < h ? (o = f + w * (r + 1 / 2) * N, s = o) : (o = f + w * r * N + E, s = f + w * (r + 1) * N - E), a.startAngle = o, a.endAngle = s;
				}
			});
		} else y = A / j, M = f, n.each(a, function(t, r) {
			if (!isNaN(t)) {
				var a = n.getItemLayout(r), o = a.angle === g ? g : t * y, s = 0, c = 0;
				o < h ? (s = M + w * o / 2, c = s) : (s = M + E, c = M + w * o - E), a.startAngle = s, a.endAngle = c, M += w * o;
			}
		});
	});
}
var getSeriesLayoutData = makeInner();
function dataFilter$1(t) {
	return {
		seriesType: t,
		reset: function(t, n) {
			var r = n.findComponents({ mainType: "legend" });
			if (!(!r || !r.length)) {
				var a = t.getData();
				a.filterSelf(function(t) {
					for (var n = a.getName(t), o = 0; o < r.length; o++) if (!r[o].isSelected(n)) return !1;
					return !0;
				});
			}
		}
	};
}
var RADIAN$1 = Math.PI / 180;
function adjustSingleSide(t, n, r, a, o, s, c, l, u, d) {
	if (t.length < 2) return;
	function f(t) {
		for (var s = t.rB, c = s * s, l = 0; l < t.list.length; l++) {
			var u = t.list[l], d = Math.abs(u.label.y - r), f = a + u.len, p = f * f, h = n + (Math.sqrt(Math.abs((1 - d * d / c) * p)) + u.len2) * o, g = h - u.label.x;
			constrainTextWidth(u, u.targetTextWidth - g * o, !0), u.label.x = h;
		}
	}
	function p(t) {
		for (var s = {
			list: [],
			maxY: 0
		}, c = {
			list: [],
			maxY: 0
		}, l = 0; l < t.length; l++) if (t[l].labelAlignTo === "none") {
			var u = t[l], d = u.label.y > r ? c : s, p = Math.abs(u.label.y - r);
			if (p >= d.maxY) {
				var h = u.label.x - n - u.len2 * o, g = a + u.len;
				d.rB = Math.abs(h) < g ? Math.sqrt(p * p / (1 - h * h / g / g)) : g, d.maxY = p;
			}
			d.list.push(u);
		}
		f(s), f(c);
	}
	for (var h = t.length, g = 0; g < h; g++) if (t[g].position === "outer" && t[g].labelAlignTo === "labelLine") {
		var _ = t[g].label.x - d;
		t[g].linePoints[1][0] += _, t[g].label.x = d;
	}
	shiftLayoutOnY(t, u, u + c) && p(t);
}
function avoidOverlap(t, n, r, a, o, s, c, l) {
	for (var u = [], d = [], f = Number.MAX_VALUE, p = -Number.MAX_VALUE, h = 0; h < t.length; h++) {
		var g = t[h].label;
		isPositionCenter(t[h]) || (g.x < n ? (f = Math.min(f, g.x), u.push(t[h])) : (p = Math.max(p, g.x), d.push(t[h])));
	}
	for (var h = 0; h < t.length; h++) {
		var _ = t[h];
		if (!isPositionCenter(_) && _.linePoints) {
			if (_.labelStyleWidth != null) continue;
			var g = _.label, v = _.linePoints, y = void 0;
			y = _.labelAlignTo === "edge" ? g.x < n ? v[2][0] - _.labelDistance - c - _.edgeDistance : c + o - _.edgeDistance - v[2][0] - _.labelDistance : _.labelAlignTo === "labelLine" ? g.x < n ? f - c - _.bleedMargin : c + o - p - _.bleedMargin : g.x < n ? g.x - c - _.bleedMargin : c + o - g.x - _.bleedMargin, _.targetTextWidth = y, constrainTextWidth(_, y);
		}
	}
	adjustSingleSide(d, n, r, a, 1, o, s, c, l, p), adjustSingleSide(u, n, r, a, -1, o, s, c, l, f);
	for (var h = 0; h < t.length; h++) {
		var _ = t[h];
		if (!isPositionCenter(_) && _.linePoints) {
			var g = _.label, v = _.linePoints, b = _.labelAlignTo === "edge", x = g.style.padding, S = x ? x[1] + x[3] : 0, C = g.style.backgroundColor ? 0 : S, w = _.rect.width + C, T = v[1][0] - v[2][0];
			b ? g.x < n ? v[2][0] = c + _.edgeDistance + w + _.labelDistance : v[2][0] = c + o - _.edgeDistance - w - _.labelDistance : (g.x < n ? v[2][0] = g.x + _.labelDistance : v[2][0] = g.x - _.labelDistance, v[1][0] = v[2][0] + T), v[1][1] = v[2][1] = g.y;
		}
	}
}
function constrainTextWidth(t, n, r) {
	if (r === void 0 && (r = !1), t.labelStyleWidth == null) {
		var a = t.label, o = a.style, s = t.rect, c = o.backgroundColor, l = o.padding, u = l ? l[1] + l[3] : 0, d = o.overflow, f = s.width + (c ? 0 : u);
		if (n < f || r) {
			var p = s.height;
			if (d && d.match("break")) {
				a.setStyle("backgroundColor", null), a.setStyle("width", n - u);
				var h = a.getBoundingRect();
				a.setStyle("width", Math.ceil(h.width)), a.setStyle("backgroundColor", c);
			} else {
				var g = n - u, _ = n < f ? g : r ? g > t.unconstrainedWidth ? null : g : null;
				a.setStyle("width", _);
			}
			var v = a.getBoundingRect();
			s.width = v.width;
			var y = (a.style.margin || 0) + 2.1;
			s.height = v.height + y, s.y -= (s.height - p) / 2;
		}
	}
}
function isPositionCenter(t) {
	return t.position === "center";
}
function pieLabelLayout(t) {
	var n = t.getData(), r = [], a, o, s = !1, c = (t.get("minShowLabelAngle") || 0) * RADIAN$1, l = n.getLayout("viewRect"), u = n.getLayout("r"), d = l.width, f = l.x, p = l.y, h = l.height;
	function g(t) {
		t.ignore = !0;
	}
	function _(t) {
		if (!t.ignore) return !0;
		for (var n in t.states) if (t.states[n].ignore === !1) return !0;
		return !1;
	}
	n.each(function(t) {
		var l = n.getItemGraphicEl(t), p = l.shape, h = l.getTextContent(), v = l.getTextGuideLine(), y = n.getItemModel(t), b = y.getModel("label"), x = b.get("position") || y.get([
			"emphasis",
			"label",
			"position"
		]), S = b.get("distanceToLabelLine"), C = b.get("alignTo"), w = parsePercent$1(b.get("edgeDistance"), d), T = b.get("bleedMargin"), E = y.getModel("labelLine"), D = E.get("length");
		D = parsePercent$1(D, d);
		var O = E.get("length2");
		if (O = parsePercent$1(O, d), Math.abs(p.endAngle - p.startAngle) < c) {
			each(h.states, g), h.ignore = !0, v && (each(v.states, g), v.ignore = !0);
			return;
		}
		if (_(h)) {
			var A = (p.startAngle + p.endAngle) / 2, j = Math.cos(A), M = Math.sin(A), N, P, F, I;
			a = p.cx, o = p.cy;
			var L = x === "inside" || x === "inner";
			if (x === "center") N = p.cx, P = p.cy, I = "center";
			else {
				var R = (L ? (p.r + p.r0) / 2 * j : p.r * j) + a, z = (L ? (p.r + p.r0) / 2 * M : p.r * M) + o;
				if (N = R + j * 3, P = z + M * 3, !L) {
					var B = R + j * (D + u - p.r), V = z + M * (D + u - p.r), H = B + (j < 0 ? -1 : 1) * O, U = V;
					N = C === "edge" ? j < 0 ? f + w : f + d - w : H + (j < 0 ? -S : S), P = U, F = [
						[R, z],
						[B, V],
						[H, U]
					];
				}
				I = L ? "center" : C === "edge" ? j > 0 ? "right" : "left" : j > 0 ? "left" : "right";
			}
			var W = Math.PI, G = 0, K = b.get("rotate");
			if (isNumber(K)) G = K * (W / 180);
			else if (x === "center") G = 0;
			else if (K === "radial" || K === !0) G = j < 0 ? -A + W : -A;
			else if (K === "tangential" && x !== "outside" && x !== "outer") {
				var q = Math.atan2(j, M);
				q < 0 && (q = W * 2 + q), M > 0 && (q = W + q), G = q - W;
			}
			if (s = !!G, h.x = N, h.y = P, h.rotation = G, h.setStyle({ verticalAlign: "middle" }), L) {
				h.setStyle({ align: I });
				var J = h.states.select;
				J && (J.x += h.x, J.y += h.y);
			} else {
				var Y = h.getBoundingRect().clone();
				Y.applyTransform(h.getComputedTransform());
				var Z = (h.style.margin || 0) + 2.1;
				Y.y -= Z / 2, Y.height += Z, r.push({
					label: h,
					labelLine: v,
					position: x,
					len: D,
					len2: O,
					minTurnAngle: E.get("minTurnAngle"),
					maxSurfaceAngle: E.get("maxSurfaceAngle"),
					surfaceNormal: new Point_default(j, M),
					linePoints: F,
					textAlign: I,
					labelDistance: S,
					labelAlignTo: C,
					edgeDistance: w,
					bleedMargin: T,
					rect: Y,
					unconstrainedWidth: Y.width,
					labelStyleWidth: h.style.width
				});
			}
			l.setTextConfig({ inside: L });
		}
	}), !s && t.get("avoidLabelOverlap") && avoidOverlap(r, a, o, u, d, h, f, p);
	for (var v = 0; v < r.length; v++) {
		var y = r[v], b = y.label, x = y.labelLine, S = isNaN(b.x) || isNaN(b.y);
		if (b) {
			b.setStyle({ align: y.textAlign }), S && (each(b.states, g), b.ignore = !0);
			var C = b.states.select;
			C && (C.x += b.x, C.y += b.y);
		}
		if (x) {
			var w = y.linePoints;
			S || !w ? (each(x.states, g), x.ignore = !0) : (limitTurnAngle(w, y.minTurnAngle), limitSurfaceAngle(w, y.surfaceNormal, y.maxSurfaceAngle), x.setShape({ points: w }), b.__hostTarget.textGuideLineConfig = { anchor: new Point_default(w[0][0], w[0][1]) });
		}
	}
}
var PiePiece = function(t) {
	__extends(n, t);
	function n(n, r, a) {
		var o = t.call(this) || this;
		o.z2 = 2;
		var s = new Text_default();
		return o.setTextContent(s), o.updateData(n, r, a, !0), o;
	}
	return n.prototype.updateData = function(t, n, r, a) {
		var o = this, s = t.hostModel, c = t.getItemModel(n), l = c.getModel("emphasis"), u = t.getItemLayout(n), d = extend(getSectorCornerRadius(c.getModel("itemStyle"), u, !0), u);
		if (isNaN(d.startAngle)) {
			o.setShape(d);
			return;
		}
		if (a) {
			o.setShape(d);
			var f = s.getShallow("animationType");
			s.ecModel.ssr ? (initProps(o, {
				scaleX: 0,
				scaleY: 0
			}, s, {
				dataIndex: n,
				isFrom: !0
			}), o.originX = d.cx, o.originY = d.cy) : f === "scale" ? (o.shape.r = u.r0, initProps(o, { shape: { r: u.r } }, s, n)) : r == null ? (o.shape.endAngle = u.startAngle, updateProps(o, { shape: { endAngle: u.endAngle } }, s, n)) : (o.setShape({
				startAngle: r,
				endAngle: r
			}), initProps(o, { shape: {
				startAngle: u.startAngle,
				endAngle: u.endAngle
			} }, s, n));
		} else saveOldStyle(o), updateProps(o, { shape: d }, s, n);
		o.useStyle(t.getItemVisual(n, "style")), setStatesStylesFromModel(o, c);
		var p = (u.startAngle + u.endAngle) / 2, h = s.get("selectedOffset"), g = Math.cos(p) * h, _ = Math.sin(p) * h, v = c.getShallow("cursor");
		v && o.attr("cursor", v), this._updateLabel(s, t, n), o.ensureState("emphasis").shape = extend({ r: u.r + (l.get("scale") && l.get("scaleSize") || 0) }, getSectorCornerRadius(l.getModel("itemStyle"), u)), extend(o.ensureState("select"), {
			x: g,
			y: _,
			shape: getSectorCornerRadius(c.getModel(["select", "itemStyle"]), u)
		}), extend(o.ensureState("blur"), { shape: getSectorCornerRadius(c.getModel(["blur", "itemStyle"]), u) });
		var y = o.getTextGuideLine(), b = o.getTextContent();
		y && extend(y.ensureState("select"), {
			x: g,
			y: _
		}), extend(b.ensureState("select"), {
			x: g,
			y: _
		}), toggleHoverEmphasis(this, l.get("focus"), l.get("blurScope"), l.get("disabled"));
	}, n.prototype._updateLabel = function(t, n, r) {
		var a = this, o = n.getItemModel(r), s = o.getModel("labelLine"), c = n.getItemVisual(r, "style"), l = c && c.fill, u = c && c.opacity;
		setLabelStyle(a, getLabelStatesModels(o), {
			labelFetcher: n.hostModel,
			labelDataIndex: r,
			inheritColor: l,
			defaultOpacity: u,
			defaultText: t.getFormattedLabel(r, "normal") || n.getName(r)
		});
		var d = a.getTextContent();
		a.setTextConfig({
			position: null,
			rotation: null
		}), d.attr({ z2: 10 });
		var f = t.get(["label", "position"]);
		if (f !== "outside" && f !== "outer") a.removeTextGuideLine();
		else {
			var p = this.getTextGuideLine();
			p || (p = new Polyline_default$1(), this.setTextGuideLine(p)), setLabelLineStyle(this, getLabelLineStatesModels(o), {
				stroke: l,
				opacity: retrieve3(s.get(["lineStyle", "opacity"]), u, 1)
			});
		}
	}, n;
}(Sector_default), PieView_default = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n.ignoreLabelLineUpdate = !0, n;
	}
	return n.prototype.render = function(t, n, r, a) {
		var o = t.getData(), s = this._data, c = this.group, l;
		if (!s && o.count() > 0) {
			for (var u = o.getItemLayout(0), d = 1; isNaN(u && u.startAngle) && d < o.count(); ++d) u = o.getItemLayout(d);
			u && (l = u.startAngle);
		}
		if (this._emptyCircleSector && c.remove(this._emptyCircleSector), o.count() === 0 && t.get("showEmptyCircle")) {
			var f = getSeriesLayoutData(t), p = new Sector_default({ shape: extend(getBasicPieLayout(t, r), f) });
			p.useStyle(t.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = p, c.add(p);
		}
		o.diff(s).add(function(t) {
			var n = new PiePiece(o, t, l);
			o.setItemGraphicEl(t, n), c.add(n);
		}).update(function(t, n) {
			var r = s.getItemGraphicEl(n);
			r.updateData(o, t, l), r.off("click"), c.add(r), o.setItemGraphicEl(t, r);
		}).remove(function(n) {
			removeElementWithFadeOut(s.getItemGraphicEl(n), t, n);
		}).execute(), pieLabelLayout(t), t.get("animationTypeUpdate") !== "expansion" && (this._data = o);
	}, n.prototype.dispose = function() {}, n.prototype.containPoint = function(t, n) {
		var r = n.getData().getItemLayout(0);
		if (r) {
			var a = t[0] - r.cx, o = t[1] - r.cy, s = Math.sqrt(a * a + o * o);
			return s <= r.r && s >= r.r0;
		}
	}, n.type = "pie", n;
}(Chart_default);
function createSeriesDataSimply(t, n, r) {
	n = isArray(n) && { coordDimensions: n } || extend({ encodeDefine: t.getEncode() }, n);
	var a = t.getSource(), o = prepareSeriesDataSchema(a, n).dimensions, s = new SeriesData_default(o, t);
	return s.initData(a, r), s;
}
var LegendVisualProvider_default = function() {
	function t(t, n) {
		this._getDataWithEncodedVisual = t, this._getRawData = n;
	}
	return t.prototype.getAllNames = function() {
		var t = this._getRawData();
		return t.mapArray(t.getName);
	}, t.prototype.containName = function(t) {
		return this._getRawData().indexOfName(t) >= 0;
	}, t.prototype.indexOfName = function(t) {
		return this._getDataWithEncodedVisual().indexOfName(t);
	}, t.prototype.getItemVisual = function(t, n) {
		return this._getDataWithEncodedVisual().getItemVisual(t, n);
	}, t;
}(), innerData = makeInner(), PieSeries_default = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.init = function(n) {
		t.prototype.init.apply(this, arguments), this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this)), this._defaultLabelLine(n);
	}, n.prototype.mergeOption = function() {
		t.prototype.mergeOption.apply(this, arguments);
	}, n.prototype.getInitialData = function() {
		return createSeriesDataSimply(this, {
			coordDimensions: ["value"],
			encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
		});
	}, n.prototype.getDataParams = function(n) {
		var r = this.getData(), a = innerData(r), o = a.seats;
		if (!o) {
			var s = [];
			r.each(r.mapDimension("value"), function(t) {
				s.push(t);
			}), o = a.seats = getPercentSeats(s, r.hostModel.get("percentPrecision"));
		}
		var c = t.prototype.getDataParams.call(this, n);
		return c.percent = o[n] || 0, c.$vars.push("percent"), c;
	}, n.prototype._defaultLabelLine = function(t) {
		defaultEmphasis(t, "labelLine", ["show"]);
		var n = t.labelLine, r = t.emphasis.labelLine;
		n.show = n.show && t.label.show, r.show = r.show && t.emphasis.label.show;
	}, n.type = "series.pie", n.defaultOption = {
		z: 2,
		legendHoverLink: !0,
		colorBy: "data",
		center: ["50%", "50%"],
		radius: [0, "75%"],
		clockwise: !0,
		startAngle: 90,
		endAngle: "auto",
		padAngle: 0,
		minAngle: 0,
		minShowLabelAngle: 0,
		selectedOffset: 10,
		percentPrecision: 2,
		stillShowZeroSum: !0,
		left: 0,
		top: 0,
		right: 0,
		bottom: 0,
		width: null,
		height: null,
		label: {
			rotate: 0,
			show: !0,
			overflow: "truncate",
			position: "outer",
			alignTo: "none",
			edgeDistance: "25%",
			bleedMargin: 10,
			distanceToLabelLine: 5
		},
		labelLine: {
			show: !0,
			length: 15,
			length2: 15,
			smooth: !1,
			minTurnAngle: 90,
			maxSurfaceAngle: 90,
			lineStyle: {
				width: 1,
				type: "solid"
			}
		},
		itemStyle: {
			borderWidth: 1,
			borderJoin: "round"
		},
		showEmptyCircle: !0,
		emptyCircleStyle: {
			color: "lightgray",
			opacity: 1
		},
		labelLayout: { hideOverlap: !0 },
		emphasis: {
			scale: !0,
			scaleSize: 5
		},
		avoidLabelOverlap: !0,
		animationType: "expansion",
		animationDuration: 1e3,
		animationTypeUpdate: "transition",
		animationEasingUpdate: "cubicInOut",
		animationDurationUpdate: 500,
		animationEasing: "cubicInOut"
	}, n;
}(Series_default);
function negativeDataFilter(t) {
	return {
		seriesType: t,
		reset: function(t, n) {
			var r = t.getData();
			r.filterSelf(function(t) {
				var n = r.mapDimension("value"), a = r.get(n, t);
				return !(isNumber(a) && !isNaN(a) && a < 0);
			});
		}
	};
}
function install$4(t) {
	t.registerChartView(PieView_default), t.registerSeriesModel(PieSeries_default), createLegacyDataSelectAction("pie", t.registerAction), t.registerLayout(curry(pieLayout, "pie")), t.registerProcessor(dataFilter$1("pie")), t.registerProcessor(negativeDataFilter("pie"));
}
var ScatterSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.hasSymbolVisual = !0, r;
	}
	return n.prototype.getInitialData = function(t, n) {
		return createSeriesData_default(null, this, { useEncodeDefaulter: !0 });
	}, n.prototype.getProgressive = function() {
		return this.option.progressive ?? (this.option.large ? 5e3 : this.get("progressive"));
	}, n.prototype.getProgressiveThreshold = function() {
		return this.option.progressiveThreshold ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
	}, n.prototype.brushSelector = function(t, n, r) {
		return r.point(n.getItemLayout(t));
	}, n.prototype.getZLevelKey = function() {
		return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
	}, n.type = "series.scatter", n.dependencies = [
		"grid",
		"polar",
		"geo",
		"singleAxis",
		"calendar"
	], n.defaultOption = {
		coordinateSystem: "cartesian2d",
		z: 2,
		legendHoverLink: !0,
		symbolSize: 10,
		large: !1,
		largeThreshold: 2e3,
		itemStyle: { opacity: .8 },
		emphasis: { scale: !0 },
		clip: !0,
		select: { itemStyle: { borderColor: "#212121" } },
		universalTransition: { divideShape: "clone" }
	}, n;
}(Series_default), BOOST_SIZE_THRESHOLD = 4, LargeSymbolPathShape = function() {
	function t() {}
	return t;
}(), LargeSymbolPath = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this, n) || this;
		return r._off = 0, r.hoverDataIdx = -1, r;
	}
	return n.prototype.getDefaultShape = function() {
		return new LargeSymbolPathShape();
	}, n.prototype.reset = function() {
		this.notClear = !1, this._off = 0;
	}, n.prototype.buildPath = function(t, n) {
		var r = n.points, a = n.size, o = this.symbolProxy, s = o.shape, c = t.getContext ? t.getContext() : t, l = c && a[0] < BOOST_SIZE_THRESHOLD, u = this.softClipShape, d;
		if (l) {
			this._ctx = c;
			return;
		}
		for (this._ctx = null, d = this._off; d < r.length;) {
			var f = r[d++], p = r[d++];
			isNaN(f) || isNaN(p) || u && !u.contain(f, p) || (s.x = f - a[0] / 2, s.y = p - a[1] / 2, s.width = a[0], s.height = a[1], o.buildPath(t, s, !0));
		}
		this.incremental && (this._off = d, this.notClear = !0);
	}, n.prototype.afterBrush = function() {
		var t = this.shape, n = t.points, r = t.size, a = this._ctx, o = this.softClipShape, s;
		if (a) {
			for (s = this._off; s < n.length;) {
				var c = n[s++], l = n[s++];
				isNaN(c) || isNaN(l) || o && !o.contain(c, l) || a.fillRect(c - r[0] / 2, l - r[1] / 2, r[0], r[1]);
			}
			this.incremental && (this._off = s, this.notClear = !0);
		}
	}, n.prototype.findDataIndex = function(t, n) {
		for (var r = this.shape, a = r.points, o = r.size, s = Math.max(o[0], 4), c = Math.max(o[1], 4), l = a.length / 2 - 1; l >= 0; l--) {
			var u = l * 2, d = a[u] - s / 2, f = a[u + 1] - c / 2;
			if (t >= d && n >= f && t <= d + s && n <= f + c) return l;
		}
		return -1;
	}, n.prototype.contain = function(t, n) {
		var r = this.transformCoordToLocal(t, n), a = this.getBoundingRect();
		return t = r[0], n = r[1], a.contain(t, n) ? (this.hoverDataIdx = this.findDataIndex(t, n)) >= 0 : (this.hoverDataIdx = -1, !1);
	}, n.prototype.getBoundingRect = function() {
		var t = this._rect;
		if (!t) {
			for (var n = this.shape, r = n.points, a = n.size, o = a[0], s = a[1], c = Infinity, l = Infinity, u = -Infinity, d = -Infinity, f = 0; f < r.length;) {
				var p = r[f++], h = r[f++];
				c = Math.min(p, c), u = Math.max(p, u), l = Math.min(h, l), d = Math.max(h, d);
			}
			t = this._rect = new BoundingRect_default(c - o / 2, l - s / 2, u - c + o, d - l + s);
		}
		return t;
	}, n;
}(Path_default), LargeSymbolDraw_default = function() {
	function t() {
		this.group = new Group_default();
	}
	return t.prototype.updateData = function(t, n) {
		this._clear();
		var r = this._create();
		r.setShape({ points: t.getLayout("points") }), this._setCommon(r, t, n);
	}, t.prototype.updateLayout = function(t) {
		var n = t.getLayout("points");
		this.group.eachChild(function(t) {
			if (t.startIndex != null) {
				var r = (t.endIndex - t.startIndex) * 2, a = t.startIndex * 4 * 2;
				n = new Float32Array(n.buffer, a, r);
			}
			t.setShape("points", n), t.reset();
		});
	}, t.prototype.incrementalPrepareUpdate = function(t) {
		this._clear();
	}, t.prototype.incrementalUpdate = function(t, n, r) {
		var a = this._newAdded[0], o = n.getLayout("points"), s = a && a.shape.points;
		if (s && s.length < 2e4) {
			var c = s.length, l = new Float32Array(c + o.length);
			l.set(s), l.set(o, c), a.endIndex = t.end, a.setShape({ points: l });
		} else {
			this._newAdded = [];
			var u = this._create();
			u.startIndex = t.start, u.endIndex = t.end, u.incremental = !0, u.setShape({ points: o }), this._setCommon(u, n, r);
		}
	}, t.prototype.eachRendered = function(t) {
		this._newAdded[0] && t(this._newAdded[0]);
	}, t.prototype._create = function() {
		var t = new LargeSymbolPath({ cursor: "default" });
		return t.ignoreCoarsePointer = !0, this.group.add(t), this._newAdded.push(t), t;
	}, t.prototype._setCommon = function(t, n, r) {
		var a = n.hostModel;
		r ||= {};
		var o = n.getVisual("symbolSize");
		t.setShape("size", o instanceof Array ? o : [o, o]), t.softClipShape = r.clipShape || null, t.symbolProxy = createSymbol(n.getVisual("symbol"), 0, 0, 0, 0), t.setColor = t.symbolProxy.setColor;
		var s = t.shape.size[0] < BOOST_SIZE_THRESHOLD;
		t.useStyle(a.getModel("itemStyle").getItemStyle(s ? [
			"color",
			"shadowBlur",
			"shadowColor"
		] : ["color"]));
		var c = n.getVisual("style"), l = c && c.fill;
		l && t.setColor(l);
		var u = getECData(t);
		u.seriesIndex = a.seriesIndex, t.on("mousemove", function(n) {
			u.dataIndex = null;
			var r = t.hoverDataIdx;
			r >= 0 && (u.dataIndex = r + (t.startIndex || 0));
		});
	}, t.prototype.remove = function() {
		this._clear();
	}, t.prototype._clear = function() {
		this._newAdded = [], this.group.removeAll();
	}, t;
}(), ScatterView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r) {
		var a = t.getData();
		this._updateSymbolDraw(a, t).updateData(a, { clipShape: this._getClipShape(t) }), this._finished = !0;
	}, n.prototype.incrementalPrepareRender = function(t, n, r) {
		var a = t.getData();
		this._updateSymbolDraw(a, t).incrementalPrepareUpdate(a), this._finished = !1;
	}, n.prototype.incrementalRender = function(t, n, r) {
		this._symbolDraw.incrementalUpdate(t, n.getData(), { clipShape: this._getClipShape(n) }), this._finished = t.end === n.getData().count();
	}, n.prototype.updateTransform = function(t, n, r) {
		var a = t.getData();
		if (this.group.dirty(), !this._finished || a.count() > 1e4) return { update: !0 };
		var o = pointsLayout("").reset(t, n, r);
		o.progress && o.progress({
			start: 0,
			end: a.count(),
			count: a.count()
		}, a), this._symbolDraw.updateLayout(a);
	}, n.prototype.eachRendered = function(t) {
		this._symbolDraw && this._symbolDraw.eachRendered(t);
	}, n.prototype._getClipShape = function(t) {
		if (t.get("clip", !0)) {
			var n = t.coordinateSystem;
			return n && n.getArea && n.getArea(.1);
		}
	}, n.prototype._updateSymbolDraw = function(t, n) {
		var r = this._symbolDraw, a = n.pipelineContext.large;
		return (!r || a !== this._isLargeDraw) && (r && r.remove(), r = this._symbolDraw = a ? new LargeSymbolDraw_default() : new SymbolDraw_default(), this._isLargeDraw = a, this.group.removeAll()), this.group.add(r.group), r;
	}, n.prototype.remove = function(t, n) {
		this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
	}, n.prototype.dispose = function() {}, n.type = "scatter", n;
}(Chart_default), GridModel_default = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.type = "grid", n.dependencies = ["xAxis", "yAxis"], n.layoutMode = "box", n.defaultOption = {
		show: !1,
		z: 0,
		left: "10%",
		top: 60,
		right: "10%",
		bottom: 70,
		containLabel: !1,
		backgroundColor: "rgba(0,0,0,0)",
		borderWidth: 1,
		borderColor: "#ccc"
	}, n;
}(Component_default), CartesianAxisModel = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.getCoordSysModel = function() {
		return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
	}, n.type = "cartesian2dAxis", n;
}(Component_default);
mixin(CartesianAxisModel, AxisModelCommonMixin);
var defaultOption$1 = {
	show: !0,
	z: 0,
	inverse: !1,
	name: "",
	nameLocation: "end",
	nameRotate: null,
	nameTruncate: {
		maxWidth: null,
		ellipsis: "...",
		placeholder: "."
	},
	nameTextStyle: {},
	nameGap: 15,
	silent: !1,
	triggerEvent: !1,
	tooltip: { show: !1 },
	axisPointer: {},
	axisLine: {
		show: !0,
		onZero: !0,
		onZeroAxisIndex: null,
		lineStyle: {
			color: "#6E7079",
			width: 1,
			type: "solid"
		},
		symbol: ["none", "none"],
		symbolSize: [10, 15]
	},
	axisTick: {
		show: !0,
		inside: !1,
		length: 5,
		lineStyle: { width: 1 }
	},
	axisLabel: {
		show: !0,
		inside: !1,
		rotate: 0,
		showMinLabel: null,
		showMaxLabel: null,
		margin: 8,
		fontSize: 12
	},
	splitLine: {
		show: !0,
		showMinLine: !0,
		showMaxLine: !0,
		lineStyle: {
			color: ["#E0E6F1"],
			width: 1,
			type: "solid"
		}
	},
	splitArea: {
		show: !1,
		areaStyle: { color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"] }
	}
}, categoryAxis = merge({
	boundaryGap: !0,
	deduplication: null,
	splitLine: { show: !1 },
	axisTick: {
		alignWithLabel: !1,
		interval: "auto"
	},
	axisLabel: { interval: "auto" }
}, defaultOption$1), valueAxis = merge({
	boundaryGap: [0, 0],
	axisLine: { show: "auto" },
	axisTick: { show: "auto" },
	splitNumber: 5,
	minorTick: {
		show: !1,
		splitNumber: 5,
		length: 3,
		lineStyle: {}
	},
	minorSplitLine: {
		show: !1,
		lineStyle: {
			color: "#F4F7FD",
			width: 1
		}
	}
}, defaultOption$1), axisDefault_default = {
	category: categoryAxis,
	value: valueAxis,
	time: merge({
		splitNumber: 6,
		axisLabel: {
			showMinLabel: !1,
			showMaxLabel: !1,
			rich: { primary: { fontWeight: "bold" } }
		},
		splitLine: { show: !1 }
	}, valueAxis),
	log: defaults({ logBase: 10 }, valueAxis)
}, AXIS_TYPES = {
	value: 1,
	category: 1,
	time: 1,
	log: 1
};
function axisModelCreator(t, n, r, a) {
	each(AXIS_TYPES, function(o, s) {
		var c = merge(merge({}, axisDefault_default[s], !0), a, !0), l = function(t) {
			__extends(r, t);
			function r() {
				var r = t !== null && t.apply(this, arguments) || this;
				return r.type = n + "Axis." + s, r;
			}
			return r.prototype.mergeDefaultAndTheme = function(t, n) {
				var r = fetchLayoutMode(this), a = r ? getLayoutParams(t) : {};
				merge(t, n.getTheme().get(s + "Axis")), merge(t, this.getDefaultOption()), t.type = getAxisType(t), r && mergeLayoutParam(t, a, r);
			}, r.prototype.optionUpdated = function() {
				this.option.type === "category" && (this.__ordinalMeta = OrdinalMeta_default.createByAxisModel(this));
			}, r.prototype.getCategories = function(t) {
				var n = this.option;
				if (n.type === "category") return t ? n.data : this.__ordinalMeta.categories;
			}, r.prototype.getOrdinalMeta = function() {
				return this.__ordinalMeta;
			}, r.type = n + "Axis." + s, r.defaultOption = c, r;
		}(r);
		t.registerComponentModel(l);
	}), t.registerSubTypeDefaulter(n + "Axis", getAxisType);
}
function getAxisType(t) {
	return t.type || (t.data ? "category" : "value");
}
var Cartesian_default = function() {
	function t(t) {
		this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = t || "";
	}
	return t.prototype.getAxis = function(t) {
		return this._axes[t];
	}, t.prototype.getAxes = function() {
		return map(this._dimList, function(t) {
			return this._axes[t];
		}, this);
	}, t.prototype.getAxesByScale = function(t) {
		return t = t.toLowerCase(), filter(this.getAxes(), function(n) {
			return n.scale.type === t;
		});
	}, t.prototype.addAxis = function(t) {
		var n = t.dim;
		this._axes[n] = t, this._dimList.push(n);
	}, t;
}(), cartesian2DDimensions = ["x", "y"];
function canCalculateAffineTransform(t) {
	return t.type === "interval" || t.type === "time";
}
var Cartesian2D_default = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n.type = "cartesian2d", n.dimensions = cartesian2DDimensions, n;
	}
	return n.prototype.calcAffineTransform = function() {
		this._transform = this._invTransform = null;
		var t = this.getAxis("x").scale, n = this.getAxis("y").scale;
		if (!(!canCalculateAffineTransform(t) || !canCalculateAffineTransform(n))) {
			var r = t.getExtent(), a = n.getExtent(), o = this.dataToPoint([r[0], a[0]]), s = this.dataToPoint([r[1], a[1]]), c = r[1] - r[0], l = a[1] - a[0];
			if (!(!c || !l)) {
				var u = (s[0] - o[0]) / c, d = (s[1] - o[1]) / l;
				this._invTransform = invert([], this._transform = [
					u,
					0,
					0,
					d,
					o[0] - r[0] * u,
					o[1] - a[0] * d
				]);
			}
		}
	}, n.prototype.getBaseAxis = function() {
		return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
	}, n.prototype.containPoint = function(t) {
		var n = this.getAxis("x"), r = this.getAxis("y");
		return n.contain(n.toLocalCoord(t[0])) && r.contain(r.toLocalCoord(t[1]));
	}, n.prototype.containData = function(t) {
		return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]);
	}, n.prototype.containZone = function(t, n) {
		var r = this.dataToPoint(t), a = this.dataToPoint(n), o = this.getArea(), s = new BoundingRect_default(r[0], r[1], a[0] - r[0], a[1] - r[1]);
		return o.intersect(s);
	}, n.prototype.dataToPoint = function(t, n, r) {
		r ||= [];
		var a = t[0], o = t[1];
		if (this._transform && a != null && isFinite(a) && o != null && isFinite(o)) return applyTransform(r, t, this._transform);
		var s = this.getAxis("x"), c = this.getAxis("y");
		return r[0] = s.toGlobalCoord(s.dataToCoord(a, n)), r[1] = c.toGlobalCoord(c.dataToCoord(o, n)), r;
	}, n.prototype.clampData = function(t, n) {
		var r = this.getAxis("x").scale, a = this.getAxis("y").scale, o = r.getExtent(), s = a.getExtent(), c = r.parse(t[0]), l = a.parse(t[1]);
		return n ||= [], n[0] = Math.min(Math.max(Math.min(o[0], o[1]), c), Math.max(o[0], o[1])), n[1] = Math.min(Math.max(Math.min(s[0], s[1]), l), Math.max(s[0], s[1])), n;
	}, n.prototype.pointToData = function(t, n) {
		var r = [];
		if (this._invTransform) return applyTransform(r, t, this._invTransform);
		var a = this.getAxis("x"), o = this.getAxis("y");
		return r[0] = a.coordToData(a.toLocalCoord(t[0]), n), r[1] = o.coordToData(o.toLocalCoord(t[1]), n), r;
	}, n.prototype.getOtherAxis = function(t) {
		return this.getAxis(t.dim === "x" ? "y" : "x");
	}, n.prototype.getArea = function(t) {
		t ||= 0;
		var n = this.getAxis("x").getGlobalExtent(), r = this.getAxis("y").getGlobalExtent(), a = Math.min(n[0], n[1]) - t, o = Math.min(r[0], r[1]) - t;
		return new BoundingRect_default(a, o, Math.max(n[0], n[1]) - a + t, Math.max(r[0], r[1]) - o + t);
	}, n;
}(Cartesian_default), Axis2D_default = function(t) {
	__extends(n, t);
	function n(n, r, a, o, s) {
		var c = t.call(this, n, r, a) || this;
		return c.index = 0, c.type = o || "value", c.position = s || "bottom", c;
	}
	return n.prototype.isHorizontal = function() {
		var t = this.position;
		return t === "top" || t === "bottom";
	}, n.prototype.getGlobalExtent = function(t) {
		var n = this.getExtent();
		return n[0] = this.toGlobalCoord(n[0]), n[1] = this.toGlobalCoord(n[1]), t && n[0] > n[1] && n.reverse(), n;
	}, n.prototype.pointToData = function(t, n) {
		return this.coordToData(this.toLocalCoord(t[this.dim === "x" ? 0 : 1]), n);
	}, n.prototype.setCategorySortInfo = function(t) {
		if (this.type !== "category") return !1;
		this.model.option.categorySortInfo = t, this.scale.setSortInfo(t);
	}, n;
}(Axis_default);
init_dist$2();
function layout$3(t, n, r) {
	r ||= {};
	var a = t.coordinateSystem, o = n.axis, s = {}, c = o.getAxesOnZeroOf()[0], l = o.position, u = c ? "onZero" : l, d = o.dim, f = a.getRect(), p = [
		f.x,
		f.x + f.width,
		f.y,
		f.y + f.height
	], h = {
		left: 0,
		right: 1,
		top: 0,
		bottom: 1,
		onZero: 2
	}, g = n.get("offset") || 0, _ = d === "x" ? [p[2] - g, p[3] + g] : [p[0] - g, p[1] + g];
	if (c) {
		var v = c.toGlobalCoord(c.dataToCoord(0));
		_[h.onZero] = Math.max(Math.min(v, _[1]), _[0]);
	}
	s.position = [d === "y" ? _[h[u]] : p[0], d === "x" ? _[h[u]] : p[3]], s.rotation = Math.PI / 2 * (d === "x" ? 0 : 1), s.labelDirection = s.tickDirection = s.nameDirection = {
		top: -1,
		bottom: 1,
		left: -1,
		right: 1
	}[l], s.labelOffset = c ? _[h[l]] - _[h.onZero] : 0, n.get(["axisTick", "inside"]) && (s.tickDirection = -s.tickDirection), retrieve(r.labelInside, n.get(["axisLabel", "inside"])) && (s.labelDirection = -s.labelDirection);
	var y = n.get(["axisLabel", "rotate"]);
	return s.labelRotate = u === "top" ? -y : y, s.z2 = 1, s;
}
function isCartesian2DSeries(t) {
	return t.get("coordinateSystem") === "cartesian2d";
}
function findAxisModels(t) {
	var n = {
		xAxisModel: null,
		yAxisModel: null
	};
	return each(n, function(r, a) {
		var o = a.replace(/Model$/, ""), c = t.getReferringComponents(o, SINGLE_REFERRING).models[0];
		if (process$1.env.NODE_ENV !== "production" && !c) throw Error(o + " \"" + retrieve3(t.get(o + "Index"), t.get(o + "Id"), 0) + "\" not found");
		n[a] = c;
	}), n;
}
init_dist$2();
var mathLog = Math.log;
function alignScaleTicks(t, n, r) {
	var a = Interval_default.prototype, o = a.getTicks.call(r), c = a.getTicks.call(r, !0), l = o.length - 1, u = a.getInterval.call(r), d = getScaleExtent(t, n), f = d.extent, p = d.fixMin, h = d.fixMax;
	if (t.type === "log") {
		var g = mathLog(t.base);
		f = [mathLog(f[0]) / g, mathLog(f[1]) / g];
	}
	t.setExtent(f[0], f[1]), t.calcNiceExtent({
		splitNumber: l,
		fixMin: p,
		fixMax: h
	});
	var _ = a.getExtent.call(t);
	p && (f[0] = _[0]), h && (f[1] = _[1]);
	var v = a.getInterval.call(t), y = f[0], b = f[1];
	if (p && h) v = (b - y) / l;
	else if (p) for (b = f[0] + v * l; b < f[1] && isFinite(b) && isFinite(f[1]);) v = increaseInterval(v), b = f[0] + v * l;
	else if (h) for (y = f[1] - v * l; y > f[0] && isFinite(y) && isFinite(f[0]);) v = increaseInterval(v), y = f[1] - v * l;
	else {
		t.getTicks().length - 1 > l && (v = increaseInterval(v));
		var x = v * l;
		b = Math.ceil(f[1] / v) * v, y = round$1(b - x), y < 0 && f[0] >= 0 ? (y = 0, b = round$1(x)) : b > 0 && f[1] <= 0 && (b = 0, y = -round$1(x));
	}
	var S = (o[0].value - c[0].value) / u, C = (o[l].value - c[l].value) / u;
	if (a.setExtent.call(t, y + v * S, b + v * C), a.setInterval.call(t, v), (S || C) && a.setNiceExtent.call(t, y + v, b - v), process$1.env.NODE_ENV !== "production") {
		var w = a.getTicks.call(t);
		w[1] && (!isValueNice(v) || getPrecisionSafe(w[1].value) > getPrecisionSafe(v)) && warn("The ticks may be not readable when set min: " + n.get("min") + ", max: " + n.get("max") + " and alignTicks: true");
	}
}
init_dist$2();
var Grid = function() {
	function t(t, n, r) {
		this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = cartesian2DDimensions, this._initCartesian(t, n, r), this.model = t;
	}
	return t.prototype.getRect = function() {
		return this._rect;
	}, t.prototype.update = function(t, n) {
		var r = this._axesMap;
		this._updateScale(t, this.model);
		function a(t) {
			var n, r = keys(t), a = r.length;
			if (a) {
				for (var o = [], s = a - 1; s >= 0; s--) {
					var c = t[+r[s]], l = c.model, u = c.scale;
					isIntervalOrLogScale(u) && l.get("alignTicks") && l.get("interval") == null ? o.push(c) : (niceScaleExtent(u, l), isIntervalOrLogScale(u) && (n = c));
				}
				o.length && (n || (n = o.pop(), niceScaleExtent(n.scale, n.model)), each(o, function(t) {
					alignScaleTicks(t.scale, t.model, n.scale);
				}));
			}
		}
		a(r.x), a(r.y);
		var o = {};
		each(r.x, function(t) {
			fixAxisOnZero(r, "y", t, o);
		}), each(r.y, function(t) {
			fixAxisOnZero(r, "x", t, o);
		}), this.resize(this.model, n);
	}, t.prototype.resize = function(t, n, r) {
		var a = t.getBoxLayoutParams(), o = !r && t.get("containLabel"), s = getLayoutRect(a, {
			width: n.getWidth(),
			height: n.getHeight()
		});
		this._rect = s;
		var c = this._axesList;
		l(), o && (each(c, function(t) {
			if (!t.model.get(["axisLabel", "inside"])) {
				var n = estimateLabelUnionRect(t);
				if (n) {
					var r = t.isHorizontal() ? "height" : "width", a = t.model.get(["axisLabel", "margin"]);
					s[r] -= n[r] + a, t.position === "top" ? s.y += n.height + a : t.position === "left" && (s.x += n.width + a);
				}
			}
		}), l()), each(this._coordsList, function(t) {
			t.calcAffineTransform();
		});
		function l() {
			each(c, function(t) {
				var n = t.isHorizontal(), r = n ? [0, s.width] : [0, s.height], a = t.inverse ? 1 : 0;
				t.setExtent(r[a], r[1 - a]), updateAxisTransform(t, n ? s.x : s.y);
			});
		}
	}, t.prototype.getAxis = function(t, n) {
		var r = this._axesMap[t];
		if (r != null) return r[n || 0];
	}, t.prototype.getAxes = function() {
		return this._axesList.slice();
	}, t.prototype.getCartesian = function(t, n) {
		if (t != null && n != null) {
			var r = "x" + t + "y" + n;
			return this._coordsMap[r];
		}
		isObject(t) && (n = t.yAxisIndex, t = t.xAxisIndex);
		for (var a = 0, o = this._coordsList; a < o.length; a++) if (o[a].getAxis("x").index === t || o[a].getAxis("y").index === n) return o[a];
	}, t.prototype.getCartesians = function() {
		return this._coordsList.slice();
	}, t.prototype.convertToPixel = function(t, n, r) {
		var a = this._findConvertTarget(n);
		return a.cartesian ? a.cartesian.dataToPoint(r) : a.axis ? a.axis.toGlobalCoord(a.axis.dataToCoord(r)) : null;
	}, t.prototype.convertFromPixel = function(t, n, r) {
		var a = this._findConvertTarget(n);
		return a.cartesian ? a.cartesian.pointToData(r) : a.axis ? a.axis.coordToData(a.axis.toLocalCoord(r)) : null;
	}, t.prototype._findConvertTarget = function(t) {
		var n = t.seriesModel, r = t.xAxisModel || n && n.getReferringComponents("xAxis", SINGLE_REFERRING).models[0], a = t.yAxisModel || n && n.getReferringComponents("yAxis", SINGLE_REFERRING).models[0], o = t.gridModel, s = this._coordsList, c, l;
		return n ? (c = n.coordinateSystem, indexOf(s, c) < 0 && (c = null)) : r && a ? c = this.getCartesian(r.componentIndex, a.componentIndex) : r ? l = this.getAxis("x", r.componentIndex) : a ? l = this.getAxis("y", a.componentIndex) : o && o.coordinateSystem === this && (c = this._coordsList[0]), {
			cartesian: c,
			axis: l
		};
	}, t.prototype.containPoint = function(t) {
		var n = this._coordsList[0];
		if (n) return n.containPoint(t);
	}, t.prototype._initCartesian = function(t, n, r) {
		var a = this, o = this, s = {
			left: !1,
			right: !1,
			top: !1,
			bottom: !1
		}, c = {
			x: {},
			y: {}
		}, l = {
			x: 0,
			y: 0
		};
		if (n.eachComponent("xAxis", u("x"), this), n.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
			this._axesMap = {}, this._axesList = [];
			return;
		}
		this._axesMap = c, each(c.x, function(n, r) {
			each(c.y, function(o, s) {
				var c = "x" + r + "y" + s, l = new Cartesian2D_default(c);
				l.master = a, l.model = t, a._coordsMap[c] = l, a._coordsList.push(l), l.addAxis(n), l.addAxis(o);
			});
		});
		function u(n) {
			return function(r, a) {
				if (isAxisUsedInTheGrid(r, t)) {
					var u = r.get("position");
					n === "x" ? u !== "top" && u !== "bottom" && (u = s.bottom ? "top" : "bottom") : u !== "left" && u !== "right" && (u = s.left ? "right" : "left"), s[u] = !0;
					var d = new Axis2D_default(n, createScaleByModel$1(r), [0, 0], r.get("type"), u);
					d.onBand = d.type === "category" && r.get("boundaryGap"), d.inverse = r.get("inverse"), r.axis = d, d.model = r, d.grid = o, d.index = a, o._axesList.push(d), c[n][a] = d, l[n]++;
				}
			};
		}
	}, t.prototype._updateScale = function(t, n) {
		each(this._axesList, function(t) {
			if (t.scale.setExtent(Infinity, -Infinity), t.type === "category") {
				var n = t.model.get("categorySortInfo");
				t.scale.setSortInfo(n);
			}
		}), t.eachSeries(function(t) {
			if (isCartesian2DSeries(t)) {
				var a = findAxisModels(t), o = a.xAxisModel, s = a.yAxisModel;
				if (!isAxisUsedInTheGrid(o, n) || !isAxisUsedInTheGrid(s, n)) return;
				var c = this.getCartesian(o.componentIndex, s.componentIndex), l = t.getData(), u = c.getAxis("x"), d = c.getAxis("y");
				r(l, u), r(l, d);
			}
		}, this);
		function r(t, n) {
			each(getDataDimensionsOnAxis(t, n.dim), function(r) {
				n.scale.unionExtentFromData(t, r);
			});
		}
	}, t.prototype.getTooltipAxes = function(t) {
		var n = [], r = [];
		return each(this.getCartesians(), function(a) {
			var o = t != null && t !== "auto" ? a.getAxis(t) : a.getBaseAxis(), s = a.getOtherAxis(o);
			indexOf(n, o) < 0 && n.push(o), indexOf(r, s) < 0 && r.push(s);
		}), {
			baseAxes: n,
			otherAxes: r
		};
	}, t.create = function(n, r) {
		var a = [];
		return n.eachComponent("grid", function(o, s) {
			var c = new t(o, n, r);
			c.name = "grid_" + s, c.resize(o, r, !0), o.coordinateSystem = c, a.push(c);
		}), n.eachSeries(function(t) {
			if (isCartesian2DSeries(t)) {
				var n = findAxisModels(t), r = n.xAxisModel, a = n.yAxisModel, o = r.getCoordSysModel();
				if (process$1.env.NODE_ENV !== "production") {
					if (!o) throw Error("Grid \"" + retrieve3(r.get("gridIndex"), r.get("gridId"), 0) + "\" not found");
					if (r.getCoordSysModel() !== a.getCoordSysModel()) throw Error("xAxis and yAxis must use the same grid");
				}
				t.coordinateSystem = o.coordinateSystem.getCartesian(r.componentIndex, a.componentIndex);
			}
		}), a;
	}, t.dimensions = cartesian2DDimensions, t;
}();
function isAxisUsedInTheGrid(t, n) {
	return t.getCoordSysModel() === n;
}
function fixAxisOnZero(t, n, r, a) {
	r.getAxesOnZeroOf = function() {
		return s ? [s] : [];
	};
	var o = t[n], s, c = r.model, l = c.get(["axisLine", "onZero"]), u = c.get(["axisLine", "onZeroAxisIndex"]);
	if (!l) return;
	if (u != null) canOnZeroToAxis(o[u]) && (s = o[u]);
	else for (var d in o) if (o.hasOwnProperty(d) && canOnZeroToAxis(o[d]) && !a[f(o[d])]) {
		s = o[d];
		break;
	}
	s && (a[f(s)] = !0);
	function f(t) {
		return t.dim + "_" + t.index;
	}
}
function canOnZeroToAxis(t) {
	return t && t.type !== "category" && t.type !== "time" && ifAxisCrossZero(t);
}
function updateAxisTransform(t, n) {
	var r = t.getExtent(), a = r[0] + r[1];
	t.toGlobalCoord = t.dim === "x" ? function(t) {
		return t + n;
	} : function(t) {
		return a - t + n;
	}, t.toLocalCoord = t.dim === "x" ? function(t) {
		return t - n;
	} : function(t) {
		return a - t + n;
	};
}
var Grid_default = Grid, PI$3 = Math.PI, AxisBuilder = function() {
	function t(t, n) {
		this.group = new Group_default(), this.opt = n, this.axisModel = t, defaults(n, {
			labelOffset: 0,
			nameDirection: 1,
			tickDirection: 1,
			labelDirection: 1,
			silent: !0,
			handleAutoShown: function() {
				return !0;
			}
		});
		var r = new Group_default({
			x: n.position[0],
			y: n.position[1],
			rotation: n.rotation
		});
		r.updateTransform(), this._transformGroup = r;
	}
	return t.prototype.hasBuilder = function(t) {
		return !!builders[t];
	}, t.prototype.add = function(t) {
		builders[t](this.opt, this.axisModel, this.group, this._transformGroup);
	}, t.prototype.getGroup = function() {
		return this.group;
	}, t.innerTextLayout = function(t, n, r) {
		var a = remRadian(n - t), o, s;
		return isRadianAroundZero(a) ? (s = r > 0 ? "top" : "bottom", o = "center") : isRadianAroundZero(a - PI$3) ? (s = r > 0 ? "bottom" : "top", o = "center") : (s = "middle", o = a > 0 && a < PI$3 ? r > 0 ? "right" : "left" : r > 0 ? "left" : "right"), {
			rotation: a,
			textAlign: o,
			textVerticalAlign: s
		};
	}, t.makeAxisEventDataBase = function(t) {
		var n = {
			componentType: t.mainType,
			componentIndex: t.componentIndex
		};
		return n[t.mainType + "Index"] = t.componentIndex, n;
	}, t.isLabelSilent = function(t) {
		var n = t.get("tooltip");
		return t.get("silent") || !(t.get("triggerEvent") || n && n.show);
	}, t;
}(), builders = {
	axisLine: function(t, n, r, a) {
		var o = n.get(["axisLine", "show"]);
		if (o === "auto" && t.handleAutoShown && (o = t.handleAutoShown("axisLine")), o) {
			var s = n.axis.getExtent(), c = a.transform, l = [s[0], 0], u = [s[1], 0], d = l[0] > u[0];
			c && (applyTransform(l, l, c), applyTransform(u, u, c));
			var f = extend({ lineCap: "round" }, n.getModel(["axisLine", "lineStyle"]).getLineStyle()), p = new Line_default$1({
				shape: {
					x1: l[0],
					y1: l[1],
					x2: u[0],
					y2: u[1]
				},
				style: f,
				strokeContainThreshold: t.strokeContainThreshold || 5,
				silent: !0,
				z2: 1
			});
			subPixelOptimizeLine(p.shape, p.style.lineWidth), p.anid = "line", r.add(p);
			var h = n.get(["axisLine", "symbol"]);
			if (h != null) {
				var g = n.get(["axisLine", "symbolSize"]);
				isString(h) && (h = [h, h]), (isString(g) || isNumber(g)) && (g = [g, g]);
				var _ = normalizeSymbolOffset(n.get(["axisLine", "symbolOffset"]) || 0, g), v = g[0], y = g[1];
				each([{
					rotate: t.rotation + Math.PI / 2,
					offset: _[0],
					r: 0
				}, {
					rotate: t.rotation - Math.PI / 2,
					offset: _[1],
					r: Math.sqrt((l[0] - u[0]) * (l[0] - u[0]) + (l[1] - u[1]) * (l[1] - u[1]))
				}], function(n, a) {
					if (h[a] !== "none" && h[a] != null) {
						var o = createSymbol(h[a], -v / 2, -y / 2, v, y, f.stroke, !0), s = n.r + n.offset, c = d ? u : l;
						o.attr({
							rotation: n.rotate,
							x: c[0] + s * Math.cos(t.rotation),
							y: c[1] - s * Math.sin(t.rotation),
							silent: !0,
							z2: 11
						}), r.add(o);
					}
				});
			}
		}
	},
	axisTickLabel: function(t, n, r, a) {
		var o = buildAxisMajorTicks(r, a, n, t), s = buildAxisLabel(r, a, n, t);
		fixMinMaxLabelShow(n, s, o), buildAxisMinorTicks(r, a, n, t.tickDirection), n.get(["axisLabel", "hideOverlap"]) && hideOverlap(prepareLayoutList(map(s, function(t) {
			return {
				label: t,
				priority: t.z2,
				defaultAttr: { ignore: t.ignore }
			};
		})));
	},
	axisName: function(t, n, r, a) {
		var o = retrieve(t.axisName, n.get("name"));
		if (o) {
			var s = n.get("nameLocation"), c = t.nameDirection, l = n.getModel("nameTextStyle"), u = n.get("nameGap") || 0, d = n.axis.getExtent(), f = d[0] > d[1] ? -1 : 1, p = [s === "start" ? d[0] - f * u : s === "end" ? d[1] + f * u : (d[0] + d[1]) / 2, isNameLocationCenter(s) ? t.labelOffset + c * u : 0], h, g = n.get("nameRotate");
			g != null && (g = g * PI$3 / 180);
			var _;
			isNameLocationCenter(s) ? h = AxisBuilder.innerTextLayout(t.rotation, g ?? t.rotation, c) : (h = endTextLayout(t.rotation, s, g || 0, d), _ = t.axisNameAvailableWidth, _ != null && (_ = Math.abs(_ / Math.sin(h.rotation)), !isFinite(_) && (_ = null)));
			var v = l.getFont(), y = n.get("nameTruncate", !0) || {}, b = y.ellipsis, x = retrieve(t.nameTruncateMaxWidth, y.maxWidth, _), S = new Text_default({
				x: p[0],
				y: p[1],
				rotation: h.rotation,
				silent: AxisBuilder.isLabelSilent(n),
				style: createTextStyle(l, {
					text: o,
					font: v,
					overflow: "truncate",
					width: x,
					ellipsis: b,
					fill: l.getTextColor() || n.get([
						"axisLine",
						"lineStyle",
						"color"
					]),
					align: l.get("align") || h.textAlign,
					verticalAlign: l.get("verticalAlign") || h.textVerticalAlign
				}),
				z2: 1
			});
			if (setTooltipConfig({
				el: S,
				componentModel: n,
				itemName: o
			}), S.__fullText = o, S.anid = "name", n.get("triggerEvent")) {
				var C = AxisBuilder.makeAxisEventDataBase(n);
				C.targetType = "axisName", C.name = o, getECData(S).eventData = C;
			}
			a.add(S), S.updateTransform(), r.add(S), S.decomposeTransform();
		}
	}
};
function endTextLayout(t, n, r, a) {
	var o = remRadian(r - t), s, c, l = a[0] > a[1], u = n === "start" && !l || n !== "start" && l;
	return isRadianAroundZero(o - PI$3 / 2) ? (c = u ? "bottom" : "top", s = "center") : isRadianAroundZero(o - PI$3 * 1.5) ? (c = u ? "top" : "bottom", s = "center") : (c = "middle", s = o < PI$3 * 1.5 && o > PI$3 / 2 ? u ? "left" : "right" : u ? "right" : "left"), {
		rotation: o,
		textAlign: s,
		textVerticalAlign: c
	};
}
function fixMinMaxLabelShow(t, n, r) {
	if (!shouldShowAllLabels(t.axis)) {
		var a = t.get(["axisLabel", "showMinLabel"]), o = t.get(["axisLabel", "showMaxLabel"]);
		n ||= [], r ||= [];
		var s = n[0], c = n[1], l = n[n.length - 1], u = n[n.length - 2], d = r[0], f = r[1], p = r[r.length - 1], h = r[r.length - 2];
		a === !1 ? (ignoreEl(s), ignoreEl(d)) : isTwoLabelOverlapped(s, c) && (a ? (ignoreEl(c), ignoreEl(f)) : (ignoreEl(s), ignoreEl(d))), o === !1 ? (ignoreEl(l), ignoreEl(p)) : isTwoLabelOverlapped(u, l) && (o ? (ignoreEl(u), ignoreEl(h)) : (ignoreEl(l), ignoreEl(p)));
	}
}
function ignoreEl(t) {
	t && (t.ignore = !0);
}
function isTwoLabelOverlapped(t, n) {
	var r = t && t.getBoundingRect().clone(), a = n && n.getBoundingRect().clone();
	if (!(!r || !a)) {
		var o = identity([]);
		return rotate(o, o, -t.rotation), r.applyTransform(mul([], o, t.getLocalTransform())), a.applyTransform(mul([], o, n.getLocalTransform())), r.intersect(a);
	}
}
function isNameLocationCenter(t) {
	return t === "middle" || t === "center";
}
function createTicks(t, n, r, a, o) {
	for (var s = [], c = [], l = [], u = 0; u < t.length; u++) {
		var d = t[u].coord;
		c[0] = d, c[1] = 0, l[0] = d, l[1] = r, n && (applyTransform(c, c, n), applyTransform(l, l, n));
		var f = new Line_default$1({
			shape: {
				x1: c[0],
				y1: c[1],
				x2: l[0],
				y2: l[1]
			},
			style: a,
			z2: 2,
			autoBatch: !0,
			silent: !0
		});
		subPixelOptimizeLine(f.shape, f.style.lineWidth), f.anid = o + "_" + t[u].tickValue, s.push(f);
	}
	return s;
}
function buildAxisMajorTicks(t, n, r, a) {
	var o = r.axis, s = r.getModel("axisTick"), c = s.get("show");
	if (c === "auto" && a.handleAutoShown && (c = a.handleAutoShown("axisTick")), !(!c || o.scale.isBlank())) {
		for (var l = s.getModel("lineStyle"), u = a.tickDirection * s.get("length"), d = createTicks(o.getTicksCoords(), n.transform, u, defaults(l.getLineStyle(), { stroke: r.get([
			"axisLine",
			"lineStyle",
			"color"
		]) }), "ticks"), f = 0; f < d.length; f++) t.add(d[f]);
		return d;
	}
}
function buildAxisMinorTicks(t, n, r, a) {
	var o = r.axis, s = r.getModel("minorTick");
	if (!(!s.get("show") || o.scale.isBlank())) {
		var c = o.getMinorTicksCoords();
		if (c.length) for (var l = s.getModel("lineStyle"), u = a * s.get("length"), d = defaults(l.getLineStyle(), defaults(r.getModel("axisTick").getLineStyle(), { stroke: r.get([
			"axisLine",
			"lineStyle",
			"color"
		]) })), f = 0; f < c.length; f++) for (var p = createTicks(c[f], n.transform, u, d, "minorticks_" + f), h = 0; h < p.length; h++) t.add(p[h]);
	}
}
function buildAxisLabel(t, n, r, a) {
	var o = r.axis;
	if (!(!retrieve(a.axisLabelShow, r.get(["axisLabel", "show"])) || o.scale.isBlank())) {
		var s = r.getModel("axisLabel"), c = s.get("margin"), l = o.getViewLabels(), u = (retrieve(a.labelRotate, s.get("rotate")) || 0) * PI$3 / 180, d = AxisBuilder.innerTextLayout(a.rotation, u, a.labelDirection), f = r.getCategories && r.getCategories(!0), p = [], h = AxisBuilder.isLabelSilent(r), g = r.get("triggerEvent");
		return each(l, function(u, _) {
			var v = o.scale.type === "ordinal" ? o.scale.getRawOrdinalNumber(u.tickValue) : u.tickValue, y = u.formattedLabel, b = u.rawLabel, x = s;
			if (f && f[v]) {
				var S = f[v];
				isObject(S) && S.textStyle && (x = new Model_default(S.textStyle, s, r.ecModel));
			}
			var C = x.getTextColor() || r.get([
				"axisLine",
				"lineStyle",
				"color"
			]), w = o.dataToCoord(v), T = x.getShallow("align", !0) || d.textAlign, E = retrieve2(x.getShallow("alignMinLabel", !0), T), D = retrieve2(x.getShallow("alignMaxLabel", !0), T), O = x.getShallow("verticalAlign", !0) || x.getShallow("baseline", !0) || d.textVerticalAlign, A = retrieve2(x.getShallow("verticalAlignMinLabel", !0), O), j = retrieve2(x.getShallow("verticalAlignMaxLabel", !0), O), M = new Text_default({
				x: w,
				y: a.labelOffset + a.labelDirection * c,
				rotation: d.rotation,
				silent: h,
				z2: 10 + (u.level || 0),
				style: createTextStyle(x, {
					text: y,
					align: _ === 0 ? E : _ === l.length - 1 ? D : T,
					verticalAlign: _ === 0 ? A : _ === l.length - 1 ? j : O,
					fill: isFunction(C) ? C(o.type === "category" ? b : o.type === "value" ? v + "" : v, _) : C
				})
			});
			if (M.anid = "label_" + v, setTooltipConfig({
				el: M,
				componentModel: r,
				itemName: y,
				formatterParamsExtra: {
					isTruncated: function() {
						return M.isTruncated;
					},
					value: b,
					tickIndex: _
				}
			}), g) {
				var N = AxisBuilder.makeAxisEventDataBase(r);
				N.targetType = "axisLabel", N.value = b, N.tickIndex = _, o.type === "category" && (N.dataIndex = v), getECData(M).eventData = N;
			}
			n.add(M), M.updateTransform(), p.push(M), t.add(M), M.decomposeTransform();
		}), p;
	}
}
var AxisBuilder_default = AxisBuilder;
function collect(t, n) {
	var r = {
		axesInfo: {},
		seriesInvolved: !1,
		coordSysAxesInfo: {},
		coordSysMap: {}
	};
	return collectAxesInfo(r, t, n), r.seriesInvolved && collectSeriesInfo(r, t), r;
}
function collectAxesInfo(t, n, r) {
	var a = n.getComponent("tooltip"), o = n.getComponent("axisPointer"), s = o.get("link", !0) || [], c = [];
	each(r.getCoordinateSystems(), function(r) {
		if (!r.axisPointerEnabled) return;
		var l = makeKey(r.model), u = t.coordSysAxesInfo[l] = {};
		t.coordSysMap[l] = r;
		var d = r.model.getModel("tooltip", a);
		if (each(r.getAxes(), curry(g, !1, null)), r.getTooltipAxes && a && d.get("show")) {
			var f = d.get("trigger") === "axis", p = d.get(["axisPointer", "type"]) === "cross", h = r.getTooltipAxes(d.get(["axisPointer", "axis"]));
			(f || p) && each(h.baseAxes, curry(g, p ? "cross" : !0, f)), p && each(h.otherAxes, curry(g, "cross", !1));
		}
		function g(a, l, f) {
			var p = f.model.getModel("axisPointer", o), h = p.get("show");
			if (!(!h || h === "auto" && !a && !isHandleTrigger(p))) {
				l ??= p.get("triggerTooltip"), p = a ? makeAxisPointerModel(f, d, o, n, a, l) : p;
				var g = p.get("snap"), _ = p.get("triggerEmphasis"), v = makeKey(f.model), y = l || g || f.type === "category", b = t.axesInfo[v] = {
					key: v,
					axis: f,
					coordSys: r,
					axisPointerModel: p,
					triggerTooltip: l,
					triggerEmphasis: _,
					involveSeries: y,
					snap: g,
					useHandle: isHandleTrigger(p),
					seriesModels: [],
					linkGroup: null
				};
				u[v] = b, t.seriesInvolved = t.seriesInvolved || y;
				var x = getLinkGroupIndex(s, f);
				if (x != null) {
					var S = c[x] || (c[x] = { axesInfo: {} });
					S.axesInfo[v] = b, S.mapper = s[x].mapper, b.linkGroup = S;
				}
			}
		}
	});
}
function makeAxisPointerModel(t, n, r, a, o, s) {
	var c = n.getModel("axisPointer"), l = [
		"type",
		"snap",
		"lineStyle",
		"shadowStyle",
		"label",
		"animation",
		"animationDurationUpdate",
		"animationEasingUpdate",
		"z"
	], u = {};
	each(l, function(t) {
		u[t] = clone$1(c.get(t));
	}), u.snap = t.type !== "category" && !!s, c.get("type") === "cross" && (u.type = "line");
	var d = u.label ||= {};
	if (d.show ??= !1, o === "cross" && (d.show = c.get(["label", "show"]) ?? !0, !s)) {
		var f = u.lineStyle = c.get("crossStyle");
		f && defaults(d, f.textStyle);
	}
	return t.model.getModel("axisPointer", new Model_default(u, r, a));
}
function collectSeriesInfo(t, n) {
	n.eachSeries(function(n) {
		var r = n.coordinateSystem, a = n.get(["tooltip", "trigger"], !0), o = n.get(["tooltip", "show"], !0);
		!r || a === "none" || a === !1 || a === "item" || o === !1 || n.get(["axisPointer", "show"], !0) === !1 || each(t.coordSysAxesInfo[makeKey(r.model)], function(t) {
			var a = t.axis;
			r.getAxis(a.dim) === a && (t.seriesModels.push(n), t.seriesDataCount ??= 0, t.seriesDataCount += n.getData().count());
		});
	});
}
function getLinkGroupIndex(t, n) {
	for (var r = n.model, a = n.dim, o = 0; o < t.length; o++) {
		var s = t[o] || {};
		if (checkPropInLink(s[a + "AxisId"], r.id) || checkPropInLink(s[a + "AxisIndex"], r.componentIndex) || checkPropInLink(s[a + "AxisName"], r.name)) return o;
	}
}
function checkPropInLink(t, n) {
	return t === "all" || isArray(t) && indexOf(t, n) >= 0 || t === n;
}
function fixValue(t) {
	var n = getAxisInfo$1(t);
	if (n) {
		var r = n.axisPointerModel, a = n.axis.scale, o = r.option, s = r.get("status"), c = r.get("value");
		c != null && (c = a.parse(c));
		var l = isHandleTrigger(r);
		s ?? (o.status = l ? "show" : "hide");
		var u = a.getExtent().slice();
		u[0] > u[1] && u.reverse(), (c == null || c > u[1]) && (c = u[1]), c < u[0] && (c = u[0]), o.value = c, l && (o.status = n.axis.scale.isBlank() ? "hide" : "show");
	}
}
function getAxisInfo$1(t) {
	var n = (t.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
	return n && n.axesInfo[makeKey(t)];
}
function getAxisPointerModel(t) {
	var n = getAxisInfo$1(t);
	return n && n.axisPointerModel;
}
function isHandleTrigger(t) {
	return !!t.get(["handle", "show"]);
}
function makeKey(t) {
	return t.type + "||" + t.id;
}
init_dist$2();
var axisPointerClazz = {}, AxisView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(n, r, a, o) {
		this.axisPointerClass && fixValue(n), t.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(n, a, !0);
	}, n.prototype.updateAxisPointer = function(t, n, r, a) {
		this._doUpdateAxisPointerClass(t, r, !1);
	}, n.prototype.remove = function(t, n) {
		var r = this._axisPointer;
		r && r.remove(n);
	}, n.prototype.dispose = function(n, r) {
		this._disposeAxisPointer(r), t.prototype.dispose.apply(this, arguments);
	}, n.prototype._doUpdateAxisPointerClass = function(t, r, a) {
		var o = n.getAxisPointerClass(this.axisPointerClass);
		if (o) {
			var s = getAxisPointerModel(t);
			s ? (this._axisPointer ||= new o()).render(t, s, r, a) : this._disposeAxisPointer(r);
		}
	}, n.prototype._disposeAxisPointer = function(t) {
		this._axisPointer && this._axisPointer.dispose(t), this._axisPointer = null;
	}, n.registerAxisPointerClass = function(t, n) {
		if (process$1.env.NODE_ENV !== "production" && axisPointerClazz[t]) throw Error("axisPointer " + t + " exists");
		axisPointerClazz[t] = n;
	}, n.getAxisPointerClass = function(t) {
		return t && axisPointerClazz[t];
	}, n.type = "axis", n;
}(Component_default$1), inner$15 = makeInner();
function rectCoordAxisBuildSplitArea(t, n, r, a) {
	var o = r.axis;
	if (!o.scale.isBlank()) {
		var s = r.getModel("splitArea"), c = s.getModel("areaStyle"), l = c.get("color"), u = a.coordinateSystem.getRect(), d = o.getTicksCoords({
			tickModel: s,
			clamp: !0
		});
		if (d.length) {
			var f = l.length, p = inner$15(t).splitAreaColors, h = createHashMap(), g = 0;
			if (p) for (var _ = 0; _ < d.length; _++) {
				var v = p.get(d[_].tickValue);
				if (v != null) {
					g = (v + (f - 1) * _) % f;
					break;
				}
			}
			var y = o.toGlobalCoord(d[0].coord), b = c.getAreaStyle();
			l = isArray(l) ? l : [l];
			for (var _ = 1; _ < d.length; _++) {
				var x = o.toGlobalCoord(d[_].coord), S = void 0, C = void 0, w = void 0, T = void 0;
				o.isHorizontal() ? (S = y, C = u.y, w = x - S, T = u.height, y = S + w) : (S = u.x, C = y, w = u.width, T = x - C, y = C + T);
				var E = d[_ - 1].tickValue;
				E != null && h.set(E, g), n.add(new Rect_default({
					anid: E == null ? null : "area_" + E,
					shape: {
						x: S,
						y: C,
						width: w,
						height: T
					},
					style: defaults({ fill: l[g] }, b),
					autoBatch: !0,
					silent: !0
				})), g = (g + 1) % f;
			}
			inner$15(t).splitAreaColors = h;
		}
	}
}
function rectCoordAxisHandleRemove(t) {
	inner$15(t).splitAreaColors = null;
}
var axisBuilderAttrs$3 = [
	"axisLine",
	"axisTickLabel",
	"axisName"
], selfBuilderAttrs$2 = [
	"splitArea",
	"splitLine",
	"minorSplitLine"
], CartesianAxisView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.axisPointerClass = "CartesianAxisPointer", r;
	}
	return n.prototype.render = function(n, r, a, o) {
		this.group.removeAll();
		var s = this._axisGroup;
		if (this._axisGroup = new Group_default(), this.group.add(this._axisGroup), n.get("show")) {
			var c = n.getCoordSysModel(), l = new AxisBuilder_default(n, extend({ handleAutoShown: function(t) {
				for (var r = c.coordinateSystem.getCartesians(), a = 0; a < r.length; a++) if (isIntervalOrLogScale(r[a].getOtherAxis(n.axis).scale)) return !0;
				return !1;
			} }, layout$3(c, n)));
			each(axisBuilderAttrs$3, l.add, l), this._axisGroup.add(l.getGroup()), each(selfBuilderAttrs$2, function(t) {
				n.get([t, "show"]) && axisElementBuilders$2[t](this, this._axisGroup, n, c);
			}, this), o && o.type === "changeAxisOrder" && o.isInitSort || groupTransition(s, this._axisGroup, n), t.prototype.render.call(this, n, r, a, o);
		}
	}, n.prototype.remove = function() {
		rectCoordAxisHandleRemove(this);
	}, n.type = "cartesianAxis", n;
}(AxisView_default), axisElementBuilders$2 = {
	splitLine: function(t, n, r, a) {
		var o = r.axis;
		if (!o.scale.isBlank()) {
			var s = r.getModel("splitLine"), c = s.getModel("lineStyle"), l = c.get("color"), u = s.get("showMinLine") !== !1, d = s.get("showMaxLine") !== !1;
			l = isArray(l) ? l : [l];
			for (var f = a.coordinateSystem.getRect(), p = o.isHorizontal(), h = 0, g = o.getTicksCoords({ tickModel: s }), _ = [], v = [], y = c.getLineStyle(), b = 0; b < g.length; b++) {
				var x = o.toGlobalCoord(g[b].coord);
				if (!(b === 0 && !u || b === g.length - 1 && !d)) {
					var S = g[b].tickValue;
					p ? (_[0] = x, _[1] = f.y, v[0] = x, v[1] = f.y + f.height) : (_[0] = f.x, _[1] = x, v[0] = f.x + f.width, v[1] = x);
					var C = h++ % l.length, w = new Line_default$1({
						anid: S == null ? null : "line_" + S,
						autoBatch: !0,
						shape: {
							x1: _[0],
							y1: _[1],
							x2: v[0],
							y2: v[1]
						},
						style: defaults({ stroke: l[C] }, y),
						silent: !0
					});
					subPixelOptimizeLine(w.shape, y.lineWidth), n.add(w);
				}
			}
		}
	},
	minorSplitLine: function(t, n, r, a) {
		var o = r.axis, s = r.getModel("minorSplitLine").getModel("lineStyle"), c = a.coordinateSystem.getRect(), l = o.isHorizontal(), u = o.getMinorTicksCoords();
		if (u.length) for (var d = [], f = [], p = s.getLineStyle(), h = 0; h < u.length; h++) for (var g = 0; g < u[h].length; g++) {
			var _ = o.toGlobalCoord(u[h][g].coord);
			l ? (d[0] = _, d[1] = c.y, f[0] = _, f[1] = c.y + c.height) : (d[0] = c.x, d[1] = _, f[0] = c.x + c.width, f[1] = _);
			var v = new Line_default$1({
				anid: "minor_line_" + u[h][g].tickValue,
				autoBatch: !0,
				shape: {
					x1: d[0],
					y1: d[1],
					x2: f[0],
					y2: f[1]
				},
				style: p,
				silent: !0
			});
			subPixelOptimizeLine(v.shape, p.lineWidth), n.add(v);
		}
	},
	splitArea: function(t, n, r, a) {
		rectCoordAxisBuildSplitArea(t, n, r, a);
	}
}, CartesianXAxisView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.type = "xAxis", n;
}(CartesianAxisView), CartesianYAxisView = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n.type = CartesianXAxisView.type, n;
	}
	return n.type = "yAxis", n;
}(CartesianAxisView), GridView = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n.type = "grid", n;
	}
	return n.prototype.render = function(t, n) {
		this.group.removeAll(), t.get("show") && this.group.add(new Rect_default({
			shape: t.coordinateSystem.getRect(),
			style: defaults({ fill: t.get("backgroundColor") }, t.getItemStyle()),
			silent: !0,
			z2: -1
		}));
	}, n.type = "grid", n;
}(Component_default$1), extraOption = { offset: 0 };
function install$53(t) {
	t.registerComponentView(GridView), t.registerComponentModel(GridModel_default), t.registerCoordinateSystem("cartesian2d", Grid_default), axisModelCreator(t, "x", CartesianAxisModel, extraOption), axisModelCreator(t, "y", CartesianAxisModel, extraOption), t.registerComponentView(CartesianXAxisView), t.registerComponentView(CartesianYAxisView), t.registerPreprocessor(function(t) {
		t.xAxis && t.yAxis && !t.grid && (t.grid = {});
	});
}
function install$5(t) {
	use(install$53), t.registerSeriesModel(ScatterSeries_default), t.registerChartView(ScatterView_default), t.registerLayout(pointsLayout("scatter"));
}
function radarLayout(t) {
	t.eachSeriesByType("radar", function(t) {
		var n = t.getData(), r = [], a = t.coordinateSystem;
		if (a) {
			var o = a.getIndicatorAxes();
			each(o, function(t, s) {
				n.each(n.mapDimension(o[s].dim), function(t, n) {
					r[n] = r[n] || [];
					var o = a.dataToPoint(t, s);
					r[n][s] = isValidPoint(o) ? o : getValueMissingPoint(a);
				});
			}), n.each(function(t) {
				var o = find(r[t], function(t) {
					return isValidPoint(t);
				}) || getValueMissingPoint(a);
				r[t].push(o.slice()), n.setItemLayout(t, r[t]);
			});
		}
	});
}
function isValidPoint(t) {
	return !isNaN(t[0]) && !isNaN(t[1]);
}
function getValueMissingPoint(t) {
	return [t.cx, t.cy];
}
function radarBackwardCompat(t) {
	var n = t.polar;
	if (n) {
		isArray(n) || (n = [n]);
		var r = [];
		each(n, function(n, a) {
			n.indicator ? (n.type && !n.shape && (n.shape = n.type), t.radar = t.radar || [], isArray(t.radar) || (t.radar = [t.radar]), t.radar.push(n)) : r.push(n);
		}), t.polar = r;
	}
	each(t.series, function(t) {
		t && t.type === "radar" && t.polarIndex && (t.radarIndex = t.polarIndex);
	});
}
var RadarView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r) {
		var a = t.coordinateSystem, o = this.group, s = t.getData(), c = this._data;
		function l(t, n) {
			var r = t.getItemVisual(n, "symbol") || "circle";
			if (r !== "none") {
				var a = normalizeSymbolSize(t.getItemVisual(n, "symbolSize")), o = createSymbol(r, -1, -1, 2, 2), s = t.getItemVisual(n, "symbolRotate") || 0;
				return o.attr({
					style: { strokeNoScale: !0 },
					z2: 100,
					scaleX: a[0] / 2,
					scaleY: a[1] / 2,
					rotation: s * Math.PI / 180 || 0
				}), o;
			}
		}
		function u(n, r, a, o, s, c) {
			a.removeAll();
			for (var u = 0; u < r.length - 1; u++) {
				var d = l(o, s);
				d && (d.__dimIdx = u, n[u] ? (d.setPosition(n[u]), graphic_exports$1[c ? "initProps" : "updateProps"](d, {
					x: r[u][0],
					y: r[u][1]
				}, t, s)) : d.setPosition(r[u]), a.add(d));
			}
		}
		function d(t) {
			return map(t, function(t) {
				return [a.cx, a.cy];
			});
		}
		s.diff(c).add(function(n) {
			var r = s.getItemLayout(n);
			if (r) {
				var a = new Polygon_default(), o = new Polyline_default$1(), c = { shape: { points: r } };
				a.shape.points = d(r), o.shape.points = d(r), initProps(a, c, t, n), initProps(o, c, t, n);
				var l = new Group_default(), f = new Group_default();
				l.add(o), l.add(a), l.add(f), u(o.shape.points, r, f, s, n, !0), s.setItemGraphicEl(n, l);
			}
		}).update(function(n, r) {
			var a = c.getItemGraphicEl(r), o = a.childAt(0), l = a.childAt(1), d = a.childAt(2), f = { shape: { points: s.getItemLayout(n) } };
			f.shape.points && (u(o.shape.points, f.shape.points, d, s, n, !1), saveOldStyle(l), saveOldStyle(o), updateProps(o, f, t), updateProps(l, f, t), s.setItemGraphicEl(n, a));
		}).remove(function(t) {
			o.remove(c.getItemGraphicEl(t));
		}).execute(), s.eachItemGraphicEl(function(t, n) {
			var r = s.getItemModel(n), a = t.childAt(0), c = t.childAt(1), l = t.childAt(2), u = s.getItemVisual(n, "style"), d = u.fill;
			o.add(t), a.useStyle(defaults(r.getModel("lineStyle").getLineStyle(), {
				fill: "none",
				stroke: d
			})), setStatesStylesFromModel(a, r, "lineStyle"), setStatesStylesFromModel(c, r, "areaStyle");
			var f = r.getModel("areaStyle"), p = f.isEmpty() && f.parentModel.isEmpty();
			c.ignore = p, each([
				"emphasis",
				"select",
				"blur"
			], function(t) {
				var n = r.getModel([t, "areaStyle"]), a = n.isEmpty() && n.parentModel.isEmpty();
				c.ensureState(t).ignore = a && p;
			}), c.useStyle(defaults(f.getAreaStyle(), {
				fill: d,
				opacity: .7,
				decal: u.decal
			}));
			var h = r.getModel("emphasis"), g = h.getModel("itemStyle").getItemStyle();
			l.eachChild(function(t) {
				if (t instanceof Image_default) {
					var a = t.style;
					t.useStyle(extend({
						image: a.image,
						x: a.x,
						y: a.y,
						width: a.width,
						height: a.height
					}, u));
				} else t.useStyle(u), t.setColor(d), t.style.strokeNoScale = !0;
				var o = t.ensureState("emphasis");
				o.style = clone$1(g);
				var c = s.getStore().get(s.getDimensionIndex(t.__dimIdx), n);
				(c == null || isNaN(c)) && (c = ""), setLabelStyle(t, getLabelStatesModels(r), {
					labelFetcher: s.hostModel,
					labelDataIndex: n,
					labelDimIndex: t.__dimIdx,
					defaultText: c,
					inheritColor: d,
					defaultOpacity: u.opacity
				});
			}), toggleHoverEmphasis(t, h.get("focus"), h.get("blurScope"), h.get("disabled"));
		}), this._data = s;
	}, n.prototype.remove = function() {
		this.group.removeAll(), this._data = null;
	}, n.type = "radar", n;
}(Chart_default), RadarSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.hasSymbolVisual = !0, r;
	}
	return n.prototype.init = function(n) {
		t.prototype.init.apply(this, arguments), this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
	}, n.prototype.getInitialData = function(t, n) {
		return createSeriesDataSimply(this, {
			generateCoord: "indicator_",
			generateCoordCount: Infinity
		});
	}, n.prototype.formatTooltip = function(t, n, r) {
		var a = this.getData(), o = this.coordinateSystem.getIndicatorAxes(), s = this.getData().getName(t), c = s === "" ? this.name : s, l = retrieveVisualColorForTooltipMarker(this, t);
		return createTooltipMarkup("section", {
			header: c,
			sortBlocks: !0,
			blocks: map(o, function(n) {
				var r = a.get(a.mapDimension(n.dim), t);
				return createTooltipMarkup("nameValue", {
					markerType: "subItem",
					markerColor: l,
					name: n.name,
					value: r,
					sortParam: r
				});
			})
		});
	}, n.prototype.getTooltipPosition = function(t) {
		if (t != null) {
			for (var n = this.getData(), r = this.coordinateSystem, a = n.getValues(map(r.dimensions, function(t) {
				return n.mapDimension(t);
			}), t), o = 0, s = a.length; o < s; o++) if (!isNaN(a[o])) {
				var c = r.getIndicatorAxes();
				return r.coordToPoint(c[o].dataToCoord(a[o]), o);
			}
		}
	}, n.type = "series.radar", n.dependencies = ["radar"], n.defaultOption = {
		z: 2,
		colorBy: "data",
		coordinateSystem: "radar",
		legendHoverLink: !0,
		radarIndex: 0,
		lineStyle: {
			width: 2,
			type: "solid",
			join: "round"
		},
		label: { position: "top" },
		symbolSize: 8
	}, n;
}(Series_default), valueAxisDefault = axisDefault_default.value;
function defaultsShow(t, n) {
	return defaults({ show: n }, t);
}
var RadarModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.optionUpdated = function() {
		var t = this.get("boundaryGap"), n = this.get("splitNumber"), r = this.get("scale"), a = this.get("axisLine"), o = this.get("axisTick"), s = this.get("axisLabel"), c = this.get("axisName"), l = this.get(["axisName", "show"]), u = this.get(["axisName", "formatter"]), d = this.get("axisNameGap"), f = this.get("triggerEvent");
		this._indicatorModels = map(this.get("indicator") || [], function(p) {
			p.max != null && p.max > 0 && !p.min ? p.min = 0 : p.min != null && p.min < 0 && !p.max && (p.max = 0);
			var h = c;
			p.color != null && (h = defaults({ color: p.color }, c));
			var g = merge(clone$1(p), {
				boundaryGap: t,
				splitNumber: n,
				scale: r,
				axisLine: a,
				axisTick: o,
				axisLabel: s,
				name: p.text,
				showName: l,
				nameLocation: "end",
				nameGap: d,
				nameTextStyle: h,
				triggerEvent: f
			}, !1);
			if (isString(u)) {
				var _ = g.name;
				g.name = u.replace("{value}", _ ?? "");
			} else isFunction(u) && (g.name = u(g.name, g));
			var v = new Model_default(g, null, this.ecModel);
			return mixin(v, AxisModelCommonMixin.prototype), v.mainType = "radar", v.componentIndex = this.componentIndex, v;
		}, this);
	}, n.prototype.getIndicatorModels = function() {
		return this._indicatorModels;
	}, n.type = "radar", n.defaultOption = {
		z: 0,
		center: ["50%", "50%"],
		radius: "75%",
		startAngle: 90,
		axisName: { show: !0 },
		boundaryGap: [0, 0],
		splitNumber: 5,
		axisNameGap: 15,
		scale: !1,
		shape: "polygon",
		axisLine: merge({ lineStyle: { color: "#bbb" } }, valueAxisDefault.axisLine),
		axisLabel: defaultsShow(valueAxisDefault.axisLabel, !1),
		axisTick: defaultsShow(valueAxisDefault.axisTick, !1),
		splitLine: defaultsShow(valueAxisDefault.splitLine, !0),
		splitArea: defaultsShow(valueAxisDefault.splitArea, !0),
		indicator: []
	}, n;
}(Component_default);
init_dist$2();
var axisBuilderAttrs$2 = [
	"axisLine",
	"axisTickLabel",
	"axisName"
], RadarView_default$1 = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r) {
		this.group.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t);
	}, n.prototype._buildAxes = function(t) {
		var n = t.coordinateSystem;
		each(map(n.getIndicatorAxes(), function(t) {
			var r = t.model.get("showName") ? t.name : "";
			return new AxisBuilder_default(t.model, {
				axisName: r,
				position: [n.cx, n.cy],
				rotation: t.angle,
				labelDirection: -1,
				tickDirection: -1,
				nameDirection: 1
			});
		}), function(t) {
			each(axisBuilderAttrs$2, t.add, t), this.group.add(t.getGroup());
		}, this);
	}, n.prototype._buildSplitLineAndArea = function(t) {
		var n = t.coordinateSystem, r = n.getIndicatorAxes();
		if (!r.length) return;
		var a = t.get("shape"), o = t.getModel("splitLine"), c = t.getModel("splitArea"), l = o.getModel("lineStyle"), u = c.getModel("areaStyle"), d = o.get("show"), f = c.get("show"), p = l.get("color"), h = u.get("color"), g = isArray(p) ? p : [p], _ = isArray(h) ? h : [h], v = [], y = [];
		function b(t, n, r) {
			var a = r % n.length;
			return t[a] = t[a] || [], a;
		}
		if (a === "circle") for (var x = r[0].getTicksCoords(), S = n.cx, C = n.cy, w = 0; w < x.length; w++) {
			if (d) {
				var T = b(v, g, w);
				v[T].push(new Circle_default({ shape: {
					cx: S,
					cy: C,
					r: x[w].coord
				} }));
			}
			if (f && w < x.length - 1) {
				var T = b(y, _, w);
				y[T].push(new Ring_default({ shape: {
					cx: S,
					cy: C,
					r0: x[w].coord,
					r: x[w + 1].coord
				} }));
			}
		}
		else for (var E, D = map(r, function(t, r) {
			var a = t.getTicksCoords();
			return E = E == null ? a.length - 1 : Math.min(a.length - 1, E), map(a, function(t) {
				return n.coordToPoint(t.coord, r);
			});
		}), O = [], w = 0; w <= E; w++) {
			for (var A = [], j = 0; j < r.length; j++) A.push(D[j][w]);
			if (A[0] ? A.push(A[0].slice()) : process$1.env.NODE_ENV !== "production" && console.error("Can't draw value axis " + w), d) {
				var T = b(v, g, w);
				v[T].push(new Polyline_default$1({ shape: { points: A } }));
			}
			if (f && O) {
				var T = b(y, _, w - 1);
				y[T].push(new Polygon_default({ shape: { points: A.concat(O) } }));
			}
			O = A.slice().reverse();
		}
		var M = l.getLineStyle(), N = u.getAreaStyle();
		each(y, function(t, n) {
			this.group.add(mergePath(t, {
				style: defaults({
					stroke: "none",
					fill: _[n % _.length]
				}, N),
				silent: !0
			}));
		}, this), each(v, function(t, n) {
			this.group.add(mergePath(t, {
				style: defaults({
					fill: "none",
					stroke: g[n % g.length]
				}, M),
				silent: !0
			}));
		}, this);
	}, n.type = "radar", n;
}(Component_default$1), IndicatorAxis_default = function(t) {
	__extends(n, t);
	function n(n, r, a) {
		var o = t.call(this, n, r, a) || this;
		return o.type = "value", o.angle = 0, o.name = "", o;
	}
	return n;
}(Axis_default), Radar_default = function() {
	function t(t, n, r) {
		this.dimensions = [], this._model = t, this._indicatorAxes = map(t.getIndicatorModels(), function(t, n) {
			var r = "indicator_" + n, a = new IndicatorAxis_default(r, new Interval_default());
			return a.name = t.get("name"), a.model = t, t.axis = a, this.dimensions.push(r), a;
		}, this), this.resize(t, r);
	}
	return t.prototype.getIndicatorAxes = function() {
		return this._indicatorAxes;
	}, t.prototype.dataToPoint = function(t, n) {
		var r = this._indicatorAxes[n];
		return this.coordToPoint(r.dataToCoord(t), n);
	}, t.prototype.coordToPoint = function(t, n) {
		var r = this._indicatorAxes[n].angle;
		return [this.cx + t * Math.cos(r), this.cy - t * Math.sin(r)];
	}, t.prototype.pointToData = function(t) {
		var n = t[0] - this.cx, r = t[1] - this.cy, a = Math.sqrt(n * n + r * r);
		n /= a, r /= a;
		for (var o = Math.atan2(-r, n), s = Infinity, c, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
			var d = this._indicatorAxes[u], f = Math.abs(o - d.angle);
			f < s && (c = d, l = u, s = f);
		}
		return [l, +(c && c.coordToData(a))];
	}, t.prototype.resize = function(t, n) {
		var r = t.get("center"), a = n.getWidth(), o = n.getHeight(), s = Math.min(a, o) / 2;
		this.cx = parsePercent$1(r[0], a), this.cy = parsePercent$1(r[1], o), this.startAngle = t.get("startAngle") * Math.PI / 180;
		var c = t.get("radius");
		(isString(c) || isNumber(c)) && (c = [0, c]), this.r0 = parsePercent$1(c[0], s), this.r = parsePercent$1(c[1], s), each(this._indicatorAxes, function(t, n) {
			t.setExtent(this.r0, this.r);
			var r = this.startAngle + n * Math.PI * 2 / this._indicatorAxes.length;
			r = Math.atan2(Math.sin(r), Math.cos(r)), t.angle = r;
		}, this);
	}, t.prototype.update = function(t, n) {
		var r = this._indicatorAxes, a = this._model;
		each(r, function(t) {
			t.scale.setExtent(Infinity, -Infinity);
		}), t.eachSeriesByType("radar", function(n, o) {
			if (!(n.get("coordinateSystem") !== "radar" || t.getComponent("radar", n.get("radarIndex")) !== a)) {
				var s = n.getData();
				each(r, function(t) {
					t.scale.unionExtentFromData(s, s.mapDimension(t.dim));
				});
			}
		}, this);
		var o = a.get("splitNumber"), s = new Interval_default();
		s.setExtent(0, o), s.setInterval(1), each(r, function(t, n) {
			alignScaleTicks(t.scale, t.model, s);
		});
	}, t.prototype.convertToPixel = function(t, n, r) {
		return console.warn("Not implemented."), null;
	}, t.prototype.convertFromPixel = function(t, n, r) {
		return console.warn("Not implemented."), null;
	}, t.prototype.containPoint = function(t) {
		return console.warn("Not implemented."), !1;
	}, t.create = function(n, r) {
		var a = [];
		return n.eachComponent("radar", function(o) {
			var s = new t(o, n, r);
			a.push(s), o.coordinateSystem = s;
		}), n.eachSeriesByType("radar", function(t) {
			t.get("coordinateSystem") === "radar" && (t.coordinateSystem = a[t.get("radarIndex") || 0]);
		}), a;
	}, t.dimensions = [], t;
}();
function install$54(t) {
	t.registerCoordinateSystem("radar", Radar_default), t.registerComponentModel(RadarModel_default), t.registerComponentView(RadarView_default$1), t.registerVisual({
		seriesType: "radar",
		reset: function(t) {
			var n = t.getData();
			n.each(function(t) {
				n.setItemVisual(t, "legendIcon", "roundRect");
			}), n.setVisual("legendIcon", "roundRect");
		}
	});
}
function install$6(t) {
	use(install$54), t.registerChartView(RadarView_default), t.registerSeriesModel(RadarSeries_default), t.registerLayout(radarLayout), t.registerProcessor(dataFilter$1("radar")), t.registerPreprocessor(radarBackwardCompat);
}
var ATTR = "\0_ec_interaction_mutex";
function take(t, n, r) {
	var a = getStore(t);
	a[n] = r;
}
function release(t, n, r) {
	var a = getStore(t);
	a[n] === r && (a[n] = null);
}
function isTaken(t, n) {
	return !!getStore(t)[n];
}
function getStore(t) {
	return t[ATTR] || (t[ATTR] = {});
}
registerAction({
	type: "takeGlobalCursor",
	event: "globalCursorTaken",
	update: "update"
}, noop);
var RoamController = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this) || this;
		r._zr = n;
		var a = bind(r._mousedownHandler, r), o = bind(r._mousemoveHandler, r), s = bind(r._mouseupHandler, r), c = bind(r._mousewheelHandler, r), l = bind(r._pinchHandler, r);
		return r.enable = function(t, r) {
			this.disable(), this._opt = defaults(clone$1(r) || {}, {
				zoomOnMouseWheel: !0,
				moveOnMouseMove: !0,
				moveOnMouseWheel: !1,
				preventDefaultMouseMove: !0
			}), t ??= !0, (t === !0 || t === "move" || t === "pan") && (n.on("mousedown", a), n.on("mousemove", o), n.on("mouseup", s)), (t === !0 || t === "scale" || t === "zoom") && (n.on("mousewheel", c), n.on("pinch", l));
		}, r.disable = function() {
			n.off("mousedown", a), n.off("mousemove", o), n.off("mouseup", s), n.off("mousewheel", c), n.off("pinch", l);
		}, r;
	}
	return n.prototype.isDragging = function() {
		return this._dragging;
	}, n.prototype.isPinching = function() {
		return this._pinching;
	}, n.prototype.setPointerChecker = function(t) {
		this.pointerChecker = t;
	}, n.prototype.dispose = function() {
		this.disable();
	}, n.prototype._mousedownHandler = function(t) {
		if (!isMiddleOrRightButtonOnMouseUpDown(t)) {
			for (var n = t.target; n;) {
				if (n.draggable) return;
				n = n.__hostTarget || n.parent;
			}
			var r = t.offsetX, a = t.offsetY;
			this.pointerChecker && this.pointerChecker(t, r, a) && (this._x = r, this._y = a, this._dragging = !0);
		}
	}, n.prototype._mousemoveHandler = function(t) {
		if (!(!this._dragging || !isAvailableBehavior("moveOnMouseMove", t, this._opt) || t.gestureEvent === "pinch" || isTaken(this._zr, "globalPan"))) {
			var n = t.offsetX, r = t.offsetY, a = this._x, o = this._y, s = n - a, c = r - o;
			this._x = n, this._y = r, this._opt.preventDefaultMouseMove && stop(t.event), trigger$1(this, "pan", "moveOnMouseMove", t, {
				dx: s,
				dy: c,
				oldX: a,
				oldY: o,
				newX: n,
				newY: r,
				isAvailableBehavior: null
			});
		}
	}, n.prototype._mouseupHandler = function(t) {
		isMiddleOrRightButtonOnMouseUpDown(t) || (this._dragging = !1);
	}, n.prototype._mousewheelHandler = function(t) {
		var n = isAvailableBehavior("zoomOnMouseWheel", t, this._opt), r = isAvailableBehavior("moveOnMouseWheel", t, this._opt), a = t.wheelDelta, o = Math.abs(a), s = t.offsetX, c = t.offsetY;
		if (!(a === 0 || !n && !r)) {
			if (n) {
				var l = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, u = a > 0 ? l : 1 / l;
				checkPointerAndTrigger(this, "zoom", "zoomOnMouseWheel", t, {
					scale: u,
					originX: s,
					originY: c,
					isAvailableBehavior: null
				});
			}
			if (r) {
				var d = Math.abs(a);
				checkPointerAndTrigger(this, "scrollMove", "moveOnMouseWheel", t, {
					scrollDelta: (a > 0 ? 1 : -1) * (d > 3 ? .4 : d > 1 ? .15 : .05),
					originX: s,
					originY: c,
					isAvailableBehavior: null
				});
			}
		}
	}, n.prototype._pinchHandler = function(t) {
		if (!isTaken(this._zr, "globalPan")) {
			var n = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
			checkPointerAndTrigger(this, "zoom", null, t, {
				scale: n,
				originX: t.pinchX,
				originY: t.pinchY,
				isAvailableBehavior: null
			});
		}
	}, n;
}(Eventful_default);
function checkPointerAndTrigger(t, n, r, a, o) {
	t.pointerChecker && t.pointerChecker(a, o.originX, o.originY) && (stop(a.event), trigger$1(t, n, r, a, o));
}
function trigger$1(t, n, r, a, o) {
	o.isAvailableBehavior = bind(isAvailableBehavior, null, r, a), t.trigger(n, o);
}
function isAvailableBehavior(t, n, r) {
	var a = r[t];
	return !t || a && (!isString(a) || n.event[a + "Key"]);
}
var RoamController_default = RoamController;
function updateViewOnPan(t, n, r) {
	var a = t.target;
	a.x += n, a.y += r, a.dirty();
}
function updateViewOnZoom(t, n, r, a) {
	var o = t.target, s = t.zoomLimit, c = t.zoom = t.zoom || 1;
	if (c *= n, s) {
		var l = s.min || 0, u = s.max || Infinity;
		c = Math.max(Math.min(u, c), l);
	}
	var d = c / t.zoom;
	t.zoom = c, o.x -= (r - o.x) * (d - 1), o.y -= (a - o.y) * (d - 1), o.scaleX *= d, o.scaleY *= d, o.dirty();
}
var IRRELEVANT_EXCLUDES = {
	axisPointer: 1,
	tooltip: 1,
	brush: 1
};
function onIrrelevantElement(t, n, r) {
	var a = n.getComponentByElement(t.topTarget), o = a && a.coordinateSystem;
	return a && a !== r && !IRRELEVANT_EXCLUDES.hasOwnProperty(a.mainType) && o && o.model !== r;
}
function parseXML(t) {
	isString(t) && (t = new DOMParser().parseFromString(t, "text/xml"));
	var n = t;
	for (n.nodeType === 9 && (n = n.firstChild); n.nodeName.toLowerCase() !== "svg" || n.nodeType !== 1;) n = n.nextSibling;
	return n;
}
init_dist$2();
var nodeParsers, INHERITABLE_STYLE_ATTRIBUTES_MAP = {
	fill: "fill",
	stroke: "stroke",
	"stroke-width": "lineWidth",
	opacity: "opacity",
	"fill-opacity": "fillOpacity",
	"stroke-opacity": "strokeOpacity",
	"stroke-dasharray": "lineDash",
	"stroke-dashoffset": "lineDashOffset",
	"stroke-linecap": "lineCap",
	"stroke-linejoin": "lineJoin",
	"stroke-miterlimit": "miterLimit",
	"font-family": "fontFamily",
	"font-size": "fontSize",
	"font-style": "fontStyle",
	"font-weight": "fontWeight",
	"text-anchor": "textAlign",
	visibility: "visibility",
	display: "display"
}, INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = keys(INHERITABLE_STYLE_ATTRIBUTES_MAP), SELF_STYLE_ATTRIBUTES_MAP = {
	"alignment-baseline": "textBaseline",
	"stop-color": "stopColor"
}, SELF_STYLE_ATTRIBUTES_MAP_KEYS = keys(SELF_STYLE_ATTRIBUTES_MAP), SVGParser = function() {
	function t() {
		this._defs = {}, this._root = null;
	}
	return t.prototype.parse = function(t, n) {
		n ||= {};
		var r = parseXML(t);
		if (process$1.env.NODE_ENV !== "production" && !r) throw Error("Illegal svg");
		this._defsUsePending = [];
		var a = new Group_default();
		this._root = a;
		var o = [], c = r.getAttribute("viewBox") || "", l = parseFloat(r.getAttribute("width") || n.width), u = parseFloat(r.getAttribute("height") || n.height);
		isNaN(l) && (l = null), isNaN(u) && (u = null), parseAttributes(r, a, null, !0, !1);
		for (var d = r.firstChild; d;) this._parseNode(d, a, o, null, !1, !1), d = d.nextSibling;
		applyDefs(this._defs, this._defsUsePending), this._defsUsePending = [];
		var f, p;
		if (c) {
			var h = splitNumberSequence(c);
			h.length >= 4 && (f = {
				x: parseFloat(h[0] || 0),
				y: parseFloat(h[1] || 0),
				width: parseFloat(h[2]),
				height: parseFloat(h[3])
			});
		}
		if (f && l != null && u != null && (p = makeViewBoxTransform(f, {
			x: 0,
			y: 0,
			width: l,
			height: u
		}), !n.ignoreViewBox)) {
			var g = a;
			a = new Group_default(), a.add(g), g.scaleX = g.scaleY = p.scale, g.x = p.x, g.y = p.y;
		}
		return !n.ignoreRootClip && l != null && u != null && a.setClipPath(new Rect_default({ shape: {
			x: 0,
			y: 0,
			width: l,
			height: u
		} })), {
			root: a,
			width: l,
			height: u,
			viewBoxRect: f,
			viewBoxTransform: p,
			named: o
		};
	}, t.prototype._parseNode = function(t, n, r, a, o, s) {
		var c = t.nodeName.toLowerCase(), l, u = a;
		if (c === "defs" && (o = !0), c === "text" && (s = !0), c === "defs" || c === "switch") l = n;
		else {
			if (!o) {
				var d = nodeParsers[c];
				if (d && hasOwn(nodeParsers, c)) {
					l = d.call(this, t, n);
					var f = t.getAttribute("name");
					if (f) {
						var p = {
							name: f,
							namedFrom: null,
							svgNodeTagLower: c,
							el: l
						};
						r.push(p), c === "g" && (u = p);
					} else a && r.push({
						name: a.name,
						namedFrom: a,
						svgNodeTagLower: c,
						el: l
					});
					n.add(l);
				}
			}
			var h = paintServerParsers[c];
			if (h && hasOwn(paintServerParsers, c)) {
				var g = h.call(this, t), _ = t.getAttribute("id");
				_ && (this._defs[_] = g);
			}
		}
		if (l && l.isGroup) for (var v = t.firstChild; v;) v.nodeType === 1 ? this._parseNode(v, l, r, u, o, s) : v.nodeType === 3 && s && this._parseText(v, l), v = v.nextSibling;
	}, t.prototype._parseText = function(t, n) {
		var r = new TSpan_default({
			style: { text: t.textContent },
			silent: !0,
			x: this._textX || 0,
			y: this._textY || 0
		});
		inheritStyle(n, r), parseAttributes(t, r, this._defsUsePending, !1, !1), applyTextAlignment(r, n);
		var a = r.style, o = a.fontSize;
		o && o < 9 && (a.fontSize = 9, r.scaleX *= o / 9, r.scaleY *= o / 9), a.font = (a.fontSize || a.fontFamily) && [
			a.fontStyle,
			a.fontWeight,
			(a.fontSize || 12) + "px",
			a.fontFamily || "sans-serif"
		].join(" ");
		var s = r.getBoundingRect();
		return this._textX += s.width, n.add(r), r;
	}, t.internalField = (function() {
		nodeParsers = {
			g: function(t, n) {
				var r = new Group_default();
				return inheritStyle(n, r), parseAttributes(t, r, this._defsUsePending, !1, !1), r;
			},
			rect: function(t, n) {
				var r = new Rect_default();
				return inheritStyle(n, r), parseAttributes(t, r, this._defsUsePending, !1, !1), r.setShape({
					x: parseFloat(t.getAttribute("x") || "0"),
					y: parseFloat(t.getAttribute("y") || "0"),
					width: parseFloat(t.getAttribute("width") || "0"),
					height: parseFloat(t.getAttribute("height") || "0")
				}), r.silent = !0, r;
			},
			circle: function(t, n) {
				var r = new Circle_default();
				return inheritStyle(n, r), parseAttributes(t, r, this._defsUsePending, !1, !1), r.setShape({
					cx: parseFloat(t.getAttribute("cx") || "0"),
					cy: parseFloat(t.getAttribute("cy") || "0"),
					r: parseFloat(t.getAttribute("r") || "0")
				}), r.silent = !0, r;
			},
			line: function(t, n) {
				var r = new Line_default$1();
				return inheritStyle(n, r), parseAttributes(t, r, this._defsUsePending, !1, !1), r.setShape({
					x1: parseFloat(t.getAttribute("x1") || "0"),
					y1: parseFloat(t.getAttribute("y1") || "0"),
					x2: parseFloat(t.getAttribute("x2") || "0"),
					y2: parseFloat(t.getAttribute("y2") || "0")
				}), r.silent = !0, r;
			},
			ellipse: function(t, n) {
				var r = new Ellipse_default();
				return inheritStyle(n, r), parseAttributes(t, r, this._defsUsePending, !1, !1), r.setShape({
					cx: parseFloat(t.getAttribute("cx") || "0"),
					cy: parseFloat(t.getAttribute("cy") || "0"),
					rx: parseFloat(t.getAttribute("rx") || "0"),
					ry: parseFloat(t.getAttribute("ry") || "0")
				}), r.silent = !0, r;
			},
			polygon: function(t, n) {
				var r = t.getAttribute("points"), a;
				r && (a = parsePoints(r));
				var o = new Polygon_default({
					shape: { points: a || [] },
					silent: !0
				});
				return inheritStyle(n, o), parseAttributes(t, o, this._defsUsePending, !1, !1), o;
			},
			polyline: function(t, n) {
				var r = t.getAttribute("points"), a;
				r && (a = parsePoints(r));
				var o = new Polyline_default$1({
					shape: { points: a || [] },
					silent: !0
				});
				return inheritStyle(n, o), parseAttributes(t, o, this._defsUsePending, !1, !1), o;
			},
			image: function(t, n) {
				var r = new Image_default();
				return inheritStyle(n, r), parseAttributes(t, r, this._defsUsePending, !1, !1), r.setStyle({
					image: t.getAttribute("xlink:href") || t.getAttribute("href"),
					x: +t.getAttribute("x"),
					y: +t.getAttribute("y"),
					width: +t.getAttribute("width"),
					height: +t.getAttribute("height")
				}), r.silent = !0, r;
			},
			text: function(t, n) {
				var r = t.getAttribute("x") || "0", a = t.getAttribute("y") || "0", o = t.getAttribute("dx") || "0", s = t.getAttribute("dy") || "0";
				this._textX = parseFloat(r) + parseFloat(o), this._textY = parseFloat(a) + parseFloat(s);
				var c = new Group_default();
				return inheritStyle(n, c), parseAttributes(t, c, this._defsUsePending, !1, !0), c;
			},
			tspan: function(t, n) {
				var r = t.getAttribute("x"), a = t.getAttribute("y");
				r != null && (this._textX = parseFloat(r)), a != null && (this._textY = parseFloat(a));
				var o = t.getAttribute("dx") || "0", s = t.getAttribute("dy") || "0", c = new Group_default();
				return inheritStyle(n, c), parseAttributes(t, c, this._defsUsePending, !1, !0), this._textX += parseFloat(o), this._textY += parseFloat(s), c;
			},
			path: function(t, n) {
				var r = createFromString(t.getAttribute("d") || "");
				return inheritStyle(n, r), parseAttributes(t, r, this._defsUsePending, !1, !1), r.silent = !0, r;
			}
		};
	})(), t;
}(), paintServerParsers = {
	lineargradient: function(t) {
		var n = new LinearGradient_default(parseInt(t.getAttribute("x1") || "0", 10), parseInt(t.getAttribute("y1") || "0", 10), parseInt(t.getAttribute("x2") || "10", 10), parseInt(t.getAttribute("y2") || "0", 10));
		return parsePaintServerUnit(t, n), parseGradientColorStops(t, n), n;
	},
	radialgradient: function(t) {
		var n = new RadialGradient_default(parseInt(t.getAttribute("cx") || "0", 10), parseInt(t.getAttribute("cy") || "0", 10), parseInt(t.getAttribute("r") || "0", 10));
		return parsePaintServerUnit(t, n), parseGradientColorStops(t, n), n;
	}
};
function parsePaintServerUnit(t, n) {
	t.getAttribute("gradientUnits") === "userSpaceOnUse" && (n.global = !0);
}
function parseGradientColorStops(t, n) {
	for (var r = t.firstChild; r;) {
		if (r.nodeType === 1 && r.nodeName.toLocaleLowerCase() === "stop") {
			var a = r.getAttribute("offset"), o = void 0;
			o = a && a.indexOf("%") > 0 ? parseInt(a, 10) / 100 : a ? parseFloat(a) : 0;
			var s = {};
			parseInlineStyle(r, s, s);
			var c = s.stopColor || r.getAttribute("stop-color") || "#000000";
			n.colorStops.push({
				offset: o,
				color: c
			});
		}
		r = r.nextSibling;
	}
}
function inheritStyle(t, n) {
	t && t.__inheritedStyle && (n.__inheritedStyle ||= {}, defaults(n.__inheritedStyle, t.__inheritedStyle));
}
function parsePoints(t) {
	for (var n = splitNumberSequence(t), r = [], a = 0; a < n.length; a += 2) {
		var o = parseFloat(n[a]), s = parseFloat(n[a + 1]);
		r.push([o, s]);
	}
	return r;
}
function parseAttributes(t, n, r, a, o) {
	var s = n, c = s.__inheritedStyle = s.__inheritedStyle || {}, l = {};
	t.nodeType === 1 && (parseTransformAttribute(t, n), parseInlineStyle(t, c, l), a || parseAttributeStyle(t, c, l)), s.style = s.style || {}, c.fill != null && (s.style.fill = getFillStrokeStyle(s, "fill", c.fill, r)), c.stroke != null && (s.style.stroke = getFillStrokeStyle(s, "stroke", c.stroke, r)), each([
		"lineWidth",
		"opacity",
		"fillOpacity",
		"strokeOpacity",
		"miterLimit",
		"fontSize"
	], function(t) {
		c[t] != null && (s.style[t] = parseFloat(c[t]));
	}), each([
		"lineDashOffset",
		"lineCap",
		"lineJoin",
		"fontWeight",
		"fontFamily",
		"fontStyle",
		"textAlign"
	], function(t) {
		c[t] != null && (s.style[t] = c[t]);
	}), o && (s.__selfStyle = l), c.lineDash && (s.style.lineDash = map(splitNumberSequence(c.lineDash), function(t) {
		return parseFloat(t);
	})), (c.visibility === "hidden" || c.visibility === "collapse") && (s.invisible = !0), c.display === "none" && (s.ignore = !0);
}
function applyTextAlignment(t, n) {
	var r = n.__selfStyle;
	if (r) {
		var a = r.textBaseline, o = a;
		!a || a === "auto" || a === "baseline" ? o = "alphabetic" : a === "before-edge" || a === "text-before-edge" ? o = "top" : a === "after-edge" || a === "text-after-edge" ? o = "bottom" : (a === "central" || a === "mathematical") && (o = "middle"), t.style.textBaseline = o;
	}
	var s = n.__inheritedStyle;
	if (s) {
		var c = s.textAlign, l = c;
		c && (c === "middle" && (l = "center"), t.style.textAlign = l);
	}
}
var urlRegex = /^url\(\s*#(.*?)\)/;
function getFillStrokeStyle(t, n, r, a) {
	var o = r && r.match(urlRegex);
	if (o) {
		var s = trim(o[1]);
		a.push([
			t,
			n,
			s
		]);
		return;
	}
	return r === "none" && (r = null), r;
}
function applyDefs(t, n) {
	for (var r = 0; r < n.length; r++) {
		var a = n[r];
		a[0].style[a[1]] = t[a[2]];
	}
}
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function splitNumberSequence(t) {
	return t.match(numberReg) || [];
}
var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, DEGREE_TO_ANGLE = Math.PI / 180;
function parseTransformAttribute(t, n) {
	var r = t.getAttribute("transform");
	if (r) {
		r = r.replace(/,/g, " ");
		var a = [], o = null;
		r.replace(transformRegex, function(t, n, r) {
			return a.push(n, r), "";
		});
		for (var s = a.length - 1; s > 0; s -= 2) {
			var c = a[s], l = a[s - 1], u = splitNumberSequence(c);
			switch (o ||= create$2(), l) {
				case "translate":
					translate(o, o, [parseFloat(u[0]), parseFloat(u[1] || "0")]);
					break;
				case "scale":
					scale$2(o, o, [parseFloat(u[0]), parseFloat(u[1] || u[0])]);
					break;
				case "rotate":
					rotate(o, o, -parseFloat(u[0]) * DEGREE_TO_ANGLE, [parseFloat(u[1] || "0"), parseFloat(u[2] || "0")]);
					break;
				case "skewX":
					var d = Math.tan(parseFloat(u[0]) * DEGREE_TO_ANGLE);
					mul(o, [
						1,
						0,
						d,
						1,
						0,
						0
					], o);
					break;
				case "skewY":
					var f = Math.tan(parseFloat(u[0]) * DEGREE_TO_ANGLE);
					mul(o, [
						1,
						f,
						0,
						1,
						0,
						0
					], o);
					break;
				case "matrix":
					o[0] = parseFloat(u[0]), o[1] = parseFloat(u[1]), o[2] = parseFloat(u[2]), o[3] = parseFloat(u[3]), o[4] = parseFloat(u[4]), o[5] = parseFloat(u[5]);
					break;
			}
		}
		n.setLocalTransform(o);
	}
}
var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function parseInlineStyle(t, n, r) {
	var a = t.getAttribute("style");
	if (a) {
		styleRegex.lastIndex = 0;
		for (var o; (o = styleRegex.exec(a)) != null;) {
			var s = o[1], c = hasOwn(INHERITABLE_STYLE_ATTRIBUTES_MAP, s) ? INHERITABLE_STYLE_ATTRIBUTES_MAP[s] : null;
			c && (n[c] = o[2]);
			var l = hasOwn(SELF_STYLE_ATTRIBUTES_MAP, s) ? SELF_STYLE_ATTRIBUTES_MAP[s] : null;
			l && (r[l] = o[2]);
		}
	}
}
function parseAttributeStyle(t, n, r) {
	for (var a = 0; a < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; a++) {
		var o = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[a], s = t.getAttribute(o);
		s != null && (n[INHERITABLE_STYLE_ATTRIBUTES_MAP[o]] = s);
	}
	for (var a = 0; a < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; a++) {
		var o = SELF_STYLE_ATTRIBUTES_MAP_KEYS[a], s = t.getAttribute(o);
		s != null && (r[SELF_STYLE_ATTRIBUTES_MAP[o]] = s);
	}
}
function makeViewBoxTransform(t, n) {
	var r = n.width / t.width, a = n.height / t.height, o = Math.min(r, a);
	return {
		scale: o,
		x: -(t.x + t.width / 2) * o + (n.x + n.width / 2),
		y: -(t.y + t.height / 2) * o + (n.y + n.height / 2)
	};
}
function parseSVG(t, n) {
	return new SVGParser().parse(t, n);
}
var REGION_AVAILABLE_SVG_TAG_MAP = createHashMap([
	"rect",
	"circle",
	"line",
	"ellipse",
	"polygon",
	"polyline",
	"path",
	"text",
	"tspan",
	"g"
]), GeoSVGResource = function() {
	function t(t, n) {
		this.type = "geoSVG", this._usedGraphicMap = createHashMap(), this._freedGraphics = [], this._mapName = t, this._parsedXML = parseXML(n);
	}
	return t.prototype.load = function() {
		var t = this._firstGraphic;
		if (!t) {
			t = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(t), this._boundingRect = this._firstGraphic.boundingRect.clone();
			var n = createRegions(t.named), r = n.regions, a = n.regionsMap;
			this._regions = r, this._regionsMap = a;
		}
		return {
			boundingRect: this._boundingRect,
			regions: this._regions,
			regionsMap: this._regionsMap
		};
	}, t.prototype._buildGraphic = function(t) {
		var n, r;
		try {
			n = t && parseSVG(t, {
				ignoreViewBox: !0,
				ignoreRootClip: !0
			}) || {}, r = n.root, assert(r != null);
		} catch (t) {
			throw Error("Invalid svg format\n" + t.message);
		}
		var a = new Group_default();
		a.add(r), a.isGeoSVGGraphicRoot = !0;
		var o = n.width, s = n.height, c = n.viewBoxRect, l = this._boundingRect;
		if (!l) {
			var u = void 0, d = void 0, f = void 0, p = void 0;
			if (o == null ? c && (u = c.x, f = c.width) : (u = 0, f = o), s == null ? c && (d = c.y, p = c.height) : (d = 0, p = s), u == null || d == null) {
				var h = r.getBoundingRect();
				u ?? (u = h.x, f = h.width), d ?? (d = h.y, p = h.height);
			}
			l = this._boundingRect = new BoundingRect_default(u, d, f, p);
		}
		if (c) {
			var g = makeViewBoxTransform(c, l);
			r.scaleX = r.scaleY = g.scale, r.x = g.x, r.y = g.y;
		}
		a.setClipPath(new Rect_default({ shape: l.plain() }));
		var _ = [];
		return each(n.named, function(t) {
			REGION_AVAILABLE_SVG_TAG_MAP.get(t.svgNodeTagLower) != null && (_.push(t), setSilent(t.el));
		}), {
			root: a,
			boundingRect: l,
			named: _
		};
	}, t.prototype.useGraphic = function(t) {
		var n = this._usedGraphicMap, r = n.get(t);
		return r || (r = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), n.set(t, r), r);
	}, t.prototype.freeGraphic = function(t) {
		var n = this._usedGraphicMap, r = n.get(t);
		r && (n.removeKey(t), this._freedGraphics.push(r));
	}, t;
}();
function setSilent(t) {
	t.silent = !1, t.isGroup && t.traverse(function(t) {
		t.silent = !1;
	});
}
function createRegions(t) {
	var n = [], r = createHashMap();
	return each(t, function(t) {
		if (t.namedFrom == null) {
			var a = new GeoSVGRegion(t.name, t.el);
			n.push(a), r.set(t.name, a);
		}
	}), {
		regions: n,
		regionsMap: r
	};
}
for (var geoCoord = [126, 25], nanhaiName = "南海诸岛", points$1 = [
	[
		[0, 3.5],
		[7, 11.2],
		[15, 11.9],
		[30, 7],
		[42, .7],
		[52, .7],
		[56, 7.7],
		[59, .7],
		[64, .7],
		[64, 0],
		[5, 0],
		[0, 3.5]
	],
	[
		[13, 16.1],
		[19, 14.7],
		[16, 21.7],
		[11, 23.1],
		[13, 16.1]
	],
	[
		[12, 32.2],
		[14, 38.5],
		[15, 38.5],
		[13, 32.2],
		[12, 32.2]
	],
	[
		[16, 47.6],
		[12, 53.2],
		[13, 53.2],
		[18, 47.6],
		[16, 47.6]
	],
	[
		[6, 64.4],
		[8, 70],
		[9, 70],
		[8, 64.4],
		[6, 64.4]
	],
	[
		[23, 82.6],
		[29, 79.8],
		[30, 79.8],
		[25, 82.6],
		[23, 82.6]
	],
	[
		[37, 70.7],
		[43, 62.3],
		[44, 62.3],
		[39, 70.7],
		[37, 70.7]
	],
	[
		[48, 51.1],
		[51, 45.5],
		[53, 45.5],
		[50, 51.1],
		[48, 51.1]
	],
	[
		[51, 35],
		[51, 28.7],
		[53, 28.7],
		[53, 35],
		[51, 35]
	],
	[
		[52, 22.4],
		[55, 17.5],
		[56, 17.5],
		[53, 22.4],
		[52, 22.4]
	],
	[
		[58, 12.6],
		[62, 7],
		[63, 7],
		[60, 12.6],
		[58, 12.6]
	],
	[
		[0, 3.5],
		[0, 93.1],
		[64, 93.1],
		[64, 0],
		[63, 0],
		[63, 92.4],
		[1, 92.4],
		[1, 3.5],
		[0, 3.5]
	]
], i = 0; i < points$1.length; i++) for (var k = 0; k < points$1[i].length; k++) points$1[i][k][0] /= 10.5, points$1[i][k][1] /= -10.5 / .75, points$1[i][k][0] += geoCoord[0], points$1[i][k][1] += geoCoord[1];
function fixNanhai(t, n) {
	if (t === "china") {
		for (var r = 0; r < n.length; r++) if (n[r].name === nanhaiName) return;
		n.push(new GeoJSONRegion(nanhaiName, map(points$1, function(t) {
			return {
				type: "polygon",
				exterior: t
			};
		}), geoCoord));
	}
}
var coordsOffsetMap = {
	南海诸岛: [32, 80],
	广东: [0, -10],
	香港: [10, 5],
	澳门: [-10, 10],
	天津: [5, 5]
};
function fixTextCoords(t, n) {
	if (t === "china") {
		var r = coordsOffsetMap[n.name];
		if (r) {
			var a = n.getCenter();
			a[0] += r[0] / 10.5, a[1] += -r[1] / (10.5 / .75), n.setCenter(a);
		}
	}
}
var points = [[
	[123.45165252685547, 25.73527164402261],
	[123.49731445312499, 25.73527164402261],
	[123.49731445312499, 25.750734064600884],
	[123.45165252685547, 25.750734064600884],
	[123.45165252685547, 25.73527164402261]
]];
function fixDiaoyuIsland(t, n) {
	t === "china" && n.name === "台湾" && n.geometries.push({
		type: "polygon",
		exterior: points[0]
	});
}
var DEFAULT_NAME_PROPERTY = "name", GeoJSONResource = function() {
	function t(t, n, r) {
		this.type = "geoJSON", this._parsedMap = createHashMap(), this._mapName = t, this._specialAreas = r, this._geoJSON = parseInput(n);
	}
	return t.prototype.load = function(t, n) {
		n ||= DEFAULT_NAME_PROPERTY;
		var r = this._parsedMap.get(n);
		if (!r) {
			var a = this._parseToRegions(n);
			r = this._parsedMap.set(n, {
				regions: a,
				boundingRect: calculateBoundingRect(a)
			});
		}
		var o = createHashMap(), s = [];
		return each(r.regions, function(n) {
			var r = n.name;
			t && hasOwn(t, r) && (n = n.cloneShallow(r = t[r])), s.push(n), o.set(r, n);
		}), {
			regions: s,
			boundingRect: r.boundingRect || new BoundingRect_default(0, 0, 0, 0),
			regionsMap: o
		};
	}, t.prototype._parseToRegions = function(t) {
		var n = this._mapName, r = this._geoJSON, a;
		try {
			a = r ? parseGeoJSON(r, t) : [];
		} catch (t) {
			throw Error("Invalid geoJson format\n" + t.message);
		}
		return fixNanhai(n, a), each(a, function(t) {
			var r = t.name;
			fixTextCoords(n, t), fixDiaoyuIsland(n, t);
			var a = this._specialAreas && this._specialAreas[r];
			a && t.transformTo(a.left, a.top, a.width, a.height);
		}, this), a;
	}, t.prototype.getMapForUser = function() {
		return {
			geoJson: this._geoJSON,
			geoJSON: this._geoJSON,
			specialAreas: this._specialAreas
		};
	}, t;
}();
function calculateBoundingRect(t) {
	for (var n, r = 0; r < t.length; r++) {
		var a = t[r].getBoundingRect();
		n ||= a.clone(), n.union(a);
	}
	return n;
}
function parseInput(t) {
	return isString(t) ? typeof JSON < "u" && JSON.parse ? JSON.parse(t) : Function("return (" + t + ");")() : t;
}
init_dist$2();
var storage = createHashMap(), geoSourceManager_default = {
	registerMap: function(t, n, r) {
		if (n.svg) {
			var a = new GeoSVGResource(t, n.svg);
			storage.set(t, a);
		} else {
			var o = n.geoJson || n.geoJSON;
			o && !n.features ? r = n.specialAreas : o = n;
			var a = new GeoJSONResource(t, o, r);
			storage.set(t, a);
		}
	},
	getGeoResource: function(t) {
		return storage.get(t);
	},
	getMapForUser: function(t) {
		var n = storage.get(t);
		return n && n.type === "geoJSON" && n.getMapForUser();
	},
	load: function(t, n, r) {
		var a = storage.get(t);
		if (!a) {
			process$1.env.NODE_ENV !== "production" && console.error("Map " + t + " not exists. The GeoJSON of the map must be provided.");
			return;
		}
		return a.load(n, r);
	}
}, OPTION_STYLE_ENABLED_TAGS = [
	"rect",
	"circle",
	"line",
	"ellipse",
	"polygon",
	"polyline",
	"path"
], OPTION_STYLE_ENABLED_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS), STATE_TRIGGER_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"])), LABEL_HOST_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"])), mapLabelRaw = makeInner();
function getFixedItemStyle(t) {
	var n = t.getItemStyle(), r = t.get("areaColor");
	return r != null && (n.fill = r), n;
}
function fixLineStyle(t) {
	var n = t.style;
	n && (n.stroke = n.stroke || n.fill, n.fill = null);
}
var MapDraw = function() {
	function t(t) {
		var n = new Group_default();
		this.uid = getUID("ec_map_draw"), this._controller = new RoamController_default(t.getZr()), this._controllerHost = { target: n }, this.group = n, n.add(this._regionsGroup = new Group_default()), n.add(this._svgGroup = new Group_default());
	}
	return t.prototype.draw = function(t, n, r, a, o) {
		var s = t.mainType === "geo", c = t.getData && t.getData();
		s && n.eachComponent({
			mainType: "series",
			subType: "map"
		}, function(n) {
			!c && n.getHostGeoModel() === t && (c = n.getData());
		});
		var l = t.coordinateSystem, u = this._regionsGroup, d = this.group, f = l.getTransformInfo(), p = f.raw, h = f.roam;
		!u.childAt(0) || o ? (d.x = h.x, d.y = h.y, d.scaleX = h.scaleX, d.scaleY = h.scaleY, d.dirty()) : updateProps(d, h, t);
		var g = c && c.getVisual("visualMeta") && c.getVisual("visualMeta").length > 0, _ = {
			api: r,
			geo: l,
			mapOrGeoModel: t,
			data: c,
			isVisualEncodedByVisualMap: g,
			isGeo: s,
			transformInfoRaw: p
		};
		l.resourceType === "geoJSON" ? this._buildGeoJSON(_) : l.resourceType === "geoSVG" && this._buildSVG(_), this._updateController(t, n, r), this._updateMapSelectHandler(t, u, r, a);
	}, t.prototype._buildGeoJSON = function(t) {
		var n = this._regionsGroupByName = createHashMap(), r = createHashMap(), a = this._regionsGroup, o = t.transformInfoRaw, s = t.mapOrGeoModel, c = t.data, l = t.geo.projection, u = l && l.stream;
		function d(t, n) {
			return n && (t = n(t)), t && [t[0] * o.scaleX + o.x, t[1] * o.scaleY + o.y];
		}
		function f(t) {
			for (var n = [], r = !u && l && l.project, a = 0; a < t.length; ++a) {
				var o = d(t[a], r);
				o && n.push(o);
			}
			return n;
		}
		function p(t) {
			return { shape: { points: f(t) } };
		}
		a.removeAll(), each(t.geo.regions, function(o) {
			var f = o.name, h = n.get(f), g = r.get(f) || {}, _ = g.dataIdx, v = g.regionModel;
			if (!h) {
				h = n.set(f, new Group_default()), a.add(h), _ = c ? c.indexOfName(f) : null, v = t.isGeo ? s.getRegionModel(f) : c ? c.getItemModel(_) : null;
				var y = v.get("silent", !0);
				y != null && (h.silent = y), r.set(f, {
					dataIdx: _,
					regionModel: v
				});
			}
			var b = [], x = [];
			each(o.geometries, function(t) {
				if (t.type === "polygon") {
					var n = [t.exterior].concat(t.interiors || []);
					u && (n = projectPolys(n, u)), each(n, function(t) {
						b.push(new Polygon_default(p(t)));
					});
				} else {
					var r = t.points;
					u && (r = projectPolys(r, u, !0)), each(r, function(t) {
						x.push(new Polyline_default$1(p(t)));
					});
				}
			});
			var S = d(o.getCenter(), l && l.project);
			function C(n, r) {
				if (n.length) {
					var a = new CompoundPath_default({
						culling: !0,
						segmentIgnoreThreshold: 1,
						shape: { paths: n }
					});
					h.add(a), applyOptionStyleForRegion(t, a, _, v), resetLabelForRegion(t, a, f, v, s, _, S), r && (fixLineStyle(a), each(a.states, fixLineStyle));
				}
			}
			C(b), C(x, !0);
		}), n.each(function(n, a) {
			var o = r.get(a), c = o.dataIdx, l = o.regionModel;
			resetEventTriggerForRegion(t, n, a, l, s, c), resetTooltipForRegion(t, n, a, l, s), resetStateTriggerForRegion(t, n, a, l, s);
		}, this);
	}, t.prototype._buildSVG = function(t) {
		var n = t.geo.map, r = t.transformInfoRaw;
		this._svgGroup.x = r.x, this._svgGroup.y = r.y, this._svgGroup.scaleX = r.scaleX, this._svgGroup.scaleY = r.scaleY, this._svgResourceChanged(n) && (this._freeSVG(), this._useSVG(n));
		var a = this._svgDispatcherMap = createHashMap(), o = !1;
		each(this._svgGraphicRecord.named, function(n) {
			var r = n.name, s = t.mapOrGeoModel, c = t.data, l = n.svgNodeTagLower, u = n.el, d = c ? c.indexOfName(r) : null, f = s.getRegionModel(r);
			OPTION_STYLE_ENABLED_TAG_MAP.get(l) != null && u instanceof Displayable_default && applyOptionStyleForRegion(t, u, d, f), u instanceof Displayable_default && (u.culling = !0);
			var p = f.get("silent", !0);
			p != null && (u.silent = p), u.z2EmphasisLift = 0, n.namedFrom || (LABEL_HOST_MAP.get(l) != null && resetLabelForRegion(t, u, r, f, s, d, null), resetEventTriggerForRegion(t, u, r, f, s, d), resetTooltipForRegion(t, u, r, f, s), STATE_TRIGGER_TAG_MAP.get(l) != null && (resetStateTriggerForRegion(t, u, r, f, s) === "self" && (o = !0), (a.get(r) || a.set(r, [])).push(u)));
		}, this), this._enableBlurEntireSVG(o, t);
	}, t.prototype._enableBlurEntireSVG = function(t, n) {
		if (t && n.isGeo) {
			var r = n.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle().opacity;
			this._svgGraphicRecord.root.traverse(function(t) {
				if (!t.isGroup) {
					setDefaultStateProxy(t);
					var n = t.ensureState("blur").style || {};
					n.opacity == null && r != null && (n.opacity = r), t.ensureState("emphasis");
				}
			});
		}
	}, t.prototype.remove = function() {
		this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
	}, t.prototype.findHighDownDispatchers = function(t, n) {
		if (t == null) return [];
		var r = n.coordinateSystem;
		if (r.resourceType === "geoJSON") {
			var a = this._regionsGroupByName;
			if (a) {
				var o = a.get(t);
				return o ? [o] : [];
			}
		} else if (r.resourceType === "geoSVG") return this._svgDispatcherMap && this._svgDispatcherMap.get(t) || [];
	}, t.prototype._svgResourceChanged = function(t) {
		return this._svgMapName !== t;
	}, t.prototype._useSVG = function(t) {
		var n = geoSourceManager_default.getGeoResource(t);
		if (n && n.type === "geoSVG") {
			var r = n.useGraphic(this.uid);
			this._svgGroup.add(r.root), this._svgGraphicRecord = r, this._svgMapName = t;
		}
	}, t.prototype._freeSVG = function() {
		var t = this._svgMapName;
		if (t != null) {
			var n = geoSourceManager_default.getGeoResource(t);
			n && n.type === "geoSVG" && n.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
		}
	}, t.prototype._updateController = function(t, n, r) {
		var a = t.coordinateSystem, o = this._controller, s = this._controllerHost;
		s.zoomLimit = t.get("scaleLimit"), s.zoom = a.getZoom(), o.enable(t.get("roam") || !1);
		var c = t.mainType;
		function l() {
			var n = {
				type: "geoRoam",
				componentType: c
			};
			return n[c + "Id"] = t.id, n;
		}
		o.off("pan").on("pan", function(t) {
			this._mouseDownFlag = !1, updateViewOnPan(s, t.dx, t.dy), r.dispatchAction(extend(l(), {
				dx: t.dx,
				dy: t.dy,
				animation: { duration: 0 }
			}));
		}, this), o.off("zoom").on("zoom", function(t) {
			this._mouseDownFlag = !1, updateViewOnZoom(s, t.scale, t.originX, t.originY), r.dispatchAction(extend(l(), {
				totalZoom: s.zoom,
				zoom: t.scale,
				originX: t.originX,
				originY: t.originY,
				animation: { duration: 0 }
			}));
		}, this), o.setPointerChecker(function(n, o, s) {
			return a.containPoint([o, s]) && !onIrrelevantElement(n, r, t);
		});
	}, t.prototype.resetForLabelLayout = function() {
		this.group.traverse(function(t) {
			var n = t.getTextContent();
			n && (n.ignore = mapLabelRaw(n).ignore);
		});
	}, t.prototype._updateMapSelectHandler = function(t, n, r, a) {
		var o = this;
		n.off("mousedown"), n.off("click"), t.get("selectedMode") && (n.on("mousedown", function() {
			o._mouseDownFlag = !0;
		}), n.on("click", function(t) {
			o._mouseDownFlag &&= !1;
		}));
	}, t;
}();
function applyOptionStyleForRegion(t, n, r, a) {
	var o = a.getModel("itemStyle"), s = a.getModel(["emphasis", "itemStyle"]), c = a.getModel(["blur", "itemStyle"]), l = a.getModel(["select", "itemStyle"]), u = getFixedItemStyle(o), d = getFixedItemStyle(s), f = getFixedItemStyle(l), p = getFixedItemStyle(c), h = t.data;
	if (h) {
		var g = h.getItemVisual(r, "style"), _ = h.getItemVisual(r, "decal");
		t.isVisualEncodedByVisualMap && g.fill && (u.fill = g.fill), _ && (u.decal = createOrUpdatePatternFromDecal(_, t.api));
	}
	n.setStyle(u), n.style.strokeNoScale = !0, n.ensureState("emphasis").style = d, n.ensureState("select").style = f, n.ensureState("blur").style = p, setDefaultStateProxy(n);
}
function resetLabelForRegion(t, n, r, a, o, s, c) {
	var l = t.data, u = t.isGeo, d = l && isNaN(l.get(l.mapDimension("value"), s)), f = l && l.getItemLayout(s);
	if (u || d || f && f.showLabel) {
		var p = u ? r : s, h = void 0;
		(!l || s >= 0) && (h = o);
		var g = c ? { normal: {
			align: "center",
			verticalAlign: "middle"
		} } : null;
		setLabelStyle(n, getLabelStatesModels(a), {
			labelFetcher: h,
			labelDataIndex: p,
			defaultText: r
		}, g);
		var _ = n.getTextContent();
		if (_ && (mapLabelRaw(_).ignore = _.ignore, n.textConfig && c)) {
			var v = n.getBoundingRect().clone();
			n.textConfig.layoutRect = v, n.textConfig.position = [(c[0] - v.x) / v.width * 100 + "%", (c[1] - v.y) / v.height * 100 + "%"];
		}
		n.disableLabelAnimation = !0;
	} else n.removeTextContent(), n.removeTextConfig(), n.disableLabelAnimation = null;
}
function resetEventTriggerForRegion(t, n, r, a, o, s) {
	t.data ? t.data.setItemGraphicEl(s, n) : getECData(n).eventData = {
		componentType: "geo",
		componentIndex: o.componentIndex,
		geoIndex: o.componentIndex,
		name: r,
		region: a && a.option || {}
	};
}
function resetTooltipForRegion(t, n, r, a, o) {
	t.data || setTooltipConfig({
		el: n,
		componentModel: o,
		itemName: r,
		itemTooltipOption: a.get("tooltip")
	});
}
function resetStateTriggerForRegion(t, n, r, a, o) {
	n.highDownSilentOnTouch = !!o.get("selectedMode");
	var s = a.getModel("emphasis"), c = s.get("focus");
	return toggleHoverEmphasis(n, c, s.get("blurScope"), s.get("disabled")), t.isGeo && enableComponentHighDownFeatures(n, o, r), c;
}
function projectPolys(t, n, r) {
	var a = [], o;
	function s() {
		o = [];
	}
	function c() {
		o.length && (a.push(o), o = []);
	}
	var l = n({
		polygonStart: s,
		polygonEnd: c,
		lineStart: s,
		lineEnd: c,
		point: function(t, n) {
			isFinite(t) && isFinite(n) && o.push([t, n]);
		},
		sphere: function() {}
	});
	return !r && l.polygonStart(), each(t, function(t) {
		l.lineStart();
		for (var n = 0; n < t.length; n++) l.point(t[n][0], t[n][1]);
		l.lineEnd();
	}), !r && l.polygonEnd(), a;
}
var MapDraw_default = MapDraw, MapView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r, a) {
		if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) {
			var o = this.group;
			if (o.removeAll(), !t.getHostGeoModel()) {
				if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === t.id) {
					var s = this._mapDraw;
					s && o.add(s.group);
				} else if (t.needsDrawMap) {
					var s = this._mapDraw || new MapDraw_default(r);
					o.add(s.group), s.draw(t, n, r, this, a), this._mapDraw = s;
				} else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
				t.get("showLegendSymbol") && n.getComponent("legend") && this._renderSymbols(t, n, r);
			}
		}
	}, n.prototype.remove = function() {
		this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
	}, n.prototype.dispose = function() {
		this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
	}, n.prototype._renderSymbols = function(t, n, r) {
		var a = t.originalData, o = this.group;
		a.each(a.mapDimension("value"), function(n, r) {
			if (!isNaN(n)) {
				var s = a.getItemLayout(r);
				if (!(!s || !s.point)) {
					var c = s.point, l = s.offset, u = new Circle_default({
						style: { fill: t.getData().getVisual("style").fill },
						shape: {
							cx: c[0] + l * 9,
							cy: c[1],
							r: 3
						},
						silent: !0,
						z2: 8 + (l ? 0 : 11)
					});
					if (!l) {
						var d = t.mainSeries.getData(), f = a.getName(r), p = d.indexOfName(f), h = a.getItemModel(r), g = h.getModel("label"), _ = d.getItemGraphicEl(p);
						setLabelStyle(u, getLabelStatesModels(h), {
							labelFetcher: { getFormattedLabel: function(n, r) {
								return t.getFormattedLabel(p, r);
							} },
							defaultText: f
						}), u.disableLabelAnimation = !0, g.get("position") || u.setTextConfig({ position: "bottom" }), _.onHoverStateChange = function(t) {
							setStatesFlag(u, t);
						};
					}
					o.add(u);
				}
			}
		});
	}, n.type = "map", n;
}(Chart_default), MapSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.needsDrawMap = !1, r.seriesGroup = [], r.getTooltipPosition = function(t) {
			if (t != null) {
				var n = this.getData().getName(t), r = this.coordinateSystem, a = r.getRegion(n);
				return a && r.dataToPoint(a.getCenter());
			}
		}, r;
	}
	return n.prototype.getInitialData = function(t) {
		for (var n = createSeriesDataSimply(this, {
			coordDimensions: ["value"],
			encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
		}), r = createHashMap(), a = [], o = 0, s = n.count(); o < s; o++) {
			var c = n.getName(o);
			r.set(c, o);
		}
		return each(geoSourceManager_default.load(this.getMapType(), this.option.nameMap, this.option.nameProperty).regions, function(t) {
			var o = t.name, s = r.get(o), c = t.properties && t.properties.echartsStyle, l;
			s == null ? (l = { name: o }, a.push(l)) : l = n.getRawDataItem(s), c && merge(l, c);
		}), n.appendData(a), n;
	}, n.prototype.getHostGeoModel = function() {
		var t = this.option.geoIndex;
		return t == null ? null : this.ecModel.getComponent("geo", t);
	}, n.prototype.getMapType = function() {
		return (this.getHostGeoModel() || this).option.map;
	}, n.prototype.getRawValue = function(t) {
		var n = this.getData();
		return n.get(n.mapDimension("value"), t);
	}, n.prototype.getRegionModel = function(t) {
		var n = this.getData();
		return n.getItemModel(n.indexOfName(t));
	}, n.prototype.formatTooltip = function(t, n, r) {
		for (var a = this.getData(), o = this.getRawValue(t), s = a.getName(t), c = this.seriesGroup, l = [], u = 0; u < c.length; u++) {
			var d = c[u].originalData.indexOfName(s), f = a.mapDimension("value");
			isNaN(c[u].originalData.get(f, d)) || l.push(c[u].name);
		}
		return createTooltipMarkup("section", {
			header: l.join(", "),
			noHeader: !l.length,
			blocks: [createTooltipMarkup("nameValue", {
				name: s,
				value: o
			})]
		});
	}, n.prototype.setZoom = function(t) {
		this.option.zoom = t;
	}, n.prototype.setCenter = function(t) {
		this.option.center = t;
	}, n.prototype.getLegendIcon = function(t) {
		var n = t.icon || "roundRect", r = createSymbol(n, 0, 0, t.itemWidth, t.itemHeight, t.itemStyle.fill);
		return r.setStyle(t.itemStyle), r.style.stroke = "none", n.indexOf("empty") > -1 && (r.style.stroke = r.style.fill, r.style.fill = "#fff", r.style.lineWidth = 2), r;
	}, n.type = "series.map", n.dependencies = ["geo"], n.layoutMode = "box", n.defaultOption = {
		z: 2,
		coordinateSystem: "geo",
		map: "",
		left: "center",
		top: "center",
		aspectScale: null,
		showLegendSymbol: !0,
		boundingCoords: null,
		center: null,
		zoom: 1,
		scaleLimit: null,
		selectedMode: !0,
		label: {
			show: !1,
			color: "#000"
		},
		itemStyle: {
			borderWidth: .5,
			borderColor: "#444",
			areaColor: "#eee"
		},
		emphasis: {
			label: {
				show: !0,
				color: "rgb(100,0,0)"
			},
			itemStyle: { areaColor: "rgba(255,215,0,0.8)" }
		},
		select: {
			label: {
				show: !0,
				color: "rgb(100,0,0)"
			},
			itemStyle: { color: "rgba(255,215,0,0.8)" }
		},
		nameProperty: "name"
	}, n;
}(Series_default);
function dataStatistics(t, n) {
	var r = {};
	return each(t, function(t) {
		t.each(t.mapDimension("value"), function(n, a) {
			var o = "ec-" + t.getName(a);
			r[o] = r[o] || [], isNaN(n) || r[o].push(n);
		});
	}), t[0].map(t[0].mapDimension("value"), function(a, o) {
		for (var s = "ec-" + t[0].getName(o), c = 0, l = Infinity, u = -Infinity, d = r[s].length, f = 0; f < d; f++) l = Math.min(l, r[s][f]), u = Math.max(u, r[s][f]), c += r[s][f];
		var p = n === "min" ? l : n === "max" ? u : n === "average" ? c / d : c;
		return d === 0 ? NaN : p;
	});
}
function mapDataStatistic(t) {
	var n = {};
	t.eachSeriesByType("map", function(t) {
		var r = t.getHostGeoModel(), a = r ? "o" + r.id : "i" + t.getMapType();
		(n[a] = n[a] || []).push(t);
	}), each(n, function(t, n) {
		for (var r = dataStatistics(map(t, function(t) {
			return t.getData();
		}), t[0].get("mapValueCalculation")), a = 0; a < t.length; a++) t[a].originalData = t[a].getData();
		for (var a = 0; a < t.length; a++) t[a].seriesGroup = t, t[a].needsDrawMap = a === 0 && !t[a].getHostGeoModel(), t[a].setData(r.cloneShallow()), t[a].mainSeries = t[0];
	});
}
function mapSymbolLayout(t) {
	var n = {};
	t.eachSeriesByType("map", function(r) {
		var a = r.getMapType();
		if (!(r.getHostGeoModel() || n[a])) {
			var o = {};
			each(r.seriesGroup, function(n) {
				var r = n.coordinateSystem, a = n.originalData;
				n.get("showLegendSymbol") && t.getComponent("legend") && a.each(a.mapDimension("value"), function(t, n) {
					var s = a.getName(n), c = r.getRegion(s);
					if (!(!c || isNaN(t))) {
						var l = o[s] || 0, u = r.dataToPoint(c.getCenter());
						o[s] = l + 1, a.setItemLayout(n, {
							point: u,
							offset: l
						});
					}
				});
			});
			var s = r.getData();
			s.each(function(t) {
				var n = s.getName(t), r = s.getItemLayout(t) || {};
				r.showLabel = !o[n], s.setItemLayout(t, r);
			}), n[a] = !0;
		}
	});
}
var v2ApplyTransform = applyTransform, View = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this) || this;
		return r.type = "view", r.dimensions = ["x", "y"], r._roamTransformable = new Transformable_default(), r._rawTransformable = new Transformable_default(), r.name = n, r;
	}
	return n.prototype.setBoundingRect = function(t, n, r, a) {
		return this._rect = new BoundingRect_default(t, n, r, a), this._rect;
	}, n.prototype.getBoundingRect = function() {
		return this._rect;
	}, n.prototype.setViewRect = function(t, n, r, a) {
		this._transformTo(t, n, r, a), this._viewRect = new BoundingRect_default(t, n, r, a);
	}, n.prototype._transformTo = function(t, n, r, a) {
		var o = this.getBoundingRect(), s = this._rawTransformable;
		s.transform = o.calculateTransform(new BoundingRect_default(t, n, r, a));
		var c = s.parent;
		s.parent = null, s.decomposeTransform(), s.parent = c, this._updateTransform();
	}, n.prototype.setCenter = function(t, n) {
		t && (this._center = [parsePercent$1(t[0], n.getWidth()), parsePercent$1(t[1], n.getHeight())], this._updateCenterAndZoom());
	}, n.prototype.setZoom = function(t) {
		t ||= 1;
		var n = this.zoomLimit;
		n && (n.max != null && (t = Math.min(n.max, t)), n.min != null && (t = Math.max(n.min, t))), this._zoom = t, this._updateCenterAndZoom();
	}, n.prototype.getDefaultCenter = function() {
		var t = this.getBoundingRect();
		return [t.x + t.width / 2, t.y + t.height / 2];
	}, n.prototype.getCenter = function() {
		return this._center || this.getDefaultCenter();
	}, n.prototype.getZoom = function() {
		return this._zoom || 1;
	}, n.prototype.getRoamTransform = function() {
		return this._roamTransformable.getLocalTransform();
	}, n.prototype._updateCenterAndZoom = function() {
		var t = this._rawTransformable.getLocalTransform(), n = this._roamTransformable, r = this.getDefaultCenter(), a = this.getCenter(), o = this.getZoom();
		a = applyTransform([], a, t), r = applyTransform([], r, t), n.originX = a[0], n.originY = a[1], n.x = r[0] - a[0], n.y = r[1] - a[1], n.scaleX = n.scaleY = o, this._updateTransform();
	}, n.prototype._updateTransform = function() {
		var t = this._roamTransformable, n = this._rawTransformable;
		n.parent = t, t.updateTransform(), n.updateTransform(), copy(this.transform ||= [], n.transform || create$2()), this._rawTransform = n.getLocalTransform(), this.invTransform = this.invTransform || [], invert(this.invTransform, this.transform), this.decomposeTransform();
	}, n.prototype.getTransformInfo = function() {
		var t = this._rawTransformable, n = this._roamTransformable, r = new Transformable_default();
		return r.transform = n.transform, r.decomposeTransform(), {
			roam: {
				x: r.x,
				y: r.y,
				scaleX: r.scaleX,
				scaleY: r.scaleY
			},
			raw: {
				x: t.x,
				y: t.y,
				scaleX: t.scaleX,
				scaleY: t.scaleY
			}
		};
	}, n.prototype.getViewRect = function() {
		return this._viewRect;
	}, n.prototype.getViewRectAfterRoam = function() {
		var t = this.getBoundingRect().clone();
		return t.applyTransform(this.transform), t;
	}, n.prototype.dataToPoint = function(t, n, r) {
		var a = n ? this._rawTransform : this.transform;
		return r ||= [], a ? v2ApplyTransform(r, t, a) : copy$1(r, t);
	}, n.prototype.pointToData = function(t) {
		var n = this.invTransform;
		return n ? v2ApplyTransform([], t, n) : [t[0], t[1]];
	}, n.prototype.convertToPixel = function(t, n, r) {
		var a = getCoordSys$4(n);
		return a === this ? a.dataToPoint(r) : null;
	}, n.prototype.convertFromPixel = function(t, n, r) {
		var a = getCoordSys$4(n);
		return a === this ? a.pointToData(r) : null;
	}, n.prototype.containPoint = function(t) {
		return this.getViewRectAfterRoam().contain(t[0], t[1]);
	}, n.dimensions = ["x", "y"], n;
}(Transformable_default);
function getCoordSys$4(t) {
	var n = t.seriesModel;
	return n ? n.coordinateSystem : null;
}
var View_default = View;
init_dist$2();
var GEO_DEFAULT_PARAMS = {
	geoJSON: {
		aspectScale: .75,
		invertLongitute: !0
	},
	geoSVG: {
		aspectScale: 1,
		invertLongitute: !1
	}
}, geo2DDimensions = ["lng", "lat"], Geo = function(t) {
	__extends(n, t);
	function n(n, r, a) {
		var o = t.call(this, n) || this;
		o.dimensions = geo2DDimensions, o.type = "geo", o._nameCoordMap = createHashMap(), o.map = r;
		var c = a.projection, l = geoSourceManager_default.load(r, a.nameMap, a.nameProperty), u = geoSourceManager_default.getGeoResource(r), d = o.resourceType = u ? u.type : null, f = o.regions = l.regions, p = GEO_DEFAULT_PARAMS[u.type];
		o._regionsMap = l.regionsMap, o.regions = l.regions, process$1.env.NODE_ENV !== "production" && c && (d === "geoSVG" && (process$1.env.NODE_ENV !== "production" && warn("Map " + r + " with SVG source can't use projection. Only GeoJSON source supports projection."), c = null), c.project && c.unproject || (process$1.env.NODE_ENV !== "production" && warn("project and unproject must be both provided in the projeciton."), c = null)), o.projection = c;
		var h;
		if (c) for (var g = 0; g < f.length; g++) {
			var _ = f[g].getBoundingRect(c);
			h ||= _.clone(), h.union(_);
		}
		else h = l.boundingRect;
		return o.setBoundingRect(h.x, h.y, h.width, h.height), o.aspectScale = c ? 1 : retrieve2(a.aspectScale, p.aspectScale), o._invertLongitute = c ? !1 : p.invertLongitute, o;
	}
	return n.prototype._transformTo = function(t, n, r, a) {
		var o = this.getBoundingRect(), s = this._invertLongitute;
		o = o.clone(), s && (o.y = -o.y - o.height);
		var c = this._rawTransformable;
		c.transform = o.calculateTransform(new BoundingRect_default(t, n, r, a));
		var l = c.parent;
		c.parent = null, c.decomposeTransform(), c.parent = l, s && (c.scaleY = -c.scaleY), this._updateTransform();
	}, n.prototype.getRegion = function(t) {
		return this._regionsMap.get(t);
	}, n.prototype.getRegionByCoord = function(t) {
		for (var n = this.regions, r = 0; r < n.length; r++) {
			var a = n[r];
			if (a.type === "geoJSON" && a.contain(t)) return n[r];
		}
	}, n.prototype.addGeoCoord = function(t, n) {
		this._nameCoordMap.set(t, n);
	}, n.prototype.getGeoCoord = function(t) {
		var n = this._regionsMap.get(t);
		return this._nameCoordMap.get(t) || n && n.getCenter();
	}, n.prototype.dataToPoint = function(t, n, r) {
		if (isString(t) && (t = this.getGeoCoord(t)), t) {
			var a = this.projection;
			return a && (t = a.project(t)), t && this.projectedToPoint(t, n, r);
		}
	}, n.prototype.pointToData = function(t) {
		var n = this.projection;
		return n && (t = n.unproject(t)), t && this.pointToProjected(t);
	}, n.prototype.pointToProjected = function(n) {
		return t.prototype.pointToData.call(this, n);
	}, n.prototype.projectedToPoint = function(n, r, a) {
		return t.prototype.dataToPoint.call(this, n, r, a);
	}, n.prototype.convertToPixel = function(t, n, r) {
		var a = getCoordSys$3(n);
		return a === this ? a.dataToPoint(r) : null;
	}, n.prototype.convertFromPixel = function(t, n, r) {
		var a = getCoordSys$3(n);
		return a === this ? a.pointToData(r) : null;
	}, n;
}(View_default);
mixin(Geo, View_default);
function getCoordSys$3(t) {
	var n = t.geoModel, r = t.seriesModel;
	return n ? n.coordinateSystem : r ? r.coordinateSystem || (r.getReferringComponents("geo", SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;
}
var Geo_default = Geo;
init_dist$2();
function resizeGeo(t, n) {
	var r = t.get("boundingCoords");
	if (r != null) {
		var a = r[0], o = r[1];
		if (!(isFinite(a[0]) && isFinite(a[1]) && isFinite(o[0]) && isFinite(o[1]))) process$1.env.NODE_ENV !== "production" && console.error("Invalid boundingCoords");
		else {
			var c = this.projection;
			if (c) {
				var l = a[0], u = a[1], d = o[0], f = o[1];
				a = [Infinity, Infinity], o = [-Infinity, -Infinity];
				var p = function(t, n, r, s) {
					for (var l = r - t, u = s - n, d = 0; d <= 100; d++) {
						var f = d / 100, p = c.project([t + l * f, n + u * f]);
						min(a, a, p), max(o, o, p);
					}
				};
				p(l, u, d, u), p(d, u, d, f), p(d, f, l, f), p(l, f, d, u);
			}
			this.setBoundingRect(a[0], a[1], o[0] - a[0], o[1] - a[1]);
		}
	}
	var h = this.getBoundingRect(), g = t.get("layoutCenter"), _ = t.get("layoutSize"), v = n.getWidth(), y = n.getHeight(), b = h.width / h.height * this.aspectScale, x = !1, S, C;
	g && _ && (S = [parsePercent$1(g[0], v), parsePercent$1(g[1], y)], C = parsePercent$1(_, Math.min(v, y)), !isNaN(S[0]) && !isNaN(S[1]) && !isNaN(C) ? x = !0 : process$1.env.NODE_ENV !== "production" && console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead."));
	var w;
	if (x) w = {}, b > 1 ? (w.width = C, w.height = C / b) : (w.height = C, w.width = C * b), w.y = S[1] - w.height / 2, w.x = S[0] - w.width / 2;
	else {
		var T = t.getBoxLayoutParams();
		T.aspect = b, w = getLayoutRect(T, {
			width: v,
			height: y
		});
	}
	this.setViewRect(w.x, w.y, w.width, w.height), this.setCenter(t.get("center"), n), this.setZoom(t.get("zoom"));
}
function setGeoCoords(t, n) {
	each(n.get("geoCoord"), function(n, r) {
		t.addGeoCoord(r, n);
	});
}
var geoCreator_default = new (function() {
	function t() {
		this.dimensions = geo2DDimensions;
	}
	return t.prototype.create = function(t, n) {
		var r = [];
		function a(t) {
			return {
				nameProperty: t.get("nameProperty"),
				aspectScale: t.get("aspectScale"),
				projection: t.get("projection")
			};
		}
		t.eachComponent("geo", function(t, o) {
			var s = t.get("map"), c = new Geo_default(s + o, s, extend({ nameMap: t.get("nameMap") }, a(t)));
			c.zoomLimit = t.get("scaleLimit"), r.push(c), t.coordinateSystem = c, c.model = t, c.resize = resizeGeo, c.resize(t, n);
		}), t.eachSeries(function(t) {
			t.get("coordinateSystem") === "geo" && (t.coordinateSystem = r[t.get("geoIndex") || 0]);
		});
		var o = {};
		return t.eachSeriesByType("map", function(t) {
			if (!t.getHostGeoModel()) {
				var n = t.getMapType();
				o[n] = o[n] || [], o[n].push(t);
			}
		}), each(o, function(t, o) {
			var s = new Geo_default(o, o, extend({ nameMap: mergeAll(map(t, function(t) {
				return t.get("nameMap");
			})) }, a(t[0])));
			s.zoomLimit = retrieve.apply(null, map(t, function(t) {
				return t.get("scaleLimit");
			})), r.push(s), s.resize = resizeGeo, s.resize(t[0], n), each(t, function(t) {
				t.coordinateSystem = s, setGeoCoords(s, t);
			});
		}), r;
	}, t.prototype.getFilledRegions = function(t, n, r, a) {
		for (var o = (t || []).slice(), s = createHashMap(), c = 0; c < o.length; c++) s.set(o[c].name, o[c]);
		return each(geoSourceManager_default.load(n, r, a).regions, function(t) {
			var n = t.name, r = s.get(n), a = t.properties && t.properties.echartsStyle;
			r || (r = { name: n }, o.push(r)), a && merge(r, a);
		}), o;
	}, t;
}())(), GeoModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.init = function(t, n, r) {
		var a = geoSourceManager_default.getGeoResource(t.map);
		if (a && a.type === "geoJSON") {
			var o = t.itemStyle = t.itemStyle || {};
			"color" in o || (o.color = "#eee");
		}
		this.mergeDefaultAndTheme(t, r), defaultEmphasis(t, "label", ["show"]);
	}, n.prototype.optionUpdated = function() {
		var t = this, n = this.option;
		n.regions = geoCreator_default.getFilledRegions(n.regions, n.map, n.nameMap, n.nameProperty);
		var r = {};
		this._optionModelMap = reduce(n.regions || [], function(n, a) {
			var o = a.name;
			return o && (n.set(o, new Model_default(a, t, t.ecModel)), a.selected && (r[o] = !0)), n;
		}, createHashMap()), n.selectedMap ||= r;
	}, n.prototype.getRegionModel = function(t) {
		return this._optionModelMap.get(t) || new Model_default(null, this, this.ecModel);
	}, n.prototype.getFormattedLabel = function(t, n) {
		var r = this.getRegionModel(t), a = n === "normal" ? r.get(["label", "formatter"]) : r.get([
			"emphasis",
			"label",
			"formatter"
		]), o = { name: t };
		if (isFunction(a)) return o.status = n, a(o);
		if (isString(a)) return a.replace("{a}", t ?? "");
	}, n.prototype.setZoom = function(t) {
		this.option.zoom = t;
	}, n.prototype.setCenter = function(t) {
		this.option.center = t;
	}, n.prototype.select = function(t) {
		var n = this.option, r = n.selectedMode;
		if (r) {
			r !== "multiple" && (n.selectedMap = null);
			var a = n.selectedMap ||= {};
			a[t] = !0;
		}
	}, n.prototype.unSelect = function(t) {
		var n = this.option.selectedMap;
		n && (n[t] = !1);
	}, n.prototype.toggleSelected = function(t) {
		this[this.isSelected(t) ? "unSelect" : "select"](t);
	}, n.prototype.isSelected = function(t) {
		var n = this.option.selectedMap;
		return !!(n && n[t]);
	}, n.type = "geo", n.layoutMode = "box", n.defaultOption = {
		z: 0,
		show: !0,
		left: "center",
		top: "center",
		aspectScale: null,
		silent: !1,
		map: "",
		boundingCoords: null,
		center: null,
		zoom: 1,
		scaleLimit: null,
		label: {
			show: !1,
			color: "#000"
		},
		itemStyle: {
			borderWidth: .5,
			borderColor: "#444"
		},
		emphasis: {
			label: {
				show: !0,
				color: "rgb(100,0,0)"
			},
			itemStyle: { color: "rgba(255,215,0,0.8)" }
		},
		select: {
			label: {
				show: !0,
				color: "rgb(100,0,0)"
			},
			itemStyle: { color: "rgba(255,215,0,0.8)" }
		},
		regions: []
	}, n;
}(Component_default);
function getCenterCoord(t, n) {
	return t.pointToProjected ? t.pointToProjected(n) : t.pointToData(n);
}
function updateCenterAndZoom(t, n, r, a) {
	var o = t.getZoom(), s = t.getCenter(), c = n.zoom, l = t.projectedToPoint ? t.projectedToPoint(s) : t.dataToPoint(s);
	if (n.dx != null && n.dy != null && (l[0] -= n.dx, l[1] -= n.dy, t.setCenter(getCenterCoord(t, l), a)), c != null) {
		if (r) {
			var u = r.min || 0, d = r.max || Infinity;
			c = Math.max(Math.min(o * c, d), u) / o;
		}
		t.scaleX *= c, t.scaleY *= c;
		var f = (n.originX - t.x) * (c - 1), p = (n.originY - t.y) * (c - 1);
		t.x -= f, t.y -= p, t.updateTransform(), t.setCenter(getCenterCoord(t, l), a), t.setZoom(c * o);
	}
	return {
		center: t.getCenter(),
		zoom: t.getZoom()
	};
}
var GeoView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.focusBlurEnabled = !0, r;
	}
	return n.prototype.init = function(t, n) {
		this._api = n;
	}, n.prototype.render = function(t, n, r, a) {
		if (this._model = t, !t.get("show")) {
			this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
			return;
		}
		this._mapDraw ||= new MapDraw_default(r);
		var o = this._mapDraw;
		o.draw(t, n, r, this, a), o.group.on("click", this._handleRegionClick, this), o.group.silent = t.get("silent"), this.group.add(o.group), this.updateSelectStatus(t, n, r);
	}, n.prototype._handleRegionClick = function(t) {
		var n;
		findEventDispatcher(t.target, function(t) {
			return (n = getECData(t).eventData) != null;
		}, !0), n && this._api.dispatchAction({
			type: "geoToggleSelect",
			geoId: this._model.id,
			name: n.name
		});
	}, n.prototype.updateSelectStatus = function(t, n, r) {
		var a = this;
		this._mapDraw.group.traverse(function(t) {
			var n = getECData(t).eventData;
			if (n) return a._model.isSelected(n.name) ? r.enterSelect(t) : r.leaveSelect(t), !0;
		});
	}, n.prototype.findHighDownDispatchers = function(t) {
		return this._mapDraw && this._mapDraw.findHighDownDispatchers(t, this._model);
	}, n.prototype.dispose = function() {
		this._mapDraw && this._mapDraw.remove();
	}, n.type = "geo", n;
}(Component_default$1);
function registerMap$1(t, n, r) {
	geoSourceManager_default.registerMap(t, n, r);
}
function install$26(t) {
	t.registerCoordinateSystem("geo", geoCreator_default), t.registerComponentModel(GeoModel_default), t.registerComponentView(GeoView_default), t.registerImpl("registerMap", registerMap$1), t.registerImpl("getMap", function(t) {
		return geoSourceManager_default.getMapForUser(t);
	});
	function n(n, r) {
		r.update = "geo:updateSelectStatus", t.registerAction(r, function(t, r) {
			var a = {}, o = [];
			return r.eachComponent({
				mainType: "geo",
				query: t
			}, function(r) {
				r[n](t.name);
				var s = r.coordinateSystem;
				each(s.regions, function(t) {
					a[t.name] = r.isSelected(t.name) || !1;
				});
				var c = [];
				each(a, function(t, n) {
					a[n] && c.push(n);
				}), o.push({
					geoIndex: r.componentIndex,
					name: c
				});
			}), {
				selected: a,
				allSelected: o,
				name: t.name
			};
		});
	}
	n("toggleSelected", {
		type: "geoToggleSelect",
		event: "geoselectchanged"
	}), n("select", {
		type: "geoSelect",
		event: "geoselected"
	}), n("unSelect", {
		type: "geoUnSelect",
		event: "geounselected"
	}), t.registerAction({
		type: "geoRoam",
		event: "geoRoam",
		update: "updateTransform"
	}, function(t, n, r) {
		var a = t.componentType || "series";
		n.eachComponent({
			mainType: a,
			query: t
		}, function(n) {
			var o = n.coordinateSystem;
			if (o.type === "geo") {
				var s = updateCenterAndZoom(o, t, n.get("scaleLimit"), r);
				n.setCenter && n.setCenter(s.center), n.setZoom && n.setZoom(s.zoom), a === "series" && each(n.seriesGroup, function(t) {
					t.setCenter(s.center), t.setZoom(s.zoom);
				});
			}
		});
	});
}
function install$7(t) {
	use(install$26), t.registerChartView(MapView_default), t.registerSeriesModel(MapSeries_default), t.registerLayout(mapSymbolLayout), t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic), createLegacyDataSelectAction("map", t.registerAction);
}
function init$1(t) {
	var n = t;
	n.hierNode = {
		defaultAncestor: null,
		ancestor: n,
		prelim: 0,
		modifier: 0,
		change: 0,
		shift: 0,
		i: 0,
		thread: null
	};
	for (var r = [n], a, o; a = r.pop();) if (o = a.children, a.isExpand && o.length) for (var s = o.length - 1; s >= 0; s--) {
		var c = o[s];
		c.hierNode = {
			defaultAncestor: null,
			ancestor: c,
			prelim: 0,
			modifier: 0,
			change: 0,
			shift: 0,
			i: s,
			thread: null
		}, r.push(c);
	}
}
function firstWalk(t, n) {
	var r = t.isExpand ? t.children : [], a = t.parentNode.children, o = t.hierNode.i ? a[t.hierNode.i - 1] : null;
	if (r.length) {
		executeShifts(t);
		var s = (r[0].hierNode.prelim + r[r.length - 1].hierNode.prelim) / 2;
		o ? (t.hierNode.prelim = o.hierNode.prelim + n(t, o), t.hierNode.modifier = t.hierNode.prelim - s) : t.hierNode.prelim = s;
	} else o && (t.hierNode.prelim = o.hierNode.prelim + n(t, o));
	t.parentNode.hierNode.defaultAncestor = apportion(t, o, t.parentNode.hierNode.defaultAncestor || a[0], n);
}
function secondWalk(t) {
	var n = t.hierNode.prelim + t.parentNode.hierNode.modifier;
	t.setLayout({ x: n }, !0), t.hierNode.modifier += t.parentNode.hierNode.modifier;
}
function separation(t) {
	return arguments.length ? t : defaultSeparation;
}
function radialCoordinate(t, n) {
	return t -= Math.PI / 2, {
		x: n * Math.cos(t),
		y: n * Math.sin(t)
	};
}
function getViewRect$4(t, n) {
	return getLayoutRect(t.getBoxLayoutParams(), {
		width: n.getWidth(),
		height: n.getHeight()
	});
}
function executeShifts(t) {
	for (var n = t.children, r = n.length, a = 0, o = 0; --r >= 0;) {
		var s = n[r];
		s.hierNode.prelim += a, s.hierNode.modifier += a, o += s.hierNode.change, a += s.hierNode.shift + o;
	}
}
function apportion(t, n, r, a) {
	if (n) {
		for (var o = t, s = t, c = s.parentNode.children[0], l = n, u = o.hierNode.modifier, d = s.hierNode.modifier, f = c.hierNode.modifier, p = l.hierNode.modifier; l = nextRight(l), s = nextLeft(s), l && s;) {
			o = nextRight(o), c = nextLeft(c), o.hierNode.ancestor = t;
			var h = l.hierNode.prelim + p - s.hierNode.prelim - d + a(l, s);
			h > 0 && (moveSubtree(nextAncestor(l, t, r), t, h), d += h, u += h), p += l.hierNode.modifier, d += s.hierNode.modifier, u += o.hierNode.modifier, f += c.hierNode.modifier;
		}
		l && !nextRight(o) && (o.hierNode.thread = l, o.hierNode.modifier += p - u), s && !nextLeft(c) && (c.hierNode.thread = s, c.hierNode.modifier += d - f, r = t);
	}
	return r;
}
function nextRight(t) {
	var n = t.children;
	return n.length && t.isExpand ? n[n.length - 1] : t.hierNode.thread;
}
function nextLeft(t) {
	var n = t.children;
	return n.length && t.isExpand ? n[0] : t.hierNode.thread;
}
function nextAncestor(t, n, r) {
	return t.hierNode.ancestor.parentNode === n.parentNode ? t.hierNode.ancestor : r;
}
function moveSubtree(t, n, r) {
	var a = r / (n.hierNode.i - t.hierNode.i);
	n.hierNode.change -= a, n.hierNode.shift += r, n.hierNode.modifier += r, n.hierNode.prelim += r, t.hierNode.change += a;
}
function defaultSeparation(t, n) {
	return t.parentNode === n.parentNode ? 1 : 2;
}
init_dist$2();
var TreeEdgeShape = function() {
	function t() {
		this.parentPoint = [], this.childPoints = [];
	}
	return t;
}(), TreePath = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	}, n.prototype.getDefaultShape = function() {
		return new TreeEdgeShape();
	}, n.prototype.buildPath = function(t, n) {
		var r = n.childPoints, a = r.length, o = n.parentPoint, s = r[0], c = r[a - 1];
		if (a === 1) {
			t.moveTo(o[0], o[1]), t.lineTo(s[0], s[1]);
			return;
		}
		var l = n.orient, u = l === "TB" || l === "BT" ? 0 : 1, d = 1 - u, f = parsePercent$1(n.forkPosition, 1), p = [];
		p[u] = o[u], p[d] = o[d] + (c[d] - o[d]) * f, t.moveTo(o[0], o[1]), t.lineTo(p[0], p[1]), t.moveTo(s[0], s[1]), p[u] = s[u], t.lineTo(p[0], p[1]), p[u] = c[u], t.lineTo(p[0], p[1]), t.lineTo(c[0], c[1]);
		for (var h = 1; h < a - 1; h++) {
			var g = r[h];
			t.moveTo(g[0], g[1]), p[u] = g[u], t.lineTo(p[0], p[1]);
		}
	}, n;
}(Path_default), TreeView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r._mainGroup = new Group_default(), r;
	}
	return n.prototype.init = function(t, n) {
		this._controller = new RoamController_default(n.getZr()), this._controllerHost = { target: this.group }, this.group.add(this._mainGroup);
	}, n.prototype.render = function(t, n, r) {
		var a = t.getData(), o = t.layoutInfo, s = this._mainGroup;
		t.get("layout") === "radial" ? (s.x = o.x + o.width / 2, s.y = o.y + o.height / 2) : (s.x = o.x, s.y = o.y), this._updateViewCoordSys(t, r), this._updateController(t, n, r);
		var c = this._data;
		a.diff(c).add(function(n) {
			symbolNeedsDraw(a, n) && updateNode(a, n, null, s, t);
		}).update(function(n, r) {
			var o = c.getItemGraphicEl(r);
			if (!symbolNeedsDraw(a, n)) {
				o && removeNode(c, r, o, s, t);
				return;
			}
			updateNode(a, n, o, s, t);
		}).remove(function(n) {
			var r = c.getItemGraphicEl(n);
			r && removeNode(c, n, r, s, t);
		}).execute(), this._nodeScaleRatio = t.get("nodeScaleRatio"), this._updateNodeAndLinkScale(t), t.get("expandAndCollapse") === !0 && a.eachItemGraphicEl(function(n, a) {
			n.off("click").on("click", function() {
				r.dispatchAction({
					type: "treeExpandAndCollapse",
					seriesId: t.id,
					dataIndex: a
				});
			});
		}), this._data = a;
	}, n.prototype._updateViewCoordSys = function(t, n) {
		var r = t.getData(), a = [];
		r.each(function(t) {
			var n = r.getItemLayout(t);
			n && !isNaN(n.x) && !isNaN(n.y) && a.push([+n.x, +n.y]);
		});
		var o = [], s = [];
		fromPoints(a, o, s);
		var c = this._min, l = this._max;
		s[0] - o[0] === 0 && (o[0] = c ? c[0] : o[0] - 1, s[0] = l ? l[0] : s[0] + 1), s[1] - o[1] === 0 && (o[1] = c ? c[1] : o[1] - 1, s[1] = l ? l[1] : s[1] + 1);
		var u = t.coordinateSystem = new View_default();
		u.zoomLimit = t.get("scaleLimit"), u.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]), u.setCenter(t.get("center"), n), u.setZoom(t.get("zoom")), this.group.attr({
			x: u.x,
			y: u.y,
			scaleX: u.scaleX,
			scaleY: u.scaleY
		}), this._min = o, this._max = s;
	}, n.prototype._updateController = function(t, n, r) {
		var a = this, o = this._controller, s = this._controllerHost, c = this.group;
		o.setPointerChecker(function(n, a, o) {
			var s = c.getBoundingRect();
			return s.applyTransform(c.transform), s.contain(a, o) && !onIrrelevantElement(n, r, t);
		}), o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(n) {
			updateViewOnPan(s, n.dx, n.dy), r.dispatchAction({
				seriesId: t.id,
				type: "treeRoam",
				dx: n.dx,
				dy: n.dy
			});
		}).on("zoom", function(n) {
			updateViewOnZoom(s, n.scale, n.originX, n.originY), r.dispatchAction({
				seriesId: t.id,
				type: "treeRoam",
				zoom: n.scale,
				originX: n.originX,
				originY: n.originY
			}), a._updateNodeAndLinkScale(t), r.updateLabelLayout();
		});
	}, n.prototype._updateNodeAndLinkScale = function(t) {
		var n = t.getData(), r = this._getNodeGlobalScale(t);
		n.eachItemGraphicEl(function(t, n) {
			t.setSymbolScale(r);
		});
	}, n.prototype._getNodeGlobalScale = function(t) {
		var n = t.coordinateSystem;
		if (n.type !== "view") return 1;
		var r = this._nodeScaleRatio, a = n.scaleX || 1;
		return ((n.getZoom() - 1) * r + 1) / a;
	}, n.prototype.dispose = function() {
		this._controller && this._controller.dispose(), this._controllerHost = null;
	}, n.prototype.remove = function() {
		this._mainGroup.removeAll(), this._data = null;
	}, n.type = "tree", n;
}(Chart_default);
function symbolNeedsDraw(t, n) {
	var r = t.getItemLayout(n);
	return r && !isNaN(r.x) && !isNaN(r.y);
}
function updateNode(t, n, r, a, o) {
	var s = !r, c = t.tree.getNodeByDataIndex(n), l = c.getModel(), u = c.getVisual("style").fill, d = c.isExpand === !1 && c.children.length !== 0 ? u : "#fff", f = t.tree.root, p = c.parentNode === f ? c : c.parentNode || c, h = t.getItemGraphicEl(p.dataIndex), g = p.getLayout(), _ = h ? {
		x: h.__oldX,
		y: h.__oldY,
		rawX: h.__radialOldRawX,
		rawY: h.__radialOldRawY
	} : g, v = c.getLayout();
	s ? (r = new Symbol_default(t, n, null, {
		symbolInnerColor: d,
		useNameLabel: !0
	}), r.x = _.x, r.y = _.y) : r.updateData(t, n, null, {
		symbolInnerColor: d,
		useNameLabel: !0
	}), r.__radialOldRawX = r.__radialRawX, r.__radialOldRawY = r.__radialRawY, r.__radialRawX = v.rawX, r.__radialRawY = v.rawY, a.add(r), t.setItemGraphicEl(n, r), r.__oldX = r.x, r.__oldY = r.y, updateProps(r, {
		x: v.x,
		y: v.y
	}, o);
	var y = r.getSymbolPath();
	if (o.get("layout") === "radial") {
		var b = f.children[0], x = b.getLayout(), S = b.children.length, C = void 0, w = void 0;
		if (v.x === x.x && c.isExpand === !0 && b.children.length) {
			var T = {
				x: (b.children[0].getLayout().x + b.children[S - 1].getLayout().x) / 2,
				y: (b.children[0].getLayout().y + b.children[S - 1].getLayout().y) / 2
			};
			C = Math.atan2(T.y - x.y, T.x - x.x), C < 0 && (C = Math.PI * 2 + C), w = T.x < x.x, w && (C -= Math.PI);
		} else C = Math.atan2(v.y - x.y, v.x - x.x), C < 0 && (C = Math.PI * 2 + C), c.children.length === 0 || c.children.length !== 0 && c.isExpand === !1 ? (w = v.x < x.x, w && (C -= Math.PI)) : (w = v.x > x.x, w || (C -= Math.PI));
		var E = w ? "left" : "right", D = l.getModel("label"), O = D.get("rotate"), A = O * (Math.PI / 180), j = y.getTextContent();
		j && (y.setTextConfig({
			position: D.get("position") || E,
			rotation: O == null ? -C : A,
			origin: "center"
		}), j.setStyle("verticalAlign", "middle"));
	}
	var M = l.get(["emphasis", "focus"]), N = M === "relative" ? concatArray(c.getAncestorsIndices(), c.getDescendantIndices()) : M === "ancestor" ? c.getAncestorsIndices() : M === "descendant" ? c.getDescendantIndices() : null;
	N && (getECData(r).focus = N), drawEdge(o, c, f, r, _, g, v, a), r.__edge && (r.onHoverStateChange = function(n) {
		if (n !== "blur") {
			var a = c.parentNode && t.getItemGraphicEl(c.parentNode.dataIndex);
			a && a.hoverState === 1 || setStatesFlag(r.__edge, n);
		}
	});
}
function drawEdge(t, n, r, a, o, c, l, u) {
	var d = n.getModel(), f = t.get("edgeShape"), p = t.get("layout"), h = t.getOrient(), g = t.get(["lineStyle", "curveness"]), _ = t.get("edgeForkPosition"), v = d.getModel("lineStyle").getLineStyle(), y = a.__edge;
	if (f === "curve") n.parentNode && n.parentNode !== r && (y ||= a.__edge = new BezierCurve_default({ shape: getEdgeShape(p, h, g, o, o) }), updateProps(y, { shape: getEdgeShape(p, h, g, c, l) }, t));
	else if (f === "polyline") {
		if (p === "orthogonal") {
			if (n !== r && n.children && n.children.length !== 0 && n.isExpand === !0) {
				for (var b = n.children, x = [], S = 0; S < b.length; S++) {
					var C = b[S].getLayout();
					x.push([C.x, C.y]);
				}
				y ||= a.__edge = new TreePath({ shape: {
					parentPoint: [l.x, l.y],
					childPoints: [[l.x, l.y]],
					orient: h,
					forkPosition: _
				} }), updateProps(y, { shape: {
					parentPoint: [l.x, l.y],
					childPoints: x
				} }, t);
			}
		} else if (process$1.env.NODE_ENV !== "production") throw Error("The polyline edgeShape can only be used in orthogonal layout");
	}
	y && !(f === "polyline" && !n.isExpand) && (y.useStyle(defaults({
		strokeNoScale: !0,
		fill: null
	}, v)), setStatesStylesFromModel(y, d, "lineStyle"), setDefaultStateProxy(y), u.add(y));
}
function removeNodeEdge(t, n, r, a, o) {
	var s = n.tree.root, c = getSourceNode(s, t), l = c.source, u = c.sourceLayout, d = n.getItemGraphicEl(t.dataIndex);
	if (d) {
		var f = n.getItemGraphicEl(l.dataIndex).__edge, p = d.__edge || (l.isExpand === !1 || l.children.length === 1 ? f : void 0), h = a.get("edgeShape"), g = a.get("layout"), _ = a.get("orient"), v = a.get(["lineStyle", "curveness"]);
		p && (h === "curve" ? removeElement(p, {
			shape: getEdgeShape(g, _, v, u, u),
			style: { opacity: 0 }
		}, a, {
			cb: function() {
				r.remove(p);
			},
			removeOpt: o
		}) : h === "polyline" && a.get("layout") === "orthogonal" && removeElement(p, {
			shape: {
				parentPoint: [u.x, u.y],
				childPoints: [[u.x, u.y]]
			},
			style: { opacity: 0 }
		}, a, {
			cb: function() {
				r.remove(p);
			},
			removeOpt: o
		}));
	}
}
function getSourceNode(t, n) {
	for (var r = n.parentNode === t ? n : n.parentNode || n, a; a = r.getLayout(), a == null;) r = r.parentNode === t ? r : r.parentNode || r;
	return {
		source: r,
		sourceLayout: a
	};
}
function removeNode(t, n, r, a, o) {
	var s = t.tree.getNodeByDataIndex(n), c = t.tree.root, l = getSourceNode(c, s).sourceLayout, u = {
		duration: o.get("animationDurationUpdate"),
		easing: o.get("animationEasingUpdate")
	};
	removeElement(r, {
		x: l.x + 1,
		y: l.y + 1
	}, o, {
		cb: function() {
			a.remove(r), t.setItemGraphicEl(n, null);
		},
		removeOpt: u
	}), r.fadeOut(null, t.hostModel, {
		fadeLabel: !0,
		animation: u
	}), s.children.forEach(function(n) {
		removeNodeEdge(n, t, a, o, u);
	}), removeNodeEdge(s, t, a, o, u);
}
function getEdgeShape(t, n, r, a, o) {
	var s, c, l, u, d, f, p, h;
	if (t === "radial") {
		d = a.rawX, p = a.rawY, f = o.rawX, h = o.rawY;
		var g = radialCoordinate(d, p), _ = radialCoordinate(d, p + (h - p) * r), v = radialCoordinate(f, h + (p - h) * r), y = radialCoordinate(f, h);
		return {
			x1: g.x || 0,
			y1: g.y || 0,
			x2: y.x || 0,
			y2: y.y || 0,
			cpx1: _.x || 0,
			cpy1: _.y || 0,
			cpx2: v.x || 0,
			cpy2: v.y || 0
		};
	} else d = a.x, p = a.y, f = o.x, h = o.y, (n === "LR" || n === "RL") && (s = d + (f - d) * r, c = p, l = f + (d - f) * r, u = h), (n === "TB" || n === "BT") && (s = d, c = p + (h - p) * r, l = f, u = h + (p - h) * r);
	return {
		x1: d,
		y1: p,
		x2: f,
		y2: h,
		cpx1: s,
		cpy1: c,
		cpx2: l,
		cpy2: u
	};
}
var TreeView_default = TreeView, inner$14 = makeInner();
function linkSeriesData(t) {
	var n = t.mainData, r = t.datas;
	r || (r = { main: n }, t.datasAttr = { main: "data" }), t.datas = t.mainData = null, linkAll(n, r, t), each(r, function(r) {
		each(n.TRANSFERABLE_METHODS, function(n) {
			r.wrapMethod(n, curry(transferInjection, t));
		});
	}), n.wrapMethod("cloneShallow", curry(cloneShallowInjection, t)), each(n.CHANGABLE_METHODS, function(r) {
		n.wrapMethod(r, curry(changeInjection, t));
	}), assert(r[n.dataType] === n);
}
function transferInjection(t, n) {
	if (isMainData(this)) {
		var r = extend({}, inner$14(this).datas);
		r[this.dataType] = n, linkAll(n, r, t);
	} else linkSingle(n, this.dataType, inner$14(this).mainData, t);
	return n;
}
function changeInjection(t, n) {
	return t.struct && t.struct.update(), n;
}
function cloneShallowInjection(t, n) {
	return each(inner$14(n).datas, function(r, a) {
		r !== n && linkSingle(r.cloneShallow(), a, n, t);
	}), n;
}
function getLinkedData(t) {
	var n = inner$14(this).mainData;
	return t == null || n == null ? n : inner$14(n).datas[t];
}
function getLinkedDataAll() {
	var t = inner$14(this).mainData;
	return t == null ? [{ data: t }] : map(keys(inner$14(t).datas), function(n) {
		return {
			type: n,
			data: inner$14(t).datas[n]
		};
	});
}
function isMainData(t) {
	return inner$14(t).mainData === t;
}
function linkAll(t, n, r) {
	inner$14(t).datas = {}, each(n, function(n, a) {
		linkSingle(n, a, t, r);
	});
}
function linkSingle(t, n, r, a) {
	inner$14(r).datas[n] = t, inner$14(t).mainData = r, t.dataType = n, a.struct && (t[a.structAttr] = a.struct, a.struct[a.datasAttr[n]] = t), t.getLinkedData = getLinkedData, t.getLinkedDataAll = getLinkedDataAll;
}
var linkSeriesData_default = linkSeriesData, TreeNode = function() {
	function t(t, n) {
		this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = t || "", this.hostTree = n;
	}
	return t.prototype.isRemoved = function() {
		return this.dataIndex < 0;
	}, t.prototype.eachNode = function(t, n, r) {
		isFunction(t) && (r = n, n = t, t = null), t ||= {}, isString(t) && (t = { order: t });
		var a = t.order || "preorder", o = this[t.attr || "children"], s;
		a === "preorder" && (s = n.call(r, this));
		for (var c = 0; !s && c < o.length; c++) o[c].eachNode(t, n, r);
		a === "postorder" && n.call(r, this);
	}, t.prototype.updateDepthAndHeight = function(t) {
		var n = 0;
		this.depth = t;
		for (var r = 0; r < this.children.length; r++) {
			var a = this.children[r];
			a.updateDepthAndHeight(t + 1), a.height > n && (n = a.height);
		}
		this.height = n + 1;
	}, t.prototype.getNodeById = function(t) {
		if (this.getId() === t) return this;
		for (var n = 0, r = this.children, a = r.length; n < a; n++) {
			var o = r[n].getNodeById(t);
			if (o) return o;
		}
	}, t.prototype.contains = function(t) {
		if (t === this) return !0;
		for (var n = 0, r = this.children, a = r.length; n < a; n++) {
			var o = r[n].contains(t);
			if (o) return o;
		}
	}, t.prototype.getAncestors = function(t) {
		for (var n = [], r = t ? this : this.parentNode; r;) n.push(r), r = r.parentNode;
		return n.reverse(), n;
	}, t.prototype.getAncestorsIndices = function() {
		for (var t = [], n = this; n;) t.push(n.dataIndex), n = n.parentNode;
		return t.reverse(), t;
	}, t.prototype.getDescendantIndices = function() {
		var t = [];
		return this.eachNode(function(n) {
			t.push(n.dataIndex);
		}), t;
	}, t.prototype.getValue = function(t) {
		var n = this.hostTree.data;
		return n.getStore().get(n.getDimensionIndex(t || "value"), this.dataIndex);
	}, t.prototype.setLayout = function(t, n) {
		this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, n);
	}, t.prototype.getLayout = function() {
		return this.hostTree.data.getItemLayout(this.dataIndex);
	}, t.prototype.getModel = function(t) {
		if (!(this.dataIndex < 0)) return this.hostTree.data.getItemModel(this.dataIndex).getModel(t);
	}, t.prototype.getLevelModel = function() {
		return (this.hostTree.levelModels || [])[this.depth];
	}, t.prototype.setVisual = function(t, n) {
		this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, n);
	}, t.prototype.getVisual = function(t) {
		return this.hostTree.data.getItemVisual(this.dataIndex, t);
	}, t.prototype.getRawIndex = function() {
		return this.hostTree.data.getRawIndex(this.dataIndex);
	}, t.prototype.getId = function() {
		return this.hostTree.data.getId(this.dataIndex);
	}, t.prototype.getChildIndex = function() {
		if (this.parentNode) {
			for (var t = this.parentNode.children, n = 0; n < t.length; ++n) if (t[n] === this) return n;
			return -1;
		}
		return -1;
	}, t.prototype.isAncestorOf = function(t) {
		for (var n = t.parentNode; n;) {
			if (n === this) return !0;
			n = n.parentNode;
		}
		return !1;
	}, t.prototype.isDescendantOf = function(t) {
		return t !== this && t.isAncestorOf(this);
	}, t;
}(), Tree = function() {
	function t(t) {
		this.type = "tree", this._nodes = [], this.hostModel = t;
	}
	return t.prototype.eachNode = function(t, n, r) {
		this.root.eachNode(t, n, r);
	}, t.prototype.getNodeByDataIndex = function(t) {
		var n = this.data.getRawIndex(t);
		return this._nodes[n];
	}, t.prototype.getNodeById = function(t) {
		return this.root.getNodeById(t);
	}, t.prototype.update = function() {
		for (var t = this.data, n = this._nodes, r = 0, a = n.length; r < a; r++) n[r].dataIndex = -1;
		for (var r = 0, a = t.count(); r < a; r++) n[t.getRawIndex(r)].dataIndex = r;
	}, t.prototype.clearLayouts = function() {
		this.data.clearItemLayouts();
	}, t.createTree = function(n, r, a) {
		var o = new t(r), s = [], c = 1;
		l(n);
		function l(t, n) {
			var r = t.value;
			c = Math.max(c, isArray(r) ? r.length : 1), s.push(t);
			var a = new TreeNode(convertOptionIdName(t.name, ""), o);
			n ? addChild(a, n) : o.root = a, o._nodes.push(a);
			var u = t.children;
			if (u) for (var d = 0; d < u.length; d++) l(u[d], a);
		}
		o.root.updateDepthAndHeight(0);
		var u = prepareSeriesDataSchema(s, {
			coordDimensions: ["value"],
			dimensionsCount: c
		}).dimensions, d = new SeriesData_default(u, r);
		return d.initData(s), a && a(d), linkSeriesData_default({
			mainData: d,
			struct: o,
			structAttr: "tree"
		}), o.update(), o;
	}, t;
}();
function addChild(t, n) {
	var r = n.children;
	t.parentNode !== n && (r.push(t), t.parentNode = n);
}
var Tree_default = Tree;
function retrieveTargetInfo(t, n, r) {
	if (t && indexOf(n, t.type) >= 0) {
		var a = r.getData().tree.root, o = t.targetNode;
		if (isString(o) && (o = a.getNodeById(o)), o && a.contains(o)) return { node: o };
		var s = t.targetNodeId;
		if (s != null && (o = a.getNodeById(s))) return { node: o };
	}
}
function getPathToRoot(t) {
	for (var n = []; t;) t = t.parentNode, t && n.push(t);
	return n.reverse();
}
function aboveViewRoot(t, n) {
	return indexOf(getPathToRoot(t), n) >= 0;
}
function wrapTreePathInfo(t, n) {
	for (var r = []; t;) {
		var a = t.dataIndex;
		r.push({
			name: t.name,
			dataIndex: a,
			value: n.getRawValue(a)
		}), t = t.parentNode;
	}
	return r.reverse(), r;
}
var TreeSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n.hasSymbolVisual = !0, n.ignoreStyleOnData = !0, n;
	}
	return n.prototype.getInitialData = function(t) {
		var n = {
			name: t.name,
			children: t.data
		}, r = new Model_default(t.leaves || {}, this, this.ecModel), a = Tree_default.createTree(n, this, o);
		function o(t) {
			t.wrapMethod("getItemModel", function(t, n) {
				var o = a.getNodeByDataIndex(n);
				return o && o.children.length && o.isExpand || (t.parentModel = r), t;
			});
		}
		var s = 0;
		a.eachNode("preorder", function(t) {
			t.depth > s && (s = t.depth);
		});
		var c = t.expandAndCollapse && t.initialTreeDepth >= 0 ? t.initialTreeDepth : s;
		return a.root.eachNode("preorder", function(t) {
			var n = t.hostTree.data.getRawDataItem(t.dataIndex);
			t.isExpand = n && n.collapsed != null ? !n.collapsed : t.depth <= c;
		}), a.data;
	}, n.prototype.getOrient = function() {
		var t = this.get("orient");
		return t === "horizontal" ? t = "LR" : t === "vertical" && (t = "TB"), t;
	}, n.prototype.setZoom = function(t) {
		this.option.zoom = t;
	}, n.prototype.setCenter = function(t) {
		this.option.center = t;
	}, n.prototype.formatTooltip = function(t, n, r) {
		for (var a = this.getData().tree, o = a.root.children[0], s = a.getNodeByDataIndex(t), c = s.getValue(), l = s.name; s && s !== o;) l = s.parentNode.name + "." + l, s = s.parentNode;
		return createTooltipMarkup("nameValue", {
			name: l,
			value: c,
			noValue: isNaN(c) || c == null
		});
	}, n.prototype.getDataParams = function(n) {
		var r = t.prototype.getDataParams.apply(this, arguments), a = this.getData().tree.getNodeByDataIndex(n);
		return r.treeAncestors = wrapTreePathInfo(a, this), r.collapsed = !a.isExpand, r;
	}, n.type = "series.tree", n.layoutMode = "box", n.defaultOption = {
		z: 2,
		coordinateSystem: "view",
		left: "12%",
		top: "12%",
		right: "12%",
		bottom: "12%",
		layout: "orthogonal",
		edgeShape: "curve",
		edgeForkPosition: "50%",
		roam: !1,
		nodeScaleRatio: .4,
		center: null,
		zoom: 1,
		orient: "LR",
		symbol: "emptyCircle",
		symbolSize: 7,
		expandAndCollapse: !0,
		initialTreeDepth: 2,
		lineStyle: {
			color: "#ccc",
			width: 1.5,
			curveness: .5
		},
		itemStyle: {
			color: "lightsteelblue",
			borderWidth: 1.5
		},
		label: { show: !0 },
		animationEasing: "linear",
		animationDuration: 700,
		animationDurationUpdate: 500
	}, n;
}(Series_default);
function eachAfter(t, n, r) {
	for (var a = [t], o = [], s; s = a.pop();) if (o.push(s), s.isExpand) {
		var c = s.children;
		if (c.length) for (var l = 0; l < c.length; l++) a.push(c[l]);
	}
	for (; s = o.pop();) n(s, r);
}
function eachBefore(t, n) {
	for (var r = [t], a; a = r.pop();) if (n(a), a.isExpand) {
		var o = a.children;
		if (o.length) for (var s = o.length - 1; s >= 0; s--) r.push(o[s]);
	}
}
function treeLayout(t, n) {
	t.eachSeriesByType("tree", function(t) {
		commonLayout(t, n);
	});
}
function commonLayout(t, n) {
	var r = getViewRect$4(t, n);
	t.layoutInfo = r;
	var a = t.get("layout"), o = 0, s = 0, c = null;
	a === "radial" ? (o = 2 * Math.PI, s = Math.min(r.height, r.width) / 2, c = separation(function(t, n) {
		return (t.parentNode === n.parentNode ? 1 : 2) / t.depth;
	})) : (o = r.width, s = r.height, c = separation());
	var l = t.getData().tree.root, u = l.children[0];
	if (u) {
		init$1(l), eachAfter(u, firstWalk, c), l.hierNode.modifier = -u.hierNode.prelim, eachBefore(u, secondWalk);
		var d = u, f = u, p = u;
		eachBefore(u, function(t) {
			var n = t.getLayout().x;
			n < d.getLayout().x && (d = t), n > f.getLayout().x && (f = t), t.depth > p.depth && (p = t);
		});
		var h = d === f ? 1 : c(d, f) / 2, g = h - d.getLayout().x, _ = 0, v = 0, y = 0, b = 0;
		if (a === "radial") _ = o / (f.getLayout().x + h + g), v = s / (p.depth - 1 || 1), eachBefore(u, function(t) {
			y = (t.getLayout().x + g) * _, b = (t.depth - 1) * v;
			var n = radialCoordinate(y, b);
			t.setLayout({
				x: n.x,
				y: n.y,
				rawX: y,
				rawY: b
			}, !0);
		});
		else {
			var x = t.getOrient();
			x === "RL" || x === "LR" ? (v = s / (f.getLayout().x + h + g), _ = o / (p.depth - 1 || 1), eachBefore(u, function(t) {
				b = (t.getLayout().x + g) * v, y = x === "LR" ? (t.depth - 1) * _ : o - (t.depth - 1) * _, t.setLayout({
					x: y,
					y: b
				}, !0);
			})) : (x === "TB" || x === "BT") && (_ = o / (f.getLayout().x + h + g), v = s / (p.depth - 1 || 1), eachBefore(u, function(t) {
				y = (t.getLayout().x + g) * _, b = x === "TB" ? (t.depth - 1) * v : s - (t.depth - 1) * v, t.setLayout({
					x: y,
					y: b
				}, !0);
			}));
		}
	}
}
function treeVisual(t) {
	t.eachSeriesByType("tree", function(t) {
		var n = t.getData();
		n.tree.eachNode(function(t) {
			var r = t.getModel().getModel("itemStyle").getItemStyle();
			extend(n.ensureUniqueItemVisual(t.dataIndex, "style"), r);
		});
	});
}
function installTreeAction(t) {
	t.registerAction({
		type: "treeExpandAndCollapse",
		event: "treeExpandAndCollapse",
		update: "update"
	}, function(t, n) {
		n.eachComponent({
			mainType: "series",
			subType: "tree",
			query: t
		}, function(n) {
			var r = t.dataIndex, a = n.getData().tree.getNodeByDataIndex(r);
			a.isExpand = !a.isExpand;
		});
	}), t.registerAction({
		type: "treeRoam",
		event: "treeRoam",
		update: "none"
	}, function(t, n, r) {
		n.eachComponent({
			mainType: "series",
			subType: "tree",
			query: t
		}, function(n) {
			var a = n.coordinateSystem, o = updateCenterAndZoom(a, t, void 0, r);
			n.setCenter && n.setCenter(o.center), n.setZoom && n.setZoom(o.zoom);
		});
	});
}
function install$8(t) {
	t.registerChartView(TreeView_default), t.registerSeriesModel(TreeSeries_default), t.registerLayout(treeLayout), t.registerVisual(treeVisual), installTreeAction(t);
}
var actionTypes = [
	"treemapZoomToNode",
	"treemapRender",
	"treemapMove"
];
function installTreemapAction(t) {
	for (var n = 0; n < actionTypes.length; n++) t.registerAction({
		type: actionTypes[n],
		update: "updateView"
	}, noop);
	t.registerAction({
		type: "treemapRootToNode",
		update: "updateView"
	}, function(t, n) {
		n.eachComponent({
			mainType: "series",
			subType: "treemap",
			query: t
		}, r);
		function r(n, r) {
			var a = retrieveTargetInfo(t, ["treemapZoomToNode", "treemapRootToNode"], n);
			if (a) {
				var o = n.getViewRoot();
				o && (t.direction = aboveViewRoot(o, a.node) ? "rollUp" : "drillDown"), n.resetViewRoot(a.node);
			}
		}
	});
}
function enableAriaDecalForTree(t) {
	var n = t.getData().tree, r = {};
	n.eachNode(function(n) {
		for (var a = n; a && a.depth > 1;) a = a.parentNode;
		var o = getDecalFromPalette(t.ecModel, a.name || a.dataIndex + "", r);
		n.setVisual("decal", o);
	});
}
var TreemapSeriesModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.preventUsingHoverLayer = !0, r;
	}
	return n.prototype.getInitialData = function(t, n) {
		var r = {
			name: t.name,
			children: t.data
		};
		completeTreeValue$1(r);
		var a = t.levels || [], o = new Model_default({ itemStyle: this.designatedVisualItemStyle = {} }, this, n);
		a = t.levels = setDefault(a, n);
		var s = map(a || [], function(t) {
			return new Model_default(t, o, n);
		}, this), c = Tree_default.createTree(r, this, l);
		function l(t) {
			t.wrapMethod("getItemModel", function(t, n) {
				var r = c.getNodeByDataIndex(n);
				return t.parentModel = (r ? s[r.depth] : null) || o, t;
			});
		}
		return c.data;
	}, n.prototype.optionUpdated = function() {
		this.resetViewRoot();
	}, n.prototype.formatTooltip = function(t, n, r) {
		var a = this.getData(), o = this.getRawValue(t);
		return createTooltipMarkup("nameValue", {
			name: a.getName(t),
			value: o
		});
	}, n.prototype.getDataParams = function(n) {
		var r = t.prototype.getDataParams.apply(this, arguments);
		return r.treeAncestors = wrapTreePathInfo(this.getData().tree.getNodeByDataIndex(n), this), r.treePathInfo = r.treeAncestors, r;
	}, n.prototype.setLayoutInfo = function(t) {
		this.layoutInfo = this.layoutInfo || {}, extend(this.layoutInfo, t);
	}, n.prototype.mapIdToIndex = function(t) {
		var n = this._idIndexMap;
		n || (n = this._idIndexMap = createHashMap(), this._idIndexMapCount = 0);
		var r = n.get(t);
		return r ?? n.set(t, r = this._idIndexMapCount++), r;
	}, n.prototype.getViewRoot = function() {
		return this._viewRoot;
	}, n.prototype.resetViewRoot = function(t) {
		t ? this._viewRoot = t : t = this._viewRoot;
		var n = this.getRawData().tree.root;
		(!t || t !== n && !n.contains(t)) && (this._viewRoot = n);
	}, n.prototype.enableAriaDecal = function() {
		enableAriaDecalForTree(this);
	}, n.type = "series.treemap", n.layoutMode = "box", n.defaultOption = {
		progressive: 0,
		left: "center",
		top: "middle",
		width: "80%",
		height: "80%",
		sort: !0,
		clipWindow: "origin",
		squareRatio: .5 * (1 + Math.sqrt(5)),
		leafDepth: null,
		drillDownIcon: "▶",
		zoomToNodeRatio: .32 * .32,
		scaleLimit: null,
		roam: !0,
		nodeClick: "zoomToNode",
		animation: !0,
		animationDurationUpdate: 900,
		animationEasing: "quinticInOut",
		breadcrumb: {
			show: !0,
			height: 22,
			left: "center",
			top: "bottom",
			emptyItemWidth: 25,
			itemStyle: {
				color: "rgba(0,0,0,0.7)",
				textStyle: { color: "#fff" }
			},
			emphasis: { itemStyle: { color: "rgba(0,0,0,0.9)" } }
		},
		label: {
			show: !0,
			distance: 0,
			padding: 5,
			position: "inside",
			color: "#fff",
			overflow: "truncate"
		},
		upperLabel: {
			show: !1,
			position: [0, "50%"],
			height: 20,
			overflow: "truncate",
			verticalAlign: "middle"
		},
		itemStyle: {
			color: null,
			colorAlpha: null,
			colorSaturation: null,
			borderWidth: 0,
			gapWidth: 0,
			borderColor: "#fff",
			borderColorSaturation: null
		},
		emphasis: { upperLabel: {
			show: !0,
			position: [0, "50%"],
			overflow: "truncate",
			verticalAlign: "middle"
		} },
		visualDimension: 0,
		visualMin: null,
		visualMax: null,
		color: [],
		colorAlpha: null,
		colorSaturation: null,
		colorMappingBy: "index",
		visibleMin: 10,
		childrenVisibleMin: null,
		levels: []
	}, n;
}(Series_default);
function completeTreeValue$1(t) {
	var n = 0;
	each(t.children, function(t) {
		completeTreeValue$1(t);
		var r = t.value;
		isArray(r) && (r = r[0]), n += r;
	});
	var r = t.value;
	isArray(r) && (r = r[0]), (r == null || isNaN(r)) && (r = n), r < 0 && (r = 0), isArray(t.value) ? t.value[0] = r : t.value = r;
}
function setDefault(t, n) {
	var r = normalizeToArray(n.get("color")), a = normalizeToArray(n.get([
		"aria",
		"decal",
		"decals"
	]));
	if (r) {
		t ||= [];
		var o, s;
		each(t, function(t) {
			var n = new Model_default(t), r = n.get("color"), a = n.get("decal");
			(n.get(["itemStyle", "color"]) || r && r !== "none") && (o = !0), (n.get(["itemStyle", "decal"]) || a && a !== "none") && (s = !0);
		});
		var c = t[0] ||= {};
		return o || (c.color = r.slice()), !s && a && (c.decal = a.slice()), t;
	}
}
var TreemapSeries_default = TreemapSeriesModel, TEXT_PADDING = 8, ITEM_GAP = 8, ARRAY_LENGTH = 5, Breadcrumb = function() {
	function t(t) {
		this.group = new Group_default(), t.add(this.group);
	}
	return t.prototype.render = function(t, n, r, a) {
		var o = t.getModel("breadcrumb"), s = this.group;
		if (s.removeAll(), !(!o.get("show") || !r)) {
			var c = o.getModel("itemStyle"), l = o.getModel("emphasis"), u = c.getModel("textStyle"), d = l.getModel(["itemStyle", "textStyle"]), f = {
				pos: {
					left: o.get("left"),
					right: o.get("right"),
					top: o.get("top"),
					bottom: o.get("bottom")
				},
				box: {
					width: n.getWidth(),
					height: n.getHeight()
				},
				emptyItemWidth: o.get("emptyItemWidth"),
				totalWidth: 0,
				renderList: []
			};
			this._prepare(r, f, u), this._renderContent(t, f, c, l, u, d, a), positionElement(s, f.pos, f.box);
		}
	}, t.prototype._prepare = function(t, n, r) {
		for (var a = t; a; a = a.parentNode) {
			var o = convertOptionIdName(a.getModel().get("name"), ""), s = r.getTextRect(o), c = Math.max(s.width + TEXT_PADDING * 2, n.emptyItemWidth);
			n.totalWidth += c + ITEM_GAP, n.renderList.push({
				node: a,
				text: o,
				width: c
			});
		}
	}, t.prototype._renderContent = function(t, n, r, a, o, s, c) {
		for (var l = 0, u = n.emptyItemWidth, d = t.get(["breadcrumb", "height"]), f = getAvailableSize(n.pos, n.box), p = n.totalWidth, h = n.renderList, g = a.getModel("itemStyle").getItemStyle(), _ = h.length - 1; _ >= 0; _--) {
			var v = h[_], y = v.node, b = v.width, x = v.text;
			p > f.width && (p -= b - u, b = u, x = null);
			var S = new Polygon_default({
				shape: { points: makeItemPoints(l, 0, b, d, _ === h.length - 1, _ === 0) },
				style: defaults(r.getItemStyle(), { lineJoin: "bevel" }),
				textContent: new Text_default({ style: createTextStyle(o, { text: x }) }),
				textConfig: { position: "inside" },
				z2: 10 * 1e4,
				onclick: curry(c, y)
			});
			S.disableLabelAnimation = !0, S.getTextContent().ensureState("emphasis").style = createTextStyle(s, { text: x }), S.ensureState("emphasis").style = g, toggleHoverEmphasis(S, a.get("focus"), a.get("blurScope"), a.get("disabled")), this.group.add(S), packEventData(S, t, y), l += b + ITEM_GAP;
		}
	}, t.prototype.remove = function() {
		this.group.removeAll();
	}, t;
}();
function makeItemPoints(t, n, r, a, o, s) {
	var c = [
		[o ? t : t - ARRAY_LENGTH, n],
		[t + r, n],
		[t + r, n + a],
		[o ? t : t - ARRAY_LENGTH, n + a]
	];
	return !s && c.splice(2, 0, [t + r + ARRAY_LENGTH, n + a / 2]), !o && c.push([t, n + a / 2]), c;
}
function packEventData(t, n, r) {
	getECData(t).eventData = {
		componentType: "series",
		componentSubType: "treemap",
		componentIndex: n.componentIndex,
		seriesIndex: n.seriesIndex,
		seriesName: n.name,
		seriesType: "treemap",
		selfType: "breadcrumb",
		nodeData: {
			dataIndex: r && r.dataIndex,
			name: r && r.name
		},
		treePathInfo: r && wrapTreePathInfo(r, n)
	};
}
var Breadcrumb_default = Breadcrumb, AnimationWrap = function() {
	function t() {
		this._storage = [], this._elExistsMap = {};
	}
	return t.prototype.add = function(t, n, r, a, o) {
		return this._elExistsMap[t.id] ? !1 : (this._elExistsMap[t.id] = !0, this._storage.push({
			el: t,
			target: n,
			duration: r,
			delay: a,
			easing: o
		}), !0);
	}, t.prototype.finished = function(t) {
		return this._finishedCallback = t, this;
	}, t.prototype.start = function() {
		for (var t = this, n = this._storage.length, r = function() {
			n--, n <= 0 && (t._storage.length = 0, t._elExistsMap = {}, t._finishedCallback && t._finishedCallback());
		}, a = 0, o = this._storage.length; a < o; a++) {
			var s = this._storage[a];
			s.el.animateTo(s.target, {
				duration: s.duration,
				delay: s.delay,
				easing: s.easing,
				setToFinal: !0,
				done: r,
				aborted: r
			});
		}
		return this;
	}, t;
}();
function createWrap() {
	return new AnimationWrap();
}
var Group$2 = Group_default, Rect$1 = Rect_default, DRAG_THRESHOLD = 3, PATH_LABEL_NOAMAL = "label", PATH_UPPERLABEL_NORMAL = "upperLabel", Z2_BASE = 100, Z2_BG = 20, Z2_CONTENT = 30, getStateItemStyle = makeStyleMapper([
	["fill", "color"],
	["stroke", "strokeColor"],
	["lineWidth", "strokeWidth"],
	["shadowBlur"],
	["shadowOffsetX"],
	["shadowOffsetY"],
	["shadowColor"]
]), getItemStyleNormal = function(t) {
	var n = getStateItemStyle(t);
	return n.stroke = n.fill = n.lineWidth = null, n;
}, inner$13 = makeInner(), TreemapView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r._state = "ready", r._storage = createStorage(), r;
	}
	return n.prototype.render = function(t, n, r, a) {
		if (!(indexOf(n.findComponents({
			mainType: "series",
			subType: "treemap",
			query: a
		}), t) < 0)) {
			this.seriesModel = t, this.api = r, this.ecModel = n;
			var o = retrieveTargetInfo(a, ["treemapZoomToNode", "treemapRootToNode"], t), s = a && a.type, c = t.layoutInfo, l = !this._oldTree, u = this._storage, d = s === "treemapRootToNode" && o && u ? {
				rootNodeGroup: u.nodeGroup[o.node.getRawIndex()],
				direction: a.direction
			} : null, f = this._giveContainerGroup(c), p = t.get("animation"), h = this._doRender(f, t, d);
			p && !l && (!s || s === "treemapZoomToNode" || s === "treemapRootToNode") ? this._doAnimation(f, h, t, d) : h.renderFinally(), this._resetController(r), this._renderBreadcrumb(t, r, o);
		}
	}, n.prototype._giveContainerGroup = function(t) {
		var n = this._containerGroup;
		return n || (n = this._containerGroup = new Group$2(), this._initEvents(n), this.group.add(n)), n.x = t.x, n.y = t.y, n;
	}, n.prototype._doRender = function(t, n, r) {
		var a = n.getData().tree, o = this._oldTree, s = createStorage(), c = createStorage(), l = this._storage, u = [];
		function d(t, a, o, d) {
			return renderNode(n, c, l, r, s, u, t, a, o, d);
		}
		g(a.root ? [a.root] : [], o && o.root ? [o.root] : [], t, a === o || !o, 0);
		var f = _(l);
		if (this._oldTree = a, this._storage = c, this._controllerHost) {
			var p = this.seriesModel.layoutInfo, h = a.root.getLayout();
			h.width === p.width && h.height === p.height && (this._controllerHost.zoom = 1);
		}
		return {
			lastsForAnimation: s,
			willDeleteEls: f,
			renderFinally: v
		};
		function g(t, n, r, a, o) {
			a ? (n = t, each(t, function(t, n) {
				!t.isRemoved() && c(n, n);
			})) : new DataDiffer_default(n, t, s, s).add(c).update(c).remove(curry(c, null)).execute();
			function s(t) {
				return t.getId();
			}
			function c(s, c) {
				var l = s == null ? null : t[s], u = c == null ? null : n[c], f = d(l, u, r, o);
				f && g(l && l.viewChildren || [], u && u.viewChildren || [], f, a, o + 1);
			}
		}
		function _(t) {
			var n = createStorage();
			return t && each(t, function(t, r) {
				var a = n[r];
				each(t, function(t) {
					t && (a.push(t), inner$13(t).willDelete = !0);
				});
			}), n;
		}
		function v() {
			each(f, function(t) {
				each(t, function(t) {
					t.parent && t.parent.remove(t);
				});
			}), each(u, function(t) {
				t.invisible = !0, t.dirty();
			});
		}
	}, n.prototype._doAnimation = function(t, n, r, a) {
		var o = r.get("animationDurationUpdate"), s = r.get("animationEasing"), c = (isFunction(o) ? 0 : o) || 0, l = (isFunction(s) ? null : s) || "cubicOut", u = createWrap();
		each(n.willDeleteEls, function(t, n) {
			each(t, function(t, r) {
				if (!t.invisible) {
					var o = t.parent, s, d = inner$13(o);
					if (a && a.direction === "drillDown") s = o === a.rootNodeGroup ? {
						shape: {
							x: 0,
							y: 0,
							width: d.nodeWidth,
							height: d.nodeHeight
						},
						style: { opacity: 0 }
					} : { style: { opacity: 0 } };
					else {
						var f = 0, p = 0;
						d.willDelete || (f = d.nodeWidth / 2, p = d.nodeHeight / 2), s = n === "nodeGroup" ? {
							x: f,
							y: p,
							style: { opacity: 0 }
						} : {
							shape: {
								x: f,
								y: p,
								width: 0,
								height: 0
							},
							style: { opacity: 0 }
						};
					}
					s && u.add(t, s, c, 0, l);
				}
			});
		}), each(this._storage, function(t, r) {
			each(t, function(t, a) {
				var o = n.lastsForAnimation[r][a], s = {};
				o && (t instanceof Group_default ? o.oldX != null && (s.x = t.x, s.y = t.y, t.x = o.oldX, t.y = o.oldY) : (o.oldShape && (s.shape = extend({}, t.shape), t.setShape(o.oldShape)), o.fadein ? (t.setStyle("opacity", 0), s.style = { opacity: 1 }) : t.style.opacity !== 1 && (s.style = { opacity: 1 })), u.add(t, s, c, 0, l));
			});
		}, this), this._state = "animating", u.finished(bind(function() {
			this._state = "ready", n.renderFinally();
		}, this)).start();
	}, n.prototype._resetController = function(t) {
		var n = this._controller, r = this._controllerHost;
		r ||= (this._controllerHost = { target: this.group }, this._controllerHost), n || (n = this._controller = new RoamController_default(t.getZr()), n.enable(this.seriesModel.get("roam")), r.zoomLimit = this.seriesModel.get("scaleLimit"), r.zoom = this.seriesModel.get("zoom"), n.on("pan", bind(this._onPan, this)), n.on("zoom", bind(this._onZoom, this)));
		var a = new BoundingRect_default(0, 0, t.getWidth(), t.getHeight());
		n.setPointerChecker(function(t, n, r) {
			return a.contain(n, r);
		});
	}, n.prototype._clearController = function() {
		var t = this._controller;
		this._controllerHost = null, t &&= (t.dispose(), null);
	}, n.prototype._onPan = function(t) {
		if (this._state !== "animating" && (Math.abs(t.dx) > DRAG_THRESHOLD || Math.abs(t.dy) > DRAG_THRESHOLD)) {
			var n = this.seriesModel.getData().tree.root;
			if (!n) return;
			var r = n.getLayout();
			if (!r) return;
			this.api.dispatchAction({
				type: "treemapMove",
				from: this.uid,
				seriesId: this.seriesModel.id,
				rootRect: {
					x: r.x + t.dx,
					y: r.y + t.dy,
					width: r.width,
					height: r.height
				}
			});
		}
	}, n.prototype._onZoom = function(t) {
		var n = t.originX, r = t.originY, a = t.scale;
		if (this._state !== "animating") {
			var o = this.seriesModel.getData().tree.root;
			if (!o) return;
			var s = o.getLayout();
			if (!s) return;
			var c = new BoundingRect_default(s.x, s.y, s.width, s.height), l = null, u = this._controllerHost;
			l = u.zoomLimit;
			var d = u.zoom = u.zoom || 1;
			if (d *= a, l) {
				var f = l.min || 0, p = l.max || Infinity;
				d = Math.max(Math.min(p, d), f);
			}
			var h = d / u.zoom;
			u.zoom = d;
			var g = this.seriesModel.layoutInfo;
			n -= g.x, r -= g.y;
			var _ = create$2();
			translate(_, _, [-n, -r]), scale$2(_, _, [h, h]), translate(_, _, [n, r]), c.applyTransform(_), this.api.dispatchAction({
				type: "treemapRender",
				from: this.uid,
				seriesId: this.seriesModel.id,
				rootRect: {
					x: c.x,
					y: c.y,
					width: c.width,
					height: c.height
				}
			});
		}
	}, n.prototype._initEvents = function(t) {
		var n = this;
		t.on("click", function(t) {
			if (n._state === "ready") {
				var r = n.seriesModel.get("nodeClick", !0);
				if (r) {
					var a = n.findTarget(t.offsetX, t.offsetY);
					if (a) {
						var o = a.node;
						if (o.getLayout().isLeafRoot) n._rootToNode(a);
						else if (r === "zoomToNode") n._zoomToNode(a);
						else if (r === "link") {
							var s = o.hostTree.data.getItemModel(o.dataIndex), c = s.get("link", !0), l = s.get("target", !0) || "blank";
							c && windowOpen(c, l);
						}
					}
				}
			}
		}, this);
	}, n.prototype._renderBreadcrumb = function(t, n, r) {
		var a = this;
		r || (r = t.get("leafDepth", !0) == null ? this.findTarget(n.getWidth() / 2, n.getHeight() / 2) : { node: t.getViewRoot() }, r ||= { node: t.getData().tree.root }), (this._breadcrumb ||= new Breadcrumb_default(this.group)).render(t, n, r.node, function(n) {
			a._state !== "animating" && (aboveViewRoot(t.getViewRoot(), n) ? a._rootToNode({ node: n }) : a._zoomToNode({ node: n }));
		});
	}, n.prototype.remove = function() {
		this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = createStorage(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
	}, n.prototype.dispose = function() {
		this._clearController();
	}, n.prototype._zoomToNode = function(t) {
		this.api.dispatchAction({
			type: "treemapZoomToNode",
			from: this.uid,
			seriesId: this.seriesModel.id,
			targetNode: t.node
		});
	}, n.prototype._rootToNode = function(t) {
		this.api.dispatchAction({
			type: "treemapRootToNode",
			from: this.uid,
			seriesId: this.seriesModel.id,
			targetNode: t.node
		});
	}, n.prototype.findTarget = function(t, n) {
		var r;
		return this.seriesModel.getViewRoot().eachNode({
			attr: "viewChildren",
			order: "preorder"
		}, function(a) {
			var o = this._storage.background[a.getRawIndex()];
			if (o) {
				var s = o.transformCoordToLocal(t, n), c = o.shape;
				if (c.x <= s[0] && s[0] <= c.x + c.width && c.y <= s[1] && s[1] <= c.y + c.height) r = {
					node: a,
					offsetX: s[0],
					offsetY: s[1]
				};
				else return !1;
			}
		}, this), r;
	}, n.type = "treemap", n;
}(Chart_default);
function createStorage() {
	return {
		nodeGroup: [],
		background: [],
		content: []
	};
}
function renderNode(t, n, r, a, o, s, c, l, u, d) {
	if (!c) return;
	var f = c.getLayout(), p = t.getData(), h = c.getModel();
	if (p.setItemGraphicEl(c.dataIndex, null), !f || !f.isInView) return;
	var g = f.width, _ = f.height, v = f.borderWidth, y = f.invisible, b = c.getRawIndex(), x = l && l.getRawIndex(), S = c.viewChildren, C = f.upperHeight, w = S && S.length, T = h.getModel("itemStyle"), E = h.getModel(["emphasis", "itemStyle"]), D = h.getModel(["blur", "itemStyle"]), O = h.getModel(["select", "itemStyle"]), A = T.get("borderRadius") || 0, j = K("nodeGroup", Group$2);
	if (!j) return;
	if (u.add(j), j.x = f.x || 0, j.y = f.y || 0, j.markRedraw(), inner$13(j).nodeWidth = g, inner$13(j).nodeHeight = _, f.isAboveViewRoot) return j;
	var M = K("background", Rect$1, d, Z2_BG);
	M && B(j, M, w && f.upperLabelHeight);
	var N = h.getModel("emphasis"), P = N.get("focus"), F = N.get("blurScope"), I = N.get("disabled"), L = P === "ancestor" ? c.getAncestorsIndices() : P === "descendant" ? c.getDescendantIndices() : P;
	if (w) isHighDownDispatcher(j) && setAsHighDownDispatcher(j, !1), M && (setAsHighDownDispatcher(M, !I), p.setItemGraphicEl(c.dataIndex, M), enableHoverFocus(M, L, F));
	else {
		var R = K("content", Rect$1, d, Z2_CONTENT);
		R && V(j, R), M.disableMorphing = !0, M && isHighDownDispatcher(M) && setAsHighDownDispatcher(M, !1), setAsHighDownDispatcher(j, !I), p.setItemGraphicEl(c.dataIndex, j);
		var z = h.getShallow("cursor");
		z && R.attr("cursor", z), enableHoverFocus(j, L, F);
	}
	return j;
	function B(n, r, a) {
		var o = getECData(r);
		if (o.dataIndex = c.dataIndex, o.seriesIndex = t.seriesIndex, r.setShape({
			x: 0,
			y: 0,
			width: g,
			height: _,
			r: A
		}), y) H(r);
		else {
			r.invisible = !1;
			var s = c.getVisual("style"), l = s.stroke, u = getItemStyleNormal(T);
			u.fill = l;
			var d = getStateItemStyle(E);
			d.fill = E.get("borderColor");
			var f = getStateItemStyle(D);
			f.fill = D.get("borderColor");
			var p = getStateItemStyle(O);
			if (p.fill = O.get("borderColor"), a) {
				var h = g - 2 * v;
				W(r, l, s.opacity, {
					x: v,
					y: 0,
					width: h,
					height: C
				});
			} else r.removeTextContent();
			r.setStyle(u), r.ensureState("emphasis").style = d, r.ensureState("blur").style = f, r.ensureState("select").style = p, setDefaultStateProxy(r);
		}
		n.add(r);
	}
	function V(n, r) {
		var a = getECData(r);
		a.dataIndex = c.dataIndex, a.seriesIndex = t.seriesIndex;
		var o = Math.max(g - 2 * v, 0), s = Math.max(_ - 2 * v, 0);
		if (r.culling = !0, r.setShape({
			x: v,
			y: v,
			width: o,
			height: s,
			r: A
		}), y) H(r);
		else {
			r.invisible = !1;
			var l = c.getVisual("style"), u = l.fill, d = getItemStyleNormal(T);
			d.fill = u, d.decal = l.decal;
			var f = getStateItemStyle(E), p = getStateItemStyle(D), h = getStateItemStyle(O);
			W(r, u, l.opacity, null), r.setStyle(d), r.ensureState("emphasis").style = f, r.ensureState("blur").style = p, r.ensureState("select").style = h, setDefaultStateProxy(r);
		}
		n.add(r);
	}
	function H(t) {
		!t.invisible && s.push(t);
	}
	function W(n, r, a, o) {
		var s = h.getModel(o ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), l = convertOptionIdName(h.get("name"), null), u = s.getShallow("show");
		setLabelStyle(n, getLabelStatesModels(h, o ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {
			defaultText: u ? l : null,
			inheritColor: r,
			defaultOpacity: a,
			labelFetcher: t,
			labelDataIndex: c.dataIndex
		});
		var d = n.getTextContent();
		if (d) {
			var p = d.style, g = normalizeCssArray$1(p.padding || 0);
			o && (n.setTextConfig({ layoutRect: o }), d.disableLabelLayout = !0), d.beforeUpdate = function() {
				var t = Math.max((o ? o.width : n.shape.width) - g[1] - g[3], 0), r = Math.max((o ? o.height : n.shape.height) - g[0] - g[2], 0);
				(p.width !== t || p.height !== r) && d.setStyle({
					width: t,
					height: r
				});
			}, p.truncateMinChar = 2, p.lineOverflow = "truncate", G(p, o, f);
			var _ = d.getState("emphasis");
			G(_ ? _.style : null, o, f);
		}
	}
	function G(n, r, a) {
		var o = n ? n.text : null;
		if (!r && a.isLeafRoot && o != null) {
			var s = t.get("drillDownIcon", !0);
			n.text = s ? s + " " + o : o;
		}
	}
	function K(t, a, s, c) {
		var l = x != null && r[t][x], u = o[t];
		return l ? (r[t][x] = null, q(u, l)) : y || (l = new a(), l instanceof Displayable_default && (l.z2 = calculateZ2(s, c)), J(u, l)), n[t][b] = l;
	}
	function q(t, n) {
		var r = t[b] = {};
		n instanceof Group$2 ? (r.oldX = n.x, r.oldY = n.y) : r.oldShape = extend({}, n.shape);
	}
	function J(t, n) {
		var r = t[b] = {}, s = c.parentNode, l = n instanceof Group_default;
		if (s && (!a || a.direction === "drillDown")) {
			var u = 0, d = 0, f = o.background[s.getRawIndex()];
			!a && f && f.oldShape && (u = f.oldShape.width, d = f.oldShape.height), l ? (r.oldX = 0, r.oldY = d) : r.oldShape = {
				x: u,
				y: d,
				width: 0,
				height: 0
			};
		}
		r.fadein = !l;
	}
}
function calculateZ2(t, n) {
	return t * Z2_BASE + n;
}
var TreemapView_default = TreemapView;
init_dist$2();
var each$13 = each, isObject$1 = isObject, CATEGORY_DEFAULT_VISUAL_INDEX = -1, VisualMapping = function() {
	function t(n) {
		var r = n.mappingMethod, a = n.type, o = this.option = clone$1(n);
		this.type = a, this.mappingMethod = r, this._normalizeData = normalizers[r];
		var s = t.visualHandlers[a];
		this.applyVisual = s.applyVisual, this.getColorMapper = s.getColorMapper, this._normalizedToVisual = s._normalizedToVisual[r], r === "piecewise" ? (normalizeVisualRange(o), preprocessForPiecewise(o)) : r === "category" ? o.categories ? preprocessForSpecifiedCategory(o) : normalizeVisualRange(o, !0) : (assert(r !== "linear" || o.dataExtent), normalizeVisualRange(o));
	}
	return t.prototype.mapValueToVisual = function(t) {
		var n = this._normalizeData(t);
		return this._normalizedToVisual(n, t);
	}, t.prototype.getNormalizer = function() {
		return bind(this._normalizeData, this);
	}, t.listVisualTypes = function() {
		return keys(t.visualHandlers);
	}, t.isValidType = function(n) {
		return t.visualHandlers.hasOwnProperty(n);
	}, t.eachVisual = function(t, n, r) {
		isObject(t) ? each(t, n, r) : n.call(r, t);
	}, t.mapVisual = function(n, r, a) {
		var o, s = isArray(n) ? [] : isObject(n) ? {} : (o = !0, null);
		return t.eachVisual(n, function(t, n) {
			var c = r.call(a, t, n);
			o ? s = c : s[n] = c;
		}), s;
	}, t.retrieveVisuals = function(n) {
		var r = {}, a;
		return n && each$13(t.visualHandlers, function(t, o) {
			n.hasOwnProperty(o) && (r[o] = n[o], a = !0);
		}), a ? r : null;
	}, t.prepareVisualTypes = function(t) {
		if (isArray(t)) t = t.slice();
		else if (isObject$1(t)) {
			var n = [];
			each$13(t, function(t, r) {
				n.push(r);
			}), t = n;
		} else return [];
		return t.sort(function(t, n) {
			return n === "color" && t !== "color" && t.indexOf("color") === 0 ? 1 : -1;
		}), t;
	}, t.dependsOn = function(t, n) {
		return n === "color" ? !!(t && t.indexOf(n) === 0) : t === n;
	}, t.findPieceIndex = function(t, n, r) {
		for (var a, o = Infinity, s = 0, c = n.length; s < c; s++) {
			var l = n[s].value;
			if (l != null) {
				if (l === t || isString(l) && l === t + "") return s;
				r && p(l, s);
			}
		}
		for (var s = 0, c = n.length; s < c; s++) {
			var u = n[s], d = u.interval, f = u.close;
			if (d) {
				if (d[0] === -Infinity) {
					if (littleThan(f[1], t, d[1])) return s;
				} else if (d[1] === Infinity) {
					if (littleThan(f[0], d[0], t)) return s;
				} else if (littleThan(f[0], d[0], t) && littleThan(f[1], t, d[1])) return s;
				r && p(d[0], s), r && p(d[1], s);
			}
		}
		if (r) return t === Infinity ? n.length - 1 : t === -Infinity ? 0 : a;
		function p(n, r) {
			var s = Math.abs(n - t);
			s < o && (o = s, a = r);
		}
	}, t.visualHandlers = {
		color: {
			applyVisual: makeApplyVisual("color"),
			getColorMapper: function() {
				var t = this.option;
				return bind(t.mappingMethod === "category" ? function(t, n) {
					return !n && (t = this._normalizeData(t)), doMapCategory.call(this, t);
				} : function(n, r, a) {
					var o = !!a;
					return !r && (n = this._normalizeData(n)), a = fastLerp(n, t.parsedVisual, a), o ? a : stringify(a, "rgba");
				}, this);
			},
			_normalizedToVisual: {
				linear: function(t) {
					return stringify(fastLerp(t, this.option.parsedVisual), "rgba");
				},
				category: doMapCategory,
				piecewise: function(t, n) {
					var r = getSpecifiedVisual.call(this, n);
					return r ??= stringify(fastLerp(t, this.option.parsedVisual), "rgba"), r;
				},
				fixed: doMapFixed
			}
		},
		colorHue: makePartialColorVisualHandler(function(t, n) {
			return modifyHSL(t, n);
		}),
		colorSaturation: makePartialColorVisualHandler(function(t, n) {
			return modifyHSL(t, null, n);
		}),
		colorLightness: makePartialColorVisualHandler(function(t, n) {
			return modifyHSL(t, null, null, n);
		}),
		colorAlpha: makePartialColorVisualHandler(function(t, n) {
			return modifyAlpha(t, n);
		}),
		decal: {
			applyVisual: makeApplyVisual("decal"),
			_normalizedToVisual: {
				linear: null,
				category: doMapCategory,
				piecewise: null,
				fixed: null
			}
		},
		opacity: {
			applyVisual: makeApplyVisual("opacity"),
			_normalizedToVisual: createNormalizedToNumericVisual([0, 1])
		},
		liftZ: {
			applyVisual: makeApplyVisual("liftZ"),
			_normalizedToVisual: {
				linear: doMapFixed,
				category: doMapFixed,
				piecewise: doMapFixed,
				fixed: doMapFixed
			}
		},
		symbol: {
			applyVisual: function(t, n, r) {
				r("symbol", this.mapValueToVisual(t));
			},
			_normalizedToVisual: {
				linear: doMapToArray,
				category: doMapCategory,
				piecewise: function(t, n) {
					var r = getSpecifiedVisual.call(this, n);
					return r ??= doMapToArray.call(this, t), r;
				},
				fixed: doMapFixed
			}
		},
		symbolSize: {
			applyVisual: makeApplyVisual("symbolSize"),
			_normalizedToVisual: createNormalizedToNumericVisual([0, 1])
		}
	}, t;
}();
function preprocessForPiecewise(t) {
	var n = t.pieceList;
	t.hasSpecialVisual = !1, each(n, function(n, r) {
		n.originIndex = r, n.visual != null && (t.hasSpecialVisual = !0);
	});
}
function preprocessForSpecifiedCategory(t) {
	var n = t.categories, r = t.categoryMap = {}, a = t.visual;
	if (each$13(n, function(t, n) {
		r[t] = n;
	}), !isArray(a)) {
		var o = [];
		isObject(a) ? each$13(a, function(t, n) {
			var a = r[n];
			o[a ?? CATEGORY_DEFAULT_VISUAL_INDEX] = t;
		}) : o[CATEGORY_DEFAULT_VISUAL_INDEX] = a, a = setVisualToOption(t, o);
	}
	for (var s = n.length - 1; s >= 0; s--) a[s] ?? (delete r[n[s]], n.pop());
}
function normalizeVisualRange(t, n) {
	var r = t.visual, a = [];
	isObject(r) ? each$13(r, function(t) {
		a.push(t);
	}) : r != null && a.push(r), !n && a.length === 1 && !{
		color: 1,
		symbol: 1
	}.hasOwnProperty(t.type) && (a[1] = a[0]), setVisualToOption(t, a);
}
function makePartialColorVisualHandler(t) {
	return {
		applyVisual: function(n, r, a) {
			var o = this.mapValueToVisual(n);
			a("color", t(r("color"), o));
		},
		_normalizedToVisual: createNormalizedToNumericVisual([0, 1])
	};
}
function doMapToArray(t) {
	var n = this.option.visual;
	return n[Math.round(linearMap$2(t, [0, 1], [0, n.length - 1], !0))] || {};
}
function makeApplyVisual(t) {
	return function(n, r, a) {
		a(t, this.mapValueToVisual(n));
	};
}
function doMapCategory(t) {
	var n = this.option.visual;
	return n[this.option.loop && t !== CATEGORY_DEFAULT_VISUAL_INDEX ? t % n.length : t];
}
function doMapFixed() {
	return this.option.visual[0];
}
function createNormalizedToNumericVisual(t) {
	return {
		linear: function(n) {
			return linearMap$2(n, t, this.option.visual, !0);
		},
		category: doMapCategory,
		piecewise: function(n, r) {
			var a = getSpecifiedVisual.call(this, r);
			return a ??= linearMap$2(n, t, this.option.visual, !0), a;
		},
		fixed: doMapFixed
	};
}
function getSpecifiedVisual(t) {
	var n = this.option, r = n.pieceList;
	if (n.hasSpecialVisual) {
		var a = r[VisualMapping.findPieceIndex(t, r)];
		if (a && a.visual) return a.visual[this.type];
	}
}
function setVisualToOption(t, n) {
	return t.visual = n, t.type === "color" && (t.parsedVisual = map(n, function(t) {
		var n = parse(t);
		return !n && process$1.env.NODE_ENV !== "production" && warn("'" + t + "' is an illegal color, fallback to '#000000'", !0), n || [
			0,
			0,
			0,
			1
		];
	})), n;
}
var normalizers = {
	linear: function(t) {
		return linearMap$2(t, this.option.dataExtent, [0, 1], !0);
	},
	piecewise: function(t) {
		var n = this.option.pieceList, r = VisualMapping.findPieceIndex(t, n, !0);
		if (r != null) return linearMap$2(r, [0, n.length - 1], [0, 1], !0);
	},
	category: function(t) {
		return (this.option.categories ? this.option.categoryMap[t] : t) ?? CATEGORY_DEFAULT_VISUAL_INDEX;
	},
	fixed: noop
};
function littleThan(t, n, r) {
	return t ? n <= r : n < r;
}
var VisualMapping_default = VisualMapping, ITEM_STYLE_NORMAL = "itemStyle", inner$12 = makeInner(), treemapVisual_default = {
	seriesType: "treemap",
	reset: function(t) {
		var n = t.getData().tree.root;
		n.isRemoved() || travelTree(n, {}, t.getViewRoot().getAncestors(), t);
	}
};
function travelTree(t, n, r, a) {
	var o = t.getModel(), s = t.getLayout(), c = t.hostTree.data;
	if (!(!s || s.invisible || !s.isInView)) {
		var l = o.getModel(ITEM_STYLE_NORMAL), u = buildVisuals(l, n, a), d = c.ensureUniqueItemVisual(t.dataIndex, "style"), f = l.get("borderColor"), p = l.get("borderColorSaturation"), h;
		p != null && (h = calculateColor(u), f = calculateBorderColor(p, h)), d.stroke = f;
		var g = t.viewChildren;
		if (!g || !g.length) h = calculateColor(u), d.fill = h;
		else {
			var _ = buildVisualMapping(t, o, s, l, u, g);
			each(g, function(t, n) {
				(t.depth >= r.length || t === r[t.depth]) && travelTree(t, mapVisual$1(o, u, t, n, _, a), r, a);
			});
		}
	}
}
function buildVisuals(t, n, r) {
	var a = extend({}, n), o = r.designatedVisualItemStyle;
	return each([
		"color",
		"colorAlpha",
		"colorSaturation"
	], function(r) {
		o[r] = n[r];
		var s = t.get(r);
		o[r] = null, s != null && (a[r] = s);
	}), a;
}
function calculateColor(t) {
	var n = getValueVisualDefine(t, "color");
	if (n) {
		var r = getValueVisualDefine(t, "colorAlpha"), a = getValueVisualDefine(t, "colorSaturation");
		return a && (n = modifyHSL(n, null, null, a)), r && (n = modifyAlpha(n, r)), n;
	}
}
function calculateBorderColor(t, n) {
	return n == null ? null : modifyHSL(n, null, null, t);
}
function getValueVisualDefine(t, n) {
	var r = t[n];
	if (r != null && r !== "none") return r;
}
function buildVisualMapping(t, n, r, a, o, s) {
	if (!(!s || !s.length)) {
		var c = getRangeVisual(n, "color") || o.color != null && o.color !== "none" && (getRangeVisual(n, "colorAlpha") || getRangeVisual(n, "colorSaturation"));
		if (c) {
			var l = n.get("visualMin"), u = n.get("visualMax"), d = r.dataExtent.slice();
			l != null && l < d[0] && (d[0] = l), u != null && u > d[1] && (d[1] = u);
			var f = n.get("colorMappingBy"), p = {
				type: c.name,
				dataExtent: d,
				visual: c.range
			};
			p.type === "color" && (f === "index" || f === "id") ? (p.mappingMethod = "category", p.loop = !0) : p.mappingMethod = "linear";
			var h = new VisualMapping_default(p);
			return inner$12(h).drColorMappingBy = f, h;
		}
	}
}
function getRangeVisual(t, n) {
	var r = t.get(n);
	return isArray(r) && r.length ? {
		name: n,
		range: r
	} : null;
}
function mapVisual$1(t, n, r, a, o, s) {
	var c = extend({}, n);
	if (o) {
		var l = o.type, u = l === "color" && inner$12(o).drColorMappingBy, d = u === "index" ? a : u === "id" ? s.mapIdToIndex(r.getId()) : r.getValue(t.get("visualDimension"));
		c[l] = o.mapValueToVisual(d);
	}
	return c;
}
var mathMax$3 = Math.max, mathMin$3 = Math.min, retrieveValue = retrieve, each$12 = each, PATH_BORDER_WIDTH = ["itemStyle", "borderWidth"], PATH_GAP_WIDTH = ["itemStyle", "gapWidth"], PATH_UPPER_LABEL_SHOW = ["upperLabel", "show"], PATH_UPPER_LABEL_HEIGHT = ["upperLabel", "height"], treemapLayout_default = {
	seriesType: "treemap",
	reset: function(t, n, r, a) {
		var o = r.getWidth(), s = r.getHeight(), c = t.option, l = getLayoutRect(t.getBoxLayoutParams(), {
			width: r.getWidth(),
			height: r.getHeight()
		}), u = c.size || [], d = parsePercent$1(retrieveValue(l.width, u[0]), o), f = parsePercent$1(retrieveValue(l.height, u[1]), s), p = a && a.type, h = retrieveTargetInfo(a, ["treemapZoomToNode", "treemapRootToNode"], t), g = p === "treemapRender" || p === "treemapMove" ? a.rootRect : null, _ = t.getViewRoot(), v = getPathToRoot(_);
		if (p !== "treemapMove") {
			var y = p === "treemapZoomToNode" ? estimateRootSize(t, h, _, d, f) : g ? [g.width, g.height] : [d, f], b = c.sort;
			b && b !== "asc" && b !== "desc" && (b = "desc");
			var x = {
				squareRatio: c.squareRatio,
				sort: b,
				leafDepth: c.leafDepth
			};
			_.hostTree.clearLayouts();
			var S = {
				x: 0,
				y: 0,
				width: y[0],
				height: y[1],
				area: y[0] * y[1]
			};
			_.setLayout(S), squarify(_, x, !1, 0), S = _.getLayout(), each$12(v, function(t, n) {
				var r = (v[n + 1] || _).getValue();
				t.setLayout(extend({
					dataExtent: [r, r],
					borderWidth: 0,
					upperHeight: 0
				}, S));
			});
		}
		var C = t.getData().tree.root;
		C.setLayout(calculateRootPosition(l, g, h), !0), t.setLayoutInfo(l), prunning(C, new BoundingRect_default(-l.x, -l.y, o, s), v, _, 0);
	}
};
function squarify(t, n, r, a) {
	var o, s;
	if (!t.isRemoved()) {
		var c = t.getLayout();
		o = c.width, s = c.height;
		var l = t.getModel(), u = l.get(PATH_BORDER_WIDTH), d = l.get(PATH_GAP_WIDTH) / 2, f = getUpperLabelHeight(l), p = Math.max(u, f), h = u - d, g = p - d;
		t.setLayout({
			borderWidth: u,
			upperHeight: p,
			upperLabelHeight: f
		}, !0), o = mathMax$3(o - 2 * h, 0), s = mathMax$3(s - h - g, 0);
		var _ = o * s, v = initChildren$1(t, l, _, n, r, a);
		if (v.length) {
			var y = {
				x: h,
				y: g,
				width: o,
				height: s
			}, b = mathMin$3(o, s), x = Infinity, S = [];
			S.area = 0;
			for (var C = 0, w = v.length; C < w;) {
				var T = v[C];
				S.push(T), S.area += T.getLayout().area;
				var E = worst(S, b, n.squareRatio);
				E <= x ? (C++, x = E) : (S.area -= S.pop().getLayout().area, position(S, b, y, d, !1), b = mathMin$3(y.width, y.height), S.length = S.area = 0, x = Infinity);
			}
			if (S.length && position(S, b, y, d, !0), !r) {
				var D = l.get("childrenVisibleMin");
				D != null && _ < D && (r = !0);
			}
			for (var C = 0, w = v.length; C < w; C++) squarify(v[C], n, r, a + 1);
		}
	}
}
function initChildren$1(t, n, r, a, o, s) {
	var c = t.children || [], l = a.sort;
	l !== "asc" && l !== "desc" && (l = null);
	var u = a.leafDepth != null && a.leafDepth <= s;
	if (o && !u) return t.viewChildren = [];
	c = filter(c, function(t) {
		return !t.isRemoved();
	}), sort$1(c, l);
	var d = statistic(n, c, l);
	if (d.sum === 0 || (d.sum = filterByThreshold(n, r, d.sum, l, c), d.sum === 0)) return t.viewChildren = [];
	for (var f = 0, p = c.length; f < p; f++) {
		var h = c[f].getValue() / d.sum * r;
		c[f].setLayout({ area: h });
	}
	return u && (c.length && t.setLayout({ isLeafRoot: !0 }, !0), c.length = 0), t.viewChildren = c, t.setLayout({ dataExtent: d.dataExtent }, !0), c;
}
function filterByThreshold(t, n, r, a, o) {
	if (!a) return r;
	for (var s = t.get("visibleMin"), c = o.length, l = c, u = c - 1; u >= 0; u--) {
		var d = o[a === "asc" ? c - u - 1 : u].getValue();
		d / r * n < s && (l = u, r -= d);
	}
	return a === "asc" ? o.splice(0, c - l) : o.splice(l, c - l), r;
}
function sort$1(t, n) {
	return n && t.sort(function(t, r) {
		var a = n === "asc" ? t.getValue() - r.getValue() : r.getValue() - t.getValue();
		return a === 0 ? n === "asc" ? t.dataIndex - r.dataIndex : r.dataIndex - t.dataIndex : a;
	}), t;
}
function statistic(t, n, r) {
	for (var a = 0, o = 0, s = n.length; o < s; o++) a += n[o].getValue();
	var c = t.get("visualDimension"), l;
	return !n || !n.length ? l = [NaN, NaN] : c === "value" && r ? (l = [n[n.length - 1].getValue(), n[0].getValue()], r === "asc" && l.reverse()) : (l = [Infinity, -Infinity], each$12(n, function(t) {
		var n = t.getValue(c);
		n < l[0] && (l[0] = n), n > l[1] && (l[1] = n);
	})), {
		sum: a,
		dataExtent: l
	};
}
function worst(t, n, r) {
	for (var a = 0, o = Infinity, s = 0, c = void 0, l = t.length; s < l; s++) c = t[s].getLayout().area, c && (c < o && (o = c), c > a && (a = c));
	var u = t.area * t.area, d = n * n * r;
	return u ? mathMax$3(d * a / u, u / (d * o)) : Infinity;
}
function position(t, n, r, a, o) {
	var s = n === r.width ? 0 : 1, c = 1 - s, l = ["x", "y"], u = ["width", "height"], d = r[l[s]], f = n ? t.area / n : 0;
	(o || f > r[u[c]]) && (f = r[u[c]]);
	for (var p = 0, h = t.length; p < h; p++) {
		var g = t[p], _ = {}, v = f ? g.getLayout().area / f : 0, y = _[u[c]] = mathMax$3(f - 2 * a, 0), b = r[l[s]] + r[u[s]] - d, x = p === h - 1 || b < v ? b : v, S = _[u[s]] = mathMax$3(x - 2 * a, 0);
		_[l[c]] = r[l[c]] + mathMin$3(a, y / 2), _[l[s]] = d + mathMin$3(a, S / 2), d += x, g.setLayout(_, !0);
	}
	r[l[c]] += f, r[u[c]] -= f;
}
function estimateRootSize(t, n, r, a, o) {
	var s = (n || {}).node, c = [a, o];
	if (!s || s === r) return c;
	for (var l, u = a * o, d = u * t.option.zoomToNodeRatio; l = s.parentNode;) {
		for (var f = 0, p = l.children, h = 0, g = p.length; h < g; h++) f += p[h].getValue();
		var _ = s.getValue();
		if (_ === 0) return c;
		d *= f / _;
		var v = l.getModel(), y = v.get(PATH_BORDER_WIDTH), b = Math.max(y, getUpperLabelHeight(v));
		d += 4 * y * y + (3 * y + b) * d ** .5, d > 9007199254740991 && (d = 9007199254740991), s = l;
	}
	d < u && (d = u);
	var x = (d / u) ** .5;
	return [a * x, o * x];
}
function calculateRootPosition(t, n, r) {
	if (n) return {
		x: n.x,
		y: n.y
	};
	var a = {
		x: 0,
		y: 0
	};
	if (!r) return a;
	var o = r.node, s = o.getLayout();
	if (!s) return a;
	for (var c = [s.width / 2, s.height / 2], l = o; l;) {
		var u = l.getLayout();
		c[0] += u.x, c[1] += u.y, l = l.parentNode;
	}
	return {
		x: t.width / 2 - c[0],
		y: t.height / 2 - c[1]
	};
}
function prunning(t, n, r, a, o) {
	var s = t.getLayout(), c = r[o], l = c && c === t;
	if (!(c && !l || o === r.length && t !== a)) {
		t.setLayout({
			isInView: !0,
			invisible: !l && !n.intersect(s),
			isAboveViewRoot: l
		}, !0);
		var u = new BoundingRect_default(n.x - s.x, n.y - s.y, n.width, n.height);
		each$12(t.viewChildren || [], function(t) {
			prunning(t, u, r, a, o + 1);
		});
	}
}
function getUpperLabelHeight(t) {
	return t.get(PATH_UPPER_LABEL_SHOW) ? t.get(PATH_UPPER_LABEL_HEIGHT) : 0;
}
function install$9(t) {
	t.registerSeriesModel(TreemapSeries_default), t.registerChartView(TreemapView_default), t.registerVisual(treemapVisual_default), t.registerLayout(treemapLayout_default), installTreemapAction(t);
}
function categoryFilter(t) {
	var n = t.findComponents({ mainType: "legend" });
	!n || !n.length || t.eachSeriesByType("graph", function(t) {
		var r = t.getCategoriesData(), a = t.getGraph().data, o = r.mapArray(r.getName);
		a.filterSelf(function(t) {
			var r = a.getItemModel(t).getShallow("category");
			if (r != null) {
				isNumber(r) && (r = o[r]);
				for (var s = 0; s < n.length; s++) if (!n[s].isSelected(r)) return !1;
			}
			return !0;
		});
	});
}
function categoryVisual(t) {
	var n = {};
	t.eachSeriesByType("graph", function(t) {
		var r = t.getCategoriesData(), a = t.getData(), o = {};
		r.each(function(a) {
			var s = r.getName(a);
			o["ec-" + s] = a;
			var c = r.getItemModel(a), l = c.getModel("itemStyle").getItemStyle();
			l.fill ||= t.getColorFromPalette(s, n), r.setItemVisual(a, "style", l);
			for (var u = [
				"symbol",
				"symbolSize",
				"symbolKeepAspect"
			], d = 0; d < u.length; d++) {
				var f = c.getShallow(u[d], !0);
				f != null && r.setItemVisual(a, u[d], f);
			}
		}), r.count() && a.each(function(t) {
			var n = a.getItemModel(t).getShallow("category");
			if (n != null) {
				isString(n) && (n = o["ec-" + n]);
				var s = r.getItemVisual(n, "style");
				extend(a.ensureUniqueItemVisual(t, "style"), s);
				for (var c = [
					"symbol",
					"symbolSize",
					"symbolKeepAspect"
				], l = 0; l < c.length; l++) a.setItemVisual(t, c[l], r.getItemVisual(n, c[l]));
			}
		});
	});
}
function normalize$1(t) {
	return t instanceof Array || (t = [t, t]), t;
}
function graphEdgeVisual(t) {
	t.eachSeriesByType("graph", function(t) {
		var n = t.getGraph(), r = t.getEdgeData(), a = normalize$1(t.get("edgeSymbol")), o = normalize$1(t.get("edgeSymbolSize"));
		r.setVisual("fromSymbol", a && a[0]), r.setVisual("toSymbol", a && a[1]), r.setVisual("fromSymbolSize", o && o[0]), r.setVisual("toSymbolSize", o && o[1]), r.setVisual("style", t.getModel("lineStyle").getLineStyle()), r.each(function(t) {
			var a = r.getItemModel(t), o = n.getEdgeByIndex(t), s = normalize$1(a.getShallow("symbol", !0)), c = normalize$1(a.getShallow("symbolSize", !0)), l = a.getModel("lineStyle").getLineStyle(), u = r.ensureUniqueItemVisual(t, "style");
			switch (extend(u, l), u.stroke) {
				case "source":
					var d = o.node1.getVisual("style");
					u.stroke = d && d.fill;
					break;
				case "target":
					var d = o.node2.getVisual("style");
					u.stroke = d && d.fill;
					break;
			}
			s[0] && o.setVisual("fromSymbol", s[0]), s[1] && o.setVisual("toSymbol", s[1]), c[0] && o.setVisual("fromSymbolSize", c[0]), c[1] && o.setVisual("toSymbolSize", c[1]);
		});
	});
}
var KEY_DELIMITER = "-->", getAutoCurvenessParams = function(t) {
	return t.get("autoCurveness") || null;
}, createCurveness = function(t, n) {
	var r = getAutoCurvenessParams(t), a = 20, o = [];
	if (isNumber(r)) a = r;
	else if (isArray(r)) {
		t.__curvenessList = r;
		return;
	}
	n > a && (a = n);
	var s = a % 2 ? a + 2 : a + 3;
	o = [];
	for (var c = 0; c < s; c++) o.push((c % 2 ? c + 1 : c) / 10 * (c % 2 ? -1 : 1));
	t.__curvenessList = o;
}, getKeyOfEdges = function(t, n, r) {
	var a = [t.id, t.dataIndex].join("."), o = [n.id, n.dataIndex].join(".");
	return [
		r.uid,
		a,
		o
	].join(KEY_DELIMITER);
}, getOppositeKey = function(t) {
	var n = t.split(KEY_DELIMITER);
	return [
		n[0],
		n[2],
		n[1]
	].join(KEY_DELIMITER);
}, getEdgeFromMap = function(t, n) {
	var r = getKeyOfEdges(t.node1, t.node2, n);
	return n.__edgeMap[r];
}, getTotalLengthBetweenNodes = function(t, n) {
	return getEdgeMapLengthWithKey(getKeyOfEdges(t.node1, t.node2, n), n) + getEdgeMapLengthWithKey(getKeyOfEdges(t.node2, t.node1, n), n);
}, getEdgeMapLengthWithKey = function(t, n) {
	var r = n.__edgeMap;
	return r[t] ? r[t].length : 0;
};
function initCurvenessList(t) {
	getAutoCurvenessParams(t) && (t.__curvenessList = [], t.__edgeMap = {}, createCurveness(t));
}
function createEdgeMapForCurveness(t, n, r, a) {
	if (getAutoCurvenessParams(r)) {
		var o = getKeyOfEdges(t, n, r), s = r.__edgeMap, c = s[getOppositeKey(o)];
		s[o] && !c ? s[o].isForward = !0 : c && s[o] && (c.isForward = !0, s[o].isForward = !1), s[o] = s[o] || [], s[o].push(a);
	}
}
function getCurvenessForEdge(t, n, r, a) {
	var o = getAutoCurvenessParams(n), s = isArray(o);
	if (!o) return null;
	var c = getEdgeFromMap(t, n);
	if (!c) return null;
	for (var l = -1, u = 0; u < c.length; u++) if (c[u] === r) {
		l = u;
		break;
	}
	var d = getTotalLengthBetweenNodes(t, n);
	createCurveness(n, d), t.lineStyle = t.lineStyle || {};
	var f = getKeyOfEdges(t.node1, t.node2, n), p = n.__curvenessList, h = s || d % 2 ? 0 : 1;
	if (c.isForward) return p[h + l];
	var g = getEdgeMapLengthWithKey(getOppositeKey(f), n), _ = p[l + g + h];
	return a ? s ? o && o[0] === 0 ? (g + h) % 2 ? _ : -_ : ((g % 2 ? 0 : 1) + h) % 2 ? _ : -_ : (g + h) % 2 ? _ : -_ : p[l + g + h];
}
function simpleLayout(t) {
	var n = t.coordinateSystem;
	if (!(n && n.type !== "view")) {
		var r = t.getGraph();
		r.eachNode(function(t) {
			var n = t.getModel();
			t.setLayout([+n.get("x"), +n.get("y")]);
		}), simpleLayoutEdge(r, t);
	}
}
function simpleLayoutEdge(t, n) {
	t.eachEdge(function(t, r) {
		var a = retrieve3(t.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(t, n, r, !0), 0), o = clone$3(t.node1.getLayout()), s = clone$3(t.node2.getLayout()), c = [o, s];
		+a && c.push([(o[0] + s[0]) / 2 - (o[1] - s[1]) * a, (o[1] + s[1]) / 2 - (s[0] - o[0]) * a]), t.setLayout(c);
	});
}
function graphSimpleLayout(t, n) {
	t.eachSeriesByType("graph", function(t) {
		var n = t.get("layout"), r = t.coordinateSystem;
		if (r && r.type !== "view") {
			var a = t.getData(), o = [];
			each(r.dimensions, function(t) {
				o = o.concat(a.mapDimensionsAll(t));
			});
			for (var s = 0; s < a.count(); s++) {
				for (var c = [], l = !1, u = 0; u < o.length; u++) {
					var d = a.get(o[u], s);
					isNaN(d) || (l = !0), c.push(d);
				}
				l ? a.setItemLayout(s, r.dataToPoint(c)) : a.setItemLayout(s, [NaN, NaN]);
			}
			simpleLayoutEdge(a.graph, t);
		} else (!n || n === "none") && simpleLayout(t);
	});
}
function getNodeGlobalScale(t) {
	var n = t.coordinateSystem;
	if (n.type !== "view") return 1;
	var r = t.option.nodeScaleRatio, a = n.scaleX;
	return ((n.getZoom() - 1) * r + 1) / a;
}
function getSymbolSize(t) {
	var n = t.getVisual("symbolSize");
	return n instanceof Array && (n = (n[0] + n[1]) / 2), +n;
}
var PI$2 = Math.PI, _symbolRadiansHalf = [];
function circularLayout(t, n, r, a) {
	var o = t.coordinateSystem;
	if (!(o && o.type !== "view")) {
		var s = o.getBoundingRect(), c = t.getData(), l = c.graph, u = s.width / 2 + s.x, d = s.height / 2 + s.y, f = Math.min(s.width, s.height) / 2, p = c.count();
		if (c.setLayout({
			cx: u,
			cy: d
		}), p) {
			if (r) {
				var h = o.pointToData(a), g = h[0], _ = h[1], v = [g - u, _ - d];
				normalize$3(v, v), scale$1(v, v, f), r.setLayout([u + v[0], d + v[1]], !0), rotateNodeLabel(r, t.get(["circular", "rotateLabel"]), u, d);
			}
			_layoutNodesBasedOn[n](t, l, c, f, u, d, p), l.eachEdge(function(n, r) {
				var a = retrieve3(n.getModel().get(["lineStyle", "curveness"]), getCurvenessForEdge(n, t, r), 0), o = clone$3(n.node1.getLayout()), s = clone$3(n.node2.getLayout()), c, l = (o[0] + s[0]) / 2, f = (o[1] + s[1]) / 2;
				+a && (a *= 3, c = [u * a + l * (1 - a), d * a + f * (1 - a)]), n.setLayout([
					o,
					s,
					c
				]);
			});
		}
	}
}
var _layoutNodesBasedOn = {
	value: function(t, n, r, a, o, s, c) {
		var l = 0, u = r.getSum("value"), d = Math.PI * 2 / (u || c);
		n.eachNode(function(t) {
			var n = t.getValue("value"), r = d * (u ? n : 1) / 2;
			l += r, t.setLayout([a * Math.cos(l) + o, a * Math.sin(l) + s]), l += r;
		});
	},
	symbolSize: function(t, n, r, a, o, s, c) {
		var l = 0;
		_symbolRadiansHalf.length = c;
		var u = getNodeGlobalScale(t);
		n.eachNode(function(t) {
			var n = getSymbolSize(t);
			isNaN(n) && (n = 2), n < 0 && (n = 0), n *= u;
			var r = Math.asin(n / 2 / a);
			isNaN(r) && (r = PI$2 / 2), _symbolRadiansHalf[t.dataIndex] = r, l += r * 2;
		});
		var d = (2 * PI$2 - l) / c / 2, f = 0;
		n.eachNode(function(t) {
			var n = d + _symbolRadiansHalf[t.dataIndex];
			f += n, (!t.getLayout() || !t.getLayout().fixed) && t.setLayout([a * Math.cos(f) + o, a * Math.sin(f) + s]), f += n;
		});
	}
};
function rotateNodeLabel(t, n, r, a) {
	var o = t.getGraphicEl();
	if (o) {
		var s = t.getModel().get(["label", "rotate"]) || 0, c = o.getSymbolPath();
		if (n) {
			var l = t.getLayout(), u = Math.atan2(l[1] - a, l[0] - r);
			u < 0 && (u = Math.PI * 2 + u);
			var d = l[0] < r;
			d && (u -= Math.PI);
			var f = d ? "left" : "right";
			c.setTextConfig({
				rotation: -u,
				position: f,
				origin: "center"
			});
			var p = c.ensureState("emphasis");
			extend(p.textConfig ||= {}, { position: f });
		} else c.setTextConfig({ rotation: s *= Math.PI / 180 });
	}
}
function graphCircularLayout(t) {
	t.eachSeriesByType("graph", function(t) {
		t.get("layout") === "circular" && circularLayout(t, "symbolSize");
	});
}
var scaleAndAdd = scaleAndAdd$1;
function forceLayout(t, n, r) {
	for (var a = t, o = n, s = r.rect, c = s.width, l = s.height, u = [s.x + c / 2, s.y + l / 2], d = r.gravity == null ? .1 : r.gravity, f = 0; f < a.length; f++) {
		var p = a[f];
		p.p ||= create$1(c * (Math.random() - .5) + u[0], l * (Math.random() - .5) + u[1]), p.pp = clone$3(p.p), p.edges = null;
	}
	var h = r.friction == null ? .6 : r.friction, g = h, _, v;
	return {
		warmUp: function() {
			g = h * .8;
		},
		setFixed: function(t) {
			a[t].fixed = !0;
		},
		setUnfixed: function(t) {
			a[t].fixed = !1;
		},
		beforeStep: function(t) {
			_ = t;
		},
		afterStep: function(t) {
			v = t;
		},
		step: function(t) {
			_ && _(a, o);
			for (var n = [], r = a.length, s = 0; s < o.length; s++) {
				var c = o[s];
				if (!c.ignoreForceLayout) {
					var l = c.n1, f = c.n2;
					sub(n, f.p, l.p);
					var p = len(n) - c.d, h = f.w / (l.w + f.w);
					isNaN(h) && (h = 0), normalize$3(n, n), !l.fixed && scaleAndAdd(l.p, l.p, n, h * p * g), !f.fixed && scaleAndAdd(f.p, f.p, n, -(1 - h) * p * g);
				}
			}
			for (var s = 0; s < r; s++) {
				var y = a[s];
				y.fixed || (sub(n, u, y.p), scaleAndAdd(y.p, y.p, n, d * g));
			}
			for (var s = 0; s < r; s++) for (var l = a[s], b = s + 1; b < r; b++) {
				var f = a[b];
				sub(n, f.p, l.p);
				var p = len(n);
				p === 0 && (set$1(n, Math.random() - .5, Math.random() - .5), p = 1);
				var x = (l.rep + f.rep) / p / p;
				!l.fixed && scaleAndAdd(l.pp, l.pp, n, x), !f.fixed && scaleAndAdd(f.pp, f.pp, n, -x);
			}
			for (var S = [], s = 0; s < r; s++) {
				var y = a[s];
				y.fixed || (sub(S, y.p, y.pp), scaleAndAdd(y.p, y.p, S, g), copy$1(y.pp, y.p));
			}
			g *= .992;
			var C = g < .01;
			v && v(a, o, C), t && t(C);
		}
	};
}
function graphForceLayout(t) {
	t.eachSeriesByType("graph", function(t) {
		var n = t.coordinateSystem;
		if (!(n && n.type !== "view")) if (t.get("layout") === "force") {
			var r = t.preservedPoints || {}, a = t.getGraph(), o = a.data, s = a.edgeData, c = t.getModel("force"), l = c.get("initLayout");
			t.preservedPoints ? o.each(function(t) {
				var n = o.getId(t);
				o.setItemLayout(t, r[n] || [NaN, NaN]);
			}) : !l || l === "none" ? simpleLayout(t) : l === "circular" && circularLayout(t, "value");
			var u = o.getDataExtent("value"), d = s.getDataExtent("value"), f = c.get("repulsion"), p = c.get("edgeLength"), h = isArray(f) ? f : [f, f], g = isArray(p) ? p : [p, p];
			g = [g[1], g[0]];
			var _ = o.mapArray("value", function(t, n) {
				var r = o.getItemLayout(n), a = linearMap$2(t, u, h);
				return isNaN(a) && (a = (h[0] + h[1]) / 2), {
					w: a,
					rep: a,
					fixed: o.getItemModel(n).get("fixed"),
					p: !r || isNaN(r[0]) || isNaN(r[1]) ? null : r
				};
			}), v = forceLayout(_, s.mapArray("value", function(n, r) {
				var o = a.getEdgeByIndex(r), s = linearMap$2(n, d, g);
				isNaN(s) && (s = (g[0] + g[1]) / 2);
				var c = o.getModel(), l = retrieve3(o.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(o, t, r, !0), 0);
				return {
					n1: _[o.node1.dataIndex],
					n2: _[o.node2.dataIndex],
					d: s,
					curveness: l,
					ignoreForceLayout: c.get("ignoreForceLayout")
				};
			}), {
				rect: n.getBoundingRect(),
				gravity: c.get("gravity"),
				friction: c.get("friction")
			});
			v.beforeStep(function(t, n) {
				for (var r = 0, o = t.length; r < o; r++) t[r].fixed && copy$1(t[r].p, a.getNodeByIndex(r).getLayout());
			}), v.afterStep(function(t, n, s) {
				for (var c = 0, l = t.length; c < l; c++) t[c].fixed || a.getNodeByIndex(c).setLayout(t[c].p), r[o.getId(c)] = t[c].p;
				for (var c = 0, l = n.length; c < l; c++) {
					var u = n[c], d = a.getEdgeByIndex(c), f = u.n1.p, p = u.n2.p, h = d.getLayout();
					h = h ? h.slice() : [], h[0] = h[0] || [], h[1] = h[1] || [], copy$1(h[0], f), copy$1(h[1], p), +u.curveness && (h[2] = [(f[0] + p[0]) / 2 - (f[1] - p[1]) * u.curveness, (f[1] + p[1]) / 2 - (p[0] - f[0]) * u.curveness]), d.setLayout(h);
				}
			}), t.forceLayout = v, t.preservedPoints = r, v.step();
		} else t.forceLayout = null;
	});
}
function getViewRect$3(t, n, r) {
	return getLayoutRect(extend(t.getBoxLayoutParams(), { aspect: r }), {
		width: n.getWidth(),
		height: n.getHeight()
	});
}
function createViewCoordSys(t, n) {
	var r = [];
	return t.eachSeriesByType("graph", function(t) {
		var a = t.get("coordinateSystem");
		if (!a || a === "view") {
			var o = t.getData(), s = o.mapArray(function(t) {
				var n = o.getItemModel(t);
				return [+n.get("x"), +n.get("y")];
			}), c = [], l = [];
			fromPoints(s, c, l), l[0] - c[0] === 0 && (l[0] += 1, --c[0]), l[1] - c[1] === 0 && (l[1] += 1, --c[1]);
			var u = (l[0] - c[0]) / (l[1] - c[1]), d = getViewRect$3(t, n, u);
			isNaN(u) && (c = [d.x, d.y], l = [d.x + d.width, d.y + d.height]);
			var f = l[0] - c[0], p = l[1] - c[1], h = d.width, g = d.height, _ = t.coordinateSystem = new View_default();
			_.zoomLimit = t.get("scaleLimit"), _.setBoundingRect(c[0], c[1], f, p), _.setViewRect(d.x, d.y, h, g), _.setCenter(t.get("center"), n), _.setZoom(t.get("zoom")), r.push(_);
		}
	}), r;
}
var straightLineProto = Line_default$1.prototype, bezierCurveProto = BezierCurve_default.prototype, StraightLineShape = function() {
	function t() {
		this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
	}
	return t;
}();
(function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n;
})(StraightLineShape);
function isStraightLine(t) {
	return isNaN(+t.cpx1) || isNaN(+t.cpy1);
}
var LinePath_default = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this, n) || this;
		return r.type = "ec-line", r;
	}
	return n.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	}, n.prototype.getDefaultShape = function() {
		return new StraightLineShape();
	}, n.prototype.buildPath = function(t, n) {
		isStraightLine(n) ? straightLineProto.buildPath.call(this, t, n) : bezierCurveProto.buildPath.call(this, t, n);
	}, n.prototype.pointAt = function(t) {
		return isStraightLine(this.shape) ? straightLineProto.pointAt.call(this, t) : bezierCurveProto.pointAt.call(this, t);
	}, n.prototype.tangentAt = function(t) {
		var n = this.shape, r = isStraightLine(n) ? [n.x2 - n.x1, n.y2 - n.y1] : bezierCurveProto.tangentAt.call(this, t);
		return normalize$3(r, r);
	}, n;
}(Path_default), SYMBOL_CATEGORIES = ["fromSymbol", "toSymbol"];
function makeSymbolTypeKey(t) {
	return "_" + t + "Type";
}
function makeSymbolTypeValue(t, n, r) {
	var a = n.getItemVisual(r, t);
	if (!a || a === "none") return a;
	var o = n.getItemVisual(r, t + "Size"), s = n.getItemVisual(r, t + "Rotate"), c = n.getItemVisual(r, t + "Offset"), l = n.getItemVisual(r, t + "KeepAspect"), u = normalizeSymbolSize(o), d = normalizeSymbolOffset(c || 0, u);
	return a + u + d + (s || "") + (l || "");
}
function createSymbol$1(t, n, r) {
	var a = n.getItemVisual(r, t);
	if (!(!a || a === "none")) {
		var o = n.getItemVisual(r, t + "Size"), s = n.getItemVisual(r, t + "Rotate"), c = n.getItemVisual(r, t + "Offset"), l = n.getItemVisual(r, t + "KeepAspect"), u = normalizeSymbolSize(o), d = normalizeSymbolOffset(c || 0, u), f = createSymbol(a, -u[0] / 2 + d[0], -u[1] / 2 + d[1], u[0], u[1], null, l);
		return f.__specifiedRotation = s == null || isNaN(s) ? void 0 : +s * Math.PI / 180 || 0, f.name = t, f;
	}
}
function createLine(t) {
	var n = new LinePath_default({
		name: "line",
		subPixelOptimize: !0
	});
	return setLinePoints(n.shape, t), n;
}
function setLinePoints(t, n) {
	t.x1 = n[0][0], t.y1 = n[0][1], t.x2 = n[1][0], t.y2 = n[1][1], t.percent = 1;
	var r = n[2];
	r ? (t.cpx1 = r[0], t.cpy1 = r[1]) : (t.cpx1 = NaN, t.cpy1 = NaN);
}
var Line_default = function(t) {
	__extends(n, t);
	function n(n, r, a) {
		var o = t.call(this) || this;
		return o._createLine(n, r, a), o;
	}
	return n.prototype._createLine = function(t, n, r) {
		var a = t.hostModel, o = createLine(t.getItemLayout(n));
		o.shape.percent = 0, initProps(o, { shape: { percent: 1 } }, a, n), this.add(o), each(SYMBOL_CATEGORIES, function(r) {
			var a = createSymbol$1(r, t, n);
			this.add(a), this[makeSymbolTypeKey(r)] = makeSymbolTypeValue(r, t, n);
		}, this), this._updateCommonStl(t, n, r);
	}, n.prototype.updateData = function(t, n, r) {
		var a = t.hostModel, o = this.childOfName("line"), s = t.getItemLayout(n), c = { shape: {} };
		setLinePoints(c.shape, s), updateProps(o, c, a, n), each(SYMBOL_CATEGORIES, function(r) {
			var a = makeSymbolTypeValue(r, t, n), o = makeSymbolTypeKey(r);
			if (this[o] !== a) {
				this.remove(this.childOfName(r));
				var s = createSymbol$1(r, t, n);
				this.add(s);
			}
			this[o] = a;
		}, this), this._updateCommonStl(t, n, r);
	}, n.prototype.getLinePath = function() {
		return this.childAt(0);
	}, n.prototype._updateCommonStl = function(t, n, r) {
		var a = t.hostModel, o = this.childOfName("line"), s = r && r.emphasisLineStyle, c = r && r.blurLineStyle, l = r && r.selectLineStyle, u = r && r.labelStatesModels, d = r && r.emphasisDisabled, f = r && r.focus, p = r && r.blurScope;
		if (!r || t.hasItemOption) {
			var h = t.getItemModel(n), g = h.getModel("emphasis");
			s = g.getModel("lineStyle").getLineStyle(), c = h.getModel(["blur", "lineStyle"]).getLineStyle(), l = h.getModel(["select", "lineStyle"]).getLineStyle(), d = g.get("disabled"), f = g.get("focus"), p = g.get("blurScope"), u = getLabelStatesModels(h);
		}
		var _ = t.getItemVisual(n, "style"), v = _.stroke;
		o.useStyle(_), o.style.fill = null, o.style.strokeNoScale = !0, o.ensureState("emphasis").style = s, o.ensureState("blur").style = c, o.ensureState("select").style = l, each(SYMBOL_CATEGORIES, function(t) {
			var n = this.childOfName(t);
			if (n) {
				n.setColor(v), n.style.opacity = _.opacity;
				for (var r = 0; r < SPECIAL_STATES.length; r++) {
					var a = SPECIAL_STATES[r], s = o.getState(a);
					if (s) {
						var c = s.style || {}, l = n.ensureState(a), u = l.style ||= {};
						c.stroke != null && (u[n.__isEmptyBrush ? "stroke" : "fill"] = c.stroke), c.opacity != null && (u.opacity = c.opacity);
					}
				}
				n.markRedraw();
			}
		}, this);
		var y = a.getRawValue(n);
		setLabelStyle(this, u, {
			labelDataIndex: n,
			labelFetcher: { getFormattedLabel: function(n, r) {
				return a.getFormattedLabel(n, r, t.dataType);
			} },
			inheritColor: v || "#000",
			defaultOpacity: _.opacity,
			defaultText: (y == null ? t.getName(n) : isFinite(y) ? round$1(y) : y) + ""
		});
		var b = this.getTextContent();
		if (b) {
			var x = u.normal;
			b.__align = b.style.align, b.__verticalAlign = b.style.verticalAlign, b.__position = x.get("position") || "middle";
			var S = x.get("distance");
			isArray(S) || (S = [S, S]), b.__labelDistance = S;
		}
		this.setTextConfig({
			position: null,
			local: !0,
			inside: !1
		}), toggleHoverEmphasis(this, f, p, d);
	}, n.prototype.highlight = function() {
		enterEmphasis(this);
	}, n.prototype.downplay = function() {
		leaveEmphasis(this);
	}, n.prototype.updateLayout = function(t, n) {
		this.setLinePoints(t.getItemLayout(n));
	}, n.prototype.setLinePoints = function(t) {
		var n = this.childOfName("line");
		setLinePoints(n.shape, t), n.dirty();
	}, n.prototype.beforeUpdate = function() {
		var t = this, n = t.childOfName("fromSymbol"), r = t.childOfName("toSymbol"), a = t.getTextContent();
		if (!n && !r && (!a || a.ignore)) return;
		for (var o = 1, s = this.parent; s;) s.scaleX && (o /= s.scaleX), s = s.parent;
		var c = t.childOfName("line");
		if (!this.__dirty && !c.__dirty) return;
		var l = c.shape.percent, u = c.pointAt(0), d = c.pointAt(l), f = sub([], d, u);
		normalize$3(f, f);
		function p(t, n) {
			var r = t.__specifiedRotation;
			if (r == null) {
				var a = c.tangentAt(n);
				t.attr("rotation", (n === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(a[1], a[0]));
			} else t.attr("rotation", r);
		}
		if (n && (n.setPosition(u), p(n, 0), n.scaleX = n.scaleY = o * l, n.markRedraw()), r && (r.setPosition(d), p(r, 1), r.scaleX = r.scaleY = o * l, r.markRedraw()), a && !a.ignore) {
			a.x = a.y = 0, a.originX = a.originY = 0;
			var h = void 0, g = void 0, _ = a.__labelDistance, v = _[0] * o, y = _[1] * o, b = l / 2, x = c.tangentAt(b), S = [x[1], -x[0]], C = c.pointAt(b);
			S[1] > 0 && (S[0] = -S[0], S[1] = -S[1]);
			var w = x[0] < 0 ? -1 : 1;
			if (a.__position !== "start" && a.__position !== "end") {
				var T = -Math.atan2(x[1], x[0]);
				d[0] < u[0] && (T = Math.PI + T), a.rotation = T;
			}
			var E = void 0;
			switch (a.__position) {
				case "insideStartTop":
				case "insideMiddleTop":
				case "insideEndTop":
				case "middle":
					E = -y, g = "bottom";
					break;
				case "insideStartBottom":
				case "insideMiddleBottom":
				case "insideEndBottom":
					E = y, g = "top";
					break;
				default: E = 0, g = "middle";
			}
			switch (a.__position) {
				case "end":
					a.x = f[0] * v + d[0], a.y = f[1] * y + d[1], h = f[0] > .8 ? "left" : f[0] < -.8 ? "right" : "center", g = f[1] > .8 ? "top" : f[1] < -.8 ? "bottom" : "middle";
					break;
				case "start":
					a.x = -f[0] * v + u[0], a.y = -f[1] * y + u[1], h = f[0] > .8 ? "right" : f[0] < -.8 ? "left" : "center", g = f[1] > .8 ? "bottom" : f[1] < -.8 ? "top" : "middle";
					break;
				case "insideStartTop":
				case "insideStart":
				case "insideStartBottom":
					a.x = v * w + u[0], a.y = u[1] + E, h = x[0] < 0 ? "right" : "left", a.originX = -v * w, a.originY = -E;
					break;
				case "insideMiddleTop":
				case "insideMiddle":
				case "insideMiddleBottom":
				case "middle":
					a.x = C[0], a.y = C[1] + E, h = "center", a.originY = -E;
					break;
				case "insideEndTop":
				case "insideEnd":
				case "insideEndBottom":
					a.x = -v * w + d[0], a.y = d[1] + E, h = x[0] >= 0 ? "right" : "left", a.originX = v * w, a.originY = -E;
					break;
			}
			a.scaleX = a.scaleY = o, a.setStyle({
				verticalAlign: a.__verticalAlign || g,
				align: a.__align || h
			});
		}
	}, n;
}(Group_default), LineDraw = function() {
	function t(t) {
		this.group = new Group_default(), this._LineCtor = t || Line_default;
	}
	return t.prototype.updateData = function(t) {
		var n = this;
		this._progressiveEls = null;
		var r = this, a = r.group, o = r._lineData;
		r._lineData = t, o || a.removeAll();
		var s = makeSeriesScope$1(t);
		t.diff(o).add(function(r) {
			n._doAdd(t, r, s);
		}).update(function(r, a) {
			n._doUpdate(o, t, a, r, s);
		}).remove(function(t) {
			a.remove(o.getItemGraphicEl(t));
		}).execute();
	}, t.prototype.updateLayout = function() {
		var t = this._lineData;
		t && t.eachItemGraphicEl(function(n, r) {
			n.updateLayout(t, r);
		}, this);
	}, t.prototype.incrementalPrepareUpdate = function(t) {
		this._seriesScope = makeSeriesScope$1(t), this._lineData = null, this.group.removeAll();
	}, t.prototype.incrementalUpdate = function(t, n) {
		this._progressiveEls = [];
		function r(t) {
			!t.isGroup && !isEffectObject(t) && (t.incremental = !0, t.ensureState("emphasis").hoverLayer = !0);
		}
		for (var a = t.start; a < t.end; a++) if (lineNeedsDraw(n.getItemLayout(a))) {
			var o = new this._LineCtor(n, a, this._seriesScope);
			o.traverse(r), this.group.add(o), n.setItemGraphicEl(a, o), this._progressiveEls.push(o);
		}
	}, t.prototype.remove = function() {
		this.group.removeAll();
	}, t.prototype.eachRendered = function(t) {
		traverseElements(this._progressiveEls || this.group, t);
	}, t.prototype._doAdd = function(t, n, r) {
		if (lineNeedsDraw(t.getItemLayout(n))) {
			var a = new this._LineCtor(t, n, r);
			t.setItemGraphicEl(n, a), this.group.add(a);
		}
	}, t.prototype._doUpdate = function(t, n, r, a, o) {
		var s = t.getItemGraphicEl(r);
		if (!lineNeedsDraw(n.getItemLayout(a))) {
			this.group.remove(s);
			return;
		}
		s ? s.updateData(n, a, o) : s = new this._LineCtor(n, a, o), n.setItemGraphicEl(a, s), this.group.add(s);
	}, t;
}();
function isEffectObject(t) {
	return t.animators && t.animators.length > 0;
}
function makeSeriesScope$1(t) {
	var n = t.hostModel, r = n.getModel("emphasis");
	return {
		lineStyle: n.getModel("lineStyle").getLineStyle(),
		emphasisLineStyle: r.getModel(["lineStyle"]).getLineStyle(),
		blurLineStyle: n.getModel(["blur", "lineStyle"]).getLineStyle(),
		selectLineStyle: n.getModel(["select", "lineStyle"]).getLineStyle(),
		emphasisDisabled: r.get("disabled"),
		blurScope: r.get("blurScope"),
		focus: r.get("focus"),
		labelStatesModels: getLabelStatesModels(n)
	};
}
function isPointNaN(t) {
	return isNaN(t[0]) || isNaN(t[1]);
}
function lineNeedsDraw(t) {
	return t && !isPointNaN(t[0]) && !isPointNaN(t[1]);
}
var LineDraw_default = LineDraw, v1 = [], v2 = [], v3 = [], quadraticAt = quadraticAt$1, v2DistSquare = distSquare, mathAbs = Math.abs;
function intersectCurveCircle(t, n, r) {
	for (var a = t[0], o = t[1], s = t[2], c = Infinity, l, u = r * r, d = .1, f = .1; f <= .9; f += .1) {
		v1[0] = quadraticAt(a[0], o[0], s[0], f), v1[1] = quadraticAt(a[1], o[1], s[1], f);
		var p = mathAbs(v2DistSquare(v1, n) - u);
		p < c && (c = p, l = f);
	}
	for (var h = 0; h < 32; h++) {
		var g = l + d;
		v2[0] = quadraticAt(a[0], o[0], s[0], l), v2[1] = quadraticAt(a[1], o[1], s[1], l), v3[0] = quadraticAt(a[0], o[0], s[0], g), v3[1] = quadraticAt(a[1], o[1], s[1], g);
		var p = v2DistSquare(v2, n) - u;
		if (mathAbs(p) < .01) break;
		var _ = v2DistSquare(v3, n) - u;
		d /= 2, p < 0 ? _ >= 0 ? l += d : l -= d : _ >= 0 ? l -= d : l += d;
	}
	return l;
}
function adjustEdge(t, n) {
	var r = [], a = quadraticSubdivide, o = [
		[],
		[],
		[]
	], s = [[], []], c = [];
	n /= 2, t.eachEdge(function(t, l) {
		var u = t.getLayout(), d = t.getVisual("fromSymbol"), f = t.getVisual("toSymbol");
		u.__original || (u.__original = [clone$3(u[0]), clone$3(u[1])], u[2] && u.__original.push(clone$3(u[2])));
		var p = u.__original;
		if (u[2] != null) {
			if (copy$1(o[0], p[0]), copy$1(o[1], p[2]), copy$1(o[2], p[1]), d && d !== "none") {
				var h = getSymbolSize(t.node1), g = intersectCurveCircle(o, p[0], h * n);
				a(o[0][0], o[1][0], o[2][0], g, r), o[0][0] = r[3], o[1][0] = r[4], a(o[0][1], o[1][1], o[2][1], g, r), o[0][1] = r[3], o[1][1] = r[4];
			}
			if (f && f !== "none") {
				var h = getSymbolSize(t.node2), g = intersectCurveCircle(o, p[1], h * n);
				a(o[0][0], o[1][0], o[2][0], g, r), o[1][0] = r[1], o[2][0] = r[2], a(o[0][1], o[1][1], o[2][1], g, r), o[1][1] = r[1], o[2][1] = r[2];
			}
			copy$1(u[0], o[0]), copy$1(u[1], o[2]), copy$1(u[2], o[1]);
		} else {
			if (copy$1(s[0], p[0]), copy$1(s[1], p[1]), sub(c, s[1], s[0]), normalize$3(c, c), d && d !== "none") {
				var h = getSymbolSize(t.node1);
				scaleAndAdd$1(s[0], s[0], c, h * n);
			}
			if (f && f !== "none") {
				var h = getSymbolSize(t.node2);
				scaleAndAdd$1(s[1], s[1], c, -h * n);
			}
			copy$1(u[0], s[0]), copy$1(u[1], s[1]);
		}
	});
}
function isViewCoordSys(t) {
	return t.type === "view";
}
var GraphView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.init = function(t, n) {
		var r = new SymbolDraw_default(), a = new LineDraw_default(), o = this.group;
		this._controller = new RoamController_default(n.getZr()), this._controllerHost = { target: o }, o.add(r.group), o.add(a.group), this._symbolDraw = r, this._lineDraw = a, this._firstRender = !0;
	}, n.prototype.render = function(t, n, r) {
		var a = this, o = t.coordinateSystem;
		this._model = t;
		var s = this._symbolDraw, c = this._lineDraw, l = this.group;
		if (isViewCoordSys(o)) {
			var u = {
				x: o.x,
				y: o.y,
				scaleX: o.scaleX,
				scaleY: o.scaleY
			};
			this._firstRender ? l.attr(u) : updateProps(l, u, t);
		}
		adjustEdge(t.getGraph(), getNodeGlobalScale(t));
		var d = t.getData();
		s.updateData(d);
		var f = t.getEdgeData();
		c.updateData(f), this._updateNodeAndLinkScale(), this._updateController(t, n, r), clearTimeout(this._layoutTimeout);
		var p = t.forceLayout, h = t.get(["force", "layoutAnimation"]);
		p && this._startForceLayoutIteration(p, h);
		var g = t.get("layout");
		d.graph.eachNode(function(n) {
			var r = n.dataIndex, o = n.getGraphicEl(), s = n.getModel();
			if (o) {
				o.off("drag").off("dragend");
				var c = s.get("draggable");
				c && o.on("drag", function(s) {
					switch (g) {
						case "force":
							p.warmUp(), !a._layouting && a._startForceLayoutIteration(p, h), p.setFixed(r), d.setItemLayout(r, [o.x, o.y]);
							break;
						case "circular":
							d.setItemLayout(r, [o.x, o.y]), n.setLayout({ fixed: !0 }, !0), circularLayout(t, "symbolSize", n, [s.offsetX, s.offsetY]), a.updateLayout(t);
							break;
						case "none":
						default:
							d.setItemLayout(r, [o.x, o.y]), simpleLayoutEdge(t.getGraph(), t), a.updateLayout(t);
							break;
					}
				}).on("dragend", function() {
					p && p.setUnfixed(r);
				}), o.setDraggable(c, !!s.get("cursor")), s.get(["emphasis", "focus"]) === "adjacency" && (getECData(o).focus = n.getAdjacentDataIndices());
			}
		}), d.graph.eachEdge(function(t) {
			var n = t.getGraphicEl(), r = t.getModel().get(["emphasis", "focus"]);
			n && r === "adjacency" && (getECData(n).focus = {
				edge: [t.dataIndex],
				node: [t.node1.dataIndex, t.node2.dataIndex]
			});
		});
		var _ = t.get("layout") === "circular" && t.get(["circular", "rotateLabel"]), v = d.getLayout("cx"), y = d.getLayout("cy");
		d.graph.eachNode(function(t) {
			rotateNodeLabel(t, _, v, y);
		}), this._firstRender = !1;
	}, n.prototype.dispose = function() {
		this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
	}, n.prototype._startForceLayoutIteration = function(t, n) {
		var r = this;
		(function a() {
			t.step(function(t) {
				r.updateLayout(r._model), (r._layouting = !t) && (n ? r._layoutTimeout = setTimeout(a, 16) : a());
			});
		})();
	}, n.prototype._updateController = function(t, n, r) {
		var a = this, o = this._controller, s = this._controllerHost, c = this.group;
		if (o.setPointerChecker(function(n, a, o) {
			var s = c.getBoundingRect();
			return s.applyTransform(c.transform), s.contain(a, o) && !onIrrelevantElement(n, r, t);
		}), !isViewCoordSys(t.coordinateSystem)) {
			o.disable();
			return;
		}
		o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(n) {
			updateViewOnPan(s, n.dx, n.dy), r.dispatchAction({
				seriesId: t.id,
				type: "graphRoam",
				dx: n.dx,
				dy: n.dy
			});
		}).on("zoom", function(n) {
			updateViewOnZoom(s, n.scale, n.originX, n.originY), r.dispatchAction({
				seriesId: t.id,
				type: "graphRoam",
				zoom: n.scale,
				originX: n.originX,
				originY: n.originY
			}), a._updateNodeAndLinkScale(), adjustEdge(t.getGraph(), getNodeGlobalScale(t)), a._lineDraw.updateLayout(), r.updateLabelLayout();
		});
	}, n.prototype._updateNodeAndLinkScale = function() {
		var t = this._model, n = t.getData(), r = getNodeGlobalScale(t);
		n.eachItemGraphicEl(function(t, n) {
			t && t.setSymbolScale(r);
		});
	}, n.prototype.updateLayout = function(t) {
		adjustEdge(t.getGraph(), getNodeGlobalScale(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
	}, n.prototype.remove = function() {
		clearTimeout(this._layoutTimeout), this._layouting = !1, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
	}, n.type = "graph", n;
}(Chart_default);
init_dist$2();
function generateNodeKey(t) {
	return "_EC_" + t;
}
var Graph = function() {
	function t(t) {
		this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || !1;
	}
	return t.prototype.isDirected = function() {
		return this._directed;
	}, t.prototype.addNode = function(t, n) {
		t = t == null ? "" + n : "" + t;
		var r = this._nodesMap;
		if (r[generateNodeKey(t)]) {
			process$1.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
			return;
		}
		var a = new GraphNode(t, n);
		return a.hostGraph = this, this.nodes.push(a), r[generateNodeKey(t)] = a, a;
	}, t.prototype.getNodeByIndex = function(t) {
		var n = this.data.getRawIndex(t);
		return this.nodes[n];
	}, t.prototype.getNodeById = function(t) {
		return this._nodesMap[generateNodeKey(t)];
	}, t.prototype.addEdge = function(t, n, r) {
		var a = this._nodesMap, o = this._edgesMap;
		if (isNumber(t) && (t = this.nodes[t]), isNumber(n) && (n = this.nodes[n]), t instanceof GraphNode || (t = a[generateNodeKey(t)]), n instanceof GraphNode || (n = a[generateNodeKey(n)]), !(!t || !n)) {
			var s = t.id + "-" + n.id, c = new GraphEdge(t, n, r);
			return c.hostGraph = this, this._directed && (t.outEdges.push(c), n.inEdges.push(c)), t.edges.push(c), t !== n && n.edges.push(c), this.edges.push(c), o[s] = c, c;
		}
	}, t.prototype.getEdgeByIndex = function(t) {
		var n = this.edgeData.getRawIndex(t);
		return this.edges[n];
	}, t.prototype.getEdge = function(t, n) {
		t instanceof GraphNode && (t = t.id), n instanceof GraphNode && (n = n.id);
		var r = this._edgesMap;
		return this._directed ? r[t + "-" + n] : r[t + "-" + n] || r[n + "-" + t];
	}, t.prototype.eachNode = function(t, n) {
		for (var r = this.nodes, a = r.length, o = 0; o < a; o++) r[o].dataIndex >= 0 && t.call(n, r[o], o);
	}, t.prototype.eachEdge = function(t, n) {
		for (var r = this.edges, a = r.length, o = 0; o < a; o++) r[o].dataIndex >= 0 && r[o].node1.dataIndex >= 0 && r[o].node2.dataIndex >= 0 && t.call(n, r[o], o);
	}, t.prototype.breadthFirstTraverse = function(t, n, r, a) {
		if (n instanceof GraphNode || (n = this._nodesMap[generateNodeKey(n)]), n) {
			for (var o = r === "out" ? "outEdges" : r === "in" ? "inEdges" : "edges", s = 0; s < this.nodes.length; s++) this.nodes[s].__visited = !1;
			if (!t.call(a, n, null)) for (var c = [n]; c.length;) for (var l = c.shift(), u = l[o], s = 0; s < u.length; s++) {
				var d = u[s], f = d.node1 === l ? d.node2 : d.node1;
				if (!f.__visited) {
					if (t.call(a, f, l)) return;
					c.push(f), f.__visited = !0;
				}
			}
		}
	}, t.prototype.update = function() {
		for (var t = this.data, n = this.edgeData, r = this.nodes, a = this.edges, o = 0, s = r.length; o < s; o++) r[o].dataIndex = -1;
		for (var o = 0, s = t.count(); o < s; o++) r[t.getRawIndex(o)].dataIndex = o;
		n.filterSelf(function(t) {
			var r = a[n.getRawIndex(t)];
			return r.node1.dataIndex >= 0 && r.node2.dataIndex >= 0;
		});
		for (var o = 0, s = a.length; o < s; o++) a[o].dataIndex = -1;
		for (var o = 0, s = n.count(); o < s; o++) a[n.getRawIndex(o)].dataIndex = o;
	}, t.prototype.clone = function() {
		for (var n = new t(this._directed), r = this.nodes, a = this.edges, o = 0; o < r.length; o++) n.addNode(r[o].id, r[o].dataIndex);
		for (var o = 0; o < a.length; o++) {
			var s = a[o];
			n.addEdge(s.node1.id, s.node2.id, s.dataIndex);
		}
		return n;
	}, t;
}(), GraphNode = function() {
	function t(t, n) {
		this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t ?? "", this.dataIndex = n ?? -1;
	}
	return t.prototype.degree = function() {
		return this.edges.length;
	}, t.prototype.inDegree = function() {
		return this.inEdges.length;
	}, t.prototype.outDegree = function() {
		return this.outEdges.length;
	}, t.prototype.getModel = function(t) {
		if (!(this.dataIndex < 0)) return this.hostGraph.data.getItemModel(this.dataIndex).getModel(t);
	}, t.prototype.getAdjacentDataIndices = function() {
		for (var t = {
			edge: [],
			node: []
		}, n = 0; n < this.edges.length; n++) {
			var r = this.edges[n];
			r.dataIndex < 0 || (t.edge.push(r.dataIndex), t.node.push(r.node1.dataIndex, r.node2.dataIndex));
		}
		return t;
	}, t.prototype.getTrajectoryDataIndices = function() {
		for (var t = createHashMap(), n = createHashMap(), r = 0; r < this.edges.length; r++) {
			var a = this.edges[r];
			if (!(a.dataIndex < 0)) {
				t.set(a.dataIndex, !0);
				for (var o = [a.node1], s = [a.node2], c = 0; c < o.length;) {
					var l = o[c];
					c++, n.set(l.dataIndex, !0);
					for (var u = 0; u < l.inEdges.length; u++) t.set(l.inEdges[u].dataIndex, !0), o.push(l.inEdges[u].node1);
				}
				for (c = 0; c < s.length;) {
					var d = s[c];
					c++, n.set(d.dataIndex, !0);
					for (var u = 0; u < d.outEdges.length; u++) t.set(d.outEdges[u].dataIndex, !0), s.push(d.outEdges[u].node2);
				}
			}
		}
		return {
			edge: t.keys(),
			node: n.keys()
		};
	}, t;
}(), GraphEdge = function() {
	function t(t, n, r) {
		this.dataIndex = -1, this.node1 = t, this.node2 = n, this.dataIndex = r ?? -1;
	}
	return t.prototype.getModel = function(t) {
		if (!(this.dataIndex < 0)) return this.hostGraph.edgeData.getItemModel(this.dataIndex).getModel(t);
	}, t.prototype.getAdjacentDataIndices = function() {
		return {
			edge: [this.dataIndex],
			node: [this.node1.dataIndex, this.node2.dataIndex]
		};
	}, t.prototype.getTrajectoryDataIndices = function() {
		var t = createHashMap(), n = createHashMap();
		t.set(this.dataIndex, !0);
		for (var r = [this.node1], a = [this.node2], o = 0; o < r.length;) {
			var s = r[o];
			o++, n.set(s.dataIndex, !0);
			for (var c = 0; c < s.inEdges.length; c++) t.set(s.inEdges[c].dataIndex, !0), r.push(s.inEdges[c].node1);
		}
		for (o = 0; o < a.length;) {
			var l = a[o];
			o++, n.set(l.dataIndex, !0);
			for (var c = 0; c < l.outEdges.length; c++) t.set(l.outEdges[c].dataIndex, !0), a.push(l.outEdges[c].node2);
		}
		return {
			edge: t.keys(),
			node: n.keys()
		};
	}, t;
}();
function createGraphDataProxyMixin(t, n) {
	return {
		getValue: function(r) {
			var a = this[t][n];
			return a.getStore().get(a.getDimensionIndex(r || "value"), this.dataIndex);
		},
		setVisual: function(r, a) {
			this.dataIndex >= 0 && this[t][n].setItemVisual(this.dataIndex, r, a);
		},
		getVisual: function(r) {
			return this[t][n].getItemVisual(this.dataIndex, r);
		},
		setLayout: function(r, a) {
			this.dataIndex >= 0 && this[t][n].setItemLayout(this.dataIndex, r, a);
		},
		getLayout: function() {
			return this[t][n].getItemLayout(this.dataIndex);
		},
		getGraphicEl: function() {
			return this[t][n].getItemGraphicEl(this.dataIndex);
		},
		getRawIndex: function() {
			return this[t][n].getRawIndex(this.dataIndex);
		}
	};
}
mixin(GraphNode, createGraphDataProxyMixin("hostGraph", "data")), mixin(GraphEdge, createGraphDataProxyMixin("hostGraph", "edgeData"));
var Graph_default = Graph;
function createGraphFromNodeEdge(t, n, r, a, o) {
	for (var s = new Graph_default(a), c = 0; c < t.length; c++) s.addNode(retrieve(t[c].id, t[c].name, c), c);
	for (var l = [], u = [], d = 0, c = 0; c < n.length; c++) {
		var f = n[c], p = f.source, h = f.target;
		s.addEdge(p, h, d) && (u.push(f), l.push(retrieve(convertOptionIdName(f.id, null), p + " > " + h)), d++);
	}
	var g = r.get("coordinateSystem"), _;
	if (g === "cartesian2d" || g === "polar") _ = createSeriesData_default(t, r);
	else {
		var v = CoordinateSystem_default.get(g), y = v && v.dimensions || [];
		indexOf(y, "value") < 0 && y.concat(["value"]);
		var b = prepareSeriesDataSchema(t, {
			coordDimensions: y,
			encodeDefine: r.getEncode()
		}).dimensions;
		_ = new SeriesData_default(b, r), _.initData(t);
	}
	var x = new SeriesData_default(["value"], r);
	return x.initData(u, l), o && o(_, x), linkSeriesData_default({
		mainData: _,
		struct: s,
		structAttr: "graph",
		datas: {
			node: _,
			edge: x
		},
		datasAttr: {
			node: "data",
			edge: "edgeData"
		}
	}), s.update(), s;
}
var GraphSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.hasSymbolVisual = !0, r;
	}
	return n.prototype.init = function(n) {
		t.prototype.init.apply(this, arguments);
		var r = this;
		function a() {
			return r._categoriesData;
		}
		this.legendVisualProvider = new LegendVisualProvider_default(a, a), this.fillDataTextStyle(n.edges || n.links), this._updateCategoriesData();
	}, n.prototype.mergeOption = function(n) {
		t.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(n.edges || n.links), this._updateCategoriesData();
	}, n.prototype.mergeDefaultAndTheme = function(n) {
		t.prototype.mergeDefaultAndTheme.apply(this, arguments), defaultEmphasis(n, "edgeLabel", ["show"]);
	}, n.prototype.getInitialData = function(t, n) {
		var r = t.edges || t.links || [], a = t.data || t.nodes || [], o = this;
		if (a && r) {
			initCurvenessList(this);
			var s = createGraphFromNodeEdge(a, r, this, !0, c);
			return each(s.edges, function(t) {
				createEdgeMapForCurveness(t.node1, t.node2, this, t.dataIndex);
			}, this), s.data;
		}
		function c(t, n) {
			t.wrapMethod("getItemModel", function(t) {
				var n = o._categoriesModels[t.getShallow("category")];
				return n && (n.parentModel = t.parentModel, t.parentModel = n), t;
			});
			var r = Model_default.prototype.getModel;
			function a(t, n) {
				var a = r.call(this, t, n);
				return a.resolveParentPath = s, a;
			}
			n.wrapMethod("getItemModel", function(t) {
				return t.resolveParentPath = s, t.getModel = a, t;
			});
			function s(t) {
				if (t && (t[0] === "label" || t[1] === "label")) {
					var n = t.slice();
					return t[0] === "label" ? n[0] = "edgeLabel" : t[1] === "label" && (n[1] = "edgeLabel"), n;
				}
				return t;
			}
		}
	}, n.prototype.getGraph = function() {
		return this.getData().graph;
	}, n.prototype.getEdgeData = function() {
		return this.getGraph().edgeData;
	}, n.prototype.getCategoriesData = function() {
		return this._categoriesData;
	}, n.prototype.formatTooltip = function(t, n, r) {
		if (r === "edge") {
			var a = this.getData(), o = this.getDataParams(t, r), s = a.graph.getEdgeByIndex(t), c = a.getName(s.node1.dataIndex), l = a.getName(s.node2.dataIndex), u = [];
			return c != null && u.push(c), l != null && u.push(l), createTooltipMarkup("nameValue", {
				name: u.join(" > "),
				value: o.value,
				noValue: o.value == null
			});
		}
		return defaultSeriesFormatTooltip({
			series: this,
			dataIndex: t,
			multipleSeries: n
		});
	}, n.prototype._updateCategoriesData = function() {
		var t = map(this.option.categories || [], function(t) {
			return t.value == null ? extend({ value: 0 }, t) : t;
		}), n = new SeriesData_default(["value"], this);
		n.initData(t), this._categoriesData = n, this._categoriesModels = n.mapArray(function(t) {
			return n.getItemModel(t);
		});
	}, n.prototype.setZoom = function(t) {
		this.option.zoom = t;
	}, n.prototype.setCenter = function(t) {
		this.option.center = t;
	}, n.prototype.isAnimationEnabled = function() {
		return t.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
	}, n.type = "series.graph", n.dependencies = [
		"grid",
		"polar",
		"geo",
		"singleAxis",
		"calendar"
	], n.defaultOption = {
		z: 2,
		coordinateSystem: "view",
		legendHoverLink: !0,
		layout: null,
		circular: { rotateLabel: !1 },
		force: {
			initLayout: null,
			repulsion: [0, 50],
			gravity: .1,
			friction: .6,
			edgeLength: 30,
			layoutAnimation: !0
		},
		left: "center",
		top: "center",
		symbol: "circle",
		symbolSize: 10,
		edgeSymbol: ["none", "none"],
		edgeSymbolSize: 10,
		edgeLabel: {
			position: "middle",
			distance: 5
		},
		draggable: !1,
		roam: !1,
		center: null,
		zoom: 1,
		nodeScaleRatio: .6,
		label: {
			show: !1,
			formatter: "{b}"
		},
		itemStyle: {},
		lineStyle: {
			color: "#aaa",
			width: 1,
			opacity: .5
		},
		emphasis: {
			scale: !0,
			label: { show: !0 }
		},
		select: { itemStyle: { borderColor: "#212121" } }
	}, n;
}(Series_default), actionInfo$1 = {
	type: "graphRoam",
	event: "graphRoam",
	update: "none"
};
function install$10(t) {
	t.registerChartView(GraphView_default), t.registerSeriesModel(GraphSeries_default), t.registerProcessor(categoryFilter), t.registerVisual(categoryVisual), t.registerVisual(graphEdgeVisual), t.registerLayout(graphSimpleLayout), t.registerLayout(t.PRIORITY.VISUAL.POST_CHART_LAYOUT, graphCircularLayout), t.registerLayout(graphForceLayout), t.registerCoordinateSystem("graphView", {
		dimensions: View_default.dimensions,
		create: createViewCoordSys
	}), t.registerAction({
		type: "focusNodeAdjacency",
		event: "focusNodeAdjacency",
		update: "series:focusNodeAdjacency"
	}, noop), t.registerAction({
		type: "unfocusNodeAdjacency",
		event: "unfocusNodeAdjacency",
		update: "series:unfocusNodeAdjacency"
	}, noop), t.registerAction(actionInfo$1, function(t, n, r) {
		n.eachComponent({
			mainType: "series",
			query: t
		}, function(n) {
			var a = n.coordinateSystem, o = updateCenterAndZoom(a, t, void 0, r);
			n.setCenter && n.setCenter(o.center), n.setZoom && n.setZoom(o.zoom);
		});
	});
}
var PointerShape = function() {
	function t() {
		this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
	}
	return t;
}(), PointerPath_default = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this, n) || this;
		return r.type = "pointer", r;
	}
	return n.prototype.getDefaultShape = function() {
		return new PointerShape();
	}, n.prototype.buildPath = function(t, n) {
		var r = Math.cos, a = Math.sin, o = n.r, s = n.width, c = n.angle, l = n.x - r(c) * s * (s >= o / 3 ? 1 : 2), u = n.y - a(c) * s * (s >= o / 3 ? 1 : 2);
		c = n.angle - Math.PI / 2, t.moveTo(l, u), t.lineTo(n.x + r(c) * s, n.y + a(c) * s), t.lineTo(n.x + r(n.angle) * o, n.y + a(n.angle) * o), t.lineTo(n.x - r(c) * s, n.y - a(c) * s), t.lineTo(l, u);
	}, n;
}(Path_default);
function parsePosition(t, n) {
	var r = t.get("center"), a = n.getWidth(), o = n.getHeight(), s = Math.min(a, o);
	return {
		cx: parsePercent$1(r[0], n.getWidth()),
		cy: parsePercent$1(r[1], n.getHeight()),
		r: parsePercent$1(t.get("radius"), s / 2)
	};
}
function formatLabel(t, n) {
	var r = t == null ? "" : t + "";
	return n && (isString(n) ? r = n.replace("{value}", r) : isFunction(n) && (r = n(t))), r;
}
var GaugeView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r) {
		this.group.removeAll();
		var a = t.get([
			"axisLine",
			"lineStyle",
			"color"
		]), o = parsePosition(t, r);
		this._renderMain(t, n, r, a, o), this._data = t.getData();
	}, n.prototype.dispose = function() {}, n.prototype._renderMain = function(t, n, r, a, o) {
		var s = this.group, c = t.get("clockwise"), l = -t.get("startAngle") / 180 * Math.PI, u = -t.get("endAngle") / 180 * Math.PI, d = t.getModel("axisLine"), f = d.get("roundCap") ? sausage_default : Sector_default, p = d.get("show"), h = d.getModel("lineStyle"), g = h.get("width"), _ = [l, u];
		normalizeArcAngles(_, !c), l = _[0], u = _[1];
		for (var v = u - l, y = l, b = [], x = 0; p && x < a.length; x++) {
			var S = Math.min(Math.max(a[x][0], 0), 1);
			u = l + v * S;
			var C = new f({
				shape: {
					startAngle: y,
					endAngle: u,
					cx: o.cx,
					cy: o.cy,
					clockwise: c,
					r0: o.r - g,
					r: o.r
				},
				silent: !0
			});
			C.setStyle({ fill: a[x][1] }), C.setStyle(h.getLineStyle(["color", "width"])), b.push(C), y = u;
		}
		b.reverse(), each(b, function(t) {
			return s.add(t);
		});
		var w = function(t) {
			if (t <= 0) return a[0][1];
			var n;
			for (n = 0; n < a.length; n++) if (a[n][0] >= t && (n === 0 ? 0 : a[n - 1][0]) < t) return a[n][1];
			return a[n - 1][1];
		};
		this._renderTicks(t, n, r, w, o, l, u, c, g), this._renderTitleAndDetail(t, n, r, w, o), this._renderAnchor(t, o), this._renderPointer(t, n, r, w, o, l, u, c, g);
	}, n.prototype._renderTicks = function(t, n, r, a, o, s, c, l, u) {
		for (var d = this.group, f = o.cx, p = o.cy, h = o.r, g = +t.get("min"), _ = +t.get("max"), v = t.getModel("splitLine"), y = t.getModel("axisTick"), b = t.getModel("axisLabel"), x = t.get("splitNumber"), S = y.get("splitNumber"), C = parsePercent$1(v.get("length"), h), w = parsePercent$1(y.get("length"), h), T = s, E = (c - s) / x, D = E / S, O = v.getModel("lineStyle").getLineStyle(), A = y.getModel("lineStyle").getLineStyle(), j = v.get("distance"), M, N, P = 0; P <= x; P++) {
			if (M = Math.cos(T), N = Math.sin(T), v.get("show")) {
				var F = j ? j + u : u, I = new Line_default$1({
					shape: {
						x1: M * (h - F) + f,
						y1: N * (h - F) + p,
						x2: M * (h - C - F) + f,
						y2: N * (h - C - F) + p
					},
					style: O,
					silent: !0
				});
				O.stroke === "auto" && I.setStyle({ stroke: a(P / x) }), d.add(I);
			}
			if (b.get("show")) {
				var F = b.get("distance") + j, L = formatLabel(round$1(P / x * (_ - g) + g), b.get("formatter")), R = a(P / x), z = M * (h - C - F) + f, B = N * (h - C - F) + p, V = b.get("rotate"), H = 0;
				V === "radial" ? (H = -T + 2 * Math.PI, H > Math.PI / 2 && (H += Math.PI)) : V === "tangential" ? H = -T - Math.PI / 2 : isNumber(V) && (H = V * Math.PI / 180), H === 0 ? d.add(new Text_default({
					style: createTextStyle(b, {
						text: L,
						x: z,
						y: B,
						verticalAlign: N < -.8 ? "top" : N > .8 ? "bottom" : "middle",
						align: M < -.4 ? "left" : M > .4 ? "right" : "center"
					}, { inheritColor: R }),
					silent: !0
				})) : d.add(new Text_default({
					style: createTextStyle(b, {
						text: L,
						x: z,
						y: B,
						verticalAlign: "middle",
						align: "center"
					}, { inheritColor: R }),
					silent: !0,
					originX: z,
					originY: B,
					rotation: H
				}));
			}
			if (y.get("show") && P !== x) {
				var F = y.get("distance");
				F = F ? F + u : u;
				for (var U = 0; U <= S; U++) {
					M = Math.cos(T), N = Math.sin(T);
					var W = new Line_default$1({
						shape: {
							x1: M * (h - F) + f,
							y1: N * (h - F) + p,
							x2: M * (h - w - F) + f,
							y2: N * (h - w - F) + p
						},
						silent: !0,
						style: A
					});
					A.stroke === "auto" && W.setStyle({ stroke: a((P + U / S) / x) }), d.add(W), T += D;
				}
				T -= D;
			} else T += E;
		}
	}, n.prototype._renderPointer = function(t, n, r, a, o, s, c, l, u) {
		var d = this.group, f = this._data, p = this._progressEls, h = [], g = t.get(["pointer", "show"]), _ = t.getModel("progress"), v = _.get("show"), y = t.getData(), b = y.mapDimension("value"), x = +t.get("min"), S = +t.get("max"), C = [x, S], w = [s, c];
		function T(n, r) {
			var a = y.getItemModel(n).getModel("pointer"), s = parsePercent$1(a.get("width"), o.r), c = parsePercent$1(a.get("length"), o.r), l = t.get(["pointer", "icon"]), u = a.get("offsetCenter"), d = parsePercent$1(u[0], o.r), f = parsePercent$1(u[1], o.r), p = a.get("keepAspect"), h = l ? createSymbol(l, d - s / 2, f - c, s, c, null, p) : new PointerPath_default({ shape: {
				angle: -Math.PI / 2,
				width: s,
				r: c,
				x: d,
				y: f
			} });
			return h.rotation = -(r + Math.PI / 2), h.x = o.cx, h.y = o.cy, h;
		}
		function E(t, n) {
			var r = _.get("roundCap") ? sausage_default : Sector_default, a = _.get("overlap"), c = a ? _.get("width") : u / y.count(), d = a ? o.r - c : o.r - (t + 1) * c, f = a ? o.r : o.r - t * c, p = new r({ shape: {
				startAngle: s,
				endAngle: n,
				cx: o.cx,
				cy: o.cy,
				clockwise: l,
				r0: d,
				r: f
			} });
			return a && (p.z2 = linearMap$2(y.get(b, t), [x, S], [100, 0], !0)), p;
		}
		(v || g) && (y.diff(f).add(function(n) {
			var r = y.get(b, n);
			if (g) {
				var a = T(n, s);
				initProps(a, { rotation: -((isNaN(+r) ? w[0] : linearMap$2(r, C, w, !0)) + Math.PI / 2) }, t), d.add(a), y.setItemGraphicEl(n, a);
			}
			if (v) {
				var o = E(n, s);
				initProps(o, { shape: { endAngle: linearMap$2(r, C, w, _.get("clip")) } }, t), d.add(o), setCommonECData(t.seriesIndex, y.dataType, n, o), h[n] = o;
			}
		}).update(function(n, r) {
			var a = y.get(b, n);
			if (g) {
				var o = f.getItemGraphicEl(r), c = o ? o.rotation : s, l = T(n, c);
				l.rotation = c, updateProps(l, { rotation: -((isNaN(+a) ? w[0] : linearMap$2(a, C, w, !0)) + Math.PI / 2) }, t), d.add(l), y.setItemGraphicEl(n, l);
			}
			if (v) {
				var u = p[r], x = E(n, u ? u.shape.endAngle : s);
				updateProps(x, { shape: { endAngle: linearMap$2(a, C, w, _.get("clip")) } }, t), d.add(x), setCommonECData(t.seriesIndex, y.dataType, n, x), h[n] = x;
			}
		}).execute(), y.each(function(t) {
			var n = y.getItemModel(t), r = n.getModel("emphasis"), o = r.get("focus"), s = r.get("blurScope"), c = r.get("disabled");
			if (g) {
				var l = y.getItemGraphicEl(t), u = y.getItemVisual(t, "style"), d = u.fill;
				if (l instanceof Image_default) {
					var f = l.style;
					l.useStyle(extend({
						image: f.image,
						x: f.x,
						y: f.y,
						width: f.width,
						height: f.height
					}, u));
				} else l.useStyle(u), l.type !== "pointer" && l.setColor(d);
				l.setStyle(n.getModel(["pointer", "itemStyle"]).getItemStyle()), l.style.fill === "auto" && l.setStyle("fill", a(linearMap$2(y.get(b, t), C, [0, 1], !0))), l.z2EmphasisLift = 0, setStatesStylesFromModel(l, n), toggleHoverEmphasis(l, o, s, c);
			}
			if (v) {
				var p = h[t];
				p.useStyle(y.getItemVisual(t, "style")), p.setStyle(n.getModel(["progress", "itemStyle"]).getItemStyle()), p.z2EmphasisLift = 0, setStatesStylesFromModel(p, n), toggleHoverEmphasis(p, o, s, c);
			}
		}), this._progressEls = h);
	}, n.prototype._renderAnchor = function(t, n) {
		var r = t.getModel("anchor");
		if (r.get("show")) {
			var a = r.get("size"), o = r.get("icon"), s = r.get("offsetCenter"), c = r.get("keepAspect"), l = createSymbol(o, n.cx - a / 2 + parsePercent$1(s[0], n.r), n.cy - a / 2 + parsePercent$1(s[1], n.r), a, a, null, c);
			l.z2 = r.get("showAbove") ? 1 : 0, l.setStyle(r.getModel("itemStyle").getItemStyle()), this.group.add(l);
		}
	}, n.prototype._renderTitleAndDetail = function(t, n, r, a, o) {
		var s = this, c = t.getData(), l = c.mapDimension("value"), u = +t.get("min"), d = +t.get("max"), f = new Group_default(), p = [], h = [], g = t.isAnimationEnabled(), _ = t.get(["pointer", "showAbove"]);
		c.diff(this._data).add(function(t) {
			p[t] = new Text_default({ silent: !0 }), h[t] = new Text_default({ silent: !0 });
		}).update(function(t, n) {
			p[t] = s._titleEls[n], h[t] = s._detailEls[n];
		}).execute(), c.each(function(n) {
			var r = c.getItemModel(n), s = c.get(l, n), v = new Group_default(), y = a(linearMap$2(s, [u, d], [0, 1], !0)), b = r.getModel("title");
			if (b.get("show")) {
				var x = b.get("offsetCenter"), S = o.cx + parsePercent$1(x[0], o.r), C = o.cy + parsePercent$1(x[1], o.r), w = p[n];
				w.attr({
					z2: _ ? 0 : 2,
					style: createTextStyle(b, {
						x: S,
						y: C,
						text: c.getName(n),
						align: "center",
						verticalAlign: "middle"
					}, { inheritColor: y })
				}), v.add(w);
			}
			var T = r.getModel("detail");
			if (T.get("show")) {
				var E = T.get("offsetCenter"), D = o.cx + parsePercent$1(E[0], o.r), O = o.cy + parsePercent$1(E[1], o.r), A = parsePercent$1(T.get("width"), o.r), j = parsePercent$1(T.get("height"), o.r), M = t.get(["progress", "show"]) ? c.getItemVisual(n, "style").fill : y, w = h[n], N = T.get("formatter");
				w.attr({
					z2: _ ? 0 : 2,
					style: createTextStyle(T, {
						x: D,
						y: O,
						text: formatLabel(s, N),
						width: isNaN(A) ? null : A,
						height: isNaN(j) ? null : j,
						align: "center",
						verticalAlign: "middle"
					}, { inheritColor: M })
				}), setLabelValueAnimation(w, { normal: T }, s, function(t) {
					return formatLabel(t, N);
				}), g && animateLabelValue(w, n, c, t, { getFormattedLabel: function(t, n, r, a, o, c) {
					return formatLabel(c ? c.interpolatedValue : s, N);
				} }), v.add(w);
			}
			f.add(v);
		}), this.group.add(f), this._titleEls = p, this._detailEls = h;
	}, n.type = "gauge", n;
}(Chart_default), GaugeSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.visualStyleAccessPath = "itemStyle", r;
	}
	return n.prototype.getInitialData = function(t, n) {
		return createSeriesDataSimply(this, ["value"]);
	}, n.type = "series.gauge", n.defaultOption = {
		z: 2,
		colorBy: "data",
		center: ["50%", "50%"],
		legendHoverLink: !0,
		radius: "75%",
		startAngle: 225,
		endAngle: -45,
		clockwise: !0,
		min: 0,
		max: 100,
		splitNumber: 10,
		axisLine: {
			show: !0,
			roundCap: !1,
			lineStyle: {
				color: [[1, "#E6EBF8"]],
				width: 10
			}
		},
		progress: {
			show: !1,
			overlap: !0,
			width: 10,
			roundCap: !1,
			clip: !0
		},
		splitLine: {
			show: !0,
			length: 10,
			distance: 10,
			lineStyle: {
				color: "#63677A",
				width: 3,
				type: "solid"
			}
		},
		axisTick: {
			show: !0,
			splitNumber: 5,
			length: 6,
			distance: 10,
			lineStyle: {
				color: "#63677A",
				width: 1,
				type: "solid"
			}
		},
		axisLabel: {
			show: !0,
			distance: 15,
			color: "#464646",
			fontSize: 12,
			rotate: 0
		},
		pointer: {
			icon: null,
			offsetCenter: [0, 0],
			show: !0,
			showAbove: !0,
			length: "60%",
			width: 6,
			keepAspect: !1
		},
		anchor: {
			show: !1,
			showAbove: !1,
			size: 6,
			icon: "circle",
			offsetCenter: [0, 0],
			keepAspect: !1,
			itemStyle: {
				color: "#fff",
				borderWidth: 0,
				borderColor: "#5470c6"
			}
		},
		title: {
			show: !0,
			offsetCenter: [0, "20%"],
			color: "#464646",
			fontSize: 16,
			valueAnimation: !1
		},
		detail: {
			show: !0,
			backgroundColor: "rgba(0,0,0,0)",
			borderWidth: 0,
			borderColor: "#ccc",
			width: 100,
			height: null,
			padding: [5, 10],
			offsetCenter: [0, "40%"],
			color: "#464646",
			fontSize: 30,
			fontWeight: "bold",
			lineHeight: 30,
			valueAnimation: !1
		}
	}, n;
}(Series_default);
function install$11(t) {
	t.registerChartView(GaugeView_default), t.registerSeriesModel(GaugeSeries_default);
}
var opacityAccessPath$1 = ["itemStyle", "opacity"], FunnelPiece = function(t) {
	__extends(n, t);
	function n(n, r) {
		var a = t.call(this) || this, o = a, s = new Polyline_default$1(), c = new Text_default();
		return o.setTextContent(c), a.setTextGuideLine(s), a.updateData(n, r, !0), a;
	}
	return n.prototype.updateData = function(t, n, r) {
		var a = this, o = t.hostModel, s = t.getItemModel(n), c = t.getItemLayout(n), l = s.getModel("emphasis"), u = s.get(opacityAccessPath$1);
		u ??= 1, r || saveOldStyle(a), a.useStyle(t.getItemVisual(n, "style")), a.style.lineJoin = "round", r ? (a.setShape({ points: c.points }), a.style.opacity = 0, initProps(a, { style: { opacity: u } }, o, n)) : updateProps(a, {
			style: { opacity: u },
			shape: { points: c.points }
		}, o, n), setStatesStylesFromModel(a, s), this._updateLabel(t, n), toggleHoverEmphasis(this, l.get("focus"), l.get("blurScope"), l.get("disabled"));
	}, n.prototype._updateLabel = function(t, n) {
		var r = this, a = this.getTextGuideLine(), o = r.getTextContent(), s = t.hostModel, c = t.getItemModel(n), l = t.getItemLayout(n).label, u = t.getItemVisual(n, "style"), d = u.fill;
		setLabelStyle(o, getLabelStatesModels(c), {
			labelFetcher: t.hostModel,
			labelDataIndex: n,
			defaultOpacity: u.opacity,
			defaultText: t.getName(n)
		}, { normal: {
			align: l.textAlign,
			verticalAlign: l.verticalAlign
		} }), r.setTextConfig({
			local: !0,
			inside: !!l.inside,
			insideStroke: d,
			outsideFill: d
		});
		var f = l.linePoints;
		a.setShape({ points: f }), r.textGuideLineConfig = { anchor: f ? new Point_default(f[0][0], f[0][1]) : null }, updateProps(o, { style: {
			x: l.x,
			y: l.y
		} }, s, n), o.attr({
			rotation: l.rotation,
			originX: l.x,
			originY: l.y,
			z2: 10
		}), setLabelLineStyle(r, getLabelLineStatesModels(c), { stroke: d });
	}, n;
}(Polygon_default), FunnelView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.ignoreLabelLineUpdate = !0, r;
	}
	return n.prototype.render = function(t, n, r) {
		var a = t.getData(), o = this._data, s = this.group;
		a.diff(o).add(function(t) {
			var n = new FunnelPiece(a, t);
			a.setItemGraphicEl(t, n), s.add(n);
		}).update(function(t, n) {
			var r = o.getItemGraphicEl(n);
			r.updateData(a, t), s.add(r), a.setItemGraphicEl(t, r);
		}).remove(function(n) {
			removeElementWithFadeOut(o.getItemGraphicEl(n), t, n);
		}).execute(), this._data = a;
	}, n.prototype.remove = function() {
		this.group.removeAll(), this._data = null;
	}, n.prototype.dispose = function() {}, n.type = "funnel", n;
}(Chart_default), FunnelSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.init = function(n) {
		t.prototype.init.apply(this, arguments), this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this)), this._defaultLabelLine(n);
	}, n.prototype.getInitialData = function(t, n) {
		return createSeriesDataSimply(this, {
			coordDimensions: ["value"],
			encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
		});
	}, n.prototype._defaultLabelLine = function(t) {
		defaultEmphasis(t, "labelLine", ["show"]);
		var n = t.labelLine, r = t.emphasis.labelLine;
		n.show = n.show && t.label.show, r.show = r.show && t.emphasis.label.show;
	}, n.prototype.getDataParams = function(n) {
		var r = this.getData(), a = t.prototype.getDataParams.call(this, n), o = r.mapDimension("value"), s = r.getSum(o);
		return a.percent = s ? +(r.get(o, n) / s * 100).toFixed(2) : 0, a.$vars.push("percent"), a;
	}, n.type = "series.funnel", n.defaultOption = {
		z: 2,
		legendHoverLink: !0,
		colorBy: "data",
		left: 80,
		top: 60,
		right: 80,
		bottom: 60,
		minSize: "0%",
		maxSize: "100%",
		sort: "descending",
		orient: "vertical",
		gap: 0,
		funnelAlign: "center",
		label: {
			show: !0,
			position: "outer"
		},
		labelLine: {
			show: !0,
			length: 20,
			lineStyle: { width: 1 }
		},
		itemStyle: {
			borderColor: "#fff",
			borderWidth: 1
		},
		emphasis: { label: { show: !0 } },
		select: { itemStyle: { borderColor: "#212121" } }
	}, n;
}(Series_default);
init_dist$2();
function getViewRect$2(t, n) {
	return getLayoutRect(t.getBoxLayoutParams(), {
		width: n.getWidth(),
		height: n.getHeight()
	});
}
function getSortedIndices(t, n) {
	for (var r = t.mapDimension("value"), a = t.mapArray(r, function(t) {
		return t;
	}), o = [], s = n === "ascending", c = 0, l = t.count(); c < l; c++) o[c] = c;
	return isFunction(n) ? o.sort(n) : n !== "none" && o.sort(function(t, n) {
		return s ? a[t] - a[n] : a[n] - a[t];
	}), o;
}
function labelLayout(t) {
	var n = t.hostModel.get("orient");
	t.each(function(r) {
		var a = t.getItemModel(r), o = a.getModel("label").get("position"), c = a.getModel("labelLine"), l = t.getItemLayout(r), u = l.points, d = o === "inner" || o === "inside" || o === "center" || o === "insideLeft" || o === "insideRight", f, p, h, g;
		if (d) o === "insideLeft" ? (p = (u[0][0] + u[3][0]) / 2 + 5, h = (u[0][1] + u[3][1]) / 2, f = "left") : o === "insideRight" ? (p = (u[1][0] + u[2][0]) / 2 - 5, h = (u[1][1] + u[2][1]) / 2, f = "right") : (p = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, h = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, f = "center"), g = [[p, h], [p, h]];
		else {
			var _ = void 0, v = void 0, y = void 0, b = void 0, x = c.get("length");
			process$1.env.NODE_ENV !== "production" && (n === "vertical" && ["top", "bottom"].indexOf(o) > -1 && (o = "left", console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.")), n === "horizontal" && ["left", "right"].indexOf(o) > -1 && (o = "bottom", console.warn("Position error: Funnel chart on horizontal orient dose not support left and right."))), o === "left" ? (_ = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, y = _ - x, p = y - 5, f = "right") : o === "right" ? (_ = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, y = _ + x, p = y + 5, f = "left") : o === "top" ? (_ = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, b = v - x, h = b - 5, f = "center") : o === "bottom" ? (_ = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, b = v + x, h = b + 5, f = "center") : o === "rightTop" ? (_ = n === "horizontal" ? u[3][0] : u[1][0], v = n === "horizontal" ? u[3][1] : u[1][1], n === "horizontal" ? (b = v - x, h = b - 5, f = "center") : (y = _ + x, p = y + 5, f = "top")) : o === "rightBottom" ? (_ = u[2][0], v = u[2][1], n === "horizontal" ? (b = v + x, h = b + 5, f = "center") : (y = _ + x, p = y + 5, f = "bottom")) : o === "leftTop" ? (_ = u[0][0], v = n === "horizontal" ? u[0][1] : u[1][1], n === "horizontal" ? (b = v - x, h = b - 5, f = "center") : (y = _ - x, p = y - 5, f = "right")) : o === "leftBottom" ? (_ = n === "horizontal" ? u[1][0] : u[3][0], v = n === "horizontal" ? u[1][1] : u[2][1], n === "horizontal" ? (b = v + x, h = b + 5, f = "center") : (y = _ - x, p = y - 5, f = "right")) : (_ = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, n === "horizontal" ? (b = v + x, h = b + 5, f = "center") : (y = _ + x, p = y + 5, f = "left")), n === "horizontal" ? (y = _, p = y) : (b = v, h = b), g = [[_, v], [y, b]];
		}
		l.label = {
			linePoints: g,
			x: p,
			y: h,
			verticalAlign: "middle",
			textAlign: f,
			inside: d
		};
	});
}
function funnelLayout(t, n) {
	t.eachSeriesByType("funnel", function(t) {
		var r = t.getData(), a = r.mapDimension("value"), o = t.get("sort"), s = getViewRect$2(t, n), c = t.get("orient"), l = s.width, u = s.height, d = getSortedIndices(r, o), f = s.x, p = s.y, h = c === "horizontal" ? [parsePercent$1(t.get("minSize"), u), parsePercent$1(t.get("maxSize"), u)] : [parsePercent$1(t.get("minSize"), l), parsePercent$1(t.get("maxSize"), l)], g = r.getDataExtent(a), _ = t.get("min"), v = t.get("max");
		_ ??= Math.min(g[0], 0), v ??= g[1];
		var y = t.get("funnelAlign"), b = t.get("gap"), x = ((c === "horizontal" ? l : u) - b * (r.count() - 1)) / r.count(), S = function(t, n) {
			if (c === "horizontal") {
				var o = linearMap$2(r.get(a, t) || 0, [_, v], h, !0), s = void 0;
				switch (y) {
					case "top":
						s = p;
						break;
					case "center":
						s = p + (u - o) / 2;
						break;
					case "bottom":
						s = p + (u - o);
						break;
				}
				return [[n, s], [n, s + o]];
			}
			var d = linearMap$2(r.get(a, t) || 0, [_, v], h, !0), g;
			switch (y) {
				case "left":
					g = f;
					break;
				case "center":
					g = f + (l - d) / 2;
					break;
				case "right":
					g = f + l - d;
					break;
			}
			return [[g, n], [g + d, n]];
		};
		o === "ascending" && (x = -x, b = -b, c === "horizontal" ? f += l : p += u, d = d.reverse());
		for (var C = 0; C < d.length; C++) {
			var w = d[C], T = d[C + 1], E = r.getItemModel(w);
			if (c === "horizontal") {
				var D = E.get(["itemStyle", "width"]);
				D == null ? D = x : (D = parsePercent$1(D, l), o === "ascending" && (D = -D));
				var O = S(w, f), A = S(T, f + D);
				f += D + b, r.setItemLayout(w, { points: O.concat(A.slice().reverse()) });
			} else {
				var j = E.get(["itemStyle", "height"]);
				j == null ? j = x : (j = parsePercent$1(j, u), o === "ascending" && (j = -j));
				var O = S(w, p), A = S(T, p + j);
				p += j + b, r.setItemLayout(w, { points: O.concat(A.slice().reverse()) });
			}
		}
		labelLayout(r);
	});
}
function install$12(t) {
	t.registerChartView(FunnelView_default), t.registerSeriesModel(FunnelSeries_default), t.registerLayout(funnelLayout), t.registerProcessor(dataFilter$1("funnel"));
}
var DEFAULT_SMOOTH = .3, ParallelView$1 = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r._dataGroup = new Group_default(), r._initialized = !1, r;
	}
	return n.prototype.init = function() {
		this.group.add(this._dataGroup);
	}, n.prototype.render = function(t, n, r, a) {
		this._progressiveEls = null;
		var o = this._dataGroup, s = t.getData(), c = this._data, l = t.coordinateSystem, u = l.dimensions, d = makeSeriesScope(t);
		s.diff(c).add(f).update(p).remove(h).execute();
		function f(t) {
			updateElCommon(addEl(s, o, t, u, l), s, t, d);
		}
		function p(n, r) {
			var a = c.getItemGraphicEl(r), o = createLinePoints(s, n, u, l);
			s.setItemGraphicEl(n, a), updateProps(a, { shape: { points: o } }, t, n), saveOldStyle(a), updateElCommon(a, s, n, d);
		}
		function h(t) {
			var n = c.getItemGraphicEl(t);
			o.remove(n);
		}
		if (!this._initialized) {
			this._initialized = !0;
			var g = createGridClipShape$2(l, t, function() {
				setTimeout(function() {
					o.removeClipPath();
				});
			});
			o.setClipPath(g);
		}
		this._data = s;
	}, n.prototype.incrementalPrepareRender = function(t, n, r) {
		this._initialized = !0, this._data = null, this._dataGroup.removeAll();
	}, n.prototype.incrementalRender = function(t, n, r) {
		for (var a = n.getData(), o = n.coordinateSystem, s = o.dimensions, c = makeSeriesScope(n), l = this._progressiveEls = [], u = t.start; u < t.end; u++) {
			var d = addEl(a, this._dataGroup, u, s, o);
			d.incremental = !0, updateElCommon(d, a, u, c), l.push(d);
		}
	}, n.prototype.remove = function() {
		this._dataGroup && this._dataGroup.removeAll(), this._data = null;
	}, n.type = "parallel", n;
}(Chart_default);
function createGridClipShape$2(t, n, r) {
	var a = t.model, o = t.getRect(), s = new Rect_default({ shape: {
		x: o.x,
		y: o.y,
		width: o.width,
		height: o.height
	} }), c = a.get("layout") === "horizontal" ? "width" : "height";
	return s.setShape(c, 0), initProps(s, { shape: {
		width: o.width,
		height: o.height
	} }, n, r), s;
}
function createLinePoints(t, n, r, a) {
	for (var o = [], s = 0; s < r.length; s++) {
		var c = r[s], l = t.get(t.mapDimension(c), n);
		isEmptyValue(l, a.getAxis(c).type) || o.push(a.dataToPoint(l, c));
	}
	return o;
}
function addEl(t, n, r, a, o) {
	var s = new Polyline_default$1({
		shape: { points: createLinePoints(t, r, a, o) },
		z2: 10
	});
	return n.add(s), t.setItemGraphicEl(r, s), s;
}
function makeSeriesScope(t) {
	var n = t.get("smooth", !0);
	return n === !0 && (n = DEFAULT_SMOOTH), n = numericToNumber(n), eqNaN(n) && (n = 0), { smooth: n };
}
function updateElCommon(t, n, r, a) {
	t.useStyle(n.getItemVisual(r, "style")), t.style.fill = null, t.setShape("smooth", a.smooth);
	var o = n.getItemModel(r), s = o.getModel("emphasis");
	setStatesStylesFromModel(t, o, "lineStyle"), toggleHoverEmphasis(t, s.get("focus"), s.get("blurScope"), s.get("disabled"));
}
function isEmptyValue(t, n) {
	return n === "category" ? t == null : t == null || isNaN(t);
}
var ParallelView_default = ParallelView$1, ParallelSeriesModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.visualStyleAccessPath = "lineStyle", r.visualDrawType = "stroke", r;
	}
	return n.prototype.getInitialData = function(t, n) {
		return createSeriesData_default(null, this, { useEncodeDefaulter: bind(makeDefaultEncode, null, this) });
	}, n.prototype.getRawIndicesByActiveState = function(t) {
		var n = this.coordinateSystem, r = this.getData(), a = [];
		return n.eachActiveState(r, function(n, o) {
			t === n && a.push(r.getRawIndex(o));
		}), a;
	}, n.type = "series.parallel", n.dependencies = ["parallel"], n.defaultOption = {
		z: 2,
		coordinateSystem: "parallel",
		parallelIndex: 0,
		label: { show: !1 },
		inactiveOpacity: .05,
		activeOpacity: 1,
		lineStyle: {
			width: 1,
			opacity: .45,
			type: "solid"
		},
		emphasis: { label: { show: !1 } },
		progressive: 500,
		smooth: !1,
		animationEasing: "linear"
	}, n;
}(Series_default);
function makeDefaultEncode(t) {
	var n = t.ecModel.getComponent("parallel", t.get("parallelIndex"));
	if (n) {
		var r = {};
		return each(n.dimensions, function(t) {
			r[t] = convertDimNameToNumber(t);
		}), r;
	}
}
function convertDimNameToNumber(t) {
	return +t.replace("dim", "");
}
var ParallelSeries_default = ParallelSeriesModel, opacityAccessPath = ["lineStyle", "opacity"], parallelVisual_default = {
	seriesType: "parallel",
	reset: function(t, n) {
		var r = t.coordinateSystem, a = {
			normal: t.get(["lineStyle", "opacity"]),
			active: t.get("activeOpacity"),
			inactive: t.get("inactiveOpacity")
		};
		return { progress: function(t, n) {
			r.eachActiveState(n, function(t, r) {
				var o = a[t];
				if (t === "normal" && n.hasItemOption) {
					var s = n.getItemModel(r).get(opacityAccessPath, !0);
					s != null && (o = s);
				}
				var c = n.ensureUniqueItemVisual(r, "style");
				c.opacity = o;
			}, t.start, t.end);
		} };
	}
};
function parallelPreprocessor(t) {
	createParallelIfNeeded(t), mergeAxisOptionFromParallel(t);
}
function createParallelIfNeeded(t) {
	if (!t.parallel) {
		var n = !1;
		each(t.series, function(t) {
			t && t.type === "parallel" && (n = !0);
		}), n && (t.parallel = [{}]);
	}
}
function mergeAxisOptionFromParallel(t) {
	each(normalizeToArray(t.parallelAxis), function(n) {
		if (isObject(n)) {
			var r = n.parallelIndex || 0, a = normalizeToArray(t.parallel)[r];
			a && a.parallelAxisDefault && merge(n, a.parallelAxisDefault, !1);
		}
	});
}
var CLICK_THRESHOLD = 5, ParallelView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r) {
		this._model = t, this._api = r, this._handlers || (this._handlers = {}, each(handlers$1, function(t, n) {
			r.getZr().on(n, this._handlers[n] = bind(t, this));
		}, this)), createOrUpdate(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate");
	}, n.prototype.dispose = function(t, n) {
		clear(this, "_throttledDispatchExpand"), each(this._handlers, function(t, r) {
			n.getZr().off(r, t);
		}), this._handlers = null;
	}, n.prototype._throttledDispatchExpand = function(t) {
		this._dispatchExpand(t);
	}, n.prototype._dispatchExpand = function(t) {
		t && this._api.dispatchAction(extend({ type: "parallelAxisExpand" }, t));
	}, n.type = "parallel", n;
}(Component_default$1), handlers$1 = {
	mousedown: function(t) {
		checkTrigger(this, "click") && (this._mouseDownPoint = [t.offsetX, t.offsetY]);
	},
	mouseup: function(t) {
		var n = this._mouseDownPoint;
		if (checkTrigger(this, "click") && n) {
			var r = [t.offsetX, t.offsetY];
			if ((n[0] - r[0]) ** 2 + (n[1] - r[1]) ** 2 > CLICK_THRESHOLD) return;
			var a = this._model.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY]);
			a.behavior !== "none" && this._dispatchExpand({ axisExpandWindow: a.axisExpandWindow });
		}
		this._mouseDownPoint = null;
	},
	mousemove: function(t) {
		if (!(this._mouseDownPoint || !checkTrigger(this, "mousemove"))) {
			var n = this._model, r = n.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY]), a = r.behavior;
			a === "jump" && this._throttledDispatchExpand.debounceNextCall(n.get("axisExpandDebounce")), this._throttledDispatchExpand(a === "none" ? null : {
				axisExpandWindow: r.axisExpandWindow,
				animation: a === "jump" ? null : { duration: 0 }
			});
		}
	}
};
function checkTrigger(t, n) {
	var r = t._model;
	return r.get("axisExpandable") && r.get("axisExpandTriggerOn") === n;
}
var ParallelView_default$1 = ParallelView, ParallelModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.init = function() {
		t.prototype.init.apply(this, arguments), this.mergeOption({});
	}, n.prototype.mergeOption = function(t) {
		var n = this.option;
		t && merge(n, t, !0), this._initDimensions();
	}, n.prototype.contains = function(t, n) {
		var r = t.get("parallelIndex");
		return r != null && n.getComponent("parallel", r) === this;
	}, n.prototype.setAxisExpand = function(t) {
		each([
			"axisExpandable",
			"axisExpandCenter",
			"axisExpandCount",
			"axisExpandWidth",
			"axisExpandWindow"
		], function(n) {
			t.hasOwnProperty(n) && (this.option[n] = t[n]);
		}, this);
	}, n.prototype._initDimensions = function() {
		var t = this.dimensions = [], n = this.parallelAxisIndex = [];
		each(filter(this.ecModel.queryComponents({ mainType: "parallelAxis" }), function(t) {
			return (t.get("parallelIndex") || 0) === this.componentIndex;
		}, this), function(r) {
			t.push("dim" + r.get("dim")), n.push(r.componentIndex);
		});
	}, n.type = "parallel", n.dependencies = ["parallelAxis"], n.layoutMode = "box", n.defaultOption = {
		z: 0,
		left: 80,
		top: 60,
		right: 80,
		bottom: 60,
		layout: "horizontal",
		axisExpandable: !1,
		axisExpandCenter: null,
		axisExpandCount: 0,
		axisExpandWidth: 50,
		axisExpandRate: 17,
		axisExpandDebounce: 50,
		axisExpandSlideTriggerArea: [
			-.15,
			.05,
			.4
		],
		axisExpandTriggerOn: "click",
		parallelAxisDefault: null
	}, n;
}(Component_default), ParallelAxis_default = function(t) {
	__extends(n, t);
	function n(n, r, a, o, s) {
		var c = t.call(this, n, r, a) || this;
		return c.type = o || "value", c.axisIndex = s, c;
	}
	return n.prototype.isHorizontal = function() {
		return this.coordinateSystem.getModel().get("layout") !== "horizontal";
	}, n;
}(Axis_default);
function sliderMove(t, n, r, a, o, s) {
	t ||= 0;
	var c = r[1] - r[0];
	if (o != null && (o = restrict$1(o, [0, c])), s != null && (s = Math.max(s, o ?? 0)), a === "all") {
		var l = Math.abs(n[1] - n[0]);
		l = restrict$1(l, [0, c]), o = s = restrict$1(l, [o, s]), a = 0;
	}
	n[0] = restrict$1(n[0], r), n[1] = restrict$1(n[1], r);
	var u = getSpanSign(n, a);
	n[a] += t;
	var d = o || 0, f = r.slice();
	u.sign < 0 ? f[0] += d : f[1] -= d, n[a] = restrict$1(n[a], f);
	var p = getSpanSign(n, a);
	return o != null && (p.sign !== u.sign || p.span < o) && (n[1 - a] = n[a] + u.sign * o), p = getSpanSign(n, a), s != null && p.span > s && (n[1 - a] = n[a] + p.sign * s), n;
}
function getSpanSign(t, n) {
	var r = t[n] - t[1 - n];
	return {
		span: Math.abs(r),
		sign: r > 0 ? -1 : r < 0 ? 1 : n ? -1 : 1
	};
}
function restrict$1(t, n) {
	return Math.min(n[1] == null ? Infinity : n[1], Math.max(n[0] == null ? -Infinity : n[0], t));
}
var each$11 = each, mathMin$2 = Math.min, mathMax$2 = Math.max, mathFloor = Math.floor, mathCeil = Math.ceil, round = round$1, PI$1 = Math.PI, Parallel = function() {
	function t(t, n, r) {
		this.type = "parallel", this._axesMap = createHashMap(), this._axesLayout = {}, this.dimensions = t.dimensions, this._model = t, this._init(t, n, r);
	}
	return t.prototype._init = function(t, n, r) {
		var a = t.dimensions, o = t.parallelAxisIndex;
		each$11(a, function(t, r) {
			var a = o[r], s = n.getComponent("parallelAxis", a), c = this._axesMap.set(t, new ParallelAxis_default(t, createScaleByModel$1(s), [0, 0], s.get("type"), a));
			c.onBand = c.type === "category" && s.get("boundaryGap"), c.inverse = s.get("inverse"), s.axis = c, c.model = s, c.coordinateSystem = s.coordinateSystem = this;
		}, this);
	}, t.prototype.update = function(t, n) {
		this._updateAxesFromSeries(this._model, t);
	}, t.prototype.containPoint = function(t) {
		var n = this._makeLayoutInfo(), r = n.axisBase, a = n.layoutBase, o = n.pixelDimIndex, s = t[1 - o], c = t[o];
		return s >= r && s <= r + n.axisLength && c >= a && c <= a + n.layoutLength;
	}, t.prototype.getModel = function() {
		return this._model;
	}, t.prototype._updateAxesFromSeries = function(t, n) {
		n.eachSeries(function(r) {
			if (t.contains(r, n)) {
				var a = r.getData();
				each$11(this.dimensions, function(t) {
					var n = this._axesMap.get(t);
					n.scale.unionExtentFromData(a, a.mapDimension(t)), niceScaleExtent(n.scale, n.model);
				}, this);
			}
		}, this);
	}, t.prototype.resize = function(t, n) {
		this._rect = getLayoutRect(t.getBoxLayoutParams(), {
			width: n.getWidth(),
			height: n.getHeight()
		}), this._layoutAxes();
	}, t.prototype.getRect = function() {
		return this._rect;
	}, t.prototype._makeLayoutInfo = function() {
		var t = this._model, n = this._rect, r = ["x", "y"], a = ["width", "height"], o = t.get("layout"), s = o === "horizontal" ? 0 : 1, c = n[a[s]], l = [0, c], u = this.dimensions.length, d = restrict(t.get("axisExpandWidth"), l), f = restrict(t.get("axisExpandCount") || 0, [0, u]), p = t.get("axisExpandable") && u > 3 && u > f && f > 1 && d > 0 && c > 0, h = t.get("axisExpandWindow"), g;
		h ? (g = restrict(h[1] - h[0], l), h[1] = h[0] + g) : (g = restrict(d * (f - 1), l), h = [d * (t.get("axisExpandCenter") || mathFloor(u / 2)) - g / 2], h[1] = h[0] + g);
		var _ = (c - g) / (u - f);
		_ < 3 && (_ = 0);
		var v = [mathFloor(round(h[0] / d, 1)) + 1, mathCeil(round(h[1] / d, 1)) - 1], y = _ / d * h[0];
		return {
			layout: o,
			pixelDimIndex: s,
			layoutBase: n[r[s]],
			layoutLength: c,
			axisBase: n[r[1 - s]],
			axisLength: n[a[1 - s]],
			axisExpandable: p,
			axisExpandWidth: d,
			axisCollapseWidth: _,
			axisExpandWindow: h,
			axisCount: u,
			winInnerIndices: v,
			axisExpandWindow0Pos: y
		};
	}, t.prototype._layoutAxes = function() {
		var t = this._rect, n = this._axesMap, r = this.dimensions, a = this._makeLayoutInfo(), o = a.layout;
		n.each(function(t) {
			var n = [0, a.axisLength], r = t.inverse ? 1 : 0;
			t.setExtent(n[r], n[1 - r]);
		}), each$11(r, function(n, r) {
			var s = (a.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(r, a), c = {
				horizontal: {
					x: s.position,
					y: a.axisLength
				},
				vertical: {
					x: 0,
					y: s.position
				}
			}, l = {
				horizontal: PI$1 / 2,
				vertical: 0
			}, u = [c[o].x + t.x, c[o].y + t.y], d = l[o], f = create$2();
			rotate(f, f, d), translate(f, f, u), this._axesLayout[n] = {
				position: u,
				rotation: d,
				transform: f,
				axisNameAvailableWidth: s.axisNameAvailableWidth,
				axisLabelShow: s.axisLabelShow,
				nameTruncateMaxWidth: s.nameTruncateMaxWidth,
				tickDirection: 1,
				labelDirection: 1
			};
		}, this);
	}, t.prototype.getAxis = function(t) {
		return this._axesMap.get(t);
	}, t.prototype.dataToPoint = function(t, n) {
		return this.axisCoordToPoint(this._axesMap.get(n).dataToCoord(t), n);
	}, t.prototype.eachActiveState = function(t, n, r, a) {
		r ??= 0, a ??= t.count();
		var o = this._axesMap, s = this.dimensions, c = [], l = [];
		each(s, function(n) {
			c.push(t.mapDimension(n)), l.push(o.get(n).model);
		});
		for (var u = this.hasAxisBrushed(), d = r; d < a; d++) {
			var f = void 0;
			if (!u) f = "normal";
			else {
				f = "active";
				for (var p = t.getValues(c, d), h = 0, g = s.length; h < g; h++) if (l[h].getActiveState(p[h]) === "inactive") {
					f = "inactive";
					break;
				}
			}
			n(f, d);
		}
	}, t.prototype.hasAxisBrushed = function() {
		for (var t = this.dimensions, n = this._axesMap, r = !1, a = 0, o = t.length; a < o; a++) n.get(t[a]).model.getActiveState() !== "normal" && (r = !0);
		return r;
	}, t.prototype.axisCoordToPoint = function(t, n) {
		var r = this._axesLayout[n];
		return applyTransform$1([t, 0], r.transform);
	}, t.prototype.getAxisLayout = function(t) {
		return clone$1(this._axesLayout[t]);
	}, t.prototype.getSlidedAxisExpandWindow = function(t) {
		var n = this._makeLayoutInfo(), r = n.pixelDimIndex, a = n.axisExpandWindow.slice(), o = a[1] - a[0], s = [0, n.axisExpandWidth * (n.axisCount - 1)];
		if (!this.containPoint(t)) return {
			behavior: "none",
			axisExpandWindow: a
		};
		var c = t[r] - n.layoutBase - n.axisExpandWindow0Pos, l, u = "slide", d = n.axisCollapseWidth, f = this._model.get("axisExpandSlideTriggerArea"), p = f[0] != null;
		if (d) p && d && c < o * f[0] ? (u = "jump", l = c - o * f[2]) : p && d && c > o * (1 - f[0]) ? (u = "jump", l = c - o * (1 - f[2])) : (l = c - o * f[1]) >= 0 && (l = c - o * (1 - f[1])) <= 0 && (l = 0), l *= n.axisExpandWidth / d, l ? sliderMove(l, a, s, "all") : u = "none";
		else {
			var h = a[1] - a[0];
			a = [mathMax$2(0, s[1] * c / h - h / 2)], a[1] = mathMin$2(s[1], a[0] + h), a[0] = a[1] - h;
		}
		return {
			axisExpandWindow: a,
			behavior: u
		};
	}, t;
}();
function restrict(t, n) {
	return mathMin$2(mathMax$2(t, n[0]), n[1]);
}
function layoutAxisWithoutExpand(t, n) {
	var r = n.layoutLength / (n.axisCount - 1);
	return {
		position: r * t,
		axisNameAvailableWidth: r,
		axisLabelShow: !0
	};
}
function layoutAxisWithExpand(t, n) {
	var r = n.layoutLength, a = n.axisExpandWidth, o = n.axisCount, s = n.axisCollapseWidth, c = n.winInnerIndices, l, u = s, d = !1, f;
	return t < c[0] ? (l = t * s, f = s) : t <= c[1] ? (l = n.axisExpandWindow0Pos + t * a - n.axisExpandWindow[0], u = a, d = !0) : (l = r - (o - 1 - t) * s, f = s), {
		position: l,
		axisNameAvailableWidth: u,
		axisLabelShow: d,
		nameTruncateMaxWidth: f
	};
}
var Parallel_default = Parallel;
function createParallelCoordSys(t, n) {
	var r = [];
	return t.eachComponent("parallel", function(a, o) {
		var s = new Parallel_default(a, t, n);
		s.name = "parallel_" + o, s.resize(a, n), a.coordinateSystem = s, s.model = a, r.push(s);
	}), t.eachSeries(function(t) {
		t.get("coordinateSystem") === "parallel" && (t.coordinateSystem = t.getReferringComponents("parallel", SINGLE_REFERRING).models[0].coordinateSystem);
	}), r;
}
var parallelCreator_default = { create: createParallelCoordSys }, ParallelAxisModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.activeIntervals = [], r;
	}
	return n.prototype.getAreaSelectStyle = function() {
		return makeStyleMapper([
			["fill", "color"],
			["lineWidth", "borderWidth"],
			["stroke", "borderColor"],
			["width", "width"],
			["opacity", "opacity"]
		])(this.getModel("areaSelectStyle"));
	}, n.prototype.setActiveIntervals = function(t) {
		var n = this.activeIntervals = clone$1(t);
		if (n) for (var r = n.length - 1; r >= 0; r--) asc$1(n[r]);
	}, n.prototype.getActiveState = function(t) {
		var n = this.activeIntervals;
		if (!n.length) return "normal";
		if (t == null || isNaN(+t)) return "inactive";
		if (n.length === 1) {
			var r = n[0];
			if (r[0] <= t && t <= r[1]) return "active";
		} else for (var a = 0, o = n.length; a < o; a++) if (n[a][0] <= t && t <= n[a][1]) return "active";
		return "inactive";
	}, n;
}(Component_default);
mixin(ParallelAxisModel, AxisModelCommonMixin);
var AxisModel_default$1 = ParallelAxisModel;
init_dist$2();
var BRUSH_PANEL_GLOBAL = !0, mathMin$1 = Math.min, mathMax$1 = Math.max, mathPow = Math.pow, COVER_Z = 1e4, UNSELECT_THRESHOLD = 6, MIN_RESIZE_LINE_WIDTH = 6, MUTEX_RESOURCE_KEY = "globalPan", DIRECTION_MAP = {
	w: [0, 0],
	e: [0, 1],
	n: [1, 0],
	s: [1, 1]
}, CURSOR_MAP = {
	w: "ew",
	e: "ew",
	n: "ns",
	s: "ns",
	ne: "nesw",
	sw: "nesw",
	nw: "nwse",
	se: "nwse"
}, DEFAULT_BRUSH_OPT = {
	brushStyle: {
		lineWidth: 2,
		stroke: "rgba(210,219,238,0.3)",
		fill: "#D2DBEE"
	},
	transformable: !0,
	brushMode: "single",
	removeOnClick: !1
}, baseUID = 0, BrushController = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this) || this;
		return r._track = [], r._covers = [], r._handlers = {}, process$1.env.NODE_ENV !== "production" && assert(n), r._zr = n, r.group = new Group_default(), r._uid = "brushController_" + baseUID++, each(pointerHandlers, function(t, n) {
			this._handlers[n] = bind(t, this);
		}, r), r;
	}
	return n.prototype.enableBrush = function(t) {
		return process$1.env.NODE_ENV !== "production" && assert(this._mounted), this._brushType && this._doDisableBrush(), t.brushType && this._doEnableBrush(t), this;
	}, n.prototype._doEnableBrush = function(t) {
		var n = this._zr;
		this._enableGlobalPan || take(n, MUTEX_RESOURCE_KEY, this._uid), each(this._handlers, function(t, r) {
			n.on(r, t);
		}), this._brushType = t.brushType, this._brushOption = merge(clone$1(DEFAULT_BRUSH_OPT), t, !0);
	}, n.prototype._doDisableBrush = function() {
		var t = this._zr;
		release(t, MUTEX_RESOURCE_KEY, this._uid), each(this._handlers, function(n, r) {
			t.off(r, n);
		}), this._brushType = this._brushOption = null;
	}, n.prototype.setPanels = function(t) {
		if (t && t.length) {
			var n = this._panels = {};
			each(t, function(t) {
				n[t.panelId] = clone$1(t);
			});
		} else this._panels = null;
		return this;
	}, n.prototype.mount = function(t) {
		t ||= {}, process$1.env.NODE_ENV !== "production" && (this._mounted = !0), this._enableGlobalPan = t.enableGlobalPan;
		var n = this.group;
		return this._zr.add(n), n.attr({
			x: t.x || 0,
			y: t.y || 0,
			rotation: t.rotation || 0,
			scaleX: t.scaleX || 1,
			scaleY: t.scaleY || 1
		}), this._transform = n.getLocalTransform(), this;
	}, n.prototype.updateCovers = function(t) {
		process$1.env.NODE_ENV !== "production" && assert(this._mounted), t = map(t, function(t) {
			return merge(clone$1(DEFAULT_BRUSH_OPT), t, !0);
		});
		var n = "\0-brush-index-", r = this._covers, a = this._covers = [], o = this, c = this._creatingCover;
		return new DataDiffer_default(r, t, u, l).add(d).update(d).remove(f).execute(), this;
		function l(t, r) {
			return (t.id == null ? n + r : t.id) + "-" + t.brushType;
		}
		function u(t, n) {
			return l(t.__brushOption, n);
		}
		function d(n, s) {
			var l = t[n];
			s != null && r[s] === c ? a[n] = r[s] : updateCoverAfterCreation(o, a[n] = s == null ? endCreating(o, createCover(o, l)) : (r[s].__brushOption = l, r[s]));
		}
		function f(t) {
			r[t] !== c && o.group.remove(r[t]);
		}
	}, n.prototype.unmount = function() {
		if (!(process$1.env.NODE_ENV !== "production" && !this._mounted)) return this.enableBrush(!1), clearCovers(this), this._zr.remove(this.group), process$1.env.NODE_ENV !== "production" && (this._mounted = !1), this;
	}, n.prototype.dispose = function() {
		this.unmount(), this.off();
	}, n;
}(Eventful_default);
function createCover(t, n) {
	var r = coverRenderers[n.brushType].createCover(t, n);
	return r.__brushOption = n, updateZ$1(r, n), t.group.add(r), r;
}
function endCreating(t, n) {
	var r = getCoverRenderer(n);
	return r.endCreating && (r.endCreating(t, n), updateZ$1(n, n.__brushOption)), n;
}
function updateCoverShape(t, n) {
	var r = n.__brushOption;
	getCoverRenderer(n).updateCoverShape(t, n, r.range, r);
}
function updateZ$1(t, n) {
	var r = n.z;
	r ??= COVER_Z, t.traverse(function(t) {
		t.z = r, t.z2 = r;
	});
}
function updateCoverAfterCreation(t, n) {
	getCoverRenderer(n).updateCommon(t, n), updateCoverShape(t, n);
}
function getCoverRenderer(t) {
	return coverRenderers[t.__brushOption.brushType];
}
function getPanelByPoint(t, n, r) {
	var a = t._panels;
	if (!a) return BRUSH_PANEL_GLOBAL;
	var o, s = t._transform;
	return each(a, function(t) {
		t.isTargetByCursor(n, r, s) && (o = t);
	}), o;
}
function getPanelByCover(t, n) {
	var r = t._panels;
	if (!r) return BRUSH_PANEL_GLOBAL;
	var a = n.__brushOption.panelId;
	return a == null ? BRUSH_PANEL_GLOBAL : r[a];
}
function clearCovers(t) {
	var n = t._covers, r = n.length;
	return each(n, function(n) {
		t.group.remove(n);
	}, t), n.length = 0, !!r;
}
function trigger(t, n) {
	var r = map(t._covers, function(t) {
		var n = t.__brushOption, r = clone$1(n.range);
		return {
			brushType: n.brushType,
			panelId: n.panelId,
			range: r
		};
	});
	t.trigger("brush", {
		areas: r,
		isEnd: !!n.isEnd,
		removeOnClick: !!n.removeOnClick
	});
}
function shouldShowCover(t) {
	var n = t._track;
	if (!n.length) return !1;
	var r = n[n.length - 1], a = n[0], o = r[0] - a[0], s = r[1] - a[1];
	return mathPow(o * o + s * s, .5) > UNSELECT_THRESHOLD;
}
function getTrackEnds(t) {
	var n = t.length - 1;
	return n < 0 && (n = 0), [t[0], t[n]];
}
function createBaseRectCover(t, n, r, a) {
	var o = new Group_default();
	return o.add(new Rect_default({
		name: "main",
		style: makeStyle(r),
		silent: !0,
		draggable: !0,
		cursor: "move",
		drift: curry(driftRect, t, n, o, [
			"n",
			"s",
			"w",
			"e"
		]),
		ondragend: curry(trigger, n, { isEnd: !0 })
	})), each(a, function(r) {
		o.add(new Rect_default({
			name: r.join(""),
			style: { opacity: 0 },
			draggable: !0,
			silent: !0,
			invisible: !0,
			drift: curry(driftRect, t, n, o, r),
			ondragend: curry(trigger, n, { isEnd: !0 })
		}));
	}), o;
}
function updateBaseRect(t, n, r, a) {
	var o = a.brushStyle.lineWidth || 0, s = mathMax$1(o, MIN_RESIZE_LINE_WIDTH), c = r[0][0], l = r[1][0], u = c - o / 2, d = l - o / 2, f = r[0][1], p = r[1][1], h = f - s + o / 2, g = p - s + o / 2, _ = f - c, v = p - l, y = _ + o, b = v + o;
	updateRectShape(t, n, "main", c, l, _, v), a.transformable && (updateRectShape(t, n, "w", u, d, s, b), updateRectShape(t, n, "e", h, d, s, b), updateRectShape(t, n, "n", u, d, y, s), updateRectShape(t, n, "s", u, g, y, s), updateRectShape(t, n, "nw", u, d, s, s), updateRectShape(t, n, "ne", h, d, s, s), updateRectShape(t, n, "sw", u, g, s, s), updateRectShape(t, n, "se", h, g, s, s));
}
function updateCommon$1(t, n) {
	var r = n.__brushOption, a = r.transformable, o = n.childAt(0);
	o.useStyle(makeStyle(r)), o.attr({
		silent: !a,
		cursor: a ? "move" : "default"
	}), each([
		["w"],
		["e"],
		["n"],
		["s"],
		["s", "e"],
		["s", "w"],
		["n", "e"],
		["n", "w"]
	], function(r) {
		var o = n.childOfName(r.join("")), s = r.length === 1 ? getGlobalDirection1(t, r[0]) : getGlobalDirection2(t, r);
		o && o.attr({
			silent: !a,
			invisible: !a,
			cursor: a ? CURSOR_MAP[s] + "-resize" : null
		});
	});
}
function updateRectShape(t, n, r, a, o, s, c) {
	var l = n.childOfName(r);
	l && l.setShape(pointsToRect(clipByPanel(t, n, [[a, o], [a + s, o + c]])));
}
function makeStyle(t) {
	return defaults({ strokeNoScale: !0 }, t.brushStyle);
}
function formatRectRange(t, n, r, a) {
	var o = [mathMin$1(t, r), mathMin$1(n, a)], s = [mathMax$1(t, r), mathMax$1(n, a)];
	return [[o[0], s[0]], [o[1], s[1]]];
}
function getTransform(t) {
	return getTransform$1(t.group);
}
function getGlobalDirection1(t, n) {
	return {
		left: "w",
		right: "e",
		top: "n",
		bottom: "s"
	}[transformDirection({
		w: "left",
		e: "right",
		n: "top",
		s: "bottom"
	}[n], getTransform(t))];
}
function getGlobalDirection2(t, n) {
	var r = [getGlobalDirection1(t, n[0]), getGlobalDirection1(t, n[1])];
	return (r[0] === "e" || r[0] === "w") && r.reverse(), r.join("");
}
function driftRect(t, n, r, a, o, s) {
	var c = r.__brushOption, l = t.toRectRange(c.range), u = toLocalDelta(n, o, s);
	each(a, function(t) {
		var n = DIRECTION_MAP[t];
		l[n[0]][n[1]] += u[n[0]];
	}), c.range = t.fromRectRange(formatRectRange(l[0][0], l[1][0], l[0][1], l[1][1])), updateCoverAfterCreation(n, r), trigger(n, { isEnd: !1 });
}
function driftPolygon(t, n, r, a) {
	var o = n.__brushOption.range, s = toLocalDelta(t, r, a);
	each(o, function(t) {
		t[0] += s[0], t[1] += s[1];
	}), updateCoverAfterCreation(t, n), trigger(t, { isEnd: !1 });
}
function toLocalDelta(t, n, r) {
	var a = t.group, o = a.transformCoordToLocal(n, r), s = a.transformCoordToLocal(0, 0);
	return [o[0] - s[0], o[1] - s[1]];
}
function clipByPanel(t, n, r) {
	var a = getPanelByCover(t, n);
	return a && a !== BRUSH_PANEL_GLOBAL ? a.clipPath(r, t._transform) : clone$1(r);
}
function pointsToRect(t) {
	var n = mathMin$1(t[0][0], t[1][0]), r = mathMin$1(t[0][1], t[1][1]), a = mathMax$1(t[0][0], t[1][0]), o = mathMax$1(t[0][1], t[1][1]);
	return {
		x: n,
		y: r,
		width: a - n,
		height: o - r
	};
}
function resetCursor(t, n, r) {
	if (!(!t._brushType || isOutsideZrArea(t, n.offsetX, n.offsetY))) {
		var a = t._zr, o = t._covers, s = getPanelByPoint(t, n, r);
		if (!t._dragging) for (var c = 0; c < o.length; c++) {
			var l = o[c].__brushOption;
			if (s && (s === BRUSH_PANEL_GLOBAL || l.panelId === s.panelId) && coverRenderers[l.brushType].contain(o[c], r[0], r[1])) return;
		}
		s && a.setCursorStyle("crosshair");
	}
}
function preventDefault(t) {
	var n = t.event;
	n.preventDefault && n.preventDefault();
}
function mainShapeContain(t, n, r) {
	return t.childOfName("main").contain(n, r);
}
function updateCoverByMouse(t, n, r, a) {
	var o = t._creatingCover, s = t._creatingPanel, c = t._brushOption, l;
	if (t._track.push(r.slice()), shouldShowCover(t) || o) {
		if (s && !o) {
			c.brushMode === "single" && clearCovers(t);
			var u = clone$1(c);
			u.brushType = determineBrushType(u.brushType, s), u.panelId = s === BRUSH_PANEL_GLOBAL ? null : s.panelId, o = t._creatingCover = createCover(t, u), t._covers.push(o);
		}
		if (o) {
			var d = coverRenderers[determineBrushType(t._brushType, s)], f = o.__brushOption;
			f.range = d.getCreatingRange(clipByPanel(t, o, t._track)), a && (endCreating(t, o), d.updateCommon(t, o)), updateCoverShape(t, o), l = { isEnd: a };
		}
	} else a && c.brushMode === "single" && c.removeOnClick && getPanelByPoint(t, n, r) && clearCovers(t) && (l = {
		isEnd: a,
		removeOnClick: !0
	});
	return l;
}
function determineBrushType(t, n) {
	return t === "auto" ? (process$1.env.NODE_ENV !== "production" && assert(n && n.defaultBrushType, "MUST have defaultBrushType when brushType is \"atuo\""), n.defaultBrushType) : t;
}
var pointerHandlers = {
	mousedown: function(t) {
		if (this._dragging) handleDragEnd(this, t);
		else if (!t.target || !t.target.draggable) {
			preventDefault(t);
			var n = this.group.transformCoordToLocal(t.offsetX, t.offsetY);
			this._creatingCover = null, (this._creatingPanel = getPanelByPoint(this, t, n)) && (this._dragging = !0, this._track = [n.slice()]);
		}
	},
	mousemove: function(t) {
		var n = t.offsetX, r = t.offsetY, a = this.group.transformCoordToLocal(n, r);
		if (resetCursor(this, t, a), this._dragging) {
			preventDefault(t);
			var o = updateCoverByMouse(this, t, a, !1);
			o && trigger(this, o);
		}
	},
	mouseup: function(t) {
		handleDragEnd(this, t);
	}
};
function handleDragEnd(t, n) {
	if (t._dragging) {
		preventDefault(n);
		var r = n.offsetX, a = n.offsetY, o = updateCoverByMouse(t, n, t.group.transformCoordToLocal(r, a), !0);
		t._dragging = !1, t._track = [], t._creatingCover = null, o && trigger(t, o);
	}
}
function isOutsideZrArea(t, n, r) {
	var a = t._zr;
	return n < 0 || n > a.getWidth() || r < 0 || r > a.getHeight();
}
var coverRenderers = {
	lineX: getLineRenderer(0),
	lineY: getLineRenderer(1),
	rect: {
		createCover: function(t, n) {
			function r(t) {
				return t;
			}
			return createBaseRectCover({
				toRectRange: r,
				fromRectRange: r
			}, t, n, [
				["w"],
				["e"],
				["n"],
				["s"],
				["s", "e"],
				["s", "w"],
				["n", "e"],
				["n", "w"]
			]);
		},
		getCreatingRange: function(t) {
			var n = getTrackEnds(t);
			return formatRectRange(n[1][0], n[1][1], n[0][0], n[0][1]);
		},
		updateCoverShape: function(t, n, r, a) {
			updateBaseRect(t, n, r, a);
		},
		updateCommon: updateCommon$1,
		contain: mainShapeContain
	},
	polygon: {
		createCover: function(t, n) {
			var r = new Group_default();
			return r.add(new Polyline_default$1({
				name: "main",
				style: makeStyle(n),
				silent: !0
			})), r;
		},
		getCreatingRange: function(t) {
			return t;
		},
		endCreating: function(t, n) {
			n.remove(n.childAt(0)), n.add(new Polygon_default({
				name: "main",
				draggable: !0,
				drift: curry(driftPolygon, t, n),
				ondragend: curry(trigger, t, { isEnd: !0 })
			}));
		},
		updateCoverShape: function(t, n, r, a) {
			n.childAt(0).setShape({ points: clipByPanel(t, n, r) });
		},
		updateCommon: updateCommon$1,
		contain: mainShapeContain
	}
};
function getLineRenderer(t) {
	return {
		createCover: function(n, r) {
			return createBaseRectCover({
				toRectRange: function(n) {
					var r = [n, [0, 100]];
					return t && r.reverse(), r;
				},
				fromRectRange: function(n) {
					return n[t];
				}
			}, n, r, [[["w"], ["e"]], [["n"], ["s"]]][t]);
		},
		getCreatingRange: function(n) {
			var r = getTrackEnds(n);
			return [mathMin$1(r[0][t], r[1][t]), mathMax$1(r[0][t], r[1][t])];
		},
		updateCoverShape: function(n, r, a, o) {
			var s, c = getPanelByCover(n, r);
			if (c !== BRUSH_PANEL_GLOBAL && c.getLinearBrushOtherExtent) s = c.getLinearBrushOtherExtent(t);
			else {
				var l = n._zr;
				s = [0, [l.getWidth(), l.getHeight()][1 - t]];
			}
			var u = [a, s];
			t && u.reverse(), updateBaseRect(n, r, u, o);
		},
		updateCommon: updateCommon$1,
		contain: mainShapeContain
	};
}
var BrushController_default = BrushController;
function makeRectPanelClipPath(t) {
	return t = normalizeRect(t), function(n) {
		return clipPointsByRect(n, t);
	};
}
function makeLinearBrushOtherExtent(t, n) {
	return t = normalizeRect(t), function(r) {
		var a = n ?? r, o = a ? t.width : t.height, s = a ? t.x : t.y;
		return [s, s + (o || 0)];
	};
}
function makeRectIsTargetByCursor(t, n, r) {
	var a = normalizeRect(t);
	return function(t, o) {
		return a.contain(o[0], o[1]) && !onIrrelevantElement(t, n, r);
	};
}
function normalizeRect(t) {
	return BoundingRect_default.create(t);
}
var elementList$1 = [
	"axisLine",
	"axisTickLabel",
	"axisName"
], ParallelAxisView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.init = function(n, r) {
		t.prototype.init.apply(this, arguments), (this._brushController = new BrushController_default(r.getZr())).on("brush", bind(this._onBrush, this));
	}, n.prototype.render = function(t, n, r, a) {
		if (!fromAxisAreaSelect(t, n, a)) {
			this.axisModel = t, this.api = r, this.group.removeAll();
			var o = this._axisGroup;
			if (this._axisGroup = new Group_default(), this.group.add(this._axisGroup), t.get("show")) {
				var s = getCoordSysModel(t, n), c = s.coordinateSystem, l = t.getAreaSelectStyle(), u = l.width, d = t.axis.dim, f = c.getAxisLayout(d), p = extend({ strokeContainThreshold: u }, f), h = new AxisBuilder_default(t, p);
				each(elementList$1, h.add, h), this._axisGroup.add(h.getGroup()), this._refreshBrushController(p, l, t, s, u, r), groupTransition(o, this._axisGroup, t);
			}
		}
	}, n.prototype._refreshBrushController = function(t, n, r, a, o, s) {
		var c = r.axis.getExtent(), l = c[1] - c[0], u = Math.min(30, Math.abs(l) * .1), d = BoundingRect_default.create({
			x: c[0],
			y: -o / 2,
			width: l,
			height: o
		});
		d.x -= u, d.width += 2 * u, this._brushController.mount({
			enableGlobalPan: !0,
			rotation: t.rotation,
			x: t.position[0],
			y: t.position[1]
		}).setPanels([{
			panelId: "pl",
			clipPath: makeRectPanelClipPath(d),
			isTargetByCursor: makeRectIsTargetByCursor(d, s, a),
			getLinearBrushOtherExtent: makeLinearBrushOtherExtent(d, 0)
		}]).enableBrush({
			brushType: "lineX",
			brushStyle: n,
			removeOnClick: !0
		}).updateCovers(getCoverInfoList(r));
	}, n.prototype._onBrush = function(t) {
		var n = t.areas, r = this.axisModel, a = r.axis, o = map(n, function(t) {
			return [a.coordToData(t.range[0], !0), a.coordToData(t.range[1], !0)];
		});
		(!r.option.realtime === t.isEnd || t.removeOnClick) && this.api.dispatchAction({
			type: "axisAreaSelect",
			parallelAxisId: r.id,
			intervals: o
		});
	}, n.prototype.dispose = function() {
		this._brushController.dispose();
	}, n.type = "parallelAxis", n;
}(Component_default$1);
function fromAxisAreaSelect(t, n, r) {
	return r && r.type === "axisAreaSelect" && n.findComponents({
		mainType: "parallelAxis",
		query: r
	})[0] === t;
}
function getCoverInfoList(t) {
	var n = t.axis;
	return map(t.activeIntervals, function(t) {
		return {
			brushType: "lineX",
			panelId: "pl",
			range: [n.dataToCoord(t[0], !0), n.dataToCoord(t[1], !0)]
		};
	});
}
function getCoordSysModel(t, n) {
	return n.getComponent("parallel", t.get("parallelIndex"));
}
var ParallelAxisView_default = ParallelAxisView, actionInfo = {
	type: "axisAreaSelect",
	event: "axisAreaSelected"
};
function installParallelActions(t) {
	t.registerAction(actionInfo, function(t, n) {
		n.eachComponent({
			mainType: "parallelAxis",
			query: t
		}, function(n) {
			n.axis.model.setActiveIntervals(t.intervals);
		});
	}), t.registerAction("parallelAxisExpand", function(t, n) {
		n.eachComponent({
			mainType: "parallel",
			query: t
		}, function(n) {
			n.setAxisExpand(t);
		});
	});
}
var defaultAxisOption = {
	type: "value",
	areaSelectStyle: {
		width: 20,
		borderWidth: 1,
		borderColor: "rgba(160,197,232)",
		color: "rgba(160,197,232)",
		opacity: .3
	},
	realtime: !0,
	z: 10
};
function install$28(t) {
	t.registerComponentView(ParallelView_default$1), t.registerComponentModel(ParallelModel_default), t.registerCoordinateSystem("parallel", parallelCreator_default), t.registerPreprocessor(parallelPreprocessor), t.registerComponentModel(AxisModel_default$1), t.registerComponentView(ParallelAxisView_default), axisModelCreator(t, "parallel", AxisModel_default$1, defaultAxisOption), installParallelActions(t);
}
function install$13(t) {
	use(install$28), t.registerChartView(ParallelView_default), t.registerSeriesModel(ParallelSeries_default), t.registerVisual(t.PRIORITY.VISUAL.BRUSH, parallelVisual_default);
}
var SankeyPathShape = function() {
	function t() {
		this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
	}
	return t;
}(), SankeyPath = function(t) {
	__extends(n, t);
	function n(n) {
		return t.call(this, n) || this;
	}
	return n.prototype.getDefaultShape = function() {
		return new SankeyPathShape();
	}, n.prototype.buildPath = function(t, n) {
		var r = n.extent;
		t.moveTo(n.x1, n.y1), t.bezierCurveTo(n.cpx1, n.cpy1, n.cpx2, n.cpy2, n.x2, n.y2), n.orient === "vertical" ? (t.lineTo(n.x2 + r, n.y2), t.bezierCurveTo(n.cpx2 + r, n.cpy2, n.cpx1 + r, n.cpy1, n.x1 + r, n.y1)) : (t.lineTo(n.x2, n.y2 + r), t.bezierCurveTo(n.cpx2, n.cpy2 + r, n.cpx1, n.cpy1 + r, n.x1, n.y1 + r)), t.closePath();
	}, n.prototype.highlight = function() {
		enterEmphasis(this);
	}, n.prototype.downplay = function() {
		leaveEmphasis(this);
	}, n;
}(Path_default), SankeyView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r._focusAdjacencyDisabled = !1, r;
	}
	return n.prototype.render = function(t, n, r) {
		var a = this, o = t.getGraph(), s = this.group, c = t.layoutInfo, l = c.width, u = c.height, d = t.getData(), f = t.getData("edge"), p = t.get("orient");
		this._model = t, s.removeAll(), s.x = c.x, s.y = c.y, o.eachEdge(function(n) {
			var r = new SankeyPath(), a = getECData(r);
			a.dataIndex = n.dataIndex, a.seriesIndex = t.seriesIndex, a.dataType = "edge";
			var o = n.getModel(), c = o.getModel("lineStyle"), d = c.get("curveness"), h = n.node1.getLayout(), g = n.node1.getModel(), _ = g.get("localX"), v = g.get("localY"), y = n.node2.getLayout(), b = n.node2.getModel(), x = b.get("localX"), S = b.get("localY"), C = n.getLayout(), w, T, E, D, O, A, j, M;
			r.shape.extent = Math.max(1, C.dy), r.shape.orient = p, p === "vertical" ? (w = (_ == null ? h.x : _ * l) + C.sy, T = (v == null ? h.y : v * u) + h.dy, E = (x == null ? y.x : x * l) + C.ty, D = S == null ? y.y : S * u, O = w, A = T * (1 - d) + D * d, j = E, M = T * d + D * (1 - d)) : (w = (_ == null ? h.x : _ * l) + h.dx, T = (v == null ? h.y : v * u) + C.sy, E = x == null ? y.x : x * l, D = (S == null ? y.y : S * u) + C.ty, O = w * (1 - d) + E * d, A = T, j = w * d + E * (1 - d), M = D), r.setShape({
				x1: w,
				y1: T,
				x2: E,
				y2: D,
				cpx1: O,
				cpy1: A,
				cpx2: j,
				cpy2: M
			}), r.useStyle(c.getItemStyle()), applyCurveStyle(r.style, p, n);
			var N = "" + o.get("value"), P = getLabelStatesModels(o, "edgeLabel");
			setLabelStyle(r, P, {
				labelFetcher: { getFormattedLabel: function(n, r, a, o, s, c) {
					return t.getFormattedLabel(n, r, "edge", o, retrieve3(s, P.normal && P.normal.get("formatter"), N), c);
				} },
				labelDataIndex: n.dataIndex,
				defaultText: N
			}), r.setTextConfig({ position: "inside" });
			var F = o.getModel("emphasis");
			setStatesStylesFromModel(r, o, "lineStyle", function(t) {
				var r = t.getItemStyle();
				return applyCurveStyle(r, p, n), r;
			}), s.add(r), f.setItemGraphicEl(n.dataIndex, r);
			var I = F.get("focus");
			toggleHoverEmphasis(r, I === "adjacency" ? n.getAdjacentDataIndices() : I === "trajectory" ? n.getTrajectoryDataIndices() : I, F.get("blurScope"), F.get("disabled"));
		}), o.eachNode(function(n) {
			var r = n.getLayout(), a = n.getModel(), o = a.get("localX"), c = a.get("localY"), f = a.getModel("emphasis"), p = a.get(["itemStyle", "borderRadius"]) || 0, h = new Rect_default({
				shape: {
					x: o == null ? r.x : o * l,
					y: c == null ? r.y : c * u,
					width: r.dx,
					height: r.dy,
					r: p
				},
				style: a.getModel("itemStyle").getItemStyle(),
				z2: 10
			});
			setLabelStyle(h, getLabelStatesModels(a), {
				labelFetcher: { getFormattedLabel: function(n, r) {
					return t.getFormattedLabel(n, r, "node");
				} },
				labelDataIndex: n.dataIndex,
				defaultText: n.id
			}), h.disableLabelAnimation = !0, h.setStyle("fill", n.getVisual("color")), h.setStyle("decal", n.getVisual("style").decal), setStatesStylesFromModel(h, a), s.add(h), d.setItemGraphicEl(n.dataIndex, h), getECData(h).dataType = "node";
			var g = f.get("focus");
			toggleHoverEmphasis(h, g === "adjacency" ? n.getAdjacentDataIndices() : g === "trajectory" ? n.getTrajectoryDataIndices() : g, f.get("blurScope"), f.get("disabled"));
		}), d.eachItemGraphicEl(function(n, o) {
			d.getItemModel(o).get("draggable") && (n.drift = function(n, s) {
				a._focusAdjacencyDisabled = !0, this.shape.x += n, this.shape.y += s, this.dirty(), r.dispatchAction({
					type: "dragNode",
					seriesId: t.id,
					dataIndex: d.getRawIndex(o),
					localX: this.shape.x / l,
					localY: this.shape.y / u
				});
			}, n.ondragend = function() {
				a._focusAdjacencyDisabled = !1;
			}, n.draggable = !0, n.cursor = "move");
		}), !this._data && t.isAnimationEnabled() && s.setClipPath(createGridClipShape$1(s.getBoundingRect(), t, function() {
			s.removeClipPath();
		})), this._data = t.getData();
	}, n.prototype.dispose = function() {}, n.type = "sankey", n;
}(Chart_default);
function applyCurveStyle(t, n, r) {
	switch (t.fill) {
		case "source":
			t.fill = r.node1.getVisual("color"), t.decal = r.node1.getVisual("style").decal;
			break;
		case "target":
			t.fill = r.node2.getVisual("color"), t.decal = r.node2.getVisual("style").decal;
			break;
		case "gradient":
			var a = r.node1.getVisual("color"), o = r.node2.getVisual("color");
			isString(a) && isString(o) && (t.fill = new LinearGradient_default(0, 0, +(n === "horizontal"), +(n === "vertical"), [{
				color: a,
				offset: 0
			}, {
				color: o,
				offset: 1
			}]));
	}
}
function createGridClipShape$1(t, n, r) {
	var a = new Rect_default({ shape: {
		x: t.x - 10,
		y: t.y - 10,
		width: 0,
		height: t.height + 20
	} });
	return initProps(a, { shape: { width: t.width + 20 } }, n, r), a;
}
var SankeyView_default = SankeyView;
init_dist$2();
var SankeySeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.getInitialData = function(t, n) {
		var r = t.edges || t.links || [], a = t.data || t.nodes || [], o = t.levels || [];
		this.levelModels = [];
		for (var c = this.levelModels, l = 0; l < o.length; l++) if (o[l].depth != null && o[l].depth >= 0) c[o[l].depth] = new Model_default(o[l], this, n);
		else if (process$1.env.NODE_ENV !== "production") throw Error("levels[i].depth is mandatory and should be natural number");
		return createGraphFromNodeEdge(a, r, this, !0, u).data;
		function u(t, n) {
			t.wrapMethod("getItemModel", function(t, n) {
				var r = t.parentModel, a = r.getData().getItemLayout(n);
				if (a) {
					var o = a.depth, s = r.levelModels[o];
					s && (t.parentModel = s);
				}
				return t;
			}), n.wrapMethod("getItemModel", function(t, n) {
				var r = t.parentModel, a = r.getGraph().getEdgeByIndex(n).node1.getLayout();
				if (a) {
					var o = a.depth, s = r.levelModels[o];
					s && (t.parentModel = s);
				}
				return t;
			});
		}
	}, n.prototype.setNodePosition = function(t, n) {
		var r = (this.option.data || this.option.nodes)[t];
		r.localX = n[0], r.localY = n[1];
	}, n.prototype.getGraph = function() {
		return this.getData().graph;
	}, n.prototype.getEdgeData = function() {
		return this.getGraph().edgeData;
	}, n.prototype.formatTooltip = function(t, n, r) {
		function a(t) {
			return isNaN(t) || t == null;
		}
		if (r === "edge") {
			var o = this.getDataParams(t, r), s = o.data, c = o.value;
			return createTooltipMarkup("nameValue", {
				name: s.source + " -- " + s.target,
				value: c,
				noValue: a(c)
			});
		} else {
			var l = this.getGraph().getNodeByIndex(t).getLayout().value, u = this.getDataParams(t, r).data.name;
			return createTooltipMarkup("nameValue", {
				name: u == null ? null : u + "",
				value: l,
				noValue: a(l)
			});
		}
	}, n.prototype.optionUpdated = function() {}, n.prototype.getDataParams = function(n, r) {
		var a = t.prototype.getDataParams.call(this, n, r);
		return a.value == null && r === "node" && (a.value = this.getGraph().getNodeByIndex(n).getLayout().value), a;
	}, n.type = "series.sankey", n.defaultOption = {
		z: 2,
		coordinateSystem: "view",
		left: "5%",
		top: "5%",
		right: "20%",
		bottom: "5%",
		orient: "horizontal",
		nodeWidth: 20,
		nodeGap: 8,
		draggable: !0,
		layoutIterations: 32,
		label: {
			show: !0,
			position: "right",
			fontSize: 12
		},
		edgeLabel: {
			show: !1,
			fontSize: 12
		},
		levels: [],
		nodeAlign: "justify",
		lineStyle: {
			color: "#314656",
			opacity: .2,
			curveness: .5
		},
		emphasis: {
			label: { show: !0 },
			lineStyle: { opacity: .5 }
		},
		select: { itemStyle: { borderColor: "#212121" } },
		animationEasing: "linear",
		animationDuration: 1e3
	}, n;
}(Series_default);
function sankeyLayout(t, n) {
	t.eachSeriesByType("sankey", function(t) {
		var r = t.get("nodeWidth"), a = t.get("nodeGap"), o = getViewRect$1(t, n);
		t.layoutInfo = o;
		var s = o.width, c = o.height, l = t.getGraph(), u = l.nodes, d = l.edges;
		computeNodeValues(u), layoutSankey(u, d, r, a, s, c, filter(u, function(t) {
			return t.getLayout().value === 0;
		}).length === 0 ? t.get("layoutIterations") : 0, t.get("orient"), t.get("nodeAlign"));
	});
}
function getViewRect$1(t, n) {
	return getLayoutRect(t.getBoxLayoutParams(), {
		width: n.getWidth(),
		height: n.getHeight()
	});
}
function layoutSankey(t, n, r, a, o, s, c, l, u) {
	computeNodeBreadths(t, n, r, o, s, l, u), computeNodeDepths(t, n, s, o, a, c, l), computeEdgeDepths(t, l);
}
function computeNodeValues(t) {
	each(t, function(t) {
		var n = sum(t.outEdges, getEdgeValue), r = sum(t.inEdges, getEdgeValue), a = t.getValue() || 0, o = Math.max(n, r, a);
		t.setLayout({ value: o }, !0);
	});
}
function computeNodeBreadths(t, n, r, a, o, s, c) {
	for (var l = [], u = [], d = [], f = [], p = 0, h = 0; h < n.length; h++) l[h] = 1;
	for (var h = 0; h < t.length; h++) u[h] = t[h].inEdges.length, u[h] === 0 && d.push(t[h]);
	for (var g = -1; d.length;) {
		for (var _ = 0; _ < d.length; _++) {
			var v = d[_], y = v.hostGraph.data.getRawDataItem(v.dataIndex), b = y.depth != null && y.depth >= 0;
			b && y.depth > g && (g = y.depth), v.setLayout({ depth: b ? y.depth : p }, !0), s === "vertical" ? v.setLayout({ dy: r }, !0) : v.setLayout({ dx: r }, !0);
			for (var x = 0; x < v.outEdges.length; x++) {
				var S = v.outEdges[x], C = n.indexOf(S);
				l[C] = 0;
				var w = S.node2, T = t.indexOf(w);
				--u[T] === 0 && f.indexOf(w) < 0 && f.push(w);
			}
		}
		++p, d = f, f = [];
	}
	for (var h = 0; h < l.length; h++) if (l[h] === 1) throw Error("Sankey is a DAG, the original data has cycle!");
	var E = g > p - 1 ? g : p - 1;
	c && c !== "left" && adjustNodeWithNodeAlign(t, c, s, E), scaleNodeBreadths(t, s === "vertical" ? (o - r) / E : (a - r) / E, s);
}
function isNodeDepth(t) {
	var n = t.hostGraph.data.getRawDataItem(t.dataIndex);
	return n.depth != null && n.depth >= 0;
}
function adjustNodeWithNodeAlign(t, n, r, a) {
	if (n === "right") {
		for (var o = [], s = t, c = 0; s.length;) {
			for (var l = 0; l < s.length; l++) {
				var u = s[l];
				u.setLayout({ skNodeHeight: c }, !0);
				for (var d = 0; d < u.inEdges.length; d++) {
					var f = u.inEdges[d];
					o.indexOf(f.node1) < 0 && o.push(f.node1);
				}
			}
			s = o, o = [], ++c;
		}
		each(t, function(t) {
			isNodeDepth(t) || t.setLayout({ depth: Math.max(0, a - t.getLayout().skNodeHeight) }, !0);
		});
	} else n === "justify" && moveSinksRight(t, a);
}
function moveSinksRight(t, n) {
	each(t, function(t) {
		!isNodeDepth(t) && !t.outEdges.length && t.setLayout({ depth: n }, !0);
	});
}
function scaleNodeBreadths(t, n, r) {
	each(t, function(t) {
		var a = t.getLayout().depth * n;
		r === "vertical" ? t.setLayout({ y: a }, !0) : t.setLayout({ x: a }, !0);
	});
}
function computeNodeDepths(t, n, r, a, o, s, c) {
	var l = prepareNodesByBreadth(t, c);
	initializeNodeDepth(l, n, r, a, o, c), resolveCollisions(l, o, r, a, c);
	for (var u = 1; s > 0; s--) u *= .99, relaxRightToLeft(l, u, c), resolveCollisions(l, o, r, a, c), relaxLeftToRight(l, u, c), resolveCollisions(l, o, r, a, c);
}
function prepareNodesByBreadth(t, n) {
	var r = [], a = n === "vertical" ? "y" : "x", o = groupData(t, function(t) {
		return t.getLayout()[a];
	});
	return o.keys.sort(function(t, n) {
		return t - n;
	}), each(o.keys, function(t) {
		r.push(o.buckets.get(t));
	}), r;
}
function initializeNodeDepth(t, n, r, a, o, s) {
	var c = Infinity;
	each(t, function(t) {
		var n = t.length, l = 0;
		each(t, function(t) {
			l += t.getLayout().value;
		});
		var u = s === "vertical" ? (a - (n - 1) * o) / l : (r - (n - 1) * o) / l;
		u < c && (c = u);
	}), each(t, function(t) {
		each(t, function(t, n) {
			var r = t.getLayout().value * c;
			s === "vertical" ? (t.setLayout({ x: n }, !0), t.setLayout({ dx: r }, !0)) : (t.setLayout({ y: n }, !0), t.setLayout({ dy: r }, !0));
		});
	}), each(n, function(t) {
		var n = +t.getValue() * c;
		t.setLayout({ dy: n }, !0);
	});
}
function resolveCollisions(t, n, r, a, o) {
	var s = o === "vertical" ? "x" : "y";
	each(t, function(t) {
		t.sort(function(t, n) {
			return t.getLayout()[s] - n.getLayout()[s];
		});
		for (var c, l, u, d = 0, f = t.length, p = o === "vertical" ? "dx" : "dy", h = 0; h < f; h++) l = t[h], u = d - l.getLayout()[s], u > 0 && (c = l.getLayout()[s] + u, o === "vertical" ? l.setLayout({ x: c }, !0) : l.setLayout({ y: c }, !0)), d = l.getLayout()[s] + l.getLayout()[p] + n;
		var g = o === "vertical" ? a : r;
		if (u = d - n - g, u > 0) {
			c = l.getLayout()[s] - u, o === "vertical" ? l.setLayout({ x: c }, !0) : l.setLayout({ y: c }, !0), d = c;
			for (var h = f - 2; h >= 0; --h) l = t[h], u = l.getLayout()[s] + l.getLayout()[p] + n - d, u > 0 && (c = l.getLayout()[s] - u, o === "vertical" ? l.setLayout({ x: c }, !0) : l.setLayout({ y: c }, !0)), d = l.getLayout()[s];
		}
	});
}
function relaxRightToLeft(t, n, r) {
	each(t.slice().reverse(), function(t) {
		each(t, function(t) {
			if (t.outEdges.length) {
				var a = sum(t.outEdges, weightedTarget, r) / sum(t.outEdges, getEdgeValue);
				if (isNaN(a)) {
					var o = t.outEdges.length;
					a = o ? sum(t.outEdges, centerTarget, r) / o : 0;
				}
				if (r === "vertical") {
					var s = t.getLayout().x + (a - center(t, r)) * n;
					t.setLayout({ x: s }, !0);
				} else {
					var c = t.getLayout().y + (a - center(t, r)) * n;
					t.setLayout({ y: c }, !0);
				}
			}
		});
	});
}
function weightedTarget(t, n) {
	return center(t.node2, n) * t.getValue();
}
function centerTarget(t, n) {
	return center(t.node2, n);
}
function weightedSource(t, n) {
	return center(t.node1, n) * t.getValue();
}
function centerSource(t, n) {
	return center(t.node1, n);
}
function center(t, n) {
	return n === "vertical" ? t.getLayout().x + t.getLayout().dx / 2 : t.getLayout().y + t.getLayout().dy / 2;
}
function getEdgeValue(t) {
	return t.getValue();
}
function sum(t, n, r) {
	for (var a = 0, o = t.length, s = -1; ++s < o;) {
		var c = +n(t[s], r);
		isNaN(c) || (a += c);
	}
	return a;
}
function relaxLeftToRight(t, n, r) {
	each(t, function(t) {
		each(t, function(t) {
			if (t.inEdges.length) {
				var a = sum(t.inEdges, weightedSource, r) / sum(t.inEdges, getEdgeValue);
				if (isNaN(a)) {
					var o = t.inEdges.length;
					a = o ? sum(t.inEdges, centerSource, r) / o : 0;
				}
				if (r === "vertical") {
					var s = t.getLayout().x + (a - center(t, r)) * n;
					t.setLayout({ x: s }, !0);
				} else {
					var c = t.getLayout().y + (a - center(t, r)) * n;
					t.setLayout({ y: c }, !0);
				}
			}
		});
	});
}
function computeEdgeDepths(t, n) {
	var r = n === "vertical" ? "x" : "y";
	each(t, function(t) {
		t.outEdges.sort(function(t, n) {
			return t.node2.getLayout()[r] - n.node2.getLayout()[r];
		}), t.inEdges.sort(function(t, n) {
			return t.node1.getLayout()[r] - n.node1.getLayout()[r];
		});
	}), each(t, function(t) {
		var n = 0, r = 0;
		each(t.outEdges, function(t) {
			t.setLayout({ sy: n }, !0), n += t.getLayout().dy;
		}), each(t.inEdges, function(t) {
			t.setLayout({ ty: r }, !0), r += t.getLayout().dy;
		});
	});
}
function sankeyVisual(t) {
	t.eachSeriesByType("sankey", function(t) {
		var n = t.getGraph(), r = n.nodes, a = n.edges;
		if (r.length) {
			var o = Infinity, s = -Infinity;
			each(r, function(t) {
				var n = t.getLayout().value;
				n < o && (o = n), n > s && (s = n);
			}), each(r, function(n) {
				var r = new VisualMapping_default({
					type: "color",
					mappingMethod: "linear",
					dataExtent: [o, s],
					visual: t.get("color")
				}).mapValueToVisual(n.getLayout().value), a = n.getModel().get(["itemStyle", "color"]);
				a == null ? (n.setVisual("color", r), n.setVisual("style", { fill: r })) : (n.setVisual("color", a), n.setVisual("style", { fill: a }));
			});
		}
		a.length && each(a, function(t) {
			var n = t.getModel().get("lineStyle");
			t.setVisual("style", n);
		});
	});
}
function install$14(t) {
	t.registerChartView(SankeyView_default), t.registerSeriesModel(SankeySeries_default), t.registerLayout(sankeyLayout), t.registerVisual(sankeyVisual), t.registerAction({
		type: "dragNode",
		event: "dragnode",
		update: "update"
	}, function(t, n) {
		n.eachComponent({
			mainType: "series",
			subType: "sankey",
			query: t
		}, function(n) {
			n.setNodePosition(t.dataIndex, [t.localX, t.localY]);
		});
	});
}
var WhiskerBoxCommonMixin = function() {
	function t() {}
	return t.prototype._hasEncodeRule = function(t) {
		var n = this.getEncode();
		return n && n.get(t) != null;
	}, t.prototype.getInitialData = function(t, n) {
		var r, a = n.getComponent("xAxis", this.get("xAxisIndex")), o = n.getComponent("yAxis", this.get("yAxisIndex")), s = a.get("type"), c = o.get("type"), l;
		s === "category" ? (t.layout = "horizontal", r = a.getOrdinalMeta(), l = !this._hasEncodeRule("x")) : c === "category" ? (t.layout = "vertical", r = o.getOrdinalMeta(), l = !this._hasEncodeRule("y")) : t.layout = t.layout || "horizontal";
		var u = ["x", "y"], d = t.layout === "horizontal" ? 0 : 1, f = this._baseAxisDim = u[d], p = u[1 - d], h = [a, o], g = h[d].get("type"), _ = h[1 - d].get("type"), v = t.data;
		if (v && l) {
			var y = [];
			each(v, function(t, n) {
				var r;
				isArray(t) ? (r = t.slice(), t.unshift(n)) : isArray(t.value) ? (r = extend({}, t), r.value = r.value.slice(), t.value.unshift(n)) : r = t, y.push(r);
			}), t.data = y;
		}
		var b = this.defaultValueDimensions, x = [{
			name: f,
			type: getDimensionTypeByAxis(g),
			ordinalMeta: r,
			otherDims: {
				tooltip: !1,
				itemName: 0
			},
			dimsDef: ["base"]
		}, {
			name: p,
			type: getDimensionTypeByAxis(_),
			dimsDef: b.slice()
		}];
		return createSeriesDataSimply(this, {
			coordDimensions: x,
			dimensionsCount: b.length + 1,
			encodeDefaulter: curry(makeSeriesEncodeForAxisCoordSys, x, this)
		});
	}, t.prototype.getBaseAxis = function() {
		var t = this._baseAxisDim;
		return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis;
	}, t;
}(), BoxplotSeriesModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.defaultValueDimensions = [
			{
				name: "min",
				defaultTooltip: !0
			},
			{
				name: "Q1",
				defaultTooltip: !0
			},
			{
				name: "median",
				defaultTooltip: !0
			},
			{
				name: "Q3",
				defaultTooltip: !0
			},
			{
				name: "max",
				defaultTooltip: !0
			}
		], r.visualDrawType = "stroke", r;
	}
	return n.type = "series.boxplot", n.dependencies = [
		"xAxis",
		"yAxis",
		"grid"
	], n.defaultOption = {
		z: 2,
		coordinateSystem: "cartesian2d",
		legendHoverLink: !0,
		layout: null,
		boxWidth: [7, 50],
		itemStyle: {
			color: "#fff",
			borderWidth: 1
		},
		emphasis: {
			scale: !0,
			itemStyle: {
				borderWidth: 2,
				shadowBlur: 5,
				shadowOffsetX: 1,
				shadowOffsetY: 1,
				shadowColor: "rgba(0,0,0,0.2)"
			}
		},
		animationDuration: 800
	}, n;
}(Series_default);
mixin(BoxplotSeriesModel, WhiskerBoxCommonMixin, !0);
var BoxplotSeries_default = BoxplotSeriesModel, BoxplotView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r) {
		var a = t.getData(), o = this.group, s = this._data;
		this._data || o.removeAll();
		var c = t.get("layout") === "horizontal" ? 1 : 0;
		a.diff(s).add(function(t) {
			if (a.hasValue(t)) {
				var n = createNormalBox$1(a.getItemLayout(t), a, t, c, !0);
				a.setItemGraphicEl(t, n), o.add(n);
			}
		}).update(function(t, n) {
			var r = s.getItemGraphicEl(n);
			if (!a.hasValue(t)) {
				o.remove(r);
				return;
			}
			var l = a.getItemLayout(t);
			r ? (saveOldStyle(r), updateNormalBoxData(l, r, a, t)) : r = createNormalBox$1(l, a, t, c), o.add(r), a.setItemGraphicEl(t, r);
		}).remove(function(t) {
			var n = s.getItemGraphicEl(t);
			n && o.remove(n);
		}).execute(), this._data = a;
	}, n.prototype.remove = function(t) {
		var n = this.group, r = this._data;
		this._data = null, r && r.eachItemGraphicEl(function(t) {
			t && n.remove(t);
		});
	}, n.type = "boxplot", n;
}(Chart_default), BoxPathShape = function() {
	function t() {}
	return t;
}(), BoxPath = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this, n) || this;
		return r.type = "boxplotBoxPath", r;
	}
	return n.prototype.getDefaultShape = function() {
		return new BoxPathShape();
	}, n.prototype.buildPath = function(t, n) {
		var r = n.points, a = 0;
		for (t.moveTo(r[a][0], r[a][1]), a++; a < 4; a++) t.lineTo(r[a][0], r[a][1]);
		for (t.closePath(); a < r.length; a++) t.moveTo(r[a][0], r[a][1]), a++, t.lineTo(r[a][0], r[a][1]);
	}, n;
}(Path_default);
function createNormalBox$1(t, n, r, a, o) {
	var s = t.ends, c = new BoxPath({ shape: { points: o ? transInit$1(s, a, t) : s } });
	return updateNormalBoxData(t, c, n, r, o), c;
}
function updateNormalBoxData(t, n, r, a, o) {
	var s = r.hostModel, c = graphic_exports$1[o ? "initProps" : "updateProps"];
	c(n, { shape: { points: t.ends } }, s, a), n.useStyle(r.getItemVisual(a, "style")), n.style.strokeNoScale = !0, n.z2 = 100;
	var l = r.getItemModel(a), u = l.getModel("emphasis");
	setStatesStylesFromModel(n, l), toggleHoverEmphasis(n, u.get("focus"), u.get("blurScope"), u.get("disabled"));
}
function transInit$1(t, n, r) {
	return map(t, function(t) {
		return t = t.slice(), t[n] = r.initBaseline, t;
	});
}
var BoxplotView_default = BoxplotView, each$10 = each;
function boxplotLayout(t) {
	each$10(groupSeriesByAxis(t), function(t) {
		var n = t.seriesModels;
		n.length && (calculateBase(t), each$10(n, function(n, r) {
			layoutSingleSeries(n, t.boxOffsetList[r], t.boxWidthList[r]);
		}));
	});
}
function groupSeriesByAxis(t) {
	var n = [], r = [];
	return t.eachSeriesByType("boxplot", function(t) {
		var a = t.getBaseAxis(), o = indexOf(r, a);
		o < 0 && (o = r.length, r[o] = a, n[o] = {
			axis: a,
			seriesModels: []
		}), n[o].seriesModels.push(t);
	}), n;
}
function calculateBase(t) {
	var n = t.axis, r = t.seriesModels, a = r.length, o = t.boxWidthList = [], s = t.boxOffsetList = [], c = [], l;
	if (n.type === "category") l = n.getBandWidth();
	else {
		var u = 0;
		each$10(r, function(t) {
			u = Math.max(u, t.getData().count());
		});
		var d = n.getExtent();
		l = Math.abs(d[1] - d[0]) / u;
	}
	each$10(r, function(t) {
		var n = t.get("boxWidth");
		isArray(n) || (n = [n, n]), c.push([parsePercent$1(n[0], l) || 0, parsePercent$1(n[1], l) || 0]);
	});
	var f = l * .8 - 2, p = f / a * .3, h = (f - p * (a - 1)) / a, g = h / 2 - f / 2;
	each$10(r, function(t, n) {
		s.push(g), g += p + h, o.push(Math.min(Math.max(h, c[n][0]), c[n][1]));
	});
}
function layoutSingleSeries(t, n, r) {
	var a = t.coordinateSystem, o = t.getData(), s = r / 2, c = t.get("layout") === "horizontal" ? 0 : 1, l = 1 - c, u = ["x", "y"], d = o.mapDimension(u[c]), f = o.mapDimensionsAll(u[l]);
	if (d == null || f.length < 5) return;
	for (var p = 0; p < o.count(); p++) {
		var h = o.get(d, p), g = S(h, f[2], p), _ = S(h, f[0], p), v = S(h, f[1], p), y = S(h, f[3], p), b = S(h, f[4], p), x = [];
		C(x, v, !1), C(x, y, !0), x.push(_, v, b, y), w(x, _), w(x, b), w(x, g), o.setItemLayout(p, {
			initBaseline: g[l],
			ends: x
		});
	}
	function S(t, r, s) {
		var u = o.get(r, s), d = [];
		d[c] = t, d[l] = u;
		var f;
		return isNaN(t) || isNaN(u) ? f = [NaN, NaN] : (f = a.dataToPoint(d), f[c] += n), f;
	}
	function C(t, n, r) {
		var a = n.slice(), o = n.slice();
		a[c] += s, o[c] -= s, r ? t.push(a, o) : t.push(o, a);
	}
	function w(t, n) {
		var r = n.slice(), a = n.slice();
		r[c] -= s, a[c] += s, t.push(r, a);
	}
}
function prepareBoxplotData(t, n) {
	n ||= {};
	for (var r = [], a = [], o = n.boundIQR, s = o === "none" || o === 0, c = 0; c < t.length; c++) {
		var l = asc$1(t[c].slice()), u = quantile(l, .25), d = quantile(l, .5), f = quantile(l, .75), p = l[0], h = l[l.length - 1], g = (o ?? 1.5) * (f - u), _ = s ? p : Math.max(p, u - g), v = s ? h : Math.min(h, f + g), y = n.itemNameFormatter, b = isFunction(y) ? y({ value: c }) : isString(y) ? y.replace("{value}", c + "") : c + "";
		r.push([
			b,
			_,
			u,
			d,
			f,
			v
		]);
		for (var x = 0; x < l.length; x++) {
			var S = l[x];
			if (S < _ || S > v) {
				var C = [b, S];
				a.push(C);
			}
		}
	}
	return {
		boxData: r,
		outliers: a
	};
}
init_dist$2();
var boxplotTransform = {
	type: "echarts:boxplot",
	transform: function(t) {
		var n = t.upstream;
		if (n.sourceFormat !== "arrayRows") {
			var r = "";
			process$1.env.NODE_ENV !== "production" && (r = makePrintable("source data is not applicable for this boxplot transform. Expect number[][].")), throwError(r);
		}
		var a = prepareBoxplotData(n.getRawData(), t.config);
		return [{
			dimensions: [
				"ItemName",
				"Low",
				"Q1",
				"Q2",
				"Q3",
				"High"
			],
			data: a.boxData
		}, { data: a.outliers }];
	}
};
function install$15(t) {
	t.registerSeriesModel(BoxplotSeries_default), t.registerChartView(BoxplotView_default), t.registerLayout(boxplotLayout), t.registerTransform(boxplotTransform);
}
var positiveBorderColorQuery = ["itemStyle", "borderColor"], negativeBorderColorQuery = ["itemStyle", "borderColor0"], dojiBorderColorQuery = ["itemStyle", "borderColorDoji"], positiveColorQuery = ["itemStyle", "color"], negativeColorQuery = ["itemStyle", "color0"];
function getColor(t, n) {
	return n.get(t > 0 ? positiveColorQuery : negativeColorQuery);
}
function getBorderColor(t, n) {
	return n.get(t === 0 ? dojiBorderColorQuery : t > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
}
var candlestickVisual_default = {
	seriesType: "candlestick",
	plan: createRenderPlanner(),
	performRawSeries: !0,
	reset: function(t, n) {
		if (!n.isSeriesFiltered(t)) return !t.pipelineContext.large && { progress: function(t, n) {
			for (var r; (r = t.next()) != null;) {
				var a = n.getItemModel(r), o = n.getItemLayout(r).sign, s = a.getItemStyle();
				s.fill = getColor(o, a), s.stroke = getBorderColor(o, a) || s.fill, extend(n.ensureUniqueItemVisual(r, "style"), s);
			}
		} };
	}
}, SKIP_PROPS = ["color", "borderColor"], CandlestickView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r) {
		this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(t), this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t);
	}, n.prototype.incrementalPrepareRender = function(t, n, r) {
		this._clear(), this._updateDrawMode(t);
	}, n.prototype.incrementalRender = function(t, n, r, a) {
		this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(t, n) : this._incrementalRenderNormal(t, n);
	}, n.prototype.eachRendered = function(t) {
		traverseElements(this._progressiveEls || this.group, t);
	}, n.prototype._updateDrawMode = function(t) {
		var n = t.pipelineContext.large;
		(this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
	}, n.prototype._renderNormal = function(t) {
		var n = t.getData(), r = this._data, a = this.group, o = n.getLayout("isSimpleBox"), s = t.get("clip", !0), c = t.coordinateSystem, l = c.getArea && c.getArea();
		this._data || a.removeAll(), n.diff(r).add(function(r) {
			if (n.hasValue(r)) {
				var c = n.getItemLayout(r);
				if (s && isNormalBoxClipped(l, c)) return;
				var u = createNormalBox(c, r, !0);
				initProps(u, { shape: { points: c.ends } }, t, r), setBoxCommon(u, n, r, o), a.add(u), n.setItemGraphicEl(r, u);
			}
		}).update(function(c, u) {
			var d = r.getItemGraphicEl(u);
			if (!n.hasValue(c)) {
				a.remove(d);
				return;
			}
			var f = n.getItemLayout(c);
			if (s && isNormalBoxClipped(l, f)) {
				a.remove(d);
				return;
			}
			d ? (updateProps(d, { shape: { points: f.ends } }, t, c), saveOldStyle(d)) : d = createNormalBox(f, c), setBoxCommon(d, n, c, o), a.add(d), n.setItemGraphicEl(c, d);
		}).remove(function(t) {
			var n = r.getItemGraphicEl(t);
			n && a.remove(n);
		}).execute(), this._data = n;
	}, n.prototype._renderLarge = function(t) {
		this._clear(), createLarge(t, this.group);
		var n = t.get("clip", !0) ? createClipPath(t.coordinateSystem, !1, t) : null;
		n ? this.group.setClipPath(n) : this.group.removeClipPath();
	}, n.prototype._incrementalRenderNormal = function(t, n) {
		for (var r = n.getData(), a = r.getLayout("isSimpleBox"), o; (o = t.next()) != null;) {
			var s = createNormalBox(r.getItemLayout(o), o);
			setBoxCommon(s, r, o, a), s.incremental = !0, this.group.add(s), this._progressiveEls.push(s);
		}
	}, n.prototype._incrementalRenderLarge = function(t, n) {
		createLarge(n, this.group, this._progressiveEls, !0);
	}, n.prototype.remove = function(t) {
		this._clear();
	}, n.prototype._clear = function() {
		this.group.removeAll(), this._data = null;
	}, n.type = "candlestick", n;
}(Chart_default), NormalBoxPathShape = function() {
	function t() {}
	return t;
}(), NormalBoxPath = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this, n) || this;
		return r.type = "normalCandlestickBox", r;
	}
	return n.prototype.getDefaultShape = function() {
		return new NormalBoxPathShape();
	}, n.prototype.buildPath = function(t, n) {
		var r = n.points;
		this.__simpleBox ? (t.moveTo(r[4][0], r[4][1]), t.lineTo(r[6][0], r[6][1])) : (t.moveTo(r[0][0], r[0][1]), t.lineTo(r[1][0], r[1][1]), t.lineTo(r[2][0], r[2][1]), t.lineTo(r[3][0], r[3][1]), t.closePath(), t.moveTo(r[4][0], r[4][1]), t.lineTo(r[5][0], r[5][1]), t.moveTo(r[6][0], r[6][1]), t.lineTo(r[7][0], r[7][1]));
	}, n;
}(Path_default);
function createNormalBox(t, n, r) {
	var a = t.ends;
	return new NormalBoxPath({
		shape: { points: r ? transInit(a, t) : a },
		z2: 100
	});
}
function isNormalBoxClipped(t, n) {
	for (var r = !0, a = 0; a < n.ends.length; a++) if (t.contain(n.ends[a][0], n.ends[a][1])) {
		r = !1;
		break;
	}
	return r;
}
function setBoxCommon(t, n, r, a) {
	var o = n.getItemModel(r);
	t.useStyle(n.getItemVisual(r, "style")), t.style.strokeNoScale = !0, t.__simpleBox = a, setStatesStylesFromModel(t, o);
	var s = n.getItemLayout(r).sign;
	each(t.states, function(t, n) {
		var r = o.getModel(n), a = getColor(s, r), c = getBorderColor(s, r) || a, l = t.style ||= {};
		a && (l.fill = a), c && (l.stroke = c);
	});
	var c = o.getModel("emphasis");
	toggleHoverEmphasis(t, c.get("focus"), c.get("blurScope"), c.get("disabled"));
}
function transInit(t, n) {
	return map(t, function(t) {
		return t = t.slice(), t[1] = n.initBaseline, t;
	});
}
var LargeBoxPathShape = function() {
	function t() {}
	return t;
}(), LargeBoxPath = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this, n) || this;
		return r.type = "largeCandlestickBox", r;
	}
	return n.prototype.getDefaultShape = function() {
		return new LargeBoxPathShape();
	}, n.prototype.buildPath = function(t, n) {
		for (var r = n.points, a = 0; a < r.length;) if (this.__sign === r[a++]) {
			var o = r[a++];
			t.moveTo(o, r[a++]), t.lineTo(o, r[a++]);
		} else a += 3;
	}, n;
}(Path_default);
function createLarge(t, n, r, a) {
	var o = t.getData(), s = o.getLayout("largePoints"), c = new LargeBoxPath({
		shape: { points: s },
		__sign: 1,
		ignoreCoarsePointer: !0
	});
	n.add(c);
	var l = new LargeBoxPath({
		shape: { points: s },
		__sign: -1,
		ignoreCoarsePointer: !0
	});
	n.add(l);
	var u = new LargeBoxPath({
		shape: { points: s },
		__sign: 0,
		ignoreCoarsePointer: !0
	});
	n.add(u), setLargeStyle(1, c, t, o), setLargeStyle(-1, l, t, o), setLargeStyle(0, u, t, o), a && (c.incremental = !0, l.incremental = !0), r && r.push(c, l);
}
function setLargeStyle(t, n, r, a) {
	var o = getBorderColor(t, r) || getColor(t, r), s = r.getModel("itemStyle").getItemStyle(SKIP_PROPS);
	n.useStyle(s), n.style.fill = null, n.style.stroke = o;
}
var CandlestickView_default = CandlestickView, CandlestickSeriesModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.defaultValueDimensions = [
			{
				name: "open",
				defaultTooltip: !0
			},
			{
				name: "close",
				defaultTooltip: !0
			},
			{
				name: "lowest",
				defaultTooltip: !0
			},
			{
				name: "highest",
				defaultTooltip: !0
			}
		], r;
	}
	return n.prototype.getShadowDim = function() {
		return "open";
	}, n.prototype.brushSelector = function(t, n, r) {
		var a = n.getItemLayout(t);
		return a && r.rect(a.brushRect);
	}, n.type = "series.candlestick", n.dependencies = [
		"xAxis",
		"yAxis",
		"grid"
	], n.defaultOption = {
		z: 2,
		coordinateSystem: "cartesian2d",
		legendHoverLink: !0,
		layout: null,
		clip: !0,
		itemStyle: {
			color: "#eb5454",
			color0: "#47b262",
			borderColor: "#eb5454",
			borderColor0: "#47b262",
			borderColorDoji: null,
			borderWidth: 1
		},
		emphasis: { itemStyle: { borderWidth: 2 } },
		barMaxWidth: null,
		barMinWidth: null,
		barWidth: null,
		large: !0,
		largeThreshold: 600,
		progressive: 3e3,
		progressiveThreshold: 1e4,
		progressiveChunkMode: "mod",
		animationEasing: "linear",
		animationDuration: 300
	}, n;
}(Series_default);
mixin(CandlestickSeriesModel, WhiskerBoxCommonMixin, !0);
var CandlestickSeries_default = CandlestickSeriesModel;
function candlestickPreprocessor(t) {
	!t || !isArray(t.series) || each(t.series, function(t) {
		isObject(t) && t.type === "k" && (t.type = "candlestick");
	});
}
var candlestickLayout = {
	seriesType: "candlestick",
	plan: createRenderPlanner(),
	reset: function(t) {
		var n = t.coordinateSystem, r = t.getData(), a = calculateCandleWidth(t, r), o = 0, s = 1, c = ["x", "y"], l = r.getDimensionIndex(r.mapDimension(c[o])), u = map(r.mapDimensionsAll(c[s]), r.getDimensionIndex, r), d = u[0], f = u[1], p = u[2], h = u[3];
		if (r.setLayout({
			candleWidth: a,
			isSimpleBox: a <= 1.3
		}), l < 0 || u.length < 4) return;
		return { progress: t.pipelineContext.large ? _ : g };
		function g(t, r) {
			for (var c, u = r.getStore(); (c = t.next()) != null;) {
				var g = u.get(l, c), _ = u.get(d, c), v = u.get(f, c), y = u.get(p, c), b = u.get(h, c), x = Math.min(_, v), S = Math.max(_, v), C = A(x, g), w = A(S, g), T = A(y, g), E = A(b, g), D = [];
				j(D, w, 0), j(D, C, 1), D.push(N(E), N(w), N(T), N(C));
				var O = !!r.getItemModel(c).get(["itemStyle", "borderColorDoji"]);
				r.setItemLayout(c, {
					sign: getSign(u, c, _, v, f, O),
					initBaseline: _ > v ? w[s] : C[s],
					ends: D,
					brushRect: M(y, b, g)
				});
			}
			function A(t, r) {
				var a = [];
				return a[o] = r, a[s] = t, isNaN(r) || isNaN(t) ? [NaN, NaN] : n.dataToPoint(a);
			}
			function j(t, n, r) {
				var s = n.slice(), c = n.slice();
				s[o] = subPixelOptimize(s[o] + a / 2, 1, !1), c[o] = subPixelOptimize(c[o] - a / 2, 1, !0), r ? t.push(s, c) : t.push(c, s);
			}
			function M(t, n, r) {
				var c = A(t, r), l = A(n, r);
				return c[o] -= a / 2, l[o] -= a / 2, {
					x: c[0],
					y: c[1],
					width: s ? a : l[0] - c[0],
					height: s ? l[1] - c[1] : a
				};
			}
			function N(t) {
				return t[o] = subPixelOptimize(t[o], 1), t;
			}
		}
		function _(r, a) {
			for (var c = createFloat32Array(r.count * 4), u = 0, g, _ = [], v = [], y, b = a.getStore(), x = !!t.get(["itemStyle", "borderColorDoji"]); (y = r.next()) != null;) {
				var S = b.get(l, y), C = b.get(d, y), w = b.get(f, y), T = b.get(p, y), E = b.get(h, y);
				if (isNaN(S) || isNaN(T) || isNaN(E)) {
					c[u++] = NaN, u += 3;
					continue;
				}
				c[u++] = getSign(b, y, C, w, f, x), _[o] = S, _[s] = T, g = n.dataToPoint(_, null, v), c[u++] = g ? g[0] : NaN, c[u++] = g ? g[1] : NaN, _[s] = E, g = n.dataToPoint(_, null, v), c[u++] = g ? g[1] : NaN;
			}
			a.setLayout("largePoints", c);
		}
	}
};
function getSign(t, n, r, a, o, s) {
	return r > a ? -1 : r < a ? 1 : s ? 0 : n > 0 ? t.get(o, n - 1) <= a ? 1 : -1 : 1;
}
function calculateCandleWidth(t, n) {
	var r = t.getBaseAxis(), a, o = r.type === "category" ? r.getBandWidth() : (a = r.getExtent(), Math.abs(a[1] - a[0]) / n.count()), s = parsePercent$1(retrieve2(t.get("barMaxWidth"), o), o), c = parsePercent$1(retrieve2(t.get("barMinWidth"), 1), o), l = t.get("barWidth");
	return l == null ? Math.max(Math.min(o / 2, s), c) : parsePercent$1(l, o);
}
var candlestickLayout_default = candlestickLayout;
function install$16(t) {
	t.registerChartView(CandlestickView_default), t.registerSeriesModel(CandlestickSeries_default), t.registerPreprocessor(candlestickPreprocessor), t.registerVisual(candlestickVisual_default), t.registerLayout(candlestickLayout_default);
}
function updateRipplePath(t, n) {
	var r = n.rippleEffectColor || n.color;
	t.eachChild(function(t) {
		t.attr({
			z: n.z,
			zlevel: n.zlevel,
			style: {
				stroke: n.brushType === "stroke" ? r : null,
				fill: n.brushType === "fill" ? r : null
			}
		});
	});
}
var EffectSymbol_default = function(t) {
	__extends(n, t);
	function n(n, r) {
		var a = t.call(this) || this, o = new Symbol_default(n, r), s = new Group_default();
		return a.add(o), a.add(s), a.updateData(n, r), a;
	}
	return n.prototype.stopEffectAnimation = function() {
		this.childAt(1).removeAll();
	}, n.prototype.startEffectAnimation = function(t) {
		for (var n = t.symbolType, r = t.color, a = t.rippleNumber, o = this.childAt(1), s = 0; s < a; s++) {
			var c = createSymbol(n, -1, -1, 2, 2, r);
			c.attr({
				style: { strokeNoScale: !0 },
				z2: 99,
				silent: !0,
				scaleX: .5,
				scaleY: .5
			});
			var l = -s / a * t.period + t.effectOffset;
			c.animate("", !0).when(t.period, {
				scaleX: t.rippleScale / 2,
				scaleY: t.rippleScale / 2
			}).delay(l).start(), c.animateStyle(!0).when(t.period, { opacity: 0 }).delay(l).start(), o.add(c);
		}
		updateRipplePath(o, t);
	}, n.prototype.updateEffectAnimation = function(t) {
		for (var n = this._effectCfg, r = this.childAt(1), a = [
			"symbolType",
			"period",
			"rippleScale",
			"rippleNumber"
		], o = 0; o < a.length; o++) {
			var s = a[o];
			if (n[s] !== t[s]) {
				this.stopEffectAnimation(), this.startEffectAnimation(t);
				return;
			}
		}
		updateRipplePath(r, t);
	}, n.prototype.highlight = function() {
		enterEmphasis(this);
	}, n.prototype.downplay = function() {
		leaveEmphasis(this);
	}, n.prototype.getSymbolType = function() {
		var t = this.childAt(0);
		return t && t.getSymbolType();
	}, n.prototype.updateData = function(t, n) {
		var r = this, a = t.hostModel;
		this.childAt(0).updateData(t, n);
		var o = this.childAt(1), s = t.getItemModel(n), c = t.getItemVisual(n, "symbol"), l = normalizeSymbolSize(t.getItemVisual(n, "symbolSize")), u = t.getItemVisual(n, "style"), d = u && u.fill, f = s.getModel("emphasis");
		o.setScale(l), o.traverse(function(t) {
			t.setStyle("fill", d);
		});
		var p = normalizeSymbolOffset(t.getItemVisual(n, "symbolOffset"), l);
		p && (o.x = p[0], o.y = p[1]), o.rotation = (t.getItemVisual(n, "symbolRotate") || 0) * Math.PI / 180 || 0;
		var h = {};
		h.showEffectOn = a.get("showEffectOn"), h.rippleScale = s.get(["rippleEffect", "scale"]), h.brushType = s.get(["rippleEffect", "brushType"]), h.period = s.get(["rippleEffect", "period"]) * 1e3, h.effectOffset = n / t.count(), h.z = a.getShallow("z") || 0, h.zlevel = a.getShallow("zlevel") || 0, h.symbolType = c, h.color = d, h.rippleEffectColor = s.get(["rippleEffect", "color"]), h.rippleNumber = s.get(["rippleEffect", "number"]), h.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(h) : this.startEffectAnimation(h), this._effectCfg = h) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(t) {
			t === "emphasis" ? h.showEffectOn !== "render" && r.startEffectAnimation(h) : t === "normal" && h.showEffectOn !== "render" && r.stopEffectAnimation();
		}), this._effectCfg = h, toggleHoverEmphasis(this, f.get("focus"), f.get("blurScope"), f.get("disabled"));
	}, n.prototype.fadeOut = function(t) {
		t && t();
	}, n;
}(Group_default), EffectScatterView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.init = function() {
		this._symbolDraw = new SymbolDraw_default(EffectSymbol_default);
	}, n.prototype.render = function(t, n, r) {
		var a = t.getData(), o = this._symbolDraw;
		o.updateData(a, { clipShape: this._getClipShape(t) }), this.group.add(o.group);
	}, n.prototype._getClipShape = function(t) {
		var n = t.coordinateSystem, r = n && n.getArea && n.getArea();
		return t.get("clip", !0) ? r : null;
	}, n.prototype.updateTransform = function(t, n, r) {
		var a = t.getData();
		this.group.dirty();
		var o = pointsLayout("").reset(t, n, r);
		o.progress && o.progress({
			start: 0,
			end: a.count(),
			count: a.count()
		}, a), this._symbolDraw.updateLayout();
	}, n.prototype._updateGroupTransform = function(t) {
		var n = t.coordinateSystem;
		n && n.getRoamTransform && (this.group.transform = clone$4(n.getRoamTransform()), this.group.decomposeTransform());
	}, n.prototype.remove = function(t, n) {
		this._symbolDraw && this._symbolDraw.remove(!0);
	}, n.type = "effectScatter", n;
}(Chart_default), EffectScatterSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.hasSymbolVisual = !0, r;
	}
	return n.prototype.getInitialData = function(t, n) {
		return createSeriesData_default(null, this, { useEncodeDefaulter: !0 });
	}, n.prototype.brushSelector = function(t, n, r) {
		return r.point(n.getItemLayout(t));
	}, n.type = "series.effectScatter", n.dependencies = ["grid", "polar"], n.defaultOption = {
		coordinateSystem: "cartesian2d",
		z: 2,
		legendHoverLink: !0,
		effectType: "ripple",
		progressive: 0,
		showEffectOn: "render",
		clip: !0,
		rippleEffect: {
			period: 4,
			scale: 2.5,
			brushType: "fill",
			number: 3
		},
		universalTransition: { divideShape: "clone" },
		symbolSize: 10
	}, n;
}(Series_default);
function install$17(t) {
	t.registerChartView(EffectScatterView_default), t.registerSeriesModel(EffectScatterSeries_default), t.registerLayout(pointsLayout("effectScatter"));
}
var EffectLine_default = function(t) {
	__extends(n, t);
	function n(n, r, a) {
		var o = t.call(this) || this;
		return o.add(o.createLine(n, r, a)), o._updateEffectSymbol(n, r), o;
	}
	return n.prototype.createLine = function(t, n, r) {
		return new Line_default(t, n, r);
	}, n.prototype._updateEffectSymbol = function(t, n) {
		var r = t.getItemModel(n).getModel("effect"), a = r.get("symbolSize"), o = r.get("symbol");
		isArray(a) || (a = [a, a]);
		var s = t.getItemVisual(n, "style"), c = r.get("color") || s && s.stroke, l = this.childAt(1);
		this._symbolType !== o && (this.remove(l), l = createSymbol(o, -.5, -.5, 1, 1, c), l.z2 = 100, l.culling = !0, this.add(l)), l && (l.setStyle("shadowColor", c), l.setStyle(r.getItemStyle(["color"])), l.scaleX = a[0], l.scaleY = a[1], l.setColor(c), this._symbolType = o, this._symbolScale = a, this._updateEffectAnimation(t, r, n));
	}, n.prototype._updateEffectAnimation = function(t, n, r) {
		var a = this.childAt(1);
		if (a) {
			var o = t.getItemLayout(r), s = n.get("period") * 1e3, c = n.get("loop"), l = n.get("roundTrip"), u = n.get("constantSpeed"), d = retrieve(n.get("delay"), function(n) {
				return n / t.count() * s / 3;
			});
			if (a.ignore = !0, this._updateAnimationPoints(a, o), u > 0 && (s = this._getLineLength(a) / u * 1e3), s !== this._period || c !== this._loop || l !== this._roundTrip) {
				a.stopAnimation();
				var f = void 0;
				f = isFunction(d) ? d(r) : d, a.__t > 0 && (f = -s * a.__t), this._animateSymbol(a, s, f, c, l);
			}
			this._period = s, this._loop = c, this._roundTrip = l;
		}
	}, n.prototype._animateSymbol = function(t, n, r, a, o) {
		if (n > 0) {
			t.__t = 0;
			var s = this, c = t.animate("", a).when(o ? n * 2 : n, { __t: o ? 2 : 1 }).delay(r).during(function() {
				s._updateSymbolPosition(t);
			});
			a || c.done(function() {
				s.remove(t);
			}), c.start();
		}
	}, n.prototype._getLineLength = function(t) {
		return dist$1(t.__p1, t.__cp1) + dist$1(t.__cp1, t.__p2);
	}, n.prototype._updateAnimationPoints = function(t, n) {
		t.__p1 = n[0], t.__p2 = n[1], t.__cp1 = n[2] || [(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2];
	}, n.prototype.updateData = function(t, n, r) {
		this.childAt(0).updateData(t, n, r), this._updateEffectSymbol(t, n);
	}, n.prototype._updateSymbolPosition = function(t) {
		var n = t.__p1, r = t.__p2, a = t.__cp1, o = t.__t < 1 ? t.__t : 2 - t.__t, s = [t.x, t.y], c = s.slice(), l = quadraticAt$1, u = quadraticDerivativeAt;
		s[0] = l(n[0], a[0], r[0], o), s[1] = l(n[1], a[1], r[1], o);
		var d = t.__t < 1 ? u(n[0], a[0], r[0], o) : u(r[0], a[0], n[0], 1 - o), f = t.__t < 1 ? u(n[1], a[1], r[1], o) : u(r[1], a[1], n[1], 1 - o);
		t.rotation = -Math.atan2(f, d) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (t.__lastT !== void 0 && t.__lastT < t.__t ? (t.scaleY = dist$1(c, s) * 1.05, o === 1 && (s[0] = c[0] + (s[0] - c[0]) / 2, s[1] = c[1] + (s[1] - c[1]) / 2)) : t.__lastT === 1 ? t.scaleY = 2 * dist$1(n, s) : t.scaleY = this._symbolScale[1]), t.__lastT = t.__t, t.ignore = !1, t.x = s[0], t.y = s[1];
	}, n.prototype.updateLayout = function(t, n) {
		this.childAt(0).updateLayout(t, n);
		var r = t.getItemModel(n).getModel("effect");
		this._updateEffectAnimation(t, r, n);
	}, n;
}(Group_default), Polyline_default = function(t) {
	__extends(n, t);
	function n(n, r, a) {
		var o = t.call(this) || this;
		return o._createPolyline(n, r, a), o;
	}
	return n.prototype._createPolyline = function(t, n, r) {
		var a = new Polyline_default$1({ shape: { points: t.getItemLayout(n) } });
		this.add(a), this._updateCommonStl(t, n, r);
	}, n.prototype.updateData = function(t, n, r) {
		var a = t.hostModel;
		updateProps(this.childAt(0), { shape: { points: t.getItemLayout(n) } }, a, n), this._updateCommonStl(t, n, r);
	}, n.prototype._updateCommonStl = function(t, n, r) {
		var a = this.childAt(0), o = t.getItemModel(n), s = r && r.emphasisLineStyle, c = r && r.focus, l = r && r.blurScope, u = r && r.emphasisDisabled;
		if (!r || t.hasItemOption) {
			var d = o.getModel("emphasis");
			s = d.getModel("lineStyle").getLineStyle(), u = d.get("disabled"), c = d.get("focus"), l = d.get("blurScope");
		}
		a.useStyle(t.getItemVisual(n, "style")), a.style.fill = null, a.style.strokeNoScale = !0;
		var f = a.ensureState("emphasis");
		f.style = s, toggleHoverEmphasis(this, c, l, u);
	}, n.prototype.updateLayout = function(t, n) {
		this.childAt(0).setShape("points", t.getItemLayout(n));
	}, n;
}(Group_default), EffectPolyline_default = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n._lastFrame = 0, n._lastFramePercent = 0, n;
	}
	return n.prototype.createLine = function(t, n, r) {
		return new Polyline_default(t, n, r);
	}, n.prototype._updateAnimationPoints = function(t, n) {
		this._points = n;
		for (var r = [0], a = 0, o = 1; o < n.length; o++) {
			var s = n[o - 1], c = n[o];
			a += dist$1(s, c), r.push(a);
		}
		if (a === 0) {
			this._length = 0;
			return;
		}
		for (var o = 0; o < r.length; o++) r[o] /= a;
		this._offsets = r, this._length = a;
	}, n.prototype._getLineLength = function() {
		return this._length;
	}, n.prototype._updateSymbolPosition = function(t) {
		var n = t.__t < 1 ? t.__t : 2 - t.__t, r = this._points, a = this._offsets, o = r.length;
		if (a) {
			var s = this._lastFrame, c;
			if (n < this._lastFramePercent) {
				for (c = Math.min(s + 1, o - 1); c >= 0 && !(a[c] <= n); c--);
				c = Math.min(c, o - 2);
			} else {
				for (c = s; c < o && !(a[c] > n); c++);
				c = Math.min(c - 1, o - 2);
			}
			var l = (n - a[c]) / (a[c + 1] - a[c]), u = r[c], d = r[c + 1];
			t.x = u[0] * (1 - l) + l * d[0], t.y = u[1] * (1 - l) + l * d[1];
			var f = t.__t < 1 ? d[0] - u[0] : u[0] - d[0], p = t.__t < 1 ? d[1] - u[1] : u[1] - d[1];
			t.rotation = -Math.atan2(p, f) - Math.PI / 2, this._lastFrame = c, this._lastFramePercent = n, t.ignore = !1;
		}
	}, n;
}(EffectLine_default), LargeLinesPathShape = function() {
	function t() {
		this.polyline = !1, this.curveness = 0, this.segs = [];
	}
	return t;
}(), LargeLinesPath = function(t) {
	__extends(n, t);
	function n(n) {
		var r = t.call(this, n) || this;
		return r._off = 0, r.hoverDataIdx = -1, r;
	}
	return n.prototype.reset = function() {
		this.notClear = !1, this._off = 0;
	}, n.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	}, n.prototype.getDefaultShape = function() {
		return new LargeLinesPathShape();
	}, n.prototype.buildPath = function(t, n) {
		var r = n.segs, a = n.curveness, o;
		if (n.polyline) for (o = this._off; o < r.length;) {
			var s = r[o++];
			if (s > 0) {
				t.moveTo(r[o++], r[o++]);
				for (var c = 1; c < s; c++) t.lineTo(r[o++], r[o++]);
			}
		}
		else for (o = this._off; o < r.length;) {
			var l = r[o++], u = r[o++], d = r[o++], f = r[o++];
			if (t.moveTo(l, u), a > 0) {
				var p = (l + d) / 2 - (u - f) * a, h = (u + f) / 2 - (d - l) * a;
				t.quadraticCurveTo(p, h, d, f);
			} else t.lineTo(d, f);
		}
		this.incremental && (this._off = o, this.notClear = !0);
	}, n.prototype.findDataIndex = function(t, n) {
		var r = this.shape, a = r.segs, o = r.curveness, s = this.style.lineWidth;
		if (r.polyline) for (var c = 0, l = 0; l < a.length;) {
			var u = a[l++];
			if (u > 0) for (var d = a[l++], f = a[l++], p = 1; p < u; p++) {
				var h = a[l++], g = a[l++];
				if (containStroke$4(d, f, h, g, s, t, n)) return c;
			}
			c++;
		}
		else for (var c = 0, l = 0; l < a.length;) {
			var d = a[l++], f = a[l++], h = a[l++], g = a[l++];
			if (o > 0) {
				if (containStroke$2(d, f, (d + h) / 2 - (f - g) * o, (f + g) / 2 - (h - d) * o, h, g, s, t, n)) return c;
			} else if (containStroke$4(d, f, h, g, s, t, n)) return c;
			c++;
		}
		return -1;
	}, n.prototype.contain = function(t, n) {
		var r = this.transformCoordToLocal(t, n), a = this.getBoundingRect();
		return t = r[0], n = r[1], a.contain(t, n) ? (this.hoverDataIdx = this.findDataIndex(t, n)) >= 0 : (this.hoverDataIdx = -1, !1);
	}, n.prototype.getBoundingRect = function() {
		var t = this._rect;
		if (!t) {
			for (var n = this.shape.segs, r = Infinity, a = Infinity, o = -Infinity, s = -Infinity, c = 0; c < n.length;) {
				var l = n[c++], u = n[c++];
				r = Math.min(l, r), o = Math.max(l, o), a = Math.min(u, a), s = Math.max(u, s);
			}
			t = this._rect = new BoundingRect_default(r, a, o, s);
		}
		return t;
	}, n;
}(Path_default), LargeLineDraw_default = function() {
	function t() {
		this.group = new Group_default();
	}
	return t.prototype.updateData = function(t) {
		this._clear();
		var n = this._create();
		n.setShape({ segs: t.getLayout("linesPoints") }), this._setCommon(n, t);
	}, t.prototype.incrementalPrepareUpdate = function(t) {
		this.group.removeAll(), this._clear();
	}, t.prototype.incrementalUpdate = function(t, n) {
		var r = this._newAdded[0], a = n.getLayout("linesPoints"), o = r && r.shape.segs;
		if (o && o.length < 2e4) {
			var s = o.length, c = new Float32Array(s + a.length);
			c.set(o), c.set(a, s), r.setShape({ segs: c });
		} else {
			this._newAdded = [];
			var l = this._create();
			l.incremental = !0, l.setShape({ segs: a }), this._setCommon(l, n), l.__startIndex = t.start;
		}
	}, t.prototype.remove = function() {
		this._clear();
	}, t.prototype.eachRendered = function(t) {
		this._newAdded[0] && t(this._newAdded[0]);
	}, t.prototype._create = function() {
		var t = new LargeLinesPath({
			cursor: "default",
			ignoreCoarsePointer: !0
		});
		return this._newAdded.push(t), this.group.add(t), t;
	}, t.prototype._setCommon = function(t, n, r) {
		var a = n.hostModel;
		t.setShape({
			polyline: a.get("polyline"),
			curveness: a.get(["lineStyle", "curveness"])
		}), t.useStyle(a.getModel("lineStyle").getLineStyle()), t.style.strokeNoScale = !0;
		var o = n.getVisual("style");
		o && o.stroke && t.setStyle("stroke", o.stroke), t.setStyle("fill", null);
		var s = getECData(t);
		s.seriesIndex = a.seriesIndex, t.on("mousemove", function(n) {
			s.dataIndex = null;
			var r = t.hoverDataIdx;
			r > 0 && (s.dataIndex = r + t.__startIndex);
		});
	}, t.prototype._clear = function() {
		this._newAdded = [], this.group.removeAll();
	}, t;
}();
init_dist$2();
var linesLayout_default = {
	seriesType: "lines",
	plan: createRenderPlanner(),
	reset: function(t) {
		var n = t.coordinateSystem;
		if (!n) {
			process$1.env.NODE_ENV !== "production" && error("The lines series must have a coordinate system.");
			return;
		}
		var r = t.get("polyline"), a = t.pipelineContext.large;
		return { progress: function(o, s) {
			var c = [];
			if (a) {
				var l = void 0, u = o.end - o.start;
				if (r) {
					for (var d = 0, f = o.start; f < o.end; f++) d += t.getLineCoordsCount(f);
					l = new Float32Array(u + d * 2);
				} else l = new Float32Array(u * 4);
				for (var p = 0, h = [], f = o.start; f < o.end; f++) {
					var g = t.getLineCoords(f, c);
					r && (l[p++] = g);
					for (var _ = 0; _ < g; _++) h = n.dataToPoint(c[_], !1, h), l[p++] = h[0], l[p++] = h[1];
				}
				s.setLayout("linesPoints", l);
			} else for (var f = o.start; f < o.end; f++) {
				var v = s.getItemModel(f), g = t.getLineCoords(f, c), y = [];
				if (r) for (var b = 0; b < g; b++) y.push(n.dataToPoint(c[b]));
				else {
					y[0] = n.dataToPoint(c[0]), y[1] = n.dataToPoint(c[1]);
					var x = v.get(["lineStyle", "curveness"]);
					+x && (y[2] = [(y[0][0] + y[1][0]) / 2 - (y[0][1] - y[1][1]) * x, (y[0][1] + y[1][1]) / 2 - (y[1][0] - y[0][0]) * x]);
				}
				s.setItemLayout(f, y);
			}
		} };
	}
};
init_dist$2();
var LinesView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r) {
		var a = t.getData(), o = this._updateLineDraw(a, t), c = t.get("zlevel"), l = t.get(["effect", "trailLength"]), u = r.getZr(), d = u.painter.getType() === "svg";
		d || u.painter.getLayer(c).clear(!0), this._lastZlevel != null && !d && u.configLayer(this._lastZlevel, { motionBlur: !1 }), this._showEffect(t) && l > 0 && (d ? process$1.env.NODE_ENV !== "production" && console.warn("SVG render mode doesn't support lines with trail effect") : u.configLayer(c, {
			motionBlur: !0,
			lastFrameAlpha: Math.max(Math.min(l / 10 + .9, 1), 0)
		})), o.updateData(a);
		var f = t.get("clip", !0) && createClipPath(t.coordinateSystem, !1, t);
		f ? this.group.setClipPath(f) : this.group.removeClipPath(), this._lastZlevel = c, this._finished = !0;
	}, n.prototype.incrementalPrepareRender = function(t, n, r) {
		var a = t.getData();
		this._updateLineDraw(a, t).incrementalPrepareUpdate(a), this._clearLayer(r), this._finished = !1;
	}, n.prototype.incrementalRender = function(t, n, r) {
		this._lineDraw.incrementalUpdate(t, n.getData()), this._finished = t.end === n.getData().count();
	}, n.prototype.eachRendered = function(t) {
		this._lineDraw && this._lineDraw.eachRendered(t);
	}, n.prototype.updateTransform = function(t, n, r) {
		var a = t.getData(), o = t.pipelineContext;
		if (!this._finished || o.large || o.progressiveRender) return { update: !0 };
		var s = linesLayout_default.reset(t, n, r);
		s.progress && s.progress({
			start: 0,
			end: a.count(),
			count: a.count()
		}, a), this._lineDraw.updateLayout(), this._clearLayer(r);
	}, n.prototype._updateLineDraw = function(t, n) {
		var r = this._lineDraw, a = this._showEffect(n), o = !!n.get("polyline"), c = n.pipelineContext.large;
		return process$1.env.NODE_ENV !== "production" && a && c && console.warn("Large lines not support effect"), (!r || a !== this._hasEffet || o !== this._isPolyline || c !== this._isLargeDraw) && (r && r.remove(), r = this._lineDraw = c ? new LargeLineDraw_default() : new LineDraw_default(o ? a ? EffectPolyline_default : Polyline_default : a ? EffectLine_default : Line_default), this._hasEffet = a, this._isPolyline = o, this._isLargeDraw = c), this.group.add(r.group), r;
	}, n.prototype._showEffect = function(t) {
		return !!t.get(["effect", "show"]);
	}, n.prototype._clearLayer = function(t) {
		var n = t.getZr();
		n.painter.getType() !== "svg" && this._lastZlevel != null && n.painter.getLayer(this._lastZlevel).clear(!0);
	}, n.prototype.remove = function(t, n) {
		this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(n);
	}, n.prototype.dispose = function(t, n) {
		this.remove(t, n);
	}, n.type = "lines", n;
}(Chart_default);
init_dist$2();
var Uint32Arr = typeof Uint32Array > "u" ? Array : Uint32Array, Float64Arr = typeof Float64Array > "u" ? Array : Float64Array;
function compatEc2(t) {
	var n = t.data;
	n && n[0] && n[0][0] && n[0][0].coord && (process$1.env.NODE_ENV !== "production" && console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }"), t.data = map(n, function(t) {
		var n = { coords: [t[0].coord, t[1].coord] };
		return t[0].name && (n.fromName = t[0].name), t[1].name && (n.toName = t[1].name), mergeAll([
			n,
			t[0],
			t[1]
		]);
	}));
}
var LinesSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.visualStyleAccessPath = "lineStyle", r.visualDrawType = "stroke", r;
	}
	return n.prototype.init = function(n) {
		n.data = n.data || [], compatEc2(n);
		var r = this._processFlatCoordsArray(n.data);
		this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (n.data = new Float32Array(r.count)), t.prototype.init.apply(this, arguments);
	}, n.prototype.mergeOption = function(n) {
		if (compatEc2(n), n.data) {
			var r = this._processFlatCoordsArray(n.data);
			this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (n.data = new Float32Array(r.count));
		}
		t.prototype.mergeOption.apply(this, arguments);
	}, n.prototype.appendData = function(t) {
		var n = this._processFlatCoordsArray(t.data);
		n.flatCoords && (this._flatCoords ? (this._flatCoords = concatArray(this._flatCoords, n.flatCoords), this._flatCoordsOffset = concatArray(this._flatCoordsOffset, n.flatCoordsOffset)) : (this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset), t.data = new Float32Array(n.count)), this.getRawData().appendData(t.data);
	}, n.prototype._getCoordsFromItemModel = function(t) {
		var n = this.getData().getItemModel(t), r = n.option instanceof Array ? n.option : n.getShallow("coords");
		if (process$1.env.NODE_ENV !== "production" && !(r instanceof Array && r.length > 0 && r[0] instanceof Array)) throw Error("Invalid coords " + JSON.stringify(r) + ". Lines must have 2d coords array in data item.");
		return r;
	}, n.prototype.getLineCoordsCount = function(t) {
		return this._flatCoordsOffset ? this._flatCoordsOffset[t * 2 + 1] : this._getCoordsFromItemModel(t).length;
	}, n.prototype.getLineCoords = function(t, n) {
		if (this._flatCoordsOffset) {
			for (var r = this._flatCoordsOffset[t * 2], a = this._flatCoordsOffset[t * 2 + 1], o = 0; o < a; o++) n[o] = n[o] || [], n[o][0] = this._flatCoords[r + o * 2], n[o][1] = this._flatCoords[r + o * 2 + 1];
			return a;
		} else {
			for (var s = this._getCoordsFromItemModel(t), o = 0; o < s.length; o++) n[o] = n[o] || [], n[o][0] = s[o][0], n[o][1] = s[o][1];
			return s.length;
		}
	}, n.prototype._processFlatCoordsArray = function(t) {
		var n = 0;
		if (this._flatCoords && (n = this._flatCoords.length), isNumber(t[0])) {
			for (var r = t.length, a = new Uint32Arr(r), o = new Float64Arr(r), c = 0, l = 0, u = 0, d = 0; d < r;) {
				u++;
				var f = t[d++];
				a[l++] = c + n, a[l++] = f;
				for (var p = 0; p < f; p++) {
					var h = t[d++], g = t[d++];
					if (o[c++] = h, o[c++] = g, d > r && process$1.env.NODE_ENV !== "production") throw Error("Invalid data format.");
				}
			}
			return {
				flatCoordsOffset: new Uint32Array(a.buffer, 0, l),
				flatCoords: o,
				count: u
			};
		}
		return {
			flatCoordsOffset: null,
			flatCoords: null,
			count: t.length
		};
	}, n.prototype.getInitialData = function(t, n) {
		if (process$1.env.NODE_ENV !== "production" && !CoordinateSystem_default.get(t.coordinateSystem)) throw Error("Unknown coordinate system " + t.coordinateSystem);
		var r = new SeriesData_default(["value"], this);
		return r.hasItemOption = !1, r.initData(t.data, [], function(t, n, a, o) {
			if (t instanceof Array) return NaN;
			r.hasItemOption = !0;
			var s = t.value;
			if (s != null) return s instanceof Array ? s[o] : s;
		}), r;
	}, n.prototype.formatTooltip = function(t, n, r) {
		var a = this.getData().getItemModel(t), o = a.get("name");
		if (o) return o;
		var s = a.get("fromName"), c = a.get("toName"), l = [];
		return s != null && l.push(s), c != null && l.push(c), createTooltipMarkup("nameValue", { name: l.join(" > ") });
	}, n.prototype.preventIncremental = function() {
		return !!this.get(["effect", "show"]);
	}, n.prototype.getProgressive = function() {
		return this.option.progressive ?? (this.option.large ? 1e4 : this.get("progressive"));
	}, n.prototype.getProgressiveThreshold = function() {
		return this.option.progressiveThreshold ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
	}, n.prototype.getZLevelKey = function() {
		var t = this.getModel("effect"), n = t.get("trailLength");
		return this.getData().count() > this.getProgressiveThreshold() ? this.id : t.get("show") && n > 0 ? n + "" : "";
	}, n.type = "series.lines", n.dependencies = [
		"grid",
		"polar",
		"geo",
		"calendar"
	], n.defaultOption = {
		coordinateSystem: "geo",
		z: 2,
		legendHoverLink: !0,
		xAxisIndex: 0,
		yAxisIndex: 0,
		symbol: ["none", "none"],
		symbolSize: [10, 10],
		geoIndex: 0,
		effect: {
			show: !1,
			period: 4,
			constantSpeed: 0,
			symbol: "circle",
			symbolSize: 3,
			loop: !0,
			trailLength: .2
		},
		large: !1,
		largeThreshold: 2e3,
		polyline: !1,
		clip: !0,
		label: {
			show: !1,
			position: "end"
		},
		lineStyle: { opacity: .5 }
	}, n;
}(Series_default);
function normalize(t) {
	return t instanceof Array || (t = [t, t]), t;
}
var linesVisual_default = {
	seriesType: "lines",
	reset: function(t) {
		var n = normalize(t.get("symbol")), r = normalize(t.get("symbolSize")), a = t.getData();
		a.setVisual("fromSymbol", n && n[0]), a.setVisual("toSymbol", n && n[1]), a.setVisual("fromSymbolSize", r && r[0]), a.setVisual("toSymbolSize", r && r[1]);
		function o(t, n) {
			var r = t.getItemModel(n), a = normalize(r.getShallow("symbol", !0)), o = normalize(r.getShallow("symbolSize", !0));
			a[0] && t.setItemVisual(n, "fromSymbol", a[0]), a[1] && t.setItemVisual(n, "toSymbol", a[1]), o[0] && t.setItemVisual(n, "fromSymbolSize", o[0]), o[1] && t.setItemVisual(n, "toSymbolSize", o[1]);
		}
		return { dataEach: a.hasItemOption ? o : null };
	}
};
function install$18(t) {
	t.registerChartView(LinesView_default), t.registerSeriesModel(LinesSeries_default), t.registerLayout(linesLayout_default), t.registerVisual(linesVisual_default);
}
var GRADIENT_LEVELS = 256, HeatmapLayer_default = function() {
	function t() {
		this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
			inRange: null,
			outOfRange: null
		}, this.canvas = platformApi.createCanvas();
	}
	return t.prototype.update = function(t, n, r, a, o, s) {
		var c = this._getBrush(), l = this._getGradient(o, "inRange"), u = this._getGradient(o, "outOfRange"), d = this.pointSize + this.blurSize, f = this.canvas, p = f.getContext("2d"), h = t.length;
		f.width = n, f.height = r;
		for (var g = 0; g < h; ++g) {
			var _ = t[g], v = _[0], y = _[1], b = _[2], x = a(b);
			p.globalAlpha = x, p.drawImage(c, v - d, y - d);
		}
		if (!f.width || !f.height) return f;
		for (var S = p.getImageData(0, 0, f.width, f.height), C = S.data, w = 0, T = C.length, E = this.minOpacity, D = this.maxOpacity - E; w < T;) {
			var x = C[w + 3] / 256, O = Math.floor(x * (GRADIENT_LEVELS - 1)) * 4;
			if (x > 0) {
				var A = s(x) ? l : u;
				x > 0 && (x = x * D + E), C[w++] = A[O], C[w++] = A[O + 1], C[w++] = A[O + 2], C[w++] = A[O + 3] * x * 256;
			} else w += 4;
		}
		return p.putImageData(S, 0, 0), f;
	}, t.prototype._getBrush = function() {
		var t = this._brushCanvas ||= platformApi.createCanvas(), n = this.pointSize + this.blurSize, r = n * 2;
		t.width = r, t.height = r;
		var a = t.getContext("2d");
		return a.clearRect(0, 0, r, r), a.shadowOffsetX = r, a.shadowBlur = this.blurSize, a.shadowColor = "#000", a.beginPath(), a.arc(-n, n, this.pointSize, 0, Math.PI * 2, !0), a.closePath(), a.fill(), t;
	}, t.prototype._getGradient = function(t, n) {
		for (var r = this._gradientPixels, a = r[n] || (r[n] = new Uint8ClampedArray(256 * 4)), o = [
			0,
			0,
			0,
			0
		], s = 0, c = 0; c < 256; c++) t[n](c / 255, !0, o), a[s++] = o[0], a[s++] = o[1], a[s++] = o[2], a[s++] = o[3];
		return a;
	}, t;
}();
init_dist$2();
function getIsInPiecewiseRange(t, n, r) {
	var a = t[1] - t[0];
	n = map(n, function(n) {
		return { interval: [(n.interval[0] - t[0]) / a, (n.interval[1] - t[0]) / a] };
	});
	var o = n.length, s = 0;
	return function(t) {
		var a;
		for (a = s; a < o; a++) {
			var c = n[a].interval;
			if (c[0] <= t && t <= c[1]) {
				s = a;
				break;
			}
		}
		if (a === o) for (a = s - 1; a >= 0; a--) {
			var c = n[a].interval;
			if (c[0] <= t && t <= c[1]) {
				s = a;
				break;
			}
		}
		return a >= 0 && a < o && r[a];
	};
}
function getIsInContinuousRange(t, n) {
	var r = t[1] - t[0];
	return n = [(n[0] - t[0]) / r, (n[1] - t[0]) / r], function(t) {
		return t >= n[0] && t <= n[1];
	};
}
function isGeoCoordSys(t) {
	var n = t.dimensions;
	return n[0] === "lng" && n[1] === "lat";
}
var HeatmapView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r) {
		var a;
		if (n.eachComponent("visualMap", function(n) {
			n.eachTargetSeries(function(r) {
				r === t && (a = n);
			});
		}), process$1.env.NODE_ENV !== "production" && !a) throw Error("Heatmap must use with visualMap");
		this._progressiveEls = null, this.group.removeAll();
		var o = t.coordinateSystem;
		o.type === "cartesian2d" || o.type === "calendar" ? this._renderOnCartesianAndCalendar(t, r, 0, t.getData().count()) : isGeoCoordSys(o) && this._renderOnGeo(o, t, a, r);
	}, n.prototype.incrementalPrepareRender = function(t, n, r) {
		this.group.removeAll();
	}, n.prototype.incrementalRender = function(t, n, r, a) {
		var o = n.coordinateSystem;
		o && (isGeoCoordSys(o) ? this.render(n, r, a) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(n, a, t.start, t.end, !0)));
	}, n.prototype.eachRendered = function(t) {
		traverseElements(this._progressiveEls || this.group, t);
	}, n.prototype._renderOnCartesianAndCalendar = function(t, n, r, a, o) {
		var c = t.coordinateSystem, l = isCoordinateSystemType(c, "cartesian2d"), u, d, f, p;
		if (l) {
			var h = c.getAxis("x"), g = c.getAxis("y");
			if (process$1.env.NODE_ENV !== "production") {
				if (!(h.type === "category" && g.type === "category")) throw Error("Heatmap on cartesian must have two category axes");
				if (!(h.onBand && g.onBand)) throw Error("Heatmap on cartesian must have two axes with boundaryGap true");
			}
			u = h.getBandWidth() + .5, d = g.getBandWidth() + .5, f = h.scale.getExtent(), p = g.scale.getExtent();
		}
		for (var _ = this.group, v = t.getData(), y = t.getModel(["emphasis", "itemStyle"]).getItemStyle(), b = t.getModel(["blur", "itemStyle"]).getItemStyle(), x = t.getModel(["select", "itemStyle"]).getItemStyle(), S = t.get(["itemStyle", "borderRadius"]), C = getLabelStatesModels(t), w = t.getModel("emphasis"), T = w.get("focus"), E = w.get("blurScope"), D = w.get("disabled"), O = l ? [
			v.mapDimension("x"),
			v.mapDimension("y"),
			v.mapDimension("value")
		] : [v.mapDimension("time"), v.mapDimension("value")], A = r; A < a; A++) {
			var j = void 0, M = v.getItemVisual(A, "style");
			if (l) {
				var N = v.get(O[0], A), P = v.get(O[1], A);
				if (isNaN(v.get(O[2], A)) || isNaN(N) || isNaN(P) || N < f[0] || N > f[1] || P < p[0] || P > p[1]) continue;
				var F = c.dataToPoint([N, P]);
				j = new Rect_default({
					shape: {
						x: F[0] - u / 2,
						y: F[1] - d / 2,
						width: u,
						height: d
					},
					style: M
				});
			} else {
				if (isNaN(v.get(O[1], A))) continue;
				j = new Rect_default({
					z2: 1,
					shape: c.dataToRect([v.get(O[0], A)]).contentShape,
					style: M
				});
			}
			if (v.hasItemOption) {
				var I = v.getItemModel(A), L = I.getModel("emphasis");
				y = L.getModel("itemStyle").getItemStyle(), b = I.getModel(["blur", "itemStyle"]).getItemStyle(), x = I.getModel(["select", "itemStyle"]).getItemStyle(), S = I.get(["itemStyle", "borderRadius"]), T = L.get("focus"), E = L.get("blurScope"), D = L.get("disabled"), C = getLabelStatesModels(I);
			}
			j.shape.r = S;
			var R = t.getRawValue(A), z = "-";
			R && R[2] != null && (z = R[2] + ""), setLabelStyle(j, C, {
				labelFetcher: t,
				labelDataIndex: A,
				defaultOpacity: M.opacity,
				defaultText: z
			}), j.ensureState("emphasis").style = y, j.ensureState("blur").style = b, j.ensureState("select").style = x, toggleHoverEmphasis(j, T, E, D), j.incremental = o, o && (j.states.emphasis.hoverLayer = !0), _.add(j), v.setItemGraphicEl(A, j), this._progressiveEls && this._progressiveEls.push(j);
		}
	}, n.prototype._renderOnGeo = function(t, n, r, a) {
		var o = r.targetVisuals.inRange, s = r.targetVisuals.outOfRange, c = n.getData(), l = this._hmLayer || this._hmLayer || new HeatmapLayer_default();
		l.blurSize = n.get("blurSize"), l.pointSize = n.get("pointSize"), l.minOpacity = n.get("minOpacity"), l.maxOpacity = n.get("maxOpacity");
		var u = t.getViewRect().clone(), d = t.getRoamTransform();
		u.applyTransform(d);
		var f = Math.max(u.x, 0), p = Math.max(u.y, 0), h = Math.min(u.width + u.x, a.getWidth()), g = Math.min(u.height + u.y, a.getHeight()), _ = h - f, v = g - p, y = [
			c.mapDimension("lng"),
			c.mapDimension("lat"),
			c.mapDimension("value")
		], b = c.mapArray(y, function(n, r, a) {
			var o = t.dataToPoint([n, r]);
			return o[0] -= f, o[1] -= p, o.push(a), o;
		}), x = r.getExtent(), S = r.type === "visualMap.continuous" ? getIsInContinuousRange(x, r.option.range) : getIsInPiecewiseRange(x, r.getPieceList(), r.option.selected);
		l.update(b, _, v, o.color.getNormalizer(), {
			inRange: o.color.getColorMapper(),
			outOfRange: s.color.getColorMapper()
		}, S);
		var C = new Image_default({
			style: {
				width: _,
				height: v,
				x: f,
				y: p,
				image: l.canvas
			},
			silent: !0
		});
		this.group.add(C);
	}, n.type = "heatmap", n;
}(Chart_default), HeatmapSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.getInitialData = function(t, n) {
		return createSeriesData_default(null, this, { generateCoord: "value" });
	}, n.prototype.preventIncremental = function() {
		var t = CoordinateSystem_default.get(this.get("coordinateSystem"));
		if (t && t.dimensions) return t.dimensions[0] === "lng" && t.dimensions[1] === "lat";
	}, n.type = "series.heatmap", n.dependencies = [
		"grid",
		"geo",
		"calendar"
	], n.defaultOption = {
		coordinateSystem: "cartesian2d",
		z: 2,
		geoIndex: 0,
		blurSize: 30,
		pointSize: 20,
		maxOpacity: 1,
		minOpacity: 0,
		select: { itemStyle: { borderColor: "#212121" } }
	}, n;
}(Series_default);
function install$19(t) {
	t.registerChartView(HeatmapView_default), t.registerSeriesModel(HeatmapSeries_default);
}
var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "borderWidth"], LAYOUT_ATTRS = [{
	xy: "x",
	wh: "width",
	index: 0,
	posDesc: ["left", "right"]
}, {
	xy: "y",
	wh: "height",
	index: 1,
	posDesc: ["top", "bottom"]
}], pathForLineWidth = new Circle_default(), PictorialBarView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r) {
		var a = this.group, o = t.getData(), s = this._data, c = t.coordinateSystem, l = c.getBaseAxis().isHorizontal(), u = c.master.getRect(), d = {
			ecSize: {
				width: r.getWidth(),
				height: r.getHeight()
			},
			seriesModel: t,
			coordSys: c,
			coordSysExtent: [[u.x, u.x + u.width], [u.y, u.y + u.height]],
			isHorizontal: l,
			valueDim: LAYOUT_ATTRS[+l],
			categoryDim: LAYOUT_ATTRS[1 - l]
		};
		o.diff(s).add(function(t) {
			if (o.hasValue(t)) {
				var n = getSymbolMeta(o, t, getItemModel(o, t), d), r = createBar(o, d, n);
				o.setItemGraphicEl(t, r), a.add(r), updateCommon(r, d, n);
			}
		}).update(function(t, n) {
			var r = s.getItemGraphicEl(n);
			if (!o.hasValue(t)) {
				a.remove(r);
				return;
			}
			var c = getSymbolMeta(o, t, getItemModel(o, t), d), l = getShapeStr(o, c);
			r && l !== r.__pictorialShapeStr && (a.remove(r), o.setItemGraphicEl(t, null), r = null), r ? updateBar(r, d, c) : r = createBar(o, d, c, !0), o.setItemGraphicEl(t, r), r.__pictorialSymbolMeta = c, a.add(r), updateCommon(r, d, c);
		}).remove(function(t) {
			var n = s.getItemGraphicEl(t);
			n && removeBar(s, t, n.__pictorialSymbolMeta.animationModel, n);
		}).execute();
		var f = t.get("clip", !0) ? createClipPath(t.coordinateSystem, !1, t) : null;
		return f ? a.setClipPath(f) : a.removeClipPath(), this._data = o, this.group;
	}, n.prototype.remove = function(t, n) {
		var r = this.group, a = this._data;
		t.get("animation") ? a && a.eachItemGraphicEl(function(n) {
			removeBar(a, getECData(n).dataIndex, t, n);
		}) : r.removeAll();
	}, n.type = "pictorialBar", n;
}(Chart_default);
function getSymbolMeta(t, n, r, a) {
	var o = t.getItemLayout(n), s = r.get("symbolRepeat"), c = r.get("symbolClip"), l = r.get("symbolPosition") || "start", u = (r.get("symbolRotate") || 0) * Math.PI / 180 || 0, d = r.get("symbolPatternSize") || 2, f = r.isAnimationEnabled(), p = {
		dataIndex: n,
		layout: o,
		itemModel: r,
		symbolType: t.getItemVisual(n, "symbol") || "circle",
		style: t.getItemVisual(n, "style"),
		symbolClip: c,
		symbolRepeat: s,
		symbolRepeatDirection: r.get("symbolRepeatDirection"),
		symbolPatternSize: d,
		rotation: u,
		animationModel: f ? r : null,
		hoverScale: f && r.get(["emphasis", "scale"]),
		z2: r.getShallow("z", !0) || 0
	};
	prepareBarLength(r, s, o, a, p), prepareSymbolSize(t, n, o, s, c, p.boundingLength, p.pxSign, d, a, p), prepareLineWidth(r, p.symbolScale, u, a, p);
	var h = p.symbolSize;
	return prepareLayoutInfo(r, h, o, s, c, normalizeSymbolOffset(r.get("symbolOffset"), h), l, p.valueLineWidth, p.boundingLength, p.repeatCutLength, a, p), p;
}
function prepareBarLength(t, n, r, a, o) {
	var s = a.valueDim, c = t.get("symbolBoundingData"), l = a.coordSys.getOtherAxis(a.coordSys.getBaseAxis()), u = l.toGlobalCoord(l.dataToCoord(0)), d = 1 - (r[s.wh] <= 0), f;
	if (isArray(c)) {
		var p = [convertToCoordOnAxis(l, c[0]) - u, convertToCoordOnAxis(l, c[1]) - u];
		p[1] < p[0] && p.reverse(), f = p[d];
	} else f = c == null ? n ? a.coordSysExtent[s.index][d] - u : r[s.wh] : convertToCoordOnAxis(l, c) - u;
	o.boundingLength = f, n && (o.repeatCutLength = r[s.wh]);
	var h = s.xy === "x", g = l.inverse;
	o.pxSign = h && !g || !h && g ? f >= 0 ? 1 : -1 : f > 0 ? 1 : -1;
}
function convertToCoordOnAxis(t, n) {
	return t.toGlobalCoord(t.dataToCoord(t.scale.parse(n)));
}
function prepareSymbolSize(t, n, r, a, o, s, c, l, u, d) {
	var f = u.valueDim, p = u.categoryDim, h = Math.abs(r[p.wh]), g = t.getItemVisual(n, "symbolSize"), _ = isArray(g) ? g.slice() : g == null ? ["100%", "100%"] : [g, g];
	_[p.index] = parsePercent$1(_[p.index], h), _[f.index] = parsePercent$1(_[f.index], a ? h : Math.abs(s)), d.symbolSize = _;
	var v = d.symbolScale = [_[0] / l, _[1] / l];
	v[f.index] *= (u.isHorizontal ? -1 : 1) * c;
}
function prepareLineWidth(t, n, r, a, o) {
	var s = t.get(BAR_BORDER_WIDTH_QUERY) || 0;
	s && (pathForLineWidth.attr({
		scaleX: n[0],
		scaleY: n[1],
		rotation: r
	}), pathForLineWidth.updateTransform(), s /= pathForLineWidth.getLineScale(), s *= n[a.valueDim.index]), o.valueLineWidth = s || 0;
}
function prepareLayoutInfo(t, n, r, a, o, s, c, l, u, d, f, p) {
	var h = f.categoryDim, g = f.valueDim, _ = p.pxSign, v = Math.max(n[g.index] + l, 0), y = v;
	if (a) {
		var b = Math.abs(u), x = retrieve(t.get("symbolMargin"), "15%") + "", S = !1;
		x.lastIndexOf("!") === x.length - 1 && (S = !0, x = x.slice(0, x.length - 1));
		var C = parsePercent$1(x, n[g.index]), w = Math.max(v + C * 2, 0), T = S ? 0 : C * 2, E = isNumeric(a), D = E ? a : toIntTimes((b + T) / w);
		C = (b - D * v) / 2 / (S ? D : Math.max(D - 1, 1)), w = v + C * 2, T = S ? 0 : C * 2, !E && a !== "fixed" && (D = d ? toIntTimes((Math.abs(d) + T) / w) : 0), y = D * w - T, p.repeatTimes = D, p.symbolMargin = C;
	}
	var O = _ * (y / 2), A = p.pathPosition = [];
	A[h.index] = r[h.wh] / 2, A[g.index] = c === "start" ? O : c === "end" ? u - O : u / 2, s && (A[0] += s[0], A[1] += s[1]);
	var j = p.bundlePosition = [];
	j[h.index] = r[h.xy], j[g.index] = r[g.xy];
	var M = p.barRectShape = extend({}, r);
	M[g.wh] = _ * Math.max(Math.abs(r[g.wh]), Math.abs(A[g.index] + O)), M[h.wh] = r[h.wh];
	var N = p.clipShape = {};
	N[h.xy] = -r[h.xy], N[h.wh] = f.ecSize[h.wh], N[g.xy] = 0, N[g.wh] = r[g.wh];
}
function createPath(t) {
	var n = t.symbolPatternSize, r = createSymbol(t.symbolType, -n / 2, -n / 2, n, n);
	return r.attr({ culling: !0 }), r.type !== "image" && r.setStyle({ strokeNoScale: !0 }), r;
}
function createOrUpdateRepeatSymbols(t, n, r, a) {
	var o = t.__pictorialBundle, s = r.symbolSize, c = r.valueLineWidth, l = r.pathPosition, u = n.valueDim, d = r.repeatTimes || 0, f = 0, p = s[n.valueDim.index] + c + r.symbolMargin * 2;
	for (eachPath(t, function(t) {
		t.__pictorialAnimationIndex = f, t.__pictorialRepeatTimes = d, f < d ? updateAttr(t, null, _(f), r, a) : updateAttr(t, null, {
			scaleX: 0,
			scaleY: 0
		}, r, a, function() {
			o.remove(t);
		}), f++;
	}); f < d; f++) {
		var h = createPath(r);
		h.__pictorialAnimationIndex = f, h.__pictorialRepeatTimes = d, o.add(h);
		var g = _(f);
		updateAttr(h, {
			x: g.x,
			y: g.y,
			scaleX: 0,
			scaleY: 0
		}, {
			scaleX: g.scaleX,
			scaleY: g.scaleY,
			rotation: g.rotation
		}, r, a);
	}
	function _(t) {
		var n = l.slice(), a = r.pxSign, o = t;
		return (r.symbolRepeatDirection === "start" ? a > 0 : a < 0) && (o = d - 1 - t), n[u.index] = p * (o - d / 2 + .5) + l[u.index], {
			x: n[0],
			y: n[1],
			scaleX: r.symbolScale[0],
			scaleY: r.symbolScale[1],
			rotation: r.rotation
		};
	}
}
function createOrUpdateSingleSymbol(t, n, r, a) {
	var o = t.__pictorialBundle, s = t.__pictorialMainPath;
	s ? updateAttr(s, null, {
		x: r.pathPosition[0],
		y: r.pathPosition[1],
		scaleX: r.symbolScale[0],
		scaleY: r.symbolScale[1],
		rotation: r.rotation
	}, r, a) : (s = t.__pictorialMainPath = createPath(r), o.add(s), updateAttr(s, {
		x: r.pathPosition[0],
		y: r.pathPosition[1],
		scaleX: 0,
		scaleY: 0,
		rotation: r.rotation
	}, {
		scaleX: r.symbolScale[0],
		scaleY: r.symbolScale[1]
	}, r, a));
}
function createOrUpdateBarRect(t, n, r) {
	var a = extend({}, n.barRectShape), o = t.__pictorialBarRect;
	o ? updateAttr(o, null, { shape: a }, n, r) : (o = t.__pictorialBarRect = new Rect_default({
		z2: 2,
		shape: a,
		silent: !0,
		style: {
			stroke: "transparent",
			fill: "transparent",
			lineWidth: 0
		}
	}), o.disableMorphing = !0, t.add(o));
}
function createOrUpdateClip(t, n, r, a) {
	if (r.symbolClip) {
		var o = t.__pictorialClipPath, s = extend({}, r.clipShape), c = n.valueDim, l = r.animationModel, u = r.dataIndex;
		if (o) updateProps(o, { shape: s }, l, u);
		else {
			s[c.wh] = 0, o = new Rect_default({ shape: s }), t.__pictorialBundle.setClipPath(o), t.__pictorialClipPath = o;
			var d = {};
			d[c.wh] = r.clipShape[c.wh], graphic_exports$1[a ? "updateProps" : "initProps"](o, { shape: d }, l, u);
		}
	}
}
function getItemModel(t, n) {
	var r = t.getItemModel(n);
	return r.getAnimationDelayParams = getAnimationDelayParams, r.isAnimationEnabled = isAnimationEnabled, r;
}
function getAnimationDelayParams(t) {
	return {
		index: t.__pictorialAnimationIndex,
		count: t.__pictorialRepeatTimes
	};
}
function isAnimationEnabled() {
	return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function createBar(t, n, r, a) {
	var o = new Group_default(), s = new Group_default();
	return o.add(s), o.__pictorialBundle = s, s.x = r.bundlePosition[0], s.y = r.bundlePosition[1], r.symbolRepeat ? createOrUpdateRepeatSymbols(o, n, r) : createOrUpdateSingleSymbol(o, n, r), createOrUpdateBarRect(o, r, a), createOrUpdateClip(o, n, r, a), o.__pictorialShapeStr = getShapeStr(t, r), o.__pictorialSymbolMeta = r, o;
}
function updateBar(t, n, r) {
	var a = r.animationModel, o = r.dataIndex, s = t.__pictorialBundle;
	updateProps(s, {
		x: r.bundlePosition[0],
		y: r.bundlePosition[1]
	}, a, o), r.symbolRepeat ? createOrUpdateRepeatSymbols(t, n, r, !0) : createOrUpdateSingleSymbol(t, n, r, !0), createOrUpdateBarRect(t, r, !0), createOrUpdateClip(t, n, r, !0);
}
function removeBar(t, n, r, a) {
	var o = a.__pictorialBarRect;
	o && o.removeTextContent();
	var s = [];
	eachPath(a, function(t) {
		s.push(t);
	}), a.__pictorialMainPath && s.push(a.__pictorialMainPath), a.__pictorialClipPath && (r = null), each(s, function(t) {
		removeElement(t, {
			scaleX: 0,
			scaleY: 0
		}, r, n, function() {
			a.parent && a.parent.remove(a);
		});
	}), t.setItemGraphicEl(n, null);
}
function getShapeStr(t, n) {
	return [
		t.getItemVisual(n.dataIndex, "symbol") || "none",
		!!n.symbolRepeat,
		!!n.symbolClip
	].join(":");
}
function eachPath(t, n, r) {
	each(t.__pictorialBundle.children(), function(a) {
		a !== t.__pictorialBarRect && n.call(r, a);
	});
}
function updateAttr(t, n, r, a, o, s) {
	n && t.attr(n), a.symbolClip && !o ? r && t.attr(r) : r && graphic_exports$1[o ? "updateProps" : "initProps"](t, r, a.animationModel, a.dataIndex, s);
}
function updateCommon(t, n, r) {
	var a = r.dataIndex, o = r.itemModel, s = o.getModel("emphasis"), c = s.getModel("itemStyle").getItemStyle(), l = o.getModel(["blur", "itemStyle"]).getItemStyle(), u = o.getModel(["select", "itemStyle"]).getItemStyle(), d = o.getShallow("cursor"), f = s.get("focus"), p = s.get("blurScope"), h = s.get("scale");
	eachPath(t, function(t) {
		if (t instanceof Image_default) {
			var n = t.style;
			t.useStyle(extend({
				image: n.image,
				x: n.x,
				y: n.y,
				width: n.width,
				height: n.height
			}, r.style));
		} else t.useStyle(r.style);
		var a = t.ensureState("emphasis");
		a.style = c, h && (a.scaleX = t.scaleX * 1.1, a.scaleY = t.scaleY * 1.1), t.ensureState("blur").style = l, t.ensureState("select").style = u, d && (t.cursor = d), t.z2 = r.z2;
	});
	var g = n.valueDim.posDesc[+(r.boundingLength > 0)], _ = t.__pictorialBarRect;
	_.ignoreClip = !0, setLabelStyle(_, getLabelStatesModels(o), {
		labelFetcher: n.seriesModel,
		labelDataIndex: a,
		defaultText: getDefaultLabel(n.seriesModel.getData(), a),
		inheritColor: r.style.fill,
		defaultOpacity: r.style.opacity,
		defaultOutsidePosition: g
	}), toggleHoverEmphasis(t, f, p, s.get("disabled"));
}
function toIntTimes(t) {
	var n = Math.round(t);
	return Math.abs(t - n) < 1e-4 ? n : Math.ceil(t);
}
var PictorialBarView_default = PictorialBarView, PictorialBarSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.hasSymbolVisual = !0, r.defaultSymbol = "roundRect", r;
	}
	return n.prototype.getInitialData = function(n) {
		return n.stack = null, t.prototype.getInitialData.apply(this, arguments);
	}, n.type = "series.pictorialBar", n.dependencies = ["grid"], n.defaultOption = inheritDefaultOption(BaseBarSeries_default.defaultOption, {
		symbol: "circle",
		symbolSize: null,
		symbolRotate: null,
		symbolPosition: null,
		symbolOffset: null,
		symbolMargin: null,
		symbolRepeat: !1,
		symbolRepeatDirection: "end",
		symbolClip: !1,
		symbolBoundingData: null,
		symbolPatternSize: 400,
		barGap: "-100%",
		clip: !1,
		progressive: 0,
		emphasis: { scale: !1 },
		select: { itemStyle: { borderColor: "#212121" } }
	}), n;
}(BaseBarSeries_default);
function install$20(t) {
	t.registerChartView(PictorialBarView_default), t.registerSeriesModel(PictorialBarSeries_default), t.registerLayout(t.PRIORITY.VISUAL.LAYOUT, curry(layout$2, "pictorialBar")), t.registerLayout(t.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("pictorialBar"));
}
var ThemeRiverView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r._layers = [], r;
	}
	return n.prototype.render = function(t, n, r) {
		var a = t.getData(), o = this, s = this.group, c = t.getLayerSeries(), l = a.getLayout("layoutInfo"), u = l.rect, d = l.boundaryGap;
		s.x = 0, s.y = u.y + d[0];
		function f(t) {
			return t.name;
		}
		var p = new DataDiffer_default(this._layersSeries || [], c, f, f), h = [];
		p.add(bind(g, this, "add")).update(bind(g, this, "update")).remove(bind(g, this, "remove")).execute();
		function g(n, r, l) {
			var u = o._layers;
			if (n === "remove") {
				s.remove(u[r]);
				return;
			}
			for (var d = [], f = [], p, g = c[r].indices, _ = 0; _ < g.length; _++) {
				var v = a.getItemLayout(g[_]), y = v.x, b = v.y0, x = v.y;
				d.push(y, b), f.push(y, b + x), p = a.getItemVisual(g[_], "style");
			}
			var S, C = a.getItemLayout(g[0]), w = t.getModel("label").get("margin"), T = t.getModel("emphasis");
			if (n === "add") {
				var E = h[r] = new Group_default();
				S = new ECPolygon({
					shape: {
						points: d,
						stackedOnPoints: f,
						smooth: .4,
						stackedOnSmooth: .4,
						smoothConstraint: !1
					},
					z2: 0
				}), E.add(S), s.add(E), t.isAnimationEnabled() && S.setClipPath(createGridClipShape(S.getBoundingRect(), t, function() {
					S.removeClipPath();
				}));
			} else {
				var E = u[l];
				S = E.childAt(0), s.add(E), h[r] = E, updateProps(S, { shape: {
					points: d,
					stackedOnPoints: f
				} }, t), saveOldStyle(S);
			}
			setLabelStyle(S, getLabelStatesModels(t), {
				labelDataIndex: g[_ - 1],
				defaultText: a.getName(g[_ - 1]),
				inheritColor: p.fill
			}, { normal: { verticalAlign: "middle" } }), S.setTextConfig({
				position: null,
				local: !0
			});
			var D = S.getTextContent();
			D && (D.x = C.x - w, D.y = C.y0 + C.y / 2), S.useStyle(p), a.setItemGraphicEl(r, S), setStatesStylesFromModel(S, t), toggleHoverEmphasis(S, T.get("focus"), T.get("blurScope"), T.get("disabled"));
		}
		this._layersSeries = c, this._layers = h;
	}, n.type = "themeRiver", n;
}(Chart_default);
function createGridClipShape(t, n, r) {
	var a = new Rect_default({ shape: {
		x: t.x - 10,
		y: t.y - 10,
		width: 0,
		height: t.height + 20
	} });
	return initProps(a, { shape: {
		x: t.x - 50,
		width: t.width + 100,
		height: t.height + 20
	} }, n, r), a;
}
var ThemeRiverView_default = ThemeRiverView, DATA_NAME_INDEX = 2, ThemeRiverSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.init = function(n) {
		t.prototype.init.apply(this, arguments), this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
	}, n.prototype.fixData = function(t) {
		var n = t.length, r = {}, a = groupData(t, function(t) {
			return r.hasOwnProperty(t[0] + "") || (r[t[0] + ""] = -1), t[2];
		}), o = [];
		a.buckets.each(function(t, n) {
			o.push({
				name: n,
				dataList: t
			});
		});
		for (var s = o.length, c = 0; c < s; ++c) {
			for (var l = o[c].name, u = 0; u < o[c].dataList.length; ++u) {
				var d = o[c].dataList[u][0] + "";
				r[d] = c;
			}
			for (var d in r) r.hasOwnProperty(d) && r[d] !== c && (r[d] = c, t[n] = [
				d,
				0,
				l
			], n++);
		}
		return t;
	}, n.prototype.getInitialData = function(t, n) {
		for (var r = this.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0].get("type"), a = filter(t.data, function(t) {
			return t[2] !== void 0;
		}), o = this.fixData(a || []), s = [], c = this.nameMap = createHashMap(), l = 0, u = 0; u < o.length; ++u) s.push(o[u][DATA_NAME_INDEX]), c.get(o[u][DATA_NAME_INDEX]) || (c.set(o[u][DATA_NAME_INDEX], l), l++);
		var d = prepareSeriesDataSchema(o, {
			coordDimensions: ["single"],
			dimensionsDefine: [
				{
					name: "time",
					type: getDimensionTypeByAxis(r)
				},
				{
					name: "value",
					type: "float"
				},
				{
					name: "name",
					type: "ordinal"
				}
			],
			encodeDefine: {
				single: 0,
				value: 1,
				itemName: 2
			}
		}).dimensions, f = new SeriesData_default(d, this);
		return f.initData(o), f;
	}, n.prototype.getLayerSeries = function() {
		for (var t = this.getData(), n = t.count(), r = [], a = 0; a < n; ++a) r[a] = a;
		var o = t.mapDimension("single"), s = groupData(r, function(n) {
			return t.get("name", n);
		}), c = [];
		return s.buckets.each(function(n, r) {
			n.sort(function(n, r) {
				return t.get(o, n) - t.get(o, r);
			}), c.push({
				name: r,
				indices: n
			});
		}), c;
	}, n.prototype.getAxisTooltipData = function(t, n, r) {
		isArray(t) || (t = t ? [t] : []);
		for (var a = this.getData(), o = this.getLayerSeries(), s = [], c = o.length, l, u = 0; u < c; ++u) {
			for (var d = Number.MAX_VALUE, f = -1, p = o[u].indices.length, h = 0; h < p; ++h) {
				var g = a.get(t[0], o[u].indices[h]), _ = Math.abs(g - n);
				_ <= d && (l = g, d = _, f = o[u].indices[h]);
			}
			s.push(f);
		}
		return {
			dataIndices: s,
			nestestValue: l
		};
	}, n.prototype.formatTooltip = function(t, n, r) {
		var a = this.getData();
		return createTooltipMarkup("nameValue", {
			name: a.getName(t),
			value: a.get(a.mapDimension("value"), t)
		});
	}, n.type = "series.themeRiver", n.dependencies = ["singleAxis"], n.defaultOption = {
		z: 2,
		colorBy: "data",
		coordinateSystem: "singleAxis",
		boundaryGap: ["10%", "10%"],
		singleAxisIndex: 0,
		animationEasing: "linear",
		label: {
			margin: 4,
			show: !0,
			position: "left",
			fontSize: 11
		},
		emphasis: { label: { show: !0 } }
	}, n;
}(Series_default);
function themeRiverLayout(t, n) {
	t.eachSeriesByType("themeRiver", function(t) {
		var n = t.getData(), r = t.coordinateSystem, a = {}, o = r.getRect();
		a.rect = o;
		var s = t.get("boundaryGap"), c = r.getAxis();
		a.boundaryGap = s, c.orient === "horizontal" ? (s[0] = parsePercent$1(s[0], o.height), s[1] = parsePercent$1(s[1], o.height), doThemeRiverLayout(n, t, o.height - s[0] - s[1])) : (s[0] = parsePercent$1(s[0], o.width), s[1] = parsePercent$1(s[1], o.width), doThemeRiverLayout(n, t, o.width - s[0] - s[1])), n.setLayout("layoutInfo", a);
	});
}
function doThemeRiverLayout(t, n, r) {
	if (t.count()) for (var a = n.coordinateSystem, o = n.getLayerSeries(), s = t.mapDimension("single"), c = t.mapDimension("value"), l = map(o, function(n) {
		return map(n.indices, function(n) {
			var r = a.dataToPoint(t.get(s, n));
			return r[1] = t.get(c, n), r;
		});
	}), u = computeBaseline(l), d = u.y0, f = r / u.max, p = o.length, h = o[0].indices.length, g, _ = 0; _ < h; ++_) {
		g = d[_] * f, t.setItemLayout(o[0].indices[_], {
			layerIndex: 0,
			x: l[0][_][0],
			y0: g,
			y: l[0][_][1] * f
		});
		for (var v = 1; v < p; ++v) g += l[v - 1][_][1] * f, t.setItemLayout(o[v].indices[_], {
			layerIndex: v,
			x: l[v][_][0],
			y0: g,
			y: l[v][_][1] * f
		});
	}
}
function computeBaseline(t) {
	for (var n = t.length, r = t[0].length, a = [], o = [], s = 0, c = 0; c < r; ++c) {
		for (var l = 0, u = 0; u < n; ++u) l += t[u][c][1];
		l > s && (s = l), a.push(l);
	}
	for (var d = 0; d < r; ++d) o[d] = (s - a[d]) / 2;
	s = 0;
	for (var f = 0; f < r; ++f) {
		var p = a[f] + o[f];
		p > s && (s = p);
	}
	return {
		y0: o,
		max: s
	};
}
function install$21(t) {
	t.registerChartView(ThemeRiverView_default), t.registerSeriesModel(ThemeRiverSeries_default), t.registerLayout(themeRiverLayout), t.registerProcessor(dataFilter$1("themeRiver"));
}
var DEFAULT_SECTOR_Z = 2, DEFAULT_TEXT_Z = 4, SunburstPiece_default = function(t) {
	__extends(n, t);
	function n(n, r, a, o) {
		var s = t.call(this) || this;
		s.z2 = DEFAULT_SECTOR_Z, s.textConfig = { inside: !0 }, getECData(s).seriesIndex = r.seriesIndex;
		var c = new Text_default({
			z2: DEFAULT_TEXT_Z,
			silent: n.getModel().get(["label", "silent"])
		});
		return s.setTextContent(c), s.updateData(!0, n, r, a, o), s;
	}
	return n.prototype.updateData = function(t, n, r, a, o) {
		this.node = n, n.piece = this, r ||= this._seriesModel, a ||= this._ecModel;
		var s = this;
		getECData(s).dataIndex = n.dataIndex;
		var c = n.getModel(), l = c.getModel("emphasis"), u = n.getLayout(), d = extend({}, u);
		d.label = null;
		var f = n.getVisual("style");
		f.lineJoin = "bevel";
		var p = n.getVisual("decal");
		p && (f.decal = createOrUpdatePatternFromDecal(p, o)), extend(d, getSectorCornerRadius(c.getModel("itemStyle"), d, !0)), each(SPECIAL_STATES, function(t) {
			var n = s.ensureState(t), r = c.getModel([t, "itemStyle"]);
			n.style = r.getItemStyle();
			var a = getSectorCornerRadius(r, d);
			a && (n.shape = a);
		}), t ? (s.setShape(d), s.shape.r = u.r0, initProps(s, { shape: { r: u.r } }, r, n.dataIndex)) : (updateProps(s, { shape: d }, r), saveOldStyle(s)), s.useStyle(f), this._updateLabel(r);
		var h = c.getShallow("cursor");
		h && s.attr("cursor", h), this._seriesModel = r || this._seriesModel, this._ecModel = a || this._ecModel;
		var g = l.get("focus"), _ = g === "relative" ? concatArray(n.getAncestorsIndices(), n.getDescendantIndices()) : g === "ancestor" ? n.getAncestorsIndices() : g === "descendant" ? n.getDescendantIndices() : g;
		toggleHoverEmphasis(this, _, l.get("blurScope"), l.get("disabled"));
	}, n.prototype._updateLabel = function(t) {
		var n = this, r = this.node.getModel(), a = r.getModel("label"), o = this.node.getLayout(), s = o.endAngle - o.startAngle, c = (o.startAngle + o.endAngle) / 2, l = Math.cos(c), u = Math.sin(c), d = this, f = d.getTextContent(), p = this.node.dataIndex, h = a.get("minAngle") / 180 * Math.PI;
		f.ignore = !(a.get("show") && !(h != null && Math.abs(s) < h)), each(DISPLAY_STATES, function(a) {
			var h = a === "normal" ? r.getModel("label") : r.getModel([a, "label"]), _ = a === "normal", v = _ ? f : f.ensureState(a), y = t.getFormattedLabel(p, a);
			_ && (y ||= n.node.name), v.style = createTextStyle(h, {}, null, a !== "normal", !0), y && (v.style.text = y);
			var b = h.get("show");
			b != null && !_ && (v.ignore = !b);
			var x = g(h, "position"), S = _ ? d : d.states[a], C = S.style.fill;
			S.textConfig = {
				outsideFill: h.get("color") === "inherit" ? C : null,
				inside: x !== "outside"
			};
			var w, T = g(h, "distance") || 0, E = g(h, "align"), D = g(h, "rotate"), O = Math.PI * .5, A = Math.PI * 1.5, j = normalizeRadian(D === "tangential" ? Math.PI / 2 - c : c), M = j > O && !isRadianAroundZero(j - O) && j < A;
			x === "outside" ? (w = o.r + T, E = M ? "right" : "left") : !E || E === "center" ? (w = s === 2 * Math.PI && o.r0 === 0 ? 0 : (o.r + o.r0) / 2, E = "center") : E === "left" ? (w = o.r0 + T, E = M ? "right" : "left") : E === "right" && (w = o.r - T, E = M ? "left" : "right"), v.style.align = E, v.style.verticalAlign = g(h, "verticalAlign") || "middle", v.x = w * l + o.cx, v.y = w * u + o.cy;
			var N = 0;
			D === "radial" ? N = normalizeRadian(-c) + (M ? Math.PI : 0) : D === "tangential" ? N = normalizeRadian(Math.PI / 2 - c) + (M ? Math.PI : 0) : isNumber(D) && (N = D * Math.PI / 180), v.rotation = normalizeRadian(N);
		});
		function g(t, n) {
			return t.get(n) ?? a.get(n);
		}
		f.dirtyStyle();
	}, n;
}(Sector_default);
init_dist$2();
var ROOT_TO_NODE_ACTION = "sunburstRootToNode", HIGHLIGHT_ACTION = "sunburstHighlight", UNHIGHLIGHT_ACTION = "sunburstUnhighlight";
function installSunburstAction(t) {
	t.registerAction({
		type: ROOT_TO_NODE_ACTION,
		update: "updateView"
	}, function(t, n) {
		n.eachComponent({
			mainType: "series",
			subType: "sunburst",
			query: t
		}, r);
		function r(n, r) {
			var a = retrieveTargetInfo(t, [ROOT_TO_NODE_ACTION], n);
			if (a) {
				var o = n.getViewRoot();
				o && (t.direction = aboveViewRoot(o, a.node) ? "rollUp" : "drillDown"), n.resetViewRoot(a.node);
			}
		}
	}), t.registerAction({
		type: HIGHLIGHT_ACTION,
		update: "none"
	}, function(t, n, r) {
		t = extend({}, t), n.eachComponent({
			mainType: "series",
			subType: "sunburst",
			query: t
		}, a);
		function a(n) {
			var r = retrieveTargetInfo(t, [HIGHLIGHT_ACTION], n);
			r && (t.dataIndex = r.node.dataIndex);
		}
		process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("sunburstHighlight", "highlight"), r.dispatchAction(extend(t, { type: "highlight" }));
	}), t.registerAction({
		type: UNHIGHLIGHT_ACTION,
		update: "updateView"
	}, function(t, n, r) {
		t = extend({}, t), process$1.env.NODE_ENV !== "production" && deprecateReplaceLog("sunburstUnhighlight", "downplay"), r.dispatchAction(extend(t, { type: "downplay" }));
	});
}
var SunburstView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r, a) {
		var o = this;
		this.seriesModel = t, this.api = r, this.ecModel = n;
		var s = t.getData(), c = s.tree.root, l = t.getViewRoot(), u = this.group, d = t.get("renderLabelForZeroData"), f = [];
		l.eachNode(function(t) {
			f.push(t);
		}), p(f, this._oldChildren || []), _(c, l), this._initEvents(), this._oldChildren = f;
		function p(t, n) {
			if (t.length === 0 && n.length === 0) return;
			new DataDiffer_default(n, t, r, r).add(a).update(a).remove(curry(a, null)).execute();
			function r(t) {
				return t.getId();
			}
			function a(r, a) {
				h(r == null ? null : t[r], a == null ? null : n[a]);
			}
		}
		function h(a, o) {
			if (!d && a && !a.getValue() && (a = null), a !== c && o !== c) {
				if (o && o.piece) a ? (o.piece.updateData(!1, a, t, n, r), s.setItemGraphicEl(a.dataIndex, o.piece)) : g(o);
				else if (a) {
					var l = new SunburstPiece_default(a, t, n, r);
					u.add(l), s.setItemGraphicEl(a.dataIndex, l);
				}
			}
		}
		function g(t) {
			t && (t.piece &&= (u.remove(t.piece), null));
		}
		function _(a, s) {
			s.depth > 0 ? (o.virtualPiece ? o.virtualPiece.updateData(!1, a, t, n, r) : (o.virtualPiece = new SunburstPiece_default(a, t, n, r), u.add(o.virtualPiece)), s.piece.off("click"), o.virtualPiece.on("click", function(t) {
				o._rootToNode(s.parentNode);
			})) : o.virtualPiece &&= (u.remove(o.virtualPiece), null);
		}
	}, n.prototype._initEvents = function() {
		var t = this;
		this.group.off("click"), this.group.on("click", function(n) {
			var r = !1;
			t.seriesModel.getViewRoot().eachNode(function(a) {
				if (!r && a.piece && a.piece === n.target) {
					var o = a.getModel().get("nodeClick");
					if (o === "rootToNode") t._rootToNode(a);
					else if (o === "link") {
						var s = a.getModel(), c = s.get("link");
						c && windowOpen(c, s.get("target", !0) || "_blank");
					}
					r = !0;
				}
			});
		});
	}, n.prototype._rootToNode = function(t) {
		t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
			type: ROOT_TO_NODE_ACTION,
			from: this.uid,
			seriesId: this.seriesModel.id,
			targetNode: t
		});
	}, n.prototype.containPoint = function(t, n) {
		var r = n.getData().getItemLayout(0);
		if (r) {
			var a = t[0] - r.cx, o = t[1] - r.cy, s = Math.sqrt(a * a + o * o);
			return s <= r.r && s >= r.r0;
		}
	}, n.type = "sunburst", n;
}(Chart_default), SunburstSeriesModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.ignoreStyleOnData = !0, r;
	}
	return n.prototype.getInitialData = function(t, n) {
		var r = {
			name: t.name,
			children: t.data
		};
		completeTreeValue(r);
		var a = this._levelModels = map(t.levels || [], function(t) {
			return new Model_default(t, this, n);
		}, this), o = Tree_default.createTree(r, this, s);
		function s(t) {
			t.wrapMethod("getItemModel", function(t, n) {
				var r = a[o.getNodeByDataIndex(n).depth];
				return r && (t.parentModel = r), t;
			});
		}
		return o.data;
	}, n.prototype.optionUpdated = function() {
		this.resetViewRoot();
	}, n.prototype.getDataParams = function(n) {
		var r = t.prototype.getDataParams.apply(this, arguments);
		return r.treePathInfo = wrapTreePathInfo(this.getData().tree.getNodeByDataIndex(n), this), r;
	}, n.prototype.getLevelModel = function(t) {
		return this._levelModels && this._levelModels[t.depth];
	}, n.prototype.getViewRoot = function() {
		return this._viewRoot;
	}, n.prototype.resetViewRoot = function(t) {
		t ? this._viewRoot = t : t = this._viewRoot;
		var n = this.getRawData().tree.root;
		(!t || t !== n && !n.contains(t)) && (this._viewRoot = n);
	}, n.prototype.enableAriaDecal = function() {
		enableAriaDecalForTree(this);
	}, n.type = "series.sunburst", n.defaultOption = {
		z: 2,
		center: ["50%", "50%"],
		radius: [0, "75%"],
		clockwise: !0,
		startAngle: 90,
		minAngle: 0,
		stillShowZeroSum: !0,
		nodeClick: "rootToNode",
		renderLabelForZeroData: !1,
		label: {
			rotate: "radial",
			show: !0,
			opacity: 1,
			align: "center",
			position: "inside",
			distance: 5,
			silent: !0
		},
		itemStyle: {
			borderWidth: 1,
			borderColor: "white",
			borderType: "solid",
			shadowBlur: 0,
			shadowColor: "rgba(0, 0, 0, 0.2)",
			shadowOffsetX: 0,
			shadowOffsetY: 0,
			opacity: 1
		},
		emphasis: { focus: "descendant" },
		blur: {
			itemStyle: { opacity: .2 },
			label: { opacity: .1 }
		},
		animationType: "expansion",
		animationDuration: 1e3,
		animationDurationUpdate: 500,
		data: [],
		sort: "desc"
	}, n;
}(Series_default);
function completeTreeValue(t) {
	var n = 0;
	each(t.children, function(t) {
		completeTreeValue(t);
		var r = t.value;
		isArray(r) && (r = r[0]), n += r;
	});
	var r = t.value;
	isArray(r) && (r = r[0]), (r == null || isNaN(r)) && (r = n), r < 0 && (r = 0), isArray(t.value) ? t.value[0] = r : t.value = r;
}
var SunburstSeries_default = SunburstSeriesModel, RADIAN = Math.PI / 180;
function sunburstLayout(t, n, r) {
	n.eachSeriesByType(t, function(t) {
		var n = t.get("center"), a = t.get("radius");
		isArray(a) || (a = [0, a]), isArray(n) || (n = [n, n]);
		var o = r.getWidth(), s = r.getHeight(), c = Math.min(o, s), l = parsePercent$1(n[0], o), u = parsePercent$1(n[1], s), d = parsePercent$1(a[0], c / 2), f = parsePercent$1(a[1], c / 2), p = -t.get("startAngle") * RADIAN, h = t.get("minAngle") * RADIAN, g = t.getData().tree.root, _ = t.getViewRoot(), v = _.depth, y = t.get("sort");
		y != null && initChildren(_, y);
		var b = 0;
		each(_.children, function(t) {
			!isNaN(t.getValue()) && b++;
		});
		var x = _.getValue(), S = Math.PI / (x || b) * 2, C = _.depth > 0, w = _.height - (C ? -1 : 1), T = (f - d) / (w || 1), E = t.get("clockwise"), D = t.get("stillShowZeroSum"), O = E ? 1 : -1, A = function(n, r) {
			if (n) {
				var a = r;
				if (n !== g) {
					var o = n.getValue(), s = x === 0 && D ? S : o * S;
					s < h && (s = h), a = r + O * s;
					var f = n.depth - v - (C ? -1 : 1), p = d + T * f, _ = d + T * (f + 1), y = t.getLevelModel(n);
					if (y) {
						var b = y.get("r0", !0), w = y.get("r", !0), j = y.get("radius", !0);
						j != null && (b = j[0], w = j[1]), b != null && (p = parsePercent$1(b, c / 2)), w != null && (_ = parsePercent$1(w, c / 2));
					}
					n.setLayout({
						angle: s,
						startAngle: r,
						endAngle: a,
						clockwise: E,
						cx: l,
						cy: u,
						r0: p,
						r: _
					});
				}
				if (n.children && n.children.length) {
					var M = 0;
					each(n.children, function(t) {
						M += A(t, r + M);
					});
				}
				return a - r;
			}
		};
		if (C) {
			var j = d, M = d + T, N = Math.PI * 2;
			g.setLayout({
				angle: N,
				startAngle: p,
				endAngle: p + N,
				clockwise: E,
				cx: l,
				cy: u,
				r0: j,
				r: M
			});
		}
		A(_, p);
	});
}
function initChildren(t, n) {
	var r = t.children || [];
	t.children = sort(r, n), r.length && each(t.children, function(t) {
		initChildren(t, n);
	});
}
function sort(t, n) {
	if (isFunction(n)) {
		var r = map(t, function(t, n) {
			var r = t.getValue();
			return {
				params: {
					depth: t.depth,
					height: t.height,
					dataIndex: t.dataIndex,
					getValue: function() {
						return r;
					}
				},
				index: n
			};
		});
		return r.sort(function(t, r) {
			return n(t.params, r.params);
		}), map(r, function(n) {
			return t[n.index];
		});
	} else {
		var a = n === "asc";
		return t.sort(function(t, n) {
			var r = (t.getValue() - n.getValue()) * (a ? 1 : -1);
			return r === 0 ? (t.dataIndex - n.dataIndex) * (a ? -1 : 1) : r;
		});
	}
}
function sunburstVisual(t) {
	var n = {};
	function r(t, r, a) {
		for (var o = t; o && o.depth > 1;) o = o.parentNode;
		var s = r.getColorFromPalette(o.name || o.dataIndex + "", n);
		return t.depth > 1 && isString(s) && (s = lift(s, (t.depth - 1) / (a - 1) * .5)), s;
	}
	t.eachSeriesByType("sunburst", function(t) {
		var n = t.getData(), a = n.tree;
		a.eachNode(function(o) {
			var s = o.getModel().getModel("itemStyle").getItemStyle();
			s.fill ||= r(o, t, a.root.height), extend(n.ensureUniqueItemVisual(o.dataIndex, "style"), s);
		});
	});
}
function install$22(t) {
	t.registerChartView(SunburstView_default), t.registerSeriesModel(SunburstSeries_default), t.registerLayout(curry(sunburstLayout, "sunburst")), t.registerProcessor(curry(dataFilter$1, "sunburst")), t.registerVisual(sunburstVisual), installSunburstAction(t);
}
var STYLE_VISUAL_TYPE = {
	color: "fill",
	borderColor: "stroke"
}, NON_STYLE_VISUAL_PROPS = {
	symbol: 1,
	symbolSize: 1,
	symbolKeepAspect: 1,
	legendIcon: 1,
	visualMeta: 1,
	liftZ: 1,
	decal: 1
}, customInnerStore = makeInner(), CustomSeries_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.optionUpdated = function() {
		this.currentZLevel = this.get("zlevel", !0), this.currentZ = this.get("z", !0);
	}, n.prototype.getInitialData = function(t, n) {
		return createSeriesData_default(null, this);
	}, n.prototype.getDataParams = function(n, r, a) {
		var o = t.prototype.getDataParams.call(this, n, r);
		return a && (o.info = customInnerStore(a).info), o;
	}, n.type = "series.custom", n.dependencies = [
		"grid",
		"polar",
		"geo",
		"singleAxis",
		"calendar"
	], n.defaultOption = {
		coordinateSystem: "cartesian2d",
		z: 2,
		legendHoverLink: !0,
		clip: !1
	}, n;
}(Series_default);
function dataToCoordSize$3(t, n) {
	return n ||= [0, 0], map(["x", "y"], function(r, a) {
		var o = this.getAxis(r), s = n[a], c = t[a] / 2;
		return o.type === "category" ? o.getBandWidth() : Math.abs(o.dataToCoord(s - c) - o.dataToCoord(s + c));
	}, this);
}
function cartesianPrepareCustom(t) {
	var n = t.master.getRect();
	return {
		coordSys: {
			type: "cartesian2d",
			x: n.x,
			y: n.y,
			width: n.width,
			height: n.height
		},
		api: {
			coord: function(n) {
				return t.dataToPoint(n);
			},
			size: bind(dataToCoordSize$3, t)
		}
	};
}
function dataToCoordSize$2(t, n) {
	return n ||= [0, 0], map([0, 1], function(r) {
		var a = n[r], o = t[r] / 2, s = [], c = [];
		return s[r] = a - o, c[r] = a + o, s[1 - r] = c[1 - r] = n[1 - r], Math.abs(this.dataToPoint(s)[r] - this.dataToPoint(c)[r]);
	}, this);
}
function geoPrepareCustom(t) {
	var n = t.getBoundingRect();
	return {
		coordSys: {
			type: "geo",
			x: n.x,
			y: n.y,
			width: n.width,
			height: n.height,
			zoom: t.getZoom()
		},
		api: {
			coord: function(n) {
				return t.dataToPoint(n);
			},
			size: bind(dataToCoordSize$2, t)
		}
	};
}
function dataToCoordSize$1(t, n) {
	var r = this.getAxis(), a = n instanceof Array ? n[0] : n, o = (t instanceof Array ? t[0] : t) / 2;
	return r.type === "category" ? r.getBandWidth() : Math.abs(r.dataToCoord(a - o) - r.dataToCoord(a + o));
}
function singlePrepareCustom(t) {
	var n = t.getRect();
	return {
		coordSys: {
			type: "singleAxis",
			x: n.x,
			y: n.y,
			width: n.width,
			height: n.height
		},
		api: {
			coord: function(n) {
				return t.dataToPoint(n);
			},
			size: bind(dataToCoordSize$1, t)
		}
	};
}
function dataToCoordSize(t, n) {
	return n ||= [0, 0], map(["Radius", "Angle"], function(r, a) {
		var o = "get" + r + "Axis", s = this[o](), c = n[a], l = t[a] / 2, u = s.type === "category" ? s.getBandWidth() : Math.abs(s.dataToCoord(c - l) - s.dataToCoord(c + l));
		return r === "Angle" && (u = u * Math.PI / 180), u;
	}, this);
}
function polarPrepareCustom(t) {
	var n = t.getRadiusAxis(), r = t.getAngleAxis(), a = n.getExtent();
	return a[0] > a[1] && a.reverse(), {
		coordSys: {
			type: "polar",
			cx: t.cx,
			cy: t.cy,
			r: a[1],
			r0: a[0]
		},
		api: {
			coord: function(a) {
				var o = n.dataToRadius(a[0]), s = r.dataToAngle(a[1]), c = t.coordToPoint([o, s]);
				return c.push(o, s * Math.PI / 180), c;
			},
			size: bind(dataToCoordSize, t)
		}
	};
}
function calendarPrepareCustom(t) {
	var n = t.getRect(), r = t.getRangeInfo();
	return {
		coordSys: {
			type: "calendar",
			x: n.x,
			y: n.y,
			width: n.width,
			height: n.height,
			cellWidth: t.getCellWidth(),
			cellHeight: t.getCellHeight(),
			rangeInfo: {
				start: r.start,
				end: r.end,
				weeks: r.weeks,
				dayCount: r.allDay
			}
		},
		api: { coord: function(n, r) {
			return t.dataToPoint(n, r);
		} }
	};
}
init_dist$2();
var deprecatedLogs = {};
function isEC4CompatibleStyle(t, n, r, a) {
	return t && (t.legacy || t.legacy !== !1 && !r && !a && n !== "tspan" && (n === "text" || hasOwn(t, "text")));
}
function convertFromEC4CompatibleStyle(t, n, r) {
	var a = t, o, s, c;
	if (n === "text") c = a;
	else {
		c = {}, hasOwn(a, "text") && (c.text = a.text), hasOwn(a, "rich") && (c.rich = a.rich), hasOwn(a, "textFill") && (c.fill = a.textFill), hasOwn(a, "textStroke") && (c.stroke = a.textStroke), hasOwn(a, "fontFamily") && (c.fontFamily = a.fontFamily), hasOwn(a, "fontSize") && (c.fontSize = a.fontSize), hasOwn(a, "fontStyle") && (c.fontStyle = a.fontStyle), hasOwn(a, "fontWeight") && (c.fontWeight = a.fontWeight), s = {
			type: "text",
			style: c,
			silent: !0
		}, o = {};
		var l = hasOwn(a, "textPosition");
		r ? o.position = l ? a.textPosition : "inside" : l && (o.position = a.textPosition), hasOwn(a, "textPosition") && (o.position = a.textPosition), hasOwn(a, "textOffset") && (o.offset = a.textOffset), hasOwn(a, "textRotation") && (o.rotation = a.textRotation), hasOwn(a, "textDistance") && (o.distance = a.textDistance);
	}
	return convertEC4CompatibleRichItem(c, t), each(c.rich, function(t) {
		convertEC4CompatibleRichItem(t, t);
	}), {
		textConfig: o,
		textContent: s
	};
}
function convertEC4CompatibleRichItem(t, n) {
	n && (n.font = n.textFont || n.font, hasOwn(n, "textStrokeWidth") && (t.lineWidth = n.textStrokeWidth), hasOwn(n, "textAlign") && (t.align = n.textAlign), hasOwn(n, "textVerticalAlign") && (t.verticalAlign = n.textVerticalAlign), hasOwn(n, "textLineHeight") && (t.lineHeight = n.textLineHeight), hasOwn(n, "textWidth") && (t.width = n.textWidth), hasOwn(n, "textHeight") && (t.height = n.textHeight), hasOwn(n, "textBackgroundColor") && (t.backgroundColor = n.textBackgroundColor), hasOwn(n, "textPadding") && (t.padding = n.textPadding), hasOwn(n, "textBorderColor") && (t.borderColor = n.textBorderColor), hasOwn(n, "textBorderWidth") && (t.borderWidth = n.textBorderWidth), hasOwn(n, "textBorderRadius") && (t.borderRadius = n.textBorderRadius), hasOwn(n, "textBoxShadowColor") && (t.shadowColor = n.textBoxShadowColor), hasOwn(n, "textBoxShadowBlur") && (t.shadowBlur = n.textBoxShadowBlur), hasOwn(n, "textBoxShadowOffsetX") && (t.shadowOffsetX = n.textBoxShadowOffsetX), hasOwn(n, "textBoxShadowOffsetY") && (t.shadowOffsetY = n.textBoxShadowOffsetY));
}
function convertToEC4StyleForCustomSerise(t, n, r) {
	var a = t;
	a.textPosition = a.textPosition || r.position || "inside", r.offset != null && (a.textOffset = r.offset), r.rotation != null && (a.textRotation = r.rotation), r.distance != null && (a.textDistance = r.distance);
	var o = a.textPosition.indexOf("inside") >= 0, s = t.fill || "#000";
	convertToEC4RichItem(a, n);
	var c = a.textFill == null;
	return o ? c && (a.textFill = r.insideFill || "#fff", !a.textStroke && r.insideStroke && (a.textStroke = r.insideStroke), !a.textStroke && (a.textStroke = s), a.textStrokeWidth ??= 2) : (c && (a.textFill = t.fill || r.outsideFill || "#000"), !a.textStroke && r.outsideStroke && (a.textStroke = r.outsideStroke)), a.text = n.text, a.rich = n.rich, each(n.rich, function(t) {
		convertToEC4RichItem(t, t);
	}), a;
}
function convertToEC4RichItem(t, n) {
	n && (hasOwn(n, "fill") && (t.textFill = n.fill), hasOwn(n, "stroke") && (t.textStroke = n.fill), hasOwn(n, "lineWidth") && (t.textStrokeWidth = n.lineWidth), hasOwn(n, "font") && (t.font = n.font), hasOwn(n, "fontStyle") && (t.fontStyle = n.fontStyle), hasOwn(n, "fontWeight") && (t.fontWeight = n.fontWeight), hasOwn(n, "fontSize") && (t.fontSize = n.fontSize), hasOwn(n, "fontFamily") && (t.fontFamily = n.fontFamily), hasOwn(n, "align") && (t.textAlign = n.align), hasOwn(n, "verticalAlign") && (t.textVerticalAlign = n.verticalAlign), hasOwn(n, "lineHeight") && (t.textLineHeight = n.lineHeight), hasOwn(n, "width") && (t.textWidth = n.width), hasOwn(n, "height") && (t.textHeight = n.height), hasOwn(n, "backgroundColor") && (t.textBackgroundColor = n.backgroundColor), hasOwn(n, "padding") && (t.textPadding = n.padding), hasOwn(n, "borderColor") && (t.textBorderColor = n.borderColor), hasOwn(n, "borderWidth") && (t.textBorderWidth = n.borderWidth), hasOwn(n, "borderRadius") && (t.textBorderRadius = n.borderRadius), hasOwn(n, "shadowColor") && (t.textBoxShadowColor = n.shadowColor), hasOwn(n, "shadowBlur") && (t.textBoxShadowBlur = n.shadowBlur), hasOwn(n, "shadowOffsetX") && (t.textBoxShadowOffsetX = n.shadowOffsetX), hasOwn(n, "shadowOffsetY") && (t.textBoxShadowOffsetY = n.shadowOffsetY), hasOwn(n, "textShadowColor") && (t.textShadowColor = n.textShadowColor), hasOwn(n, "textShadowBlur") && (t.textShadowBlur = n.textShadowBlur), hasOwn(n, "textShadowOffsetX") && (t.textShadowOffsetX = n.textShadowOffsetX), hasOwn(n, "textShadowOffsetY") && (t.textShadowOffsetY = n.textShadowOffsetY));
}
function warnDeprecated(t, n) {
	if (process$1.env.NODE_ENV !== "production") {
		var r = t + "^_^" + n;
		deprecatedLogs[r] || (console.warn("[ECharts] DEPRECATED: \"" + t + "\" has been deprecated. " + n), deprecatedLogs[r] = !0);
	}
}
init_dist$2();
var LEGACY_TRANSFORM_PROPS_MAP = {
	position: ["x", "y"],
	scale: ["scaleX", "scaleY"],
	origin: ["originX", "originY"]
}, LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP), TRANSFORM_PROPS_MAP = reduce(TRANSFORMABLE_PROPS, function(t, n) {
	return t[n] = 1, t;
}, {}), transformPropNamesStr = TRANSFORMABLE_PROPS.join(", "), ELEMENT_ANIMATABLE_PROPS = [
	"",
	"style",
	"shape",
	"extra"
], transitionInnerStore = makeInner();
function getElementAnimationConfig(t, n, r, a, o) {
	var s = t + "Animation", c = getAnimationConfig(t, a, o) || {}, l = transitionInnerStore(n).userDuring;
	return c.duration > 0 && (c.during = l ? bind(duringCall, {
		el: n,
		userDuring: l
	}) : null, c.setToFinal = !0, c.scope = t), extend(c, r[s]), c;
}
function applyUpdateTransition(t, n, r, a) {
	a ||= {};
	var o = a.dataIndex, s = a.isInit, c = a.clearStyle, l = r.isAnimationEnabled(), u = transitionInnerStore(t), d = n.style;
	u.userDuring = n.during;
	var f = {}, p = {};
	if (prepareTransformAllPropsFinal(t, n, p), prepareShapeOrExtraAllPropsFinal("shape", n, p), prepareShapeOrExtraAllPropsFinal("extra", n, p), !s && l && (prepareTransformTransitionFrom(t, n, f), prepareShapeOrExtraTransitionFrom("shape", t, n, f), prepareShapeOrExtraTransitionFrom("extra", t, n, f), prepareStyleTransitionFrom(t, n, d, f)), p.style = d, applyPropsDirectly(t, p, c), applyMiscProps(t, n), l) if (s) {
		var h = {};
		each(ELEMENT_ANIMATABLE_PROPS, function(t) {
			var r = t ? n[t] : n;
			r && r.enterFrom && (t && (h[t] = h[t] || {}), extend(t ? h[t] : h, r.enterFrom));
		});
		var g = getElementAnimationConfig("enter", t, n, r, o);
		g.duration > 0 && t.animateFrom(h, g);
	} else applyPropsTransition(t, n, o || 0, r, f);
	updateLeaveTo(t, n), d ? t.dirty() : t.markRedraw();
}
function updateLeaveTo(t, n) {
	for (var r = transitionInnerStore(t).leaveToProps, a = 0; a < ELEMENT_ANIMATABLE_PROPS.length; a++) {
		var o = ELEMENT_ANIMATABLE_PROPS[a], s = o ? n[o] : n;
		s && s.leaveTo && (r ||= transitionInnerStore(t).leaveToProps = {}, o && (r[o] = r[o] || {}), extend(o ? r[o] : r, s.leaveTo));
	}
}
function applyLeaveTransition(t, n, r, a) {
	if (t) {
		var o = t.parent, s = transitionInnerStore(t).leaveToProps;
		if (s) {
			var c = getElementAnimationConfig("update", t, n, r, 0);
			c.done = function() {
				o.remove(t), a && a();
			}, t.animateTo(s, c);
		} else o.remove(t), a && a();
	}
}
function isTransitionAll(t) {
	return t === "all";
}
function applyPropsDirectly(t, n, r) {
	var a = n.style;
	if (!t.isGroup && a) {
		if (r) {
			t.useStyle({});
			for (var o = t.animators, s = 0; s < o.length; s++) {
				var c = o[s];
				c.targetName === "style" && c.changeTarget(t.style);
			}
		}
		t.setStyle(a);
	}
	n && (n.style = null, n && t.attr(n), n.style = a);
}
function applyPropsTransition(t, n, r, a, o) {
	if (o) {
		var s = getElementAnimationConfig("update", t, n, a, r);
		s.duration > 0 && t.animateFrom(o, s);
	}
}
function applyMiscProps(t, n) {
	hasOwn(n, "silent") && (t.silent = n.silent), hasOwn(n, "ignore") && (t.ignore = n.ignore), t instanceof Displayable_default && hasOwn(n, "invisible") && (t.invisible = n.invisible), t instanceof Path_default && hasOwn(n, "autoBatch") && (t.autoBatch = n.autoBatch);
}
var tmpDuringScope = {}, transitionDuringAPI = {
	setTransform: function(t, n) {
		return process$1.env.NODE_ENV !== "production" && assert(hasOwn(TRANSFORM_PROPS_MAP, t), "Only " + transformPropNamesStr + " available in `setTransform`."), tmpDuringScope.el[t] = n, this;
	},
	getTransform: function(t) {
		return process$1.env.NODE_ENV !== "production" && assert(hasOwn(TRANSFORM_PROPS_MAP, t), "Only " + transformPropNamesStr + " available in `getTransform`."), tmpDuringScope.el[t];
	},
	setShape: function(t, n) {
		process$1.env.NODE_ENV !== "production" && assertNotReserved(t);
		var r = tmpDuringScope.el, a = r.shape ||= {};
		return a[t] = n, r.dirtyShape && r.dirtyShape(), this;
	},
	getShape: function(t) {
		process$1.env.NODE_ENV !== "production" && assertNotReserved(t);
		var n = tmpDuringScope.el.shape;
		if (n) return n[t];
	},
	setStyle: function(t, n) {
		process$1.env.NODE_ENV !== "production" && assertNotReserved(t);
		var r = tmpDuringScope.el, a = r.style;
		return a && (process$1.env.NODE_ENV !== "production" && eqNaN(n) && warn("style." + t + " must not be assigned with NaN."), a[t] = n, r.dirtyStyle && r.dirtyStyle()), this;
	},
	getStyle: function(t) {
		process$1.env.NODE_ENV !== "production" && assertNotReserved(t);
		var n = tmpDuringScope.el.style;
		if (n) return n[t];
	},
	setExtra: function(t, n) {
		process$1.env.NODE_ENV !== "production" && assertNotReserved(t);
		var r = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});
		return r[t] = n, this;
	},
	getExtra: function(t) {
		process$1.env.NODE_ENV !== "production" && assertNotReserved(t);
		var n = tmpDuringScope.el.extra;
		if (n) return n[t];
	}
};
function assertNotReserved(t) {
	if (process$1.env.NODE_ENV !== "production" && (t === "transition" || t === "enterFrom" || t === "leaveTo")) throw Error("key must not be \"" + t + "\"");
}
function duringCall() {
	var t = this, n = t.el;
	if (n) {
		var r = transitionInnerStore(n).userDuring, a = t.userDuring;
		if (r !== a) {
			t.el = t.userDuring = null;
			return;
		}
		tmpDuringScope.el = n, a(transitionDuringAPI);
	}
}
function prepareShapeOrExtraTransitionFrom(t, n, r, a) {
	var o = r[t];
	if (o) {
		var s = n[t], c;
		if (s) {
			var l = r.transition, u = o.transition;
			if (u) if (!c && (c = a[t] = {}), isTransitionAll(u)) extend(c, s);
			else for (var d = normalizeToArray(u), f = 0; f < d.length; f++) {
				var p = d[f], h = s[p];
				c[p] = h;
			}
			else if (isTransitionAll(l) || indexOf(l, t) >= 0) {
				!c && (c = a[t] = {});
				for (var g = keys(s), f = 0; f < g.length; f++) {
					var p = g[f], h = s[p];
					isNonStyleTransitionEnabled(o[p], h) && (c[p] = h);
				}
			}
		}
	}
}
function prepareShapeOrExtraAllPropsFinal(t, n, r) {
	var a = n[t];
	if (a) for (var o = r[t] = {}, s = keys(a), c = 0; c < s.length; c++) {
		var l = s[c];
		o[l] = cloneValue(a[l]);
	}
}
function prepareTransformTransitionFrom(t, n, r) {
	for (var a = n.transition, o = isTransitionAll(a) ? TRANSFORMABLE_PROPS : normalizeToArray(a || []), c = 0; c < o.length; c++) {
		var l = o[c];
		if (!(l === "style" || l === "shape" || l === "extra")) {
			var u = t[l];
			process$1.env.NODE_ENV !== "production" && checkTransformPropRefer(l, "el.transition"), r[l] = u;
		}
	}
}
function prepareTransformAllPropsFinal(t, n, r) {
	for (var a = 0; a < LEGACY_TRANSFORM_PROPS.length; a++) {
		var o = LEGACY_TRANSFORM_PROPS[a], s = LEGACY_TRANSFORM_PROPS_MAP[o], c = n[o];
		c && (r[s[0]] = c[0], r[s[1]] = c[1]);
	}
	for (var a = 0; a < TRANSFORMABLE_PROPS.length; a++) {
		var l = TRANSFORMABLE_PROPS[a];
		n[l] != null && (r[l] = n[l]);
	}
}
function prepareStyleTransitionFrom(t, n, r, a) {
	if (r) {
		var o = t.style, s;
		if (o) {
			var c = r.transition, l = n.transition;
			if (c && !isTransitionAll(c)) {
				var u = normalizeToArray(c);
				!s && (s = a.style = {});
				for (var d = 0; d < u.length; d++) {
					var f = u[d], p = o[f];
					s[f] = p;
				}
			} else if (t.getAnimationStyleProps && (isTransitionAll(l) || isTransitionAll(c) || indexOf(l, "style") >= 0)) {
				var h = t.getAnimationStyleProps(), g = h ? h.style : null;
				if (g) {
					!s && (s = a.style = {});
					for (var _ = keys(r), d = 0; d < _.length; d++) {
						var f = _[d];
						if (g[f]) {
							var p = o[f];
							s[f] = p;
						}
					}
				}
			}
		}
	}
}
function isNonStyleTransitionEnabled(t, n) {
	return isArrayLike(t) ? t !== n : t != null && isFinite(t);
}
var checkTransformPropRefer;
process$1.env.NODE_ENV !== "production" && (checkTransformPropRefer = function(t, n) {
	hasOwn(TRANSFORM_PROPS_MAP, t) || warn("Prop `" + t + "` is not a permitted in `" + n + "`. Only `" + keys(TRANSFORM_PROPS_MAP).join("`, `") + "` are permitted.");
}), init_dist$2();
var getStateToRestore = makeInner(), KEYFRAME_EXCLUDE_KEYS = [
	"percent",
	"easing",
	"shape",
	"style",
	"extra"
];
function stopPreviousKeyframeAnimationAndRestore(t) {
	t.stopAnimation("keyframe"), t.attr(getStateToRestore(t));
}
function applyKeyframeAnimation(t, n, r) {
	if (!(!r.isAnimationEnabled() || !n)) {
		if (isArray(n)) {
			each(n, function(n) {
				applyKeyframeAnimation(t, n, r);
			});
			return;
		}
		var a = n.keyframes, o = n.duration;
		if (r && o == null) {
			var c = getAnimationConfig("enter", r, 0);
			o = c && c.duration;
		}
		if (!(!a || !o)) {
			var l = getStateToRestore(t);
			each(ELEMENT_ANIMATABLE_PROPS, function(r) {
				if (!(r && !t[r])) {
					var c, u = !1;
					a.sort(function(t, n) {
						return t.percent - n.percent;
					}), each(a, function(a) {
						var d = t.animators, f = r ? a[r] : a;
						if (process$1.env.NODE_ENV !== "production" && a.percent >= 1 && (u = !0), f) {
							var p = keys(f);
							if (r || (p = filter(p, function(t) {
								return indexOf(KEYFRAME_EXCLUDE_KEYS, t) < 0;
							})), p.length) {
								c || (c = t.animate(r, n.loop, !0), c.scope = "keyframe");
								for (var h = 0; h < d.length; h++) d[h] !== c && d[h].targetName === c.targetName && d[h].stopTracks(p);
								r && (l[r] = l[r] || {});
								var g = r ? l[r] : l;
								each(p, function(n) {
									g[n] = ((r ? t[r] : t) || {})[n];
								}), c.whenWithKeys(o * a.percent, f, p, a.easing);
							}
						}
					}), c && (process$1.env.NODE_ENV !== "production" && (u || warn("End frame with percent: 1 is missing in the keyframeAnimation.", !0)), c.delay(n.delay || 0).duration(o).start(n.easing));
				}
			});
		}
	}
}
init_dist$2();
var EMPHASIS = "emphasis", NORMAL = "normal", BLUR = "blur", SELECT = "select", STATES = [
	NORMAL,
	EMPHASIS,
	BLUR,
	SELECT
], PATH_ITEM_STYLE = {
	normal: ["itemStyle"],
	emphasis: [EMPHASIS, "itemStyle"],
	blur: [BLUR, "itemStyle"],
	select: [SELECT, "itemStyle"]
}, PATH_LABEL = {
	normal: ["label"],
	emphasis: [EMPHASIS, "label"],
	blur: [BLUR, "label"],
	select: [SELECT, "label"]
}, DEFAULT_TRANSITION = ["x", "y"], GROUP_DIFF_PREFIX = "e\0\0", attachedTxInfoTmp = {
	normal: {},
	emphasis: {},
	blur: {},
	select: {}
}, prepareCustoms = {
	cartesian2d: cartesianPrepareCustom,
	geo: geoPrepareCustom,
	single: singlePrepareCustom,
	polar: polarPrepareCustom,
	calendar: calendarPrepareCustom
};
function isPath(t) {
	return t instanceof Path_default;
}
function isDisplayable(t) {
	return t instanceof Displayable_default;
}
function copyElement(t, n) {
	n.copyTransform(t), isDisplayable(n) && isDisplayable(t) && (n.setStyle(t.style), n.z = t.z, n.z2 = t.z2, n.zlevel = t.zlevel, n.invisible = t.invisible, n.ignore = t.ignore, isPath(n) && isPath(t) && n.setShape(t.shape));
}
var CustomView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r, a) {
		this._progressiveEls = null;
		var o = this._data, s = t.getData(), c = this.group, l = makeRenderItem(t, s, n, r);
		o || c.removeAll(), s.diff(o).add(function(n) {
			createOrUpdateItem(r, null, n, l(n, a), t, c, s);
		}).remove(function(n) {
			var r = o.getItemGraphicEl(n);
			r && applyLeaveTransition(r, customInnerStore(r).option, t);
		}).update(function(n, u) {
			createOrUpdateItem(r, o.getItemGraphicEl(u), n, l(n, a), t, c, s);
		}).execute();
		var u = t.get("clip", !0) ? createClipPath(t.coordinateSystem, !1, t) : null;
		u ? c.setClipPath(u) : c.removeClipPath(), this._data = s;
	}, n.prototype.incrementalPrepareRender = function(t, n, r) {
		this.group.removeAll(), this._data = null;
	}, n.prototype.incrementalRender = function(t, n, r, a, o) {
		var s = n.getData(), c = makeRenderItem(n, s, r, a), l = this._progressiveEls = [];
		function u(t) {
			t.isGroup || (t.incremental = !0, t.ensureState("emphasis").hoverLayer = !0);
		}
		for (var d = t.start; d < t.end; d++) {
			var f = createOrUpdateItem(null, null, d, c(d, o), n, this.group, s);
			f && (f.traverse(u), l.push(f));
		}
	}, n.prototype.eachRendered = function(t) {
		traverseElements(this._progressiveEls || this.group, t);
	}, n.prototype.filterForExposedEvent = function(t, n, r, a) {
		var o = n.element;
		if (o == null || r.name === o) return !0;
		for (; (r = r.__hostTarget || r.parent) && r !== this.group;) if (r.name === o) return !0;
		return !1;
	}, n.type = "custom", n;
}(Chart_default);
function createEl$1(t) {
	var n = t.type, r;
	if (n === "path") {
		var a = t.shape, o = a.width != null && a.height != null ? {
			x: a.x || 0,
			y: a.y || 0,
			width: a.width,
			height: a.height
		} : null, c = getPathData(a);
		r = makePath(c, null, o, a.layout || "center"), customInnerStore(r).customPathData = c;
	} else if (n === "image") r = new Image_default({}), customInnerStore(r).customImagePath = t.style.image;
	else if (n === "text") r = new Text_default({});
	else if (n === "group") r = new Group_default();
	else if (n === "compoundPath") throw Error("\"compoundPath\" is not supported yet.");
	else {
		var l = getShapeClass(n);
		if (!l) {
			var u = "";
			process$1.env.NODE_ENV !== "production" && (u = "graphic type \"" + n + "\" can not be found."), throwError(u);
		}
		r = new l();
	}
	return customInnerStore(r).customGraphicType = n, r.name = t.name, r.z2EmphasisLift = 1, r.z2SelectLift = 1, r;
}
function updateElNormal(t, n, r, a, o, s, c) {
	stopPreviousKeyframeAnimationAndRestore(n);
	var l = o && o.normal.cfg;
	l && n.setTextConfig(l), a && a.transition == null && (a.transition = DEFAULT_TRANSITION);
	var u = a && a.style;
	if (u) {
		if (n.type === "text") {
			var d = u;
			hasOwn(d, "textFill") && (d.fill = d.textFill), hasOwn(d, "textStroke") && (d.stroke = d.textStroke);
		}
		var f = void 0, p = isPath(n) ? u.decal : null;
		t && p && (p.dirty = !0, f = createOrUpdatePatternFromDecal(p, t)), u.__decalPattern = f;
	}
	if (isDisplayable(n) && u) {
		var f = u.__decalPattern;
		f && (u.decal = f);
	}
	applyUpdateTransition(n, a, s, {
		dataIndex: r,
		isInit: c,
		clearStyle: !0
	}), applyKeyframeAnimation(n, a.keyframeAnimation, s);
}
function updateElOnState(t, n, r, a, o) {
	var s = n.isGroup ? null : n, c = o && o[t].cfg;
	if (s) {
		var l = s.ensureState(t);
		if (a === !1) {
			var u = s.getState(t);
			u && (u.style = null);
		} else l.style = a || null;
		c && (l.textConfig = c), setDefaultStateProxy(s);
	}
}
function updateZ(t, n, r) {
	if (!t.isGroup) {
		var a = t, o = r.currentZ, s = r.currentZLevel;
		a.z = o, a.zlevel = s;
		var c = n.z2;
		c != null && (a.z2 = c || 0);
		for (var l = 0; l < STATES.length; l++) updateZForEachState(a, n, STATES[l]);
	}
}
function updateZForEachState(t, n, r) {
	var a = r === NORMAL, o = a ? n : retrieveStateOption(n, r), s = o ? o.z2 : null, c;
	s != null && (c = a ? t : t.ensureState(r), c.z2 = s || 0);
}
function makeRenderItem(t, n, r, a) {
	var o = t.get("renderItem"), c = t.coordinateSystem, l = {};
	c && (process$1.env.NODE_ENV !== "production" && (assert(o, "series.render is required."), assert(c.prepareCustoms || prepareCustoms[c.type], "This coordSys does not support custom series.")), l = c.prepareCustoms ? c.prepareCustoms(c) : prepareCustoms[c.type](c));
	for (var u = defaults({
		getWidth: a.getWidth,
		getHeight: a.getHeight,
		getZr: a.getZr,
		getDevicePixelRatio: a.getDevicePixelRatio,
		value: w,
		style: E,
		ordinalRawValue: T,
		styleEmphasis: D,
		visual: j,
		barLayout: M,
		currentSeriesIndices: N,
		font: P
	}, l.api || {}), d = {
		context: {},
		seriesId: t.id,
		seriesName: t.name,
		seriesIndex: t.seriesIndex,
		coordSys: l.coordSys,
		dataInsideLength: n.count(),
		encode: wrapEncodeDef(t.getData())
	}, f, p, h = {}, g = {}, _ = {}, v = {}, y = 0; y < STATES.length; y++) {
		var b = STATES[y];
		_[b] = t.getModel(PATH_ITEM_STYLE[b]), v[b] = t.getModel(PATH_LABEL[b]);
	}
	function x(t) {
		return t === f ? p ||= n.getItemModel(t) : n.getItemModel(t);
	}
	function S(t, r) {
		return n.hasItemOption ? t === f ? h[r] || (h[r] = x(t).getModel(PATH_ITEM_STYLE[r])) : x(t).getModel(PATH_ITEM_STYLE[r]) : _[r];
	}
	function C(t, r) {
		return n.hasItemOption ? t === f ? g[r] || (g[r] = x(t).getModel(PATH_LABEL[r])) : x(t).getModel(PATH_LABEL[r]) : v[r];
	}
	return function(t, r) {
		return f = t, p = null, h = {}, g = {}, o && o(defaults({
			dataIndexInside: t,
			dataIndex: n.getRawIndex(t),
			actionType: r ? r.type : null
		}, d), u);
	};
	function w(t, r) {
		return r ??= f, n.getStore().get(n.getDimensionIndex(t || 0), r);
	}
	function T(t, r) {
		r ??= f, t ||= 0;
		var a = n.getDimensionInfo(t);
		if (!a) {
			var o = n.getDimensionIndex(t);
			return o >= 0 ? n.getStore().get(o, r) : void 0;
		}
		var s = n.get(a.name, r), c = a && a.ordinalMeta;
		return c ? c.categories[s] : s;
	}
	function E(r, a) {
		process$1.env.NODE_ENV !== "production" && warnDeprecated("api.style", "Please write literal style directly instead."), a ??= f;
		var o = n.getItemVisual(a, "style"), c = o && o.fill, l = o && o.opacity, u = S(a, NORMAL).getItemStyle();
		c != null && (u.fill = c), l != null && (u.opacity = l);
		var d = { inheritColor: isString(c) ? c : "#000" }, p = C(a, NORMAL), h = createTextStyle(p, null, d, !1, !0);
		h.text = p.getShallow("show") ? retrieve2(t.getFormattedLabel(a, NORMAL), getDefaultLabel(n, a)) : null;
		var g = createTextConfig(p, d, !1);
		return A(r, u), u = convertToEC4StyleForCustomSerise(u, h, g), r && O(u, r), u.legacy = !0, u;
	}
	function D(r, a) {
		process$1.env.NODE_ENV !== "production" && warnDeprecated("api.styleEmphasis", "Please write literal style directly instead."), a ??= f;
		var o = S(a, EMPHASIS).getItemStyle(), c = C(a, EMPHASIS), l = createTextStyle(c, null, null, !0, !0);
		l.text = c.getShallow("show") ? retrieve3(t.getFormattedLabel(a, EMPHASIS), t.getFormattedLabel(a, NORMAL), getDefaultLabel(n, a)) : null;
		var u = createTextConfig(c, null, !0);
		return A(r, o), o = convertToEC4StyleForCustomSerise(o, l, u), r && O(o, r), o.legacy = !0, o;
	}
	function O(t, n) {
		for (var r in n) hasOwn(n, r) && (t[r] = n[r]);
	}
	function A(t, n) {
		t && (t.textFill && (n.textFill = t.textFill), t.textPosition && (n.textPosition = t.textPosition));
	}
	function j(t, r) {
		if (r ??= f, hasOwn(STYLE_VISUAL_TYPE, t)) {
			var a = n.getItemVisual(r, "style");
			return a ? a[STYLE_VISUAL_TYPE[t]] : null;
		}
		if (hasOwn(NON_STYLE_VISUAL_PROPS, t)) return n.getItemVisual(r, t);
	}
	function M(t) {
		if (c.type === "cartesian2d") return getLayoutOnAxis(defaults({ axis: c.getBaseAxis() }, t));
	}
	function N() {
		return r.getCurrentSeriesIndices();
	}
	function P(t) {
		return getFont(t, r);
	}
}
function wrapEncodeDef(t) {
	var n = {};
	return each(t.dimensions, function(r) {
		var a = t.getDimensionInfo(r);
		if (!a.isExtraCoord) {
			var o = a.coordDim, s = n[o] = n[o] || [];
			s[a.coordDimIndex] = t.getDimensionIndex(r);
		}
	}), n;
}
function createOrUpdateItem(t, n, r, a, o, s, c) {
	if (!a) {
		s.remove(n);
		return;
	}
	var l = doCreateOrUpdateEl(t, n, r, a, o, s);
	return l && c.setItemGraphicEl(r, l), l && toggleHoverEmphasis(l, a.focus, a.blurScope, a.emphasisDisabled), l;
}
function doCreateOrUpdateEl(t, n, r, a, o, c) {
	process$1.env.NODE_ENV !== "production" && assert(a, "should not have an null/undefined element setting");
	var l = -1, u = n;
	n && doesElNeedRecreate(n, a, o) && (l = indexOf(c.childrenRef(), n), n = null);
	var d = !n, f = n;
	f ? f.clearStates() : (f = createEl$1(a), u && copyElement(u, f)), a.morph === !1 ? f.disableMorphing = !0 : f.disableMorphing &&= !1, attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null, attachedTxInfoTmp.isLegacy = !1, doCreateOrUpdateAttachedTx(f, r, a, o, d, attachedTxInfoTmp), doCreateOrUpdateClipPath(f, r, a, o, d), updateElNormal(t, f, r, a, attachedTxInfoTmp, o, d), hasOwn(a, "info") && (customInnerStore(f).info = a.info);
	for (var p = 0; p < STATES.length; p++) {
		var h = STATES[p];
		if (h !== NORMAL) {
			var g = retrieveStateOption(a, h), _ = retrieveStyleOptionOnState(a, g, h);
			updateElOnState(h, f, g, _, attachedTxInfoTmp);
		}
	}
	return updateZ(f, a, o), a.type === "group" && mergeChildren(t, f, r, a, o), l >= 0 ? c.replaceAt(f, l) : c.add(f), f;
}
function doesElNeedRecreate(t, n, r) {
	var a = customInnerStore(t), o = n.type, s = n.shape, c = n.style;
	return r.isUniversalTransitionEnabled() || o != null && o !== a.customGraphicType || o === "path" && hasOwnPathData(s) && getPathData(s) !== a.customPathData || o === "image" && hasOwn(c, "image") && c.image !== a.customImagePath;
}
function doCreateOrUpdateClipPath(t, n, r, a, o) {
	var c = r.clipPath;
	if (c === !1) t && t.getClipPath() && t.removeClipPath();
	else if (c) {
		var l = t.getClipPath();
		l && doesElNeedRecreate(l, c, a) && (l = null), l || (l = createEl$1(c), process$1.env.NODE_ENV !== "production" && assert(isPath(l), "Only any type of `path` can be used in `clipPath`, rather than " + l.type + "."), t.setClipPath(l)), updateElNormal(null, l, n, c, null, a, o);
	}
}
function doCreateOrUpdateAttachedTx(t, n, r, a, o, s) {
	if (!t.isGroup) {
		processTxInfo(r, null, s), processTxInfo(r, EMPHASIS, s);
		var c = s.normal.conOpt, l = s.emphasis.conOpt, u = s.blur.conOpt, d = s.select.conOpt;
		if (c != null || l != null || d != null || u != null) {
			var f = t.getTextContent();
			if (c === !1) f && t.removeTextContent();
			else {
				c = s.normal.conOpt = c || { type: "text" }, f ? f.clearStates() : (f = createEl$1(c), t.setTextContent(f)), updateElNormal(null, f, n, c, null, a, o);
				for (var p = c && c.style, h = 0; h < STATES.length; h++) {
					var g = STATES[h];
					if (g !== NORMAL) {
						var _ = s[g].conOpt;
						updateElOnState(g, f, _, retrieveStyleOptionOnState(c, _, g), null);
					}
				}
				p ? f.dirty() : f.markRedraw();
			}
		}
	}
}
function processTxInfo(t, n, r) {
	var a = n ? retrieveStateOption(t, n) : t, o = n ? retrieveStyleOptionOnState(t, a, EMPHASIS) : t.style, c = t.type, l = a ? a.textConfig : null, u = t.textContent, d = u ? n ? retrieveStateOption(u, n) : u : null;
	if (o && (r.isLegacy || isEC4CompatibleStyle(o, c, !!l, !!d))) {
		r.isLegacy = !0;
		var f = convertFromEC4CompatibleStyle(o, c, !n);
		!l && f.textConfig && (l = f.textConfig), !d && f.textContent && (d = f.textContent);
	}
	if (!n && d) {
		var p = d;
		!p.type && (p.type = "text"), process$1.env.NODE_ENV !== "production" && assert(p.type === "text", "textContent.type must be \"text\"");
	}
	var h = n ? r[n] : r.normal;
	h.cfg = l, h.conOpt = d;
}
function retrieveStateOption(t, n) {
	return n ? t ? t[n] : null : t;
}
function retrieveStyleOptionOnState(t, n, r) {
	var a = n && n.style;
	return a == null && r === EMPHASIS && t && (a = t.styleEmphasis), a;
}
function mergeChildren(t, n, r, a, o) {
	var c = a.children, l = c ? c.length : 0, u = a.$mergeChildren, d = u === "byName" || a.diffChildrenByName, f = u === !1;
	if (!(!l && !d && !f)) {
		if (d) {
			diffGroupChildren({
				api: t,
				oldChildren: n.children() || [],
				newChildren: c || [],
				dataIndex: r,
				seriesModel: o,
				group: n
			});
			return;
		}
		f && n.removeAll();
		for (var p = 0; p < l; p++) {
			var h = c[p], g = n.childAt(p);
			h ? (h.ignore ??= !1, doCreateOrUpdateEl(t, g, r, h, o, n)) : (process$1.env.NODE_ENV !== "production" && assert(g, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before."), g.ignore = !0);
		}
		for (var _ = n.childCount() - 1; _ >= p; _--) removeChildFromGroup(n, n.childAt(_), o);
	}
}
function removeChildFromGroup(t, n, r) {
	n && applyLeaveTransition(n, customInnerStore(t).option, r);
}
function diffGroupChildren(t) {
	new DataDiffer_default(t.oldChildren, t.newChildren, getKey, getKey, t).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
}
function getKey(t, n) {
	return (t && t.name) ?? GROUP_DIFF_PREFIX + n;
}
function processAddUpdate(t, n) {
	var r = this.context, a = t == null ? null : r.newChildren[t], o = n == null ? null : r.oldChildren[n];
	doCreateOrUpdateEl(r.api, o, r.dataIndex, a, r.seriesModel, r.group);
}
function processRemove(t) {
	var n = this.context, r = n.oldChildren[t];
	r && applyLeaveTransition(r, customInnerStore(r).option, n.seriesModel);
}
function getPathData(t) {
	return t && (t.pathData || t.d);
}
function hasOwnPathData(t) {
	return t && (hasOwn(t, "pathData") || hasOwn(t, "d"));
}
function install$23(t) {
	t.registerChartView(CustomView_default), t.registerSeriesModel(CustomSeries_default);
}
var inner$11 = makeInner(), clone$2 = clone$1, bind$1 = bind, BaseAxisPointer = function() {
	function t() {
		this._dragging = !1, this.animationThreshold = 15;
	}
	return t.prototype.render = function(t, n, r, a) {
		var o = n.get("value"), s = n.get("status");
		if (this._axisModel = t, this._axisPointerModel = n, this._api = r, !(!a && this._lastValue === o && this._lastStatus === s)) {
			this._lastValue = o, this._lastStatus = s;
			var c = this._group, l = this._handle;
			if (!s || s === "hide") {
				c && c.hide(), l && l.hide();
				return;
			}
			c && c.show(), l && l.show();
			var u = {};
			this.makeElOption(u, o, t, n, r);
			var d = u.graphicKey;
			d !== this._lastGraphicKey && this.clear(r), this._lastGraphicKey = d;
			var f = this._moveAnimation = this.determineAnimation(t, n);
			if (!c) c = this._group = new Group_default(), this.createPointerEl(c, u, t, n), this.createLabelEl(c, u, t, n), r.getZr().add(c);
			else {
				var p = curry(updateProps$1, n, f);
				this.updatePointerEl(c, u, p), this.updateLabelEl(c, u, p, n);
			}
			updateMandatoryProps(c, n, !0), this._renderHandle(o);
		}
	}, t.prototype.remove = function(t) {
		this.clear(t);
	}, t.prototype.dispose = function(t) {
		this.clear(t);
	}, t.prototype.determineAnimation = function(t, n) {
		var r = n.get("animation"), a = t.axis, o = a.type === "category", s = n.get("snap");
		if (!s && !o) return !1;
		if (r === "auto" || r == null) {
			var c = this.animationThreshold;
			if (o && a.getBandWidth() > c) return !0;
			if (s) {
				var l = getAxisInfo$1(t).seriesDataCount, u = a.getExtent();
				return Math.abs(u[0] - u[1]) / l > c;
			}
			return !1;
		}
		return r === !0;
	}, t.prototype.makeElOption = function(t, n, r, a, o) {}, t.prototype.createPointerEl = function(t, n, r, a) {
		var o = n.pointer;
		if (o) {
			var s = inner$11(t).pointerEl = new graphic_exports$1[o.type](clone$2(n.pointer));
			t.add(s);
		}
	}, t.prototype.createLabelEl = function(t, n, r, a) {
		if (n.label) {
			var o = inner$11(t).labelEl = new Text_default(clone$2(n.label));
			t.add(o), updateLabelShowHide(o, a);
		}
	}, t.prototype.updatePointerEl = function(t, n, r) {
		var a = inner$11(t).pointerEl;
		a && n.pointer && (a.setStyle(n.pointer.style), r(a, { shape: n.pointer.shape }));
	}, t.prototype.updateLabelEl = function(t, n, r, a) {
		var o = inner$11(t).labelEl;
		o && (o.setStyle(n.label.style), r(o, {
			x: n.label.x,
			y: n.label.y
		}), updateLabelShowHide(o, a));
	}, t.prototype._renderHandle = function(t) {
		if (!(this._dragging || !this.updateHandleTransform)) {
			var n = this._axisPointerModel, r = this._api.getZr(), a = this._handle, o = n.getModel("handle"), s = n.get("status");
			if (!o.get("show") || !s || s === "hide") {
				a && r.remove(a), this._handle = null;
				return;
			}
			var c;
			this._handle || (c = !0, a = this._handle = createIcon(o.get("icon"), {
				cursor: "move",
				draggable: !0,
				onmousemove: function(t) {
					stop(t.event);
				},
				onmousedown: bind$1(this._onHandleDragMove, this, 0, 0),
				drift: bind$1(this._onHandleDragMove, this),
				ondragend: bind$1(this._onHandleDragEnd, this)
			}), r.add(a)), updateMandatoryProps(a, n, !1), a.setStyle(o.getItemStyle(null, [
				"color",
				"borderColor",
				"borderWidth",
				"opacity",
				"shadowColor",
				"shadowBlur",
				"shadowOffsetX",
				"shadowOffsetY"
			]));
			var l = o.get("size");
			isArray(l) || (l = [l, l]), a.scaleX = l[0] / 2, a.scaleY = l[1] / 2, createOrUpdate(this, "_doDispatchAxisPointer", o.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, c);
		}
	}, t.prototype._moveHandleToValue = function(t, n) {
		updateProps$1(this._axisPointerModel, !n && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
	}, t.prototype._onHandleDragMove = function(t, n) {
		var r = this._handle;
		if (r) {
			this._dragging = !0;
			var a = this.updateHandleTransform(getHandleTransProps(r), [t, n], this._axisModel, this._axisPointerModel);
			this._payloadInfo = a, r.stopAnimation(), r.attr(getHandleTransProps(a)), inner$11(r).lastProp = null, this._doDispatchAxisPointer();
		}
	}, t.prototype._doDispatchAxisPointer = function() {
		if (this._handle) {
			var t = this._payloadInfo, n = this._axisModel;
			this._api.dispatchAction({
				type: "updateAxisPointer",
				x: t.cursorPoint[0],
				y: t.cursorPoint[1],
				tooltipOption: t.tooltipOption,
				axesInfo: [{
					axisDim: n.axis.dim,
					axisIndex: n.componentIndex
				}]
			});
		}
	}, t.prototype._onHandleDragEnd = function() {
		if (this._dragging = !1, this._handle) {
			var t = this._axisPointerModel.get("value");
			this._moveHandleToValue(t), this._api.dispatchAction({ type: "hideTip" });
		}
	}, t.prototype.clear = function(t) {
		this._lastValue = null, this._lastStatus = null;
		var n = t.getZr(), r = this._group, a = this._handle;
		n && r && (this._lastGraphicKey = null, r && n.remove(r), a && n.remove(a), this._group = null, this._handle = null, this._payloadInfo = null), clear(this, "_doDispatchAxisPointer");
	}, t.prototype.doClear = function() {}, t.prototype.buildLabel = function(t, n, r) {
		return r ||= 0, {
			x: t[r],
			y: t[1 - r],
			width: n[r],
			height: n[1 - r]
		};
	}, t;
}();
function updateProps$1(t, n, r, a) {
	propsEqual(inner$11(r).lastProp, a) || (inner$11(r).lastProp = a, n ? updateProps(r, a, t) : (r.stopAnimation(), r.attr(a)));
}
function propsEqual(t, n) {
	if (isObject(t) && isObject(n)) {
		var r = !0;
		return each(n, function(n, a) {
			r &&= propsEqual(t[a], n);
		}), !!r;
	} else return t === n;
}
function updateLabelShowHide(t, n) {
	t[n.get(["label", "show"]) ? "show" : "hide"]();
}
function getHandleTransProps(t) {
	return {
		x: t.x || 0,
		y: t.y || 0,
		rotation: t.rotation || 0
	};
}
function updateMandatoryProps(t, n, r) {
	var a = n.get("z"), o = n.get("zlevel");
	t && t.traverse(function(t) {
		t.type !== "group" && (a != null && (t.z = a), o != null && (t.zlevel = o), t.silent = r);
	});
}
var BaseAxisPointer_default = BaseAxisPointer;
function buildElStyle(t) {
	var n = t.get("type"), r = t.getModel(n + "Style"), a;
	return n === "line" ? (a = r.getLineStyle(), a.fill = null) : n === "shadow" && (a = r.getAreaStyle(), a.stroke = null), a;
}
function buildLabelElOption(t, n, r, a, o) {
	var s = getValueLabel(r.get("value"), n.axis, n.ecModel, r.get("seriesDataIndices"), {
		precision: r.get(["label", "precision"]),
		formatter: r.get(["label", "formatter"])
	}), c = r.getModel("label"), l = normalizeCssArray(c.get("padding") || 0), u = c.getFont(), d = getBoundingRect(s, u), f = o.position, p = d.width + l[1] + l[3], h = d.height + l[0] + l[2], g = o.align;
	g === "right" && (f[0] -= p), g === "center" && (f[0] -= p / 2);
	var _ = o.verticalAlign;
	_ === "bottom" && (f[1] -= h), _ === "middle" && (f[1] -= h / 2), confineInContainer(f, p, h, a);
	var v = c.get("backgroundColor");
	(!v || v === "auto") && (v = n.get([
		"axisLine",
		"lineStyle",
		"color"
	])), t.label = {
		x: f[0],
		y: f[1],
		style: createTextStyle(c, {
			text: s,
			font: u,
			fill: c.getTextColor(),
			padding: l,
			backgroundColor: v
		}),
		z2: 10
	};
}
function confineInContainer(t, n, r, a) {
	var o = a.getWidth(), s = a.getHeight();
	t[0] = Math.min(t[0] + n, o) - n, t[1] = Math.min(t[1] + r, s) - r, t[0] = Math.max(t[0], 0), t[1] = Math.max(t[1], 0);
}
function getValueLabel(t, n, r, a, o) {
	t = n.scale.parse(t);
	var s = n.scale.getLabel({ value: t }, { precision: o.precision }), c = o.formatter;
	if (c) {
		var l = {
			value: getAxisRawValue(n, { value: t }),
			axisDimension: n.dim,
			axisIndex: n.index,
			seriesData: []
		};
		each(a, function(t) {
			var n = r.getSeriesByIndex(t.seriesIndex), a = t.dataIndexInside, o = n && n.getDataParams(a);
			o && l.seriesData.push(o);
		}), isString(c) ? s = c.replace("{value}", s) : isFunction(c) && (s = c(l));
	}
	return s;
}
function getTransformedPosition(t, n, r) {
	var a = create$2();
	return rotate(a, a, r.rotation), translate(a, a, r.position), applyTransform$1([t.dataToCoord(n), (r.labelOffset || 0) + (r.labelDirection || 1) * (r.labelMargin || 0)], a);
}
function buildCartesianSingleLabelElOption(t, n, r, a, o, s) {
	var c = AxisBuilder_default.innerTextLayout(r.rotation, 0, r.labelDirection);
	r.labelMargin = o.get(["label", "margin"]), buildLabelElOption(n, a, o, s, {
		position: getTransformedPosition(a.axis, t, r),
		align: c.textAlign,
		verticalAlign: c.textVerticalAlign
	});
}
function makeLineShape(t, n, r) {
	return r ||= 0, {
		x1: t[r],
		y1: t[1 - r],
		x2: n[r],
		y2: n[1 - r]
	};
}
function makeRectShape(t, n, r) {
	return r ||= 0, {
		x: t[r],
		y: t[1 - r],
		width: n[r],
		height: n[1 - r]
	};
}
function makeSectorShape(t, n, r, a, o, s) {
	return {
		cx: t,
		cy: n,
		r0: r,
		r: a,
		startAngle: o,
		endAngle: s,
		clockwise: !0
	};
}
var CartesianAxisPointer = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.makeElOption = function(t, n, r, a, o) {
		var s = r.axis, c = s.grid, l = a.get("type"), u = getCartesian(c, s).getOtherAxis(s).getGlobalExtent(), d = s.toGlobalCoord(s.dataToCoord(n, !0));
		if (l && l !== "none") {
			var f = buildElStyle(a), p = pointerShapeBuilder$2[l](s, d, u);
			p.style = f, t.graphicKey = p.type, t.pointer = p;
		}
		buildCartesianSingleLabelElOption(n, t, layout$3(c.model, r), r, a, o);
	}, n.prototype.getHandleTransform = function(t, n, r) {
		var a = layout$3(n.axis.grid.model, n, { labelInside: !1 });
		a.labelMargin = r.get(["handle", "margin"]);
		var o = getTransformedPosition(n.axis, t, a);
		return {
			x: o[0],
			y: o[1],
			rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
		};
	}, n.prototype.updateHandleTransform = function(t, n, r, a) {
		var o = r.axis, s = o.grid, c = o.getGlobalExtent(!0), l = getCartesian(s, o).getOtherAxis(o).getGlobalExtent(), u = o.dim === "x" ? 0 : 1, d = [t.x, t.y];
		d[u] += n[u], d[u] = Math.min(c[1], d[u]), d[u] = Math.max(c[0], d[u]);
		var f = (l[1] + l[0]) / 2, p = [f, f];
		return p[u] = d[u], {
			x: d[0],
			y: d[1],
			rotation: t.rotation,
			cursorPoint: p,
			tooltipOption: [{ verticalAlign: "middle" }, { align: "center" }][u]
		};
	}, n;
}(BaseAxisPointer_default);
function getCartesian(t, n) {
	var r = {};
	return r[n.dim + "AxisIndex"] = n.index, t.getCartesian(r);
}
var pointerShapeBuilder$2 = {
	line: function(t, n, r) {
		return {
			type: "Line",
			subPixelOptimize: !0,
			shape: makeLineShape([n, r[0]], [n, r[1]], getAxisDimIndex(t))
		};
	},
	shadow: function(t, n, r) {
		var a = Math.max(1, t.getBandWidth()), o = r[1] - r[0];
		return {
			type: "Rect",
			shape: makeRectShape([n - a / 2, r[0]], [a, o], getAxisDimIndex(t))
		};
	}
};
function getAxisDimIndex(t) {
	return t.dim === "x" ? 0 : 1;
}
var CartesianAxisPointer_default = CartesianAxisPointer, AxisPointerModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.type = "axisPointer", n.defaultOption = {
		show: "auto",
		z: 50,
		type: "line",
		snap: !1,
		triggerTooltip: !0,
		triggerEmphasis: !0,
		value: null,
		status: null,
		link: [],
		animation: null,
		animationDurationUpdate: 200,
		lineStyle: {
			color: "#B9BEC9",
			width: 1,
			type: "dashed"
		},
		shadowStyle: { color: "rgba(210,219,238,0.2)" },
		label: {
			show: !0,
			formatter: null,
			precision: "auto",
			margin: 3,
			color: "#fff",
			padding: [
				5,
				7,
				5,
				7
			],
			backgroundColor: "auto",
			borderColor: null,
			borderWidth: 0,
			borderRadius: 3
		},
		handle: {
			show: !1,
			icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
			size: 45,
			margin: 50,
			color: "#333",
			shadowBlur: 3,
			shadowColor: "#aaa",
			shadowOffsetX: 0,
			shadowOffsetY: 2,
			throttle: 40
		}
	}, n;
}(Component_default), inner$10 = makeInner(), each$9 = each;
function register(t, n, r) {
	if (!env_default.node) {
		var a = n.getZr();
		inner$10(a).records || (inner$10(a).records = {}), initGlobalListeners(a, n);
		var o = inner$10(a).records[t] || (inner$10(a).records[t] = {});
		o.handler = r;
	}
}
function initGlobalListeners(t, n) {
	if (inner$10(t).initialized) return;
	inner$10(t).initialized = !0, r("click", curry(doEnter, "click")), r("mousemove", curry(doEnter, "mousemove")), r("globalout", onLeave);
	function r(r, a) {
		t.on(r, function(r) {
			var o = makeDispatchAction$1(n);
			each$9(inner$10(t).records, function(t) {
				t && a(t, r, o.dispatchAction);
			}), dispatchTooltipFinally(o.pendings, n);
		});
	}
}
function dispatchTooltipFinally(t, n) {
	var r = t.showTip.length, a = t.hideTip.length, o;
	r ? o = t.showTip[r - 1] : a && (o = t.hideTip[a - 1]), o && (o.dispatchAction = null, n.dispatchAction(o));
}
function onLeave(t, n, r) {
	t.handler("leave", null, r);
}
function doEnter(t, n, r, a) {
	n.handler(t, r, a);
}
function makeDispatchAction$1(t) {
	var n = {
		showTip: [],
		hideTip: []
	}, r = function(a) {
		var o = n[a.type];
		o ? o.push(a) : (a.dispatchAction = r, t.dispatchAction(a));
	};
	return {
		dispatchAction: r,
		pendings: n
	};
}
function unregister(t, n) {
	if (!env_default.node) {
		var r = n.getZr();
		(inner$10(r).records || {})[t] && (inner$10(r).records[t] = null);
	}
}
var AxisPointerView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r) {
		var a = n.getComponent("tooltip"), o = t.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
		register("axisPointer", r, function(t, n, r) {
			o !== "none" && (t === "leave" || o.indexOf(t) >= 0) && r({
				type: "updateAxisPointer",
				currTrigger: t,
				x: n && n.offsetX,
				y: n && n.offsetY
			});
		});
	}, n.prototype.remove = function(t, n) {
		unregister("axisPointer", n);
	}, n.prototype.dispose = function(t, n) {
		unregister("axisPointer", n);
	}, n.type = "axisPointer", n;
}(Component_default$1);
function findPointFromSeries(t, n) {
	var r = [], a = t.seriesIndex, o;
	if (a == null || !(o = n.getSeriesByIndex(a))) return { point: [] };
	var s = o.getData(), c = queryDataIndex(s, t);
	if (c == null || c < 0 || isArray(c)) return { point: [] };
	var l = s.getItemGraphicEl(c), u = o.coordinateSystem;
	if (o.getTooltipPosition) r = o.getTooltipPosition(c) || [];
	else if (u && u.dataToPoint) if (t.isStacked) {
		var d = u.getBaseAxis(), f = u.getOtherAxis(d).dim, p = d.dim, h = f === "x" || f === "radius" ? 1 : 0, g = s.mapDimension(p), _ = [];
		_[h] = s.get(g, c), _[1 - h] = s.get(s.getCalculationInfo("stackResultDimension"), c), r = u.dataToPoint(_) || [];
	} else r = u.dataToPoint(s.getValues(map(u.dimensions, function(t) {
		return s.mapDimension(t);
	}), c)) || [];
	else if (l) {
		var v = l.getBoundingRect().clone();
		v.applyTransform(l.transform), r = [v.x + v.width / 2, v.y + v.height / 2];
	}
	return {
		point: r,
		el: l
	};
}
var inner$9 = makeInner();
function axisTrigger(t, n, r) {
	var a = t.currTrigger, o = [t.x, t.y], s = t, c = t.dispatchAction || bind(r.dispatchAction, r), l = n.getComponent("axisPointer").coordSysAxesInfo;
	if (l) {
		illegalPoint(o) && (o = findPointFromSeries({
			seriesIndex: s.seriesIndex,
			dataIndex: s.dataIndex
		}, n).point);
		var u = illegalPoint(o), d = s.axesInfo, f = l.axesInfo, p = a === "leave" || illegalPoint(o), h = {}, g = {}, _ = {
			list: [],
			map: {}
		}, v = {
			showPointer: curry(showPointer, g),
			showTooltip: curry(showTooltip, _)
		};
		each(l.coordSysMap, function(t, n) {
			var r = u || t.containPoint(o);
			each(l.coordSysAxesInfo[n], function(t, n) {
				var a = t.axis, s = findInputAxisInfo(d, t);
				if (!p && r && (!d || s)) {
					var c = s && s.value;
					c == null && !u && (c = a.pointToData(o)), c != null && processOnAxis(t, c, v, !1, h);
				}
			});
		});
		var y = {};
		return each(f, function(t, n) {
			var r = t.linkGroup;
			r && !g[n] && each(r.axesInfo, function(n, a) {
				var o = g[a];
				if (n !== t && o) {
					var s = o.value;
					r.mapper && (s = t.axis.scale.parse(r.mapper(s, makeMapperParam(n), makeMapperParam(t)))), y[t.key] = s;
				}
			});
		}), each(y, function(t, n) {
			processOnAxis(f[n], t, v, !0, h);
		}), updateModelActually(g, f, h), dispatchTooltipActually(_, o, t, c), dispatchHighDownActually(f, c, r), h;
	}
}
function processOnAxis(t, n, r, a, o) {
	var s = t.axis;
	if (!(s.scale.isBlank() || !s.containData(n))) {
		if (!t.involveSeries) {
			r.showPointer(t, n);
			return;
		}
		var c = buildPayloadsBySeries(n, t), l = c.payloadBatch, u = c.snapToValue;
		l[0] && o.seriesIndex == null && extend(o, l[0]), !a && t.snap && s.containData(u) && u != null && (n = u), r.showPointer(t, n, l), r.showTooltip(t, c, u);
	}
}
function buildPayloadsBySeries(t, n) {
	var r = n.axis, a = r.dim, o = t, s = [], c = Number.MAX_VALUE, l = -1;
	return each(n.seriesModels, function(n, u) {
		var d = n.getData().mapDimensionsAll(a), f, p;
		if (n.getAxisTooltipData) {
			var h = n.getAxisTooltipData(d, t, r);
			p = h.dataIndices, f = h.nestestValue;
		} else {
			if (p = n.getData().indicesOfNearest(d[0], t, r.type === "category" ? .5 : null), !p.length) return;
			f = n.getData().get(d[0], p[0]);
		}
		if (!(f == null || !isFinite(f))) {
			var g = t - f, _ = Math.abs(g);
			_ <= c && ((_ < c || g >= 0 && l < 0) && (c = _, l = g, o = f, s.length = 0), each(p, function(t) {
				s.push({
					seriesIndex: n.seriesIndex,
					dataIndexInside: t,
					dataIndex: n.getData().getRawIndex(t)
				});
			}));
		}
	}), {
		payloadBatch: s,
		snapToValue: o
	};
}
function showPointer(t, n, r, a) {
	t[n.key] = {
		value: r,
		payloadBatch: a
	};
}
function showTooltip(t, n, r, a) {
	var o = r.payloadBatch, s = n.axis, c = s.model, l = n.axisPointerModel;
	if (!(!n.triggerTooltip || !o.length)) {
		var u = n.coordSys.model, d = makeKey(u), f = t.map[d];
		f || (f = t.map[d] = {
			coordSysId: u.id,
			coordSysIndex: u.componentIndex,
			coordSysType: u.type,
			coordSysMainType: u.mainType,
			dataByAxis: []
		}, t.list.push(f)), f.dataByAxis.push({
			axisDim: s.dim,
			axisIndex: c.componentIndex,
			axisType: c.type,
			axisId: c.id,
			value: a,
			valueLabelOpt: {
				precision: l.get(["label", "precision"]),
				formatter: l.get(["label", "formatter"])
			},
			seriesDataIndices: o.slice()
		});
	}
}
function updateModelActually(t, n, r) {
	var a = r.axesInfo = [];
	each(n, function(n, r) {
		var o = n.axisPointerModel.option, s = t[r];
		s ? (!n.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !n.useHandle && (o.status = "hide"), o.status === "show" && a.push({
			axisDim: n.axis.dim,
			axisIndex: n.axis.model.componentIndex,
			value: o.value
		});
	});
}
function dispatchTooltipActually(t, n, r, a) {
	if (illegalPoint(n) || !t.list.length) {
		a({ type: "hideTip" });
		return;
	}
	var o = ((t.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
	a({
		type: "showTip",
		escapeConnect: !0,
		x: n[0],
		y: n[1],
		tooltipOption: r.tooltipOption,
		position: r.position,
		dataIndexInside: o.dataIndexInside,
		dataIndex: o.dataIndex,
		seriesIndex: o.seriesIndex,
		dataByCoordSys: t.list
	});
}
function dispatchHighDownActually(t, n, r) {
	var a = r.getZr(), o = "axisPointerLastHighlights", s = inner$9(a)[o] || {}, c = inner$9(a)[o] = {};
	each(t, function(t, n) {
		var r = t.axisPointerModel.option;
		r.status === "show" && t.triggerEmphasis && each(r.seriesDataIndices, function(t) {
			var n = t.seriesIndex + " | " + t.dataIndex;
			c[n] = t;
		});
	});
	var l = [], u = [];
	each(s, function(t, n) {
		!c[n] && u.push(t);
	}), each(c, function(t, n) {
		!s[n] && l.push(t);
	}), u.length && r.dispatchAction({
		type: "downplay",
		escapeConnect: !0,
		notBlur: !0,
		batch: u
	}), l.length && r.dispatchAction({
		type: "highlight",
		escapeConnect: !0,
		notBlur: !0,
		batch: l
	});
}
function findInputAxisInfo(t, n) {
	for (var r = 0; r < (t || []).length; r++) {
		var a = t[r];
		if (n.axis.dim === a.axisDim && n.axis.model.componentIndex === a.axisIndex) return a;
	}
}
function makeMapperParam(t) {
	var n = t.axis.model, r = {}, a = r.axisDim = t.axis.dim;
	return r.axisIndex = r[a + "AxisIndex"] = n.componentIndex, r.axisName = r[a + "AxisName"] = n.name, r.axisId = r[a + "AxisId"] = n.id, r;
}
function illegalPoint(t) {
	return !t || t[0] == null || isNaN(t[0]) || t[1] == null || isNaN(t[1]);
}
function install$33(t) {
	AxisView_default.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer_default), t.registerComponentModel(AxisPointerModel_default), t.registerComponentView(AxisPointerView_default), t.registerPreprocessor(function(t) {
		if (t) {
			(!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {});
			var n = t.axisPointer.link;
			n && !isArray(n) && (t.axisPointer.link = [n]);
		}
	}), t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC, function(t, n) {
		t.getComponent("axisPointer").coordSysAxesInfo = collect(t, n);
	}), t.registerAction({
		type: "updateAxisPointer",
		event: "updateAxisPointer",
		update: ":updateAxisPointer"
	}, axisTrigger);
}
function install$24(t) {
	use(install$53), use(install$33);
}
var PolarAxisPointer = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.makeElOption = function(t, n, r, a, o) {
		var s = r.axis;
		s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
		var c = s.polar, l = c.getOtherAxis(s).getExtent(), u = s.dataToCoord(n), d = a.get("type");
		if (d && d !== "none") {
			var f = buildElStyle(a), p = pointerShapeBuilder$1[d](s, c, u, l);
			p.style = f, t.graphicKey = p.type, t.pointer = p;
		}
		buildLabelElOption(t, r, a, o, getLabelPosition(n, r, a, c, a.get(["label", "margin"])));
	}, n;
}(BaseAxisPointer_default);
function getLabelPosition(t, n, r, a, o) {
	var s = n.axis, c = s.dataToCoord(t), l = a.getAngleAxis().getExtent()[0];
	l = l / 180 * Math.PI;
	var u = a.getRadiusAxis().getExtent(), d, f, p;
	if (s.dim === "radius") {
		var h = create$2();
		rotate(h, h, l), translate(h, h, [a.cx, a.cy]), d = applyTransform$1([c, -o], h);
		var g = n.getModel("axisLabel").get("rotate") || 0, _ = AxisBuilder_default.innerTextLayout(l, g * Math.PI / 180, -1);
		f = _.textAlign, p = _.textVerticalAlign;
	} else {
		var v = u[1];
		d = a.coordToPoint([v + o, c]);
		var y = a.cx, b = a.cy;
		f = Math.abs(d[0] - y) / v < .3 ? "center" : d[0] > y ? "left" : "right", p = Math.abs(d[1] - b) / v < .3 ? "middle" : d[1] > b ? "top" : "bottom";
	}
	return {
		position: d,
		align: f,
		verticalAlign: p
	};
}
var pointerShapeBuilder$1 = {
	line: function(t, n, r, a) {
		return t.dim === "angle" ? {
			type: "Line",
			shape: makeLineShape(n.coordToPoint([a[0], r]), n.coordToPoint([a[1], r]))
		} : {
			type: "Circle",
			shape: {
				cx: n.cx,
				cy: n.cy,
				r
			}
		};
	},
	shadow: function(t, n, r, a) {
		var o = Math.max(1, t.getBandWidth()), s = Math.PI / 180;
		return t.dim === "angle" ? {
			type: "Sector",
			shape: makeSectorShape(n.cx, n.cy, a[0], a[1], (-r - o / 2) * s, (-r + o / 2) * s)
		} : {
			type: "Sector",
			shape: makeSectorShape(n.cx, n.cy, r - o / 2, r + o / 2, 0, Math.PI * 2)
		};
	}
}, PolarAxisPointer_default = PolarAxisPointer, PolarModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.findAxisModel = function(t) {
		var n;
		return this.ecModel.eachComponent(t, function(t) {
			t.getCoordSysModel() === this && (n = t);
		}, this), n;
	}, n.type = "polar", n.dependencies = ["radiusAxis", "angleAxis"], n.defaultOption = {
		z: 0,
		center: ["50%", "50%"],
		radius: "80%"
	}, n;
}(Component_default), PolarAxisModel = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.getCoordSysModel = function() {
		return this.getReferringComponents("polar", SINGLE_REFERRING).models[0];
	}, n.type = "polarAxis", n;
}(Component_default);
mixin(PolarAxisModel, AxisModelCommonMixin);
var AngleAxisModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.type = "angleAxis", n;
}(PolarAxisModel), RadiusAxisModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.type = "radiusAxis", n;
}(PolarAxisModel), RadiusAxis = function(t) {
	__extends(n, t);
	function n(n, r) {
		return t.call(this, "radius", n, r) || this;
	}
	return n.prototype.pointToData = function(t, n) {
		return this.polar.pointToData(t, n)[this.dim === "radius" ? 0 : 1];
	}, n;
}(Axis_default);
RadiusAxis.prototype.dataToRadius = Axis_default.prototype.dataToCoord, RadiusAxis.prototype.radiusToData = Axis_default.prototype.coordToData;
var RadiusAxis_default = RadiusAxis, inner$8 = makeInner(), AngleAxis = function(t) {
	__extends(n, t);
	function n(n, r) {
		return t.call(this, "angle", n, r || [0, 360]) || this;
	}
	return n.prototype.pointToData = function(t, n) {
		return this.polar.pointToData(t, n)[this.dim === "radius" ? 0 : 1];
	}, n.prototype.calculateCategoryInterval = function() {
		var t = this, n = t.getLabelModel(), r = t.scale, a = r.getExtent(), o = r.count();
		if (a[1] - a[0] < 1) return 0;
		var s = a[0], c = t.dataToCoord(s + 1) - t.dataToCoord(s), l = Math.abs(c), u = getBoundingRect(s == null ? "" : s + "", n.getFont(), "center", "top"), d = Math.max(u.height, 7) / l;
		isNaN(d) && (d = Infinity);
		var f = Math.max(0, Math.floor(d)), p = inner$8(t.model), h = p.lastAutoInterval, g = p.lastTickCount;
		return h != null && g != null && Math.abs(h - f) <= 1 && Math.abs(g - o) <= 1 && h > f ? f = h : (p.lastTickCount = o, p.lastAutoInterval = f), f;
	}, n;
}(Axis_default);
AngleAxis.prototype.dataToAngle = Axis_default.prototype.dataToCoord, AngleAxis.prototype.angleToData = Axis_default.prototype.coordToData;
var AngleAxis_default = AngleAxis, polarDimensions = ["radius", "angle"], Polar = function() {
	function t(t) {
		this.dimensions = polarDimensions, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new RadiusAxis_default(), this._angleAxis = new AngleAxis_default(), this.axisPointerEnabled = !0, this.name = t || "", this._radiusAxis.polar = this._angleAxis.polar = this;
	}
	return t.prototype.containPoint = function(t) {
		var n = this.pointToCoord(t);
		return this._radiusAxis.contain(n[0]) && this._angleAxis.contain(n[1]);
	}, t.prototype.containData = function(t) {
		return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1]);
	}, t.prototype.getAxis = function(t) {
		var n = "_" + t + "Axis";
		return this[n];
	}, t.prototype.getAxes = function() {
		return [this._radiusAxis, this._angleAxis];
	}, t.prototype.getAxesByScale = function(t) {
		var n = [], r = this._angleAxis, a = this._radiusAxis;
		return r.scale.type === t && n.push(r), a.scale.type === t && n.push(a), n;
	}, t.prototype.getAngleAxis = function() {
		return this._angleAxis;
	}, t.prototype.getRadiusAxis = function() {
		return this._radiusAxis;
	}, t.prototype.getOtherAxis = function(t) {
		var n = this._angleAxis;
		return t === n ? this._radiusAxis : n;
	}, t.prototype.getBaseAxis = function() {
		return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
	}, t.prototype.getTooltipAxes = function(t) {
		var n = t != null && t !== "auto" ? this.getAxis(t) : this.getBaseAxis();
		return {
			baseAxes: [n],
			otherAxes: [this.getOtherAxis(n)]
		};
	}, t.prototype.dataToPoint = function(t, n) {
		return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], n), this._angleAxis.dataToAngle(t[1], n)]);
	}, t.prototype.pointToData = function(t, n) {
		var r = this.pointToCoord(t);
		return [this._radiusAxis.radiusToData(r[0], n), this._angleAxis.angleToData(r[1], n)];
	}, t.prototype.pointToCoord = function(t) {
		var n = t[0] - this.cx, r = t[1] - this.cy, a = this.getAngleAxis(), o = a.getExtent(), s = Math.min(o[0], o[1]), c = Math.max(o[0], o[1]);
		a.inverse ? s = c - 360 : c = s + 360;
		var l = Math.sqrt(n * n + r * r);
		n /= l, r /= l;
		for (var u = Math.atan2(-r, n) / Math.PI * 180, d = u < s ? 1 : -1; u < s || u > c;) u += d * 360;
		return [l, u];
	}, t.prototype.coordToPoint = function(t) {
		var n = t[0], r = t[1] / 180 * Math.PI;
		return [Math.cos(r) * n + this.cx, -Math.sin(r) * n + this.cy];
	}, t.prototype.getArea = function() {
		var t = this.getAngleAxis(), n = this.getRadiusAxis().getExtent().slice();
		n[0] > n[1] && n.reverse();
		var r = t.getExtent(), a = Math.PI / 180, o = 1e-4;
		return {
			cx: this.cx,
			cy: this.cy,
			r0: n[0],
			r: n[1],
			startAngle: -r[0] * a,
			endAngle: -r[1] * a,
			clockwise: t.inverse,
			contain: function(t, n) {
				var r = t - this.cx, a = n - this.cy, s = r * r + a * a, c = this.r, l = this.r0;
				return c !== l && s - o <= c * c && s + o >= l * l;
			}
		};
	}, t.prototype.convertToPixel = function(t, n, r) {
		return getCoordSys$2(n) === this ? this.dataToPoint(r) : null;
	}, t.prototype.convertFromPixel = function(t, n, r) {
		return getCoordSys$2(n) === this ? this.pointToData(r) : null;
	}, t;
}();
function getCoordSys$2(t) {
	var n = t.seriesModel, r = t.polarModel;
	return r && r.coordinateSystem || n && n.coordinateSystem;
}
var Polar_default = Polar;
init_dist$2();
function resizePolar(t, n, r) {
	var a = n.get("center"), o = r.getWidth(), s = r.getHeight();
	t.cx = parsePercent$1(a[0], o), t.cy = parsePercent$1(a[1], s);
	var c = t.getRadiusAxis(), l = Math.min(o, s) / 2, u = n.get("radius");
	u == null ? u = [0, "100%"] : isArray(u) || (u = [0, u]);
	var d = [parsePercent$1(u[0], l), parsePercent$1(u[1], l)];
	c.inverse ? c.setExtent(d[1], d[0]) : c.setExtent(d[0], d[1]);
}
function updatePolarScale(t, n) {
	var r = this, a = r.getAngleAxis(), o = r.getRadiusAxis();
	if (a.scale.setExtent(Infinity, -Infinity), o.scale.setExtent(Infinity, -Infinity), t.eachSeries(function(t) {
		if (t.coordinateSystem === r) {
			var n = t.getData();
			each(getDataDimensionsOnAxis(n, "radius"), function(t) {
				o.scale.unionExtentFromData(n, t);
			}), each(getDataDimensionsOnAxis(n, "angle"), function(t) {
				a.scale.unionExtentFromData(n, t);
			});
		}
	}), niceScaleExtent(a.scale, a.model), niceScaleExtent(o.scale, o.model), a.type === "category" && !a.onBand) {
		var s = a.getExtent(), c = 360 / a.scale.count();
		a.inverse ? s[1] += c : s[1] -= c, a.setExtent(s[0], s[1]);
	}
}
function isAngleAxisModel(t) {
	return t.mainType === "angleAxis";
}
function setAxis(t, n) {
	if (t.type = n.get("type"), t.scale = createScaleByModel$1(n), t.onBand = n.get("boundaryGap") && t.type === "category", t.inverse = n.get("inverse"), isAngleAxisModel(n)) {
		t.inverse = t.inverse !== n.get("clockwise");
		var r = n.get("startAngle"), a = n.get("endAngle") ?? r + (t.inverse ? -360 : 360);
		t.setExtent(r, a);
	}
	n.axis = t, t.model = n;
}
var polarCreator_default = {
	dimensions: polarDimensions,
	create: function(t, n) {
		var r = [];
		return t.eachComponent("polar", function(t, a) {
			var o = new Polar_default(a + "");
			o.update = updatePolarScale;
			var s = o.getRadiusAxis(), c = o.getAngleAxis(), l = t.findAxisModel("radiusAxis"), u = t.findAxisModel("angleAxis");
			setAxis(s, l), setAxis(c, u), resizePolar(o, t, n), r.push(o), t.coordinateSystem = o, o.model = t;
		}), t.eachSeries(function(t) {
			if (t.get("coordinateSystem") === "polar") {
				var n = t.getReferringComponents("polar", SINGLE_REFERRING).models[0];
				if (process$1.env.NODE_ENV !== "production" && !n) throw Error("Polar \"" + retrieve(t.get("polarIndex"), t.get("polarId"), 0) + "\" not found");
				t.coordinateSystem = n.coordinateSystem;
			}
		}), r;
	}
}, elementList = [
	"axisLine",
	"axisLabel",
	"axisTick",
	"minorTick",
	"splitLine",
	"minorSplitLine",
	"splitArea"
];
function getAxisLineShape(t, n, r) {
	n[1] > n[0] && (n = n.slice().reverse());
	var a = t.coordToPoint([n[0], r]), o = t.coordToPoint([n[1], r]);
	return {
		x1: a[0],
		y1: a[1],
		x2: o[0],
		y2: o[1]
	};
}
function getRadiusIdx(t) {
	return t.getRadiusAxis().inverse ? 0 : 1;
}
function fixAngleOverlap(t) {
	var n = t[0], r = t[t.length - 1];
	n && r && Math.abs(Math.abs(n.coord - r.coord) - 360) < 1e-4 && t.pop();
}
var AngleAxisView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.axisPointerClass = "PolarAxisPointer", r;
	}
	return n.prototype.render = function(t, n) {
		if (this.group.removeAll(), t.get("show")) {
			var r = t.axis, a = r.polar, o = a.getRadiusAxis().getExtent(), s = r.getTicksCoords(), c = r.getMinorTicksCoords(), l = map(r.getViewLabels(), function(t) {
				t = clone$1(t);
				var n = r.scale, a = n.type === "ordinal" ? n.getRawOrdinalNumber(t.tickValue) : t.tickValue;
				return t.coord = r.dataToCoord(a), t;
			});
			fixAngleOverlap(l), fixAngleOverlap(s), each(elementList, function(n) {
				t.get([n, "show"]) && (!r.scale.isBlank() || n === "axisLine") && angelAxisElementsBuilders[n](this.group, t, a, s, c, o, l);
			}, this);
		}
	}, n.type = "angleAxis", n;
}(AxisView_default), angelAxisElementsBuilders = {
	axisLine: function(t, n, r, a, o, s) {
		var c = n.getModel(["axisLine", "lineStyle"]), l = r.getAngleAxis(), u = Math.PI / 180, d = l.getExtent(), f = getRadiusIdx(r), p = f ? 0 : 1, h, g = Math.abs(d[1] - d[0]) === 360 ? "Circle" : "Arc";
		h = s[p] === 0 ? new graphic_exports$1[g]({
			shape: {
				cx: r.cx,
				cy: r.cy,
				r: s[f],
				startAngle: -d[0] * u,
				endAngle: -d[1] * u,
				clockwise: l.inverse
			},
			style: c.getLineStyle(),
			z2: 1,
			silent: !0
		}) : new Ring_default({
			shape: {
				cx: r.cx,
				cy: r.cy,
				r: s[f],
				r0: s[p]
			},
			style: c.getLineStyle(),
			z2: 1,
			silent: !0
		}), h.style.fill = null, t.add(h);
	},
	axisTick: function(t, n, r, a, o, s) {
		var c = n.getModel("axisTick"), l = (c.get("inside") ? -1 : 1) * c.get("length"), u = s[getRadiusIdx(r)], d = map(a, function(t) {
			return new Line_default$1({ shape: getAxisLineShape(r, [u, u + l], t.coord) });
		});
		t.add(mergePath(d, { style: defaults(c.getModel("lineStyle").getLineStyle(), { stroke: n.get([
			"axisLine",
			"lineStyle",
			"color"
		]) }) }));
	},
	minorTick: function(t, n, r, a, o, s) {
		if (o.length) {
			for (var c = n.getModel("axisTick"), l = n.getModel("minorTick"), u = (c.get("inside") ? -1 : 1) * l.get("length"), d = s[getRadiusIdx(r)], f = [], p = 0; p < o.length; p++) for (var h = 0; h < o[p].length; h++) f.push(new Line_default$1({ shape: getAxisLineShape(r, [d, d + u], o[p][h].coord) }));
			t.add(mergePath(f, { style: defaults(l.getModel("lineStyle").getLineStyle(), defaults(c.getLineStyle(), { stroke: n.get([
				"axisLine",
				"lineStyle",
				"color"
			]) })) }));
		}
	},
	axisLabel: function(t, n, r, a, o, s, c) {
		var l = n.getCategories(!0), u = n.getModel("axisLabel"), d = u.get("margin"), f = n.get("triggerEvent");
		each(c, function(a, o) {
			var c = u, p = a.tickValue, h = s[getRadiusIdx(r)], g = r.coordToPoint([h + d, a.coord]), _ = r.cx, v = r.cy, y = Math.abs(g[0] - _) / h < .3 ? "center" : g[0] > _ ? "left" : "right", b = Math.abs(g[1] - v) / h < .3 ? "middle" : g[1] > v ? "top" : "bottom";
			if (l && l[p]) {
				var x = l[p];
				isObject(x) && x.textStyle && (c = new Model_default(x.textStyle, u, u.ecModel));
			}
			var S = new Text_default({
				silent: AxisBuilder_default.isLabelSilent(n),
				style: createTextStyle(c, {
					x: g[0],
					y: g[1],
					fill: c.getTextColor() || n.get([
						"axisLine",
						"lineStyle",
						"color"
					]),
					text: a.formattedLabel,
					align: y,
					verticalAlign: b
				})
			});
			if (t.add(S), f) {
				var C = AxisBuilder_default.makeAxisEventDataBase(n);
				C.targetType = "axisLabel", C.value = a.rawLabel, getECData(S).eventData = C;
			}
		}, this);
	},
	splitLine: function(t, n, r, a, o, s) {
		var c = n.getModel("splitLine").getModel("lineStyle"), l = c.get("color"), u = 0;
		l = l instanceof Array ? l : [l];
		for (var d = [], f = 0; f < a.length; f++) {
			var p = u++ % l.length;
			d[p] = d[p] || [], d[p].push(new Line_default$1({ shape: getAxisLineShape(r, s, a[f].coord) }));
		}
		for (var f = 0; f < d.length; f++) t.add(mergePath(d[f], {
			style: defaults({ stroke: l[f % l.length] }, c.getLineStyle()),
			silent: !0,
			z: n.get("z")
		}));
	},
	minorSplitLine: function(t, n, r, a, o, s) {
		if (o.length) {
			for (var c = n.getModel("minorSplitLine").getModel("lineStyle"), l = [], u = 0; u < o.length; u++) for (var d = 0; d < o[u].length; d++) l.push(new Line_default$1({ shape: getAxisLineShape(r, s, o[u][d].coord) }));
			t.add(mergePath(l, {
				style: c.getLineStyle(),
				silent: !0,
				z: n.get("z")
			}));
		}
	},
	splitArea: function(t, n, r, a, o, s) {
		if (a.length) {
			var c = n.getModel("splitArea").getModel("areaStyle"), l = c.get("color"), u = 0;
			l = l instanceof Array ? l : [l];
			for (var d = [], f = Math.PI / 180, p = -a[0].coord * f, h = Math.min(s[0], s[1]), g = Math.max(s[0], s[1]), _ = n.get("clockwise"), v = 1, y = a.length; v <= y; v++) {
				var b = v === y ? a[0].coord : a[v].coord, x = u++ % l.length;
				d[x] = d[x] || [], d[x].push(new Sector_default({
					shape: {
						cx: r.cx,
						cy: r.cy,
						r0: h,
						r: g,
						startAngle: p,
						endAngle: -b * f,
						clockwise: _
					},
					silent: !0
				})), p = -b * f;
			}
			for (var v = 0; v < d.length; v++) t.add(mergePath(d[v], {
				style: defaults({ fill: l[v % l.length] }, c.getAreaStyle()),
				silent: !0
			}));
		}
	}
}, AngleAxisView_default = AngleAxisView, axisBuilderAttrs$1 = [
	"axisLine",
	"axisTickLabel",
	"axisName"
], selfBuilderAttrs$1 = [
	"splitLine",
	"splitArea",
	"minorSplitLine"
], RadiusAxisView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.axisPointerClass = "PolarAxisPointer", r;
	}
	return n.prototype.render = function(t, n) {
		if (this.group.removeAll(), t.get("show")) {
			var r = this._axisGroup, a = this._axisGroup = new Group_default();
			this.group.add(a);
			var o = t.axis, s = o.polar, c = s.getAngleAxis(), l = o.getTicksCoords(), u = o.getMinorTicksCoords(), d = c.getExtent()[0], f = o.getExtent(), p = new AxisBuilder_default(t, layoutAxis(s, t, d));
			each(axisBuilderAttrs$1, p.add, p), a.add(p.getGroup()), groupTransition(r, a, t), each(selfBuilderAttrs$1, function(n) {
				t.get([n, "show"]) && !o.scale.isBlank() && axisElementBuilders$1[n](this.group, t, s, d, f, l, u);
			}, this);
		}
	}, n.type = "radiusAxis", n;
}(AxisView_default), axisElementBuilders$1 = {
	splitLine: function(t, n, r, a, o, s) {
		var c = n.getModel("splitLine").getModel("lineStyle"), l = c.get("color"), u = 0, d = r.getAngleAxis(), f = Math.PI / 180, p = d.getExtent(), h = Math.abs(p[1] - p[0]) === 360 ? "Circle" : "Arc";
		l = l instanceof Array ? l : [l];
		for (var g = [], _ = 0; _ < s.length; _++) {
			var v = u++ % l.length;
			g[v] = g[v] || [], g[v].push(new graphic_exports$1[h]({ shape: {
				cx: r.cx,
				cy: r.cy,
				r: Math.max(s[_].coord, 0),
				startAngle: -p[0] * f,
				endAngle: -p[1] * f,
				clockwise: d.inverse
			} }));
		}
		for (var _ = 0; _ < g.length; _++) t.add(mergePath(g[_], {
			style: defaults({
				stroke: l[_ % l.length],
				fill: null
			}, c.getLineStyle()),
			silent: !0
		}));
	},
	minorSplitLine: function(t, n, r, a, o, s, c) {
		if (c.length) {
			for (var l = n.getModel("minorSplitLine").getModel("lineStyle"), u = [], d = 0; d < c.length; d++) for (var f = 0; f < c[d].length; f++) u.push(new Circle_default({ shape: {
				cx: r.cx,
				cy: r.cy,
				r: c[d][f].coord
			} }));
			t.add(mergePath(u, {
				style: defaults({ fill: null }, l.getLineStyle()),
				silent: !0
			}));
		}
	},
	splitArea: function(t, n, r, a, o, s) {
		if (s.length) {
			var c = n.getModel("splitArea").getModel("areaStyle"), l = c.get("color"), u = 0;
			l = l instanceof Array ? l : [l];
			for (var d = [], f = s[0].coord, p = 1; p < s.length; p++) {
				var h = u++ % l.length;
				d[h] = d[h] || [], d[h].push(new Sector_default({
					shape: {
						cx: r.cx,
						cy: r.cy,
						r0: f,
						r: s[p].coord,
						startAngle: 0,
						endAngle: Math.PI * 2
					},
					silent: !0
				})), f = s[p].coord;
			}
			for (var p = 0; p < d.length; p++) t.add(mergePath(d[p], {
				style: defaults({ fill: l[p % l.length] }, c.getAreaStyle()),
				silent: !0
			}));
		}
	}
};
function layoutAxis(t, n, r) {
	return {
		position: [t.cx, t.cy],
		rotation: r / 180 * Math.PI,
		labelDirection: -1,
		tickDirection: -1,
		nameDirection: 1,
		labelRotate: n.getModel("axisLabel").get("rotate"),
		z2: 1
	};
}
var RadiusAxisView_default = RadiusAxisView;
function getSeriesStackId(t) {
	return t.get("stack") || "__ec_stack_" + t.seriesIndex;
}
function getAxisKey(t, n) {
	return n.dim + t.model.componentIndex;
}
function barLayoutPolar(t, n, r) {
	var a = {}, o = calRadialBar(filter(n.getSeriesByType(t), function(t) {
		return !n.isSeriesFiltered(t) && t.coordinateSystem && t.coordinateSystem.type === "polar";
	}));
	n.eachSeriesByType(t, function(t) {
		if (t.coordinateSystem.type === "polar") {
			var n = t.getData(), r = t.coordinateSystem, s = r.getBaseAxis(), c = getAxisKey(r, s), l = getSeriesStackId(t), u = o[c][l], d = u.offset, f = u.width, p = r.getOtherAxis(s), h = t.coordinateSystem.cx, g = t.coordinateSystem.cy, _ = t.get("barMinHeight") || 0, v = t.get("barMinAngle") || 0;
			a[l] = a[l] || [];
			for (var y = n.mapDimension(p.dim), b = n.mapDimension(s.dim), x = isDimensionStacked(n, y), S = s.dim !== "radius" || !t.get("roundCap", !0), C = p.model.get("startValue"), w = p.dataToCoord(C || 0), T = 0, E = n.count(); T < E; T++) {
				var D = n.get(y, T), O = n.get(b, T), A = D >= 0 ? "p" : "n", j = w;
				x && (a[l][O] || (a[l][O] = {
					p: w,
					n: w
				}), j = a[l][O][A]);
				var M = void 0, N = void 0, P = void 0, F = void 0;
				if (p.dim === "radius") {
					var I = p.dataToCoord(D) - w, L = s.dataToCoord(O);
					Math.abs(I) < _ && (I = (I < 0 ? -1 : 1) * _), M = j, N = j + I, P = L - d, F = P - f, x && (a[l][O][A] = N);
				} else {
					var R = p.dataToCoord(D, S) - w, z = s.dataToCoord(O);
					Math.abs(R) < v && (R = (R < 0 ? -1 : 1) * v), M = z + d, N = M + f, P = j, F = j + R, x && (a[l][O][A] = F);
				}
				n.setItemLayout(T, {
					cx: h,
					cy: g,
					r0: M,
					r: N,
					startAngle: -P * Math.PI / 180,
					endAngle: -F * Math.PI / 180,
					clockwise: P >= F
				});
			}
		}
	});
}
function calRadialBar(t) {
	var n = {};
	each(t, function(t, r) {
		var a = t.getData(), o = t.coordinateSystem, s = o.getBaseAxis(), c = getAxisKey(o, s), l = s.getExtent(), u = s.type === "category" ? s.getBandWidth() : Math.abs(l[1] - l[0]) / a.count(), d = n[c] || {
			bandWidth: u,
			remainedWidth: u,
			autoWidthCount: 0,
			categoryGap: "20%",
			gap: "30%",
			stacks: {}
		}, f = d.stacks;
		n[c] = d;
		var p = getSeriesStackId(t);
		f[p] || d.autoWidthCount++, f[p] = f[p] || {
			width: 0,
			maxWidth: 0
		};
		var h = parsePercent$1(t.get("barWidth"), u), g = parsePercent$1(t.get("barMaxWidth"), u), _ = t.get("barGap"), v = t.get("barCategoryGap");
		h && !f[p].width && (h = Math.min(d.remainedWidth, h), f[p].width = h, d.remainedWidth -= h), g && (f[p].maxWidth = g), _ != null && (d.gap = _), v != null && (d.categoryGap = v);
	});
	var r = {};
	return each(n, function(t, n) {
		r[n] = {};
		var a = t.stacks, o = t.bandWidth, s = parsePercent$1(t.categoryGap, o), c = parsePercent$1(t.gap, 1), l = t.remainedWidth, u = t.autoWidthCount, d = (l - s) / (u + (u - 1) * c);
		d = Math.max(d, 0), each(a, function(t, n) {
			var r = t.maxWidth;
			r && r < d && (r = Math.min(r, l), t.width && (r = Math.min(r, t.width)), l -= r, t.width = r, u--);
		}), d = (l - s) / (u + (u - 1) * c), d = Math.max(d, 0);
		var f = 0, p;
		each(a, function(t, n) {
			t.width ||= d, p = t, f += t.width * (1 + c);
		}), p && (f -= p.width * c);
		var h = -f / 2;
		each(a, function(t, a) {
			r[n][a] = r[n][a] || {
				offset: h,
				width: t.width
			}, h += t.width * (1 + c);
		});
	}), r;
}
var barPolar_default = barLayoutPolar, angleAxisExtraOption = {
	startAngle: 90,
	clockwise: !0,
	splitNumber: 12,
	axisLabel: { rotate: 0 }
}, radiusAxisExtraOption = { splitNumber: 5 }, PolarView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.type = "polar", n;
}(Component_default$1);
function install$25(t) {
	use(install$33), AxisView_default.registerAxisPointerClass("PolarAxisPointer", PolarAxisPointer_default), t.registerCoordinateSystem("polar", polarCreator_default), t.registerComponentModel(PolarModel_default), t.registerComponentView(PolarView), axisModelCreator(t, "angle", AngleAxisModel, angleAxisExtraOption), axisModelCreator(t, "radius", RadiusAxisModel, radiusAxisExtraOption), t.registerComponentView(AngleAxisView_default), t.registerComponentView(RadiusAxisView_default), t.registerLayout(curry(barPolar_default, "bar"));
}
function layout$1(t, n) {
	n ||= {};
	var r = t.coordinateSystem, a = t.axis, o = {}, s = a.position, c = a.orient, l = r.getRect(), u = [
		l.x,
		l.x + l.width,
		l.y,
		l.y + l.height
	], d = {
		horizontal: {
			top: u[2],
			bottom: u[3]
		},
		vertical: {
			left: u[0],
			right: u[1]
		}
	};
	o.position = [c === "vertical" ? d.vertical[s] : u[0], c === "horizontal" ? d.horizontal[s] : u[3]], o.rotation = Math.PI / 2 * {
		horizontal: 0,
		vertical: 1
	}[c], o.labelDirection = o.tickDirection = o.nameDirection = {
		top: -1,
		bottom: 1,
		right: 1,
		left: -1
	}[s], t.get(["axisTick", "inside"]) && (o.tickDirection = -o.tickDirection), retrieve(n.labelInside, t.get(["axisLabel", "inside"])) && (o.labelDirection = -o.labelDirection);
	var f = n.rotate;
	return f ??= t.get(["axisLabel", "rotate"]), o.labelRotation = s === "top" ? -f : f, o.z2 = 1, o;
}
var axisBuilderAttrs = [
	"axisLine",
	"axisTickLabel",
	"axisName"
], selfBuilderAttrs = ["splitArea", "splitLine"], SingleAxisView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.axisPointerClass = "SingleAxisPointer", r;
	}
	return n.prototype.render = function(n, r, a, o) {
		var s = this.group;
		s.removeAll();
		var c = this._axisGroup;
		this._axisGroup = new Group_default();
		var l = new AxisBuilder_default(n, layout$1(n));
		each(axisBuilderAttrs, l.add, l), s.add(this._axisGroup), s.add(l.getGroup()), each(selfBuilderAttrs, function(t) {
			n.get([t, "show"]) && axisElementBuilders[t](this, this.group, this._axisGroup, n);
		}, this), groupTransition(c, this._axisGroup, n), t.prototype.render.call(this, n, r, a, o);
	}, n.prototype.remove = function() {
		rectCoordAxisHandleRemove(this);
	}, n.type = "singleAxis", n;
}(AxisView_default), axisElementBuilders = {
	splitLine: function(t, n, r, a) {
		var o = a.axis;
		if (!o.scale.isBlank()) {
			var s = a.getModel("splitLine"), c = s.getModel("lineStyle"), l = c.get("color");
			l = l instanceof Array ? l : [l];
			for (var u = c.get("width"), d = a.coordinateSystem.getRect(), f = o.isHorizontal(), p = [], h = 0, g = o.getTicksCoords({ tickModel: s }), _ = [], v = [], y = 0; y < g.length; ++y) {
				var b = o.toGlobalCoord(g[y].coord);
				f ? (_[0] = b, _[1] = d.y, v[0] = b, v[1] = d.y + d.height) : (_[0] = d.x, _[1] = b, v[0] = d.x + d.width, v[1] = b);
				var x = new Line_default$1({
					shape: {
						x1: _[0],
						y1: _[1],
						x2: v[0],
						y2: v[1]
					},
					silent: !0
				});
				subPixelOptimizeLine(x.shape, u);
				var S = h++ % l.length;
				p[S] = p[S] || [], p[S].push(x);
			}
			for (var C = c.getLineStyle(["color"]), y = 0; y < p.length; ++y) n.add(mergePath(p[y], {
				style: defaults({ stroke: l[y % l.length] }, C),
				silent: !0
			}));
		}
	},
	splitArea: function(t, n, r, a) {
		rectCoordAxisBuildSplitArea(t, r, a, a);
	}
}, SingleAxisView_default = SingleAxisView, SingleAxisModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.getCoordSysModel = function() {
		return this;
	}, n.type = "singleAxis", n.layoutMode = "box", n.defaultOption = {
		left: "5%",
		top: "5%",
		right: "5%",
		bottom: "5%",
		type: "value",
		position: "bottom",
		orient: "horizontal",
		axisLine: {
			show: !0,
			lineStyle: {
				width: 1,
				type: "solid"
			}
		},
		tooltip: { show: !0 },
		axisTick: {
			show: !0,
			length: 6,
			lineStyle: { width: 1 }
		},
		axisLabel: {
			show: !0,
			interval: "auto"
		},
		splitLine: {
			show: !0,
			lineStyle: {
				type: "dashed",
				opacity: .2
			}
		}
	}, n;
}(Component_default);
mixin(SingleAxisModel, AxisModelCommonMixin.prototype);
var AxisModel_default = SingleAxisModel, SingleAxis_default = function(t) {
	__extends(n, t);
	function n(n, r, a, o, s) {
		var c = t.call(this, n, r, a) || this;
		return c.type = o || "value", c.position = s || "bottom", c;
	}
	return n.prototype.isHorizontal = function() {
		var t = this.position;
		return t === "top" || t === "bottom";
	}, n.prototype.pointToData = function(t, n) {
		return this.coordinateSystem.pointToData(t)[0];
	}, n;
}(Axis_default), singleDimensions = ["single"], Single = function() {
	function t(t, n, r) {
		this.type = "single", this.dimension = "single", this.dimensions = singleDimensions, this.axisPointerEnabled = !0, this.model = t, this._init(t, n, r);
	}
	return t.prototype._init = function(t, n, r) {
		var a = this.dimension, o = new SingleAxis_default(a, createScaleByModel$1(t), [0, 0], t.get("type"), t.get("position"));
		o.onBand = o.type === "category" && t.get("boundaryGap"), o.inverse = t.get("inverse"), o.orient = t.get("orient"), t.axis = o, o.model = t, o.coordinateSystem = this, this._axis = o;
	}, t.prototype.update = function(t, n) {
		t.eachSeries(function(t) {
			if (t.coordinateSystem === this) {
				var n = t.getData();
				each(n.mapDimensionsAll(this.dimension), function(t) {
					this._axis.scale.unionExtentFromData(n, t);
				}, this), niceScaleExtent(this._axis.scale, this._axis.model);
			}
		}, this);
	}, t.prototype.resize = function(t, n) {
		this._rect = getLayoutRect({
			left: t.get("left"),
			top: t.get("top"),
			right: t.get("right"),
			bottom: t.get("bottom"),
			width: t.get("width"),
			height: t.get("height")
		}, {
			width: n.getWidth(),
			height: n.getHeight()
		}), this._adjustAxis();
	}, t.prototype.getRect = function() {
		return this._rect;
	}, t.prototype._adjustAxis = function() {
		var t = this._rect, n = this._axis, r = n.isHorizontal(), a = r ? [0, t.width] : [0, t.height], o = n.inverse ? 1 : 0;
		n.setExtent(a[o], a[1 - o]), this._updateAxisTransform(n, r ? t.x : t.y);
	}, t.prototype._updateAxisTransform = function(t, n) {
		var r = t.getExtent(), a = r[0] + r[1], o = t.isHorizontal();
		t.toGlobalCoord = o ? function(t) {
			return t + n;
		} : function(t) {
			return a - t + n;
		}, t.toLocalCoord = o ? function(t) {
			return t - n;
		} : function(t) {
			return a - t + n;
		};
	}, t.prototype.getAxis = function() {
		return this._axis;
	}, t.prototype.getBaseAxis = function() {
		return this._axis;
	}, t.prototype.getAxes = function() {
		return [this._axis];
	}, t.prototype.getTooltipAxes = function() {
		return {
			baseAxes: [this.getAxis()],
			otherAxes: []
		};
	}, t.prototype.containPoint = function(t) {
		var n = this.getRect(), r = this.getAxis();
		return r.orient === "horizontal" ? r.contain(r.toLocalCoord(t[0])) && t[1] >= n.y && t[1] <= n.y + n.height : r.contain(r.toLocalCoord(t[1])) && t[0] >= n.y && t[0] <= n.y + n.height;
	}, t.prototype.pointToData = function(t) {
		var n = this.getAxis();
		return [n.coordToData(n.toLocalCoord(t[n.orient === "horizontal" ? 0 : 1]))];
	}, t.prototype.dataToPoint = function(t) {
		var n = this.getAxis(), r = this.getRect(), a = [], o = n.orient === "horizontal" ? 0 : 1;
		return t instanceof Array && (t = t[0]), a[o] = n.toGlobalCoord(n.dataToCoord(+t)), a[1 - o] = o === 0 ? r.y + r.height / 2 : r.x + r.width / 2, a;
	}, t.prototype.convertToPixel = function(t, n, r) {
		return getCoordSys$1(n) === this ? this.dataToPoint(r) : null;
	}, t.prototype.convertFromPixel = function(t, n, r) {
		return getCoordSys$1(n) === this ? this.pointToData(r) : null;
	}, t;
}();
function getCoordSys$1(t) {
	var n = t.seriesModel, r = t.singleAxisModel;
	return r && r.coordinateSystem || n && n.coordinateSystem;
}
var Single_default = Single;
function create(t, n) {
	var r = [];
	return t.eachComponent("singleAxis", function(a, o) {
		var s = new Single_default(a, t, n);
		s.name = "single_" + o, s.resize(a, n), a.coordinateSystem = s, r.push(s);
	}), t.eachSeries(function(t) {
		if (t.get("coordinateSystem") === "singleAxis") {
			var n = t.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
			t.coordinateSystem = n && n.coordinateSystem;
		}
	}), r;
}
var singleCreator_default = {
	create,
	dimensions: singleDimensions
}, XY$1 = ["x", "y"], WH$1 = ["width", "height"], SingleAxisPointer = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.makeElOption = function(t, n, r, a, o) {
		var s = r.axis, c = s.coordinateSystem, l = getGlobalExtent(c, 1 - getPointDimIndex(s)), u = c.dataToPoint(n)[0], d = a.get("type");
		if (d && d !== "none") {
			var f = buildElStyle(a), p = pointerShapeBuilder[d](s, u, l);
			p.style = f, t.graphicKey = p.type, t.pointer = p;
		}
		buildCartesianSingleLabelElOption(n, t, layout$1(r), r, a, o);
	}, n.prototype.getHandleTransform = function(t, n, r) {
		var a = layout$1(n, { labelInside: !1 });
		a.labelMargin = r.get(["handle", "margin"]);
		var o = getTransformedPosition(n.axis, t, a);
		return {
			x: o[0],
			y: o[1],
			rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
		};
	}, n.prototype.updateHandleTransform = function(t, n, r, a) {
		var o = r.axis, s = o.coordinateSystem, c = getPointDimIndex(o), l = getGlobalExtent(s, c), u = [t.x, t.y];
		u[c] += n[c], u[c] = Math.min(l[1], u[c]), u[c] = Math.max(l[0], u[c]);
		var d = getGlobalExtent(s, 1 - c), f = (d[1] + d[0]) / 2, p = [f, f];
		return p[c] = u[c], {
			x: u[0],
			y: u[1],
			rotation: t.rotation,
			cursorPoint: p,
			tooltipOption: { verticalAlign: "middle" }
		};
	}, n;
}(BaseAxisPointer_default), pointerShapeBuilder = {
	line: function(t, n, r) {
		return {
			type: "Line",
			subPixelOptimize: !0,
			shape: makeLineShape([n, r[0]], [n, r[1]], getPointDimIndex(t))
		};
	},
	shadow: function(t, n, r) {
		var a = t.getBandWidth(), o = r[1] - r[0];
		return {
			type: "Rect",
			shape: makeRectShape([n - a / 2, r[0]], [a, o], getPointDimIndex(t))
		};
	}
};
function getPointDimIndex(t) {
	return t.isHorizontal() ? 0 : 1;
}
function getGlobalExtent(t, n) {
	var r = t.getRect();
	return [r[XY$1[n]], r[XY$1[n]] + r[WH$1[n]]];
}
var SingleAxisPointer_default = SingleAxisPointer, SingleView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.type = "single", n;
}(Component_default$1);
function install$27(t) {
	use(install$33), AxisView_default.registerAxisPointerClass("SingleAxisPointer", SingleAxisPointer_default), t.registerComponentView(SingleView), t.registerComponentView(SingleAxisView_default), t.registerComponentModel(AxisModel_default), axisModelCreator(t, "single", AxisModel_default, AxisModel_default.defaultOption), t.registerCoordinateSystem("single", singleCreator_default);
}
var CalendarModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.init = function(n, r, a) {
		var o = getLayoutParams(n);
		t.prototype.init.apply(this, arguments), mergeAndNormalizeLayoutParams$1(n, o);
	}, n.prototype.mergeOption = function(n) {
		t.prototype.mergeOption.apply(this, arguments), mergeAndNormalizeLayoutParams$1(this.option, n);
	}, n.prototype.getCellSize = function() {
		return this.option.cellSize;
	}, n.type = "calendar", n.defaultOption = {
		z: 2,
		left: 80,
		top: 60,
		cellSize: 20,
		orient: "horizontal",
		splitLine: {
			show: !0,
			lineStyle: {
				color: "#000",
				width: 1,
				type: "solid"
			}
		},
		itemStyle: {
			color: "#fff",
			borderWidth: 1,
			borderColor: "#ccc"
		},
		dayLabel: {
			show: !0,
			firstDay: 0,
			position: "start",
			margin: "50%",
			color: "#000"
		},
		monthLabel: {
			show: !0,
			position: "start",
			margin: 5,
			align: "center",
			formatter: null,
			color: "#000"
		},
		yearLabel: {
			show: !0,
			position: null,
			margin: 30,
			formatter: null,
			color: "#ccc",
			fontFamily: "sans-serif",
			fontWeight: "bolder",
			fontSize: 20
		}
	}, n;
}(Component_default);
function mergeAndNormalizeLayoutParams$1(t, n) {
	var r = t.cellSize, a = isArray(r) ? r : t.cellSize = [r, r];
	a.length === 1 && (a[1] = a[0]), mergeLayoutParam(t, n, {
		type: "box",
		ignoreSize: map([0, 1], function(t) {
			return sizeCalculable(n, t) && (a[t] = "auto"), a[t] != null && a[t] !== "auto";
		})
	});
}
var CalendarModel_default = CalendarModel, CalendarView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r) {
		var a = this.group;
		a.removeAll();
		var o = t.coordinateSystem, s = o.getRangeInfo(), c = o.getOrient(), l = n.getLocaleModel();
		this._renderDayRect(t, s, a), this._renderLines(t, s, c, a), this._renderYearText(t, s, c, a), this._renderMonthText(t, l, c, a), this._renderWeekText(t, l, s, c, a);
	}, n.prototype._renderDayRect = function(t, n, r) {
		for (var a = t.coordinateSystem, o = t.getModel("itemStyle").getItemStyle(), s = a.getCellWidth(), c = a.getCellHeight(), l = n.start.time; l <= n.end.time; l = a.getNextNDay(l, 1).time) {
			var u = a.dataToRect([l], !1).tl, d = new Rect_default({
				shape: {
					x: u[0],
					y: u[1],
					width: s,
					height: c
				},
				cursor: "default",
				style: o
			});
			r.add(d);
		}
	}, n.prototype._renderLines = function(t, n, r, a) {
		var o = this, s = t.coordinateSystem, c = t.getModel(["splitLine", "lineStyle"]).getLineStyle(), l = t.get(["splitLine", "show"]), u = c.lineWidth;
		this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
		for (var d = n.start, f = 0; d.time <= n.end.time; f++) {
			h(d.formatedDate), f === 0 && (d = s.getDateInfo(n.start.y + "-" + n.start.m));
			var p = d.date;
			p.setMonth(p.getMonth() + 1), d = s.getDateInfo(p);
		}
		h(s.getNextNDay(n.end.time, 1).formatedDate);
		function h(n) {
			o._firstDayOfMonth.push(s.getDateInfo(n)), o._firstDayPoints.push(s.dataToRect([n], !1).tl);
			var u = o._getLinePointsOfOneWeek(t, n, r);
			o._tlpoints.push(u[0]), o._blpoints.push(u[u.length - 1]), l && o._drawSplitline(u, c, a);
		}
		l && this._drawSplitline(o._getEdgesPoints(o._tlpoints, u, r), c, a), l && this._drawSplitline(o._getEdgesPoints(o._blpoints, u, r), c, a);
	}, n.prototype._getEdgesPoints = function(t, n, r) {
		var a = [t[0].slice(), t[t.length - 1].slice()], o = r === "horizontal" ? 0 : 1;
		return a[0][o] = a[0][o] - n / 2, a[1][o] = a[1][o] + n / 2, a;
	}, n.prototype._drawSplitline = function(t, n, r) {
		var a = new Polyline_default$1({
			z2: 20,
			shape: { points: t },
			style: n
		});
		r.add(a);
	}, n.prototype._getLinePointsOfOneWeek = function(t, n, r) {
		for (var a = t.coordinateSystem, o = a.getDateInfo(n), s = [], c = 0; c < 7; c++) {
			var l = a.getNextNDay(o.time, c), u = a.dataToRect([l.time], !1);
			s[2 * l.day] = u.tl, s[2 * l.day + 1] = u[r === "horizontal" ? "bl" : "tr"];
		}
		return s;
	}, n.prototype._formatterLabel = function(t, n) {
		return isString(t) && t ? formatTplSimple(t, n) : isFunction(t) ? t(n) : n.nameMap;
	}, n.prototype._yearTextPositionControl = function(t, n, r, a, o) {
		var s = n[0], c = n[1], l = ["center", "bottom"];
		a === "bottom" ? (c += o, l = ["center", "top"]) : a === "left" ? s -= o : a === "right" ? (s += o, l = ["center", "top"]) : c -= o;
		var u = 0;
		return (a === "left" || a === "right") && (u = Math.PI / 2), {
			rotation: u,
			x: s,
			y: c,
			style: {
				align: l[0],
				verticalAlign: l[1]
			}
		};
	}, n.prototype._renderYearText = function(t, n, r, a) {
		var o = t.getModel("yearLabel");
		if (o.get("show")) {
			var s = o.get("margin"), c = o.get("position");
			c ||= r === "horizontal" ? "left" : "top";
			var l = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], u = (l[0][0] + l[1][0]) / 2, d = (l[0][1] + l[1][1]) / 2, f = r === "horizontal" ? 0 : 1, p = {
				top: [u, l[f][1]],
				bottom: [u, l[1 - f][1]],
				left: [l[1 - f][0], d],
				right: [l[f][0], d]
			}, h = n.start.y;
			+n.end.y > +n.start.y && (h = h + "-" + n.end.y);
			var g = o.get("formatter"), _ = {
				start: n.start.y,
				end: n.end.y,
				nameMap: h
			}, v = new Text_default({
				z2: 30,
				style: createTextStyle(o, { text: this._formatterLabel(g, _) }),
				silent: o.get("silent")
			});
			v.attr(this._yearTextPositionControl(v, p[c], r, c, s)), a.add(v);
		}
	}, n.prototype._monthTextPositionControl = function(t, n, r, a, o) {
		var s = "left", c = "top", l = t[0], u = t[1];
		return r === "horizontal" ? (u += o, n && (s = "center"), a === "start" && (c = "bottom")) : (l += o, n && (c = "middle"), a === "start" && (s = "right")), {
			x: l,
			y: u,
			align: s,
			verticalAlign: c
		};
	}, n.prototype._renderMonthText = function(t, n, r, a) {
		var o = t.getModel("monthLabel");
		if (o.get("show")) {
			var s = o.get("nameMap"), c = o.get("margin"), l = o.get("position"), u = o.get("align"), d = [this._tlpoints, this._blpoints];
			(!s || isString(s)) && (s && (n = getLocaleModel(s) || n), s = n.get(["time", "monthAbbr"]) || []);
			var f = l === "start" ? 0 : 1, p = r === "horizontal" ? 0 : 1;
			c = l === "start" ? -c : c;
			for (var h = u === "center", g = o.get("silent"), _ = 0; _ < d[f].length - 1; _++) {
				var v = d[f][_].slice(), y = this._firstDayOfMonth[_];
				h && (v[p] = (this._firstDayPoints[_][p] + d[0][_ + 1][p]) / 2);
				var b = o.get("formatter"), x = s[y.m - 1], S = {
					yyyy: y.y,
					yy: (y.y + "").slice(2),
					MM: y.m,
					M: +y.m,
					nameMap: x
				}, C = new Text_default({
					z2: 30,
					style: extend(createTextStyle(o, { text: this._formatterLabel(b, S) }), this._monthTextPositionControl(v, h, r, l, c)),
					silent: g
				});
				a.add(C);
			}
		}
	}, n.prototype._weekTextPositionControl = function(t, n, r, a, o) {
		var s = "center", c = "middle", l = t[0], u = t[1], d = r === "start";
		return n === "horizontal" ? (l = l + a + (d ? 1 : -1) * o[0] / 2, s = d ? "right" : "left") : (u = u + a + (d ? 1 : -1) * o[1] / 2, c = d ? "bottom" : "top"), {
			x: l,
			y: u,
			align: s,
			verticalAlign: c
		};
	}, n.prototype._renderWeekText = function(t, n, r, a, o) {
		var s = t.getModel("dayLabel");
		if (s.get("show")) {
			var c = t.coordinateSystem, l = s.get("position"), u = s.get("nameMap"), d = s.get("margin"), f = c.getFirstDayOfWeek();
			(!u || isString(u)) && (u && (n = getLocaleModel(u) || n), u = n.get(["time", "dayOfWeekShort"]) || map(n.get(["time", "dayOfWeekAbbr"]), function(t) {
				return t[0];
			}));
			var p = c.getNextNDay(r.end.time, 7 - r.lweek).time, h = [c.getCellWidth(), c.getCellHeight()];
			d = parsePercent$1(d, Math.min(h[1], h[0])), l === "start" && (p = c.getNextNDay(r.start.time, -(7 + r.fweek)).time, d = -d);
			for (var g = s.get("silent"), _ = 0; _ < 7; _++) {
				var v = c.getNextNDay(p, _), y = c.dataToRect([v.time], !1).center, b = _;
				b = Math.abs((_ + f) % 7);
				var x = new Text_default({
					z2: 30,
					style: extend(createTextStyle(s, { text: u[b] }), this._weekTextPositionControl(y, a, l, d, h)),
					silent: g
				});
				o.add(x);
			}
		}
	}, n.type = "calendar", n;
}(Component_default$1);
init_dist$2();
var PROXIMATE_ONE_DAY = 864e5, Calendar = function() {
	function t(n, r, a) {
		this.type = "calendar", this.dimensions = t.dimensions, this.getDimensionsInfo = t.getDimensionsInfo, this._model = n;
	}
	return t.getDimensionsInfo = function() {
		return [{
			name: "time",
			type: "time"
		}, "value"];
	}, t.prototype.getRangeInfo = function() {
		return this._rangeInfo;
	}, t.prototype.getModel = function() {
		return this._model;
	}, t.prototype.getRect = function() {
		return this._rect;
	}, t.prototype.getCellWidth = function() {
		return this._sw;
	}, t.prototype.getCellHeight = function() {
		return this._sh;
	}, t.prototype.getOrient = function() {
		return this._orient;
	}, t.prototype.getFirstDayOfWeek = function() {
		return this._firstDayOfWeek;
	}, t.prototype.getDateInfo = function(t) {
		t = parseDate(t);
		var n = t.getFullYear(), r = t.getMonth() + 1, a = r < 10 ? "0" + r : "" + r, o = t.getDate(), s = o < 10 ? "0" + o : "" + o, c = t.getDay();
		return c = Math.abs((c + 7 - this.getFirstDayOfWeek()) % 7), {
			y: n + "",
			m: a,
			d: s,
			day: c,
			time: t.getTime(),
			formatedDate: n + "-" + a + "-" + s,
			date: t
		};
	}, t.prototype.getNextNDay = function(t, n) {
		return n ||= 0, n === 0 ? this.getDateInfo(t) : (t = new Date(this.getDateInfo(t).time), t.setDate(t.getDate() + n), this.getDateInfo(t));
	}, t.prototype.update = function(t, n) {
		this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
		var r = this._rangeInfo.weeks || 1, a = ["width", "height"], o = this._model.getCellSize().slice(), s = this._model.getBoxLayoutParams(), c = this._orient === "horizontal" ? [r, 7] : [7, r];
		each([0, 1], function(t) {
			u(o, t) && (s[a[t]] = o[t] * c[t]);
		});
		var l = this._rect = getLayoutRect(s, {
			width: n.getWidth(),
			height: n.getHeight()
		});
		each([0, 1], function(t) {
			u(o, t) || (o[t] = l[a[t]] / c[t]);
		});
		function u(t, n) {
			return t[n] != null && t[n] !== "auto";
		}
		this._sw = o[0], this._sh = o[1];
	}, t.prototype.dataToPoint = function(t, n) {
		isArray(t) && (t = t[0]), n ??= !0;
		var r = this.getDateInfo(t), a = this._rangeInfo, o = r.formatedDate;
		if (n && !(r.time >= a.start.time && r.time < a.end.time + PROXIMATE_ONE_DAY)) return [NaN, NaN];
		var s = r.day, c = this._getRangeInfo([a.start.time, o]).nthWeek;
		return this._orient === "vertical" ? [this._rect.x + s * this._sw + this._sw / 2, this._rect.y + c * this._sh + this._sh / 2] : [this._rect.x + c * this._sw + this._sw / 2, this._rect.y + s * this._sh + this._sh / 2];
	}, t.prototype.pointToData = function(t) {
		var n = this.pointToDate(t);
		return n && n.time;
	}, t.prototype.dataToRect = function(t, n) {
		var r = this.dataToPoint(t, n);
		return {
			contentShape: {
				x: r[0] - (this._sw - this._lineWidth) / 2,
				y: r[1] - (this._sh - this._lineWidth) / 2,
				width: this._sw - this._lineWidth,
				height: this._sh - this._lineWidth
			},
			center: r,
			tl: [r[0] - this._sw / 2, r[1] - this._sh / 2],
			tr: [r[0] + this._sw / 2, r[1] - this._sh / 2],
			br: [r[0] + this._sw / 2, r[1] + this._sh / 2],
			bl: [r[0] - this._sw / 2, r[1] + this._sh / 2]
		};
	}, t.prototype.pointToDate = function(t) {
		var n = Math.floor((t[0] - this._rect.x) / this._sw) + 1, r = Math.floor((t[1] - this._rect.y) / this._sh) + 1, a = this._rangeInfo.range;
		return this._orient === "vertical" ? this._getDateByWeeksAndDay(r, n - 1, a) : this._getDateByWeeksAndDay(n, r - 1, a);
	}, t.prototype.convertToPixel = function(t, n, r) {
		var a = getCoordSys(n);
		return a === this ? a.dataToPoint(r) : null;
	}, t.prototype.convertFromPixel = function(t, n, r) {
		var a = getCoordSys(n);
		return a === this ? a.pointToData(r) : null;
	}, t.prototype.containPoint = function(t) {
		return console.warn("Not implemented."), !1;
	}, t.prototype._initRangeOption = function() {
		var t = this._model.get("range"), n;
		if (isArray(t) && t.length === 1 && (t = t[0]), isArray(t)) n = t;
		else {
			var r = t.toString();
			if (/^\d{4}$/.test(r) && (n = [r + "-01-01", r + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(r)) {
				var a = this.getDateInfo(r), o = a.date;
				o.setMonth(o.getMonth() + 1);
				var c = this.getNextNDay(o, -1);
				n = [a.formatedDate, c.formatedDate];
			}
			/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(r) && (n = [r, r]);
		}
		if (!n) return process$1.env.NODE_ENV !== "production" && logError("Invalid date range."), t;
		var l = this._getRangeInfo(n);
		return l.start.time > l.end.time && n.reverse(), n;
	}, t.prototype._getRangeInfo = function(t) {
		var n = [this.getDateInfo(t[0]), this.getDateInfo(t[1])], r;
		n[0].time > n[1].time && (r = !0, n.reverse());
		var a = Math.floor(n[1].time / PROXIMATE_ONE_DAY) - Math.floor(n[0].time / PROXIMATE_ONE_DAY) + 1, o = new Date(n[0].time), s = o.getDate(), c = n[1].date.getDate();
		o.setDate(s + a - 1);
		var l = o.getDate();
		if (l !== c) for (var u = o.getTime() - n[1].time > 0 ? 1 : -1; (l = o.getDate()) !== c && (o.getTime() - n[1].time) * u > 0;) a -= u, o.setDate(l - u);
		var d = Math.floor((a + n[0].day + 6) / 7), f = r ? -d + 1 : d - 1;
		return r && n.reverse(), {
			range: [n[0].formatedDate, n[1].formatedDate],
			start: n[0],
			end: n[1],
			allDay: a,
			weeks: d,
			nthWeek: f,
			fweek: n[0].day,
			lweek: n[1].day
		};
	}, t.prototype._getDateByWeeksAndDay = function(t, n, r) {
		var a = this._getRangeInfo(r);
		if (t > a.weeks || t === 0 && n < a.fweek || t === a.weeks && n > a.lweek) return null;
		var o = (t - 1) * 7 - a.fweek + n, s = new Date(a.start.time);
		return s.setDate(+a.start.d + o), this.getDateInfo(s);
	}, t.create = function(n, r) {
		var a = [];
		return n.eachComponent("calendar", function(o) {
			var s = new t(o, n, r);
			a.push(s), o.coordinateSystem = s;
		}), n.eachSeries(function(t) {
			t.get("coordinateSystem") === "calendar" && (t.coordinateSystem = a[t.get("calendarIndex") || 0]);
		}), a;
	}, t.dimensions = ["time", "value"], t;
}();
function getCoordSys(t) {
	var n = t.calendarModel, r = t.seriesModel;
	return n ? n.coordinateSystem : r ? r.coordinateSystem : null;
}
var Calendar_default = Calendar;
function install$29(t) {
	t.registerComponentModel(CalendarModel_default), t.registerComponentView(CalendarView_default), t.registerCoordinateSystem("calendar", Calendar_default);
}
init_dist$2();
function setKeyInfoToNewElOption(t, n) {
	var r = t.existing;
	if (n.id = t.keyInfo.id, !n.type && r && (n.type = r.type), n.parentId == null) {
		var a = n.parentOption;
		a ? n.parentId = a.id : r && (n.parentId = r.parentId);
	}
	n.parentOption = null;
}
function isSetLoc(t, n) {
	var r;
	return each(n, function(n) {
		t[n] != null && t[n] !== "auto" && (r = !0);
	}), r;
}
function mergeNewElOptionToExist(t, n, r) {
	var a = extend({}, r), o = t[n], c = r.$action || "merge";
	if (c === "merge") if (o) {
		if (process$1.env.NODE_ENV !== "production") {
			var l = r.type;
			assert(!l || o.type === l, "Please set $action: \"replace\" to change `type`");
		}
		merge(o, a, !0), mergeLayoutParam(o, a, { ignoreSize: !0 }), copyLayoutParams(r, o), copyTransitionInfo(r, o), copyTransitionInfo(r, o, "shape"), copyTransitionInfo(r, o, "style"), copyTransitionInfo(r, o, "extra"), r.clipPath = o.clipPath;
	} else t[n] = a;
	else c === "replace" ? t[n] = a : c === "remove" && o && (t[n] = null);
}
var TRANSITION_PROPS_TO_COPY = [
	"transition",
	"enterFrom",
	"leaveTo"
], ROOT_TRANSITION_PROPS_TO_COPY = TRANSITION_PROPS_TO_COPY.concat([
	"enterAnimation",
	"updateAnimation",
	"leaveAnimation"
]);
function copyTransitionInfo(t, n, r) {
	if (r && (!t[r] && n[r] && (t[r] = {}), t = t[r], n = n[r]), !(!t || !n)) for (var a = r ? TRANSITION_PROPS_TO_COPY : ROOT_TRANSITION_PROPS_TO_COPY, o = 0; o < a.length; o++) {
		var s = a[o];
		t[s] == null && n[s] != null && (t[s] = n[s]);
	}
}
function setLayoutInfoToExist(t, n) {
	if (t && (t.hv = n.hv = [isSetLoc(n, ["left", "right"]), isSetLoc(n, ["top", "bottom"])], t.type === "group")) {
		var r = t, a = n;
		r.width ??= a.width = 0, r.height ??= a.height = 0;
	}
}
var GraphicComponentModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.preventAutoZ = !0, r;
	}
	return n.prototype.mergeOption = function(n, r) {
		var a = this.option.elements;
		this.option.elements = null, t.prototype.mergeOption.call(this, n, r), this.option.elements = a;
	}, n.prototype.optionUpdated = function(t, n) {
		var r = this.option, a = (n ? r : t).elements, o = r.elements = n ? [] : r.elements, c = [];
		this._flatten(a, c, null);
		var l = mappingToExists(o, c, "normalMerge"), u = this._elOptionsToUpdate = [];
		each(l, function(t, n) {
			var r = t.newOption;
			process$1.env.NODE_ENV !== "production" && assert(isObject(r) || t.existing, "Empty graphic option definition"), r && (u.push(r), setKeyInfoToNewElOption(t, r), mergeNewElOptionToExist(o, n, r), setLayoutInfoToExist(o[n], r));
		}, this), r.elements = filter(o, function(t) {
			return t && delete t.$action, t != null;
		});
	}, n.prototype._flatten = function(t, n, r) {
		each(t, function(t) {
			if (t) {
				r && (t.parentOption = r), n.push(t);
				var a = t.children;
				a && a.length && this._flatten(a, n, t), delete t.children;
			}
		}, this);
	}, n.prototype.useElOptionsToUpdate = function() {
		var t = this._elOptionsToUpdate;
		return this._elOptionsToUpdate = null, t;
	}, n.type = "graphic", n.defaultOption = { elements: [] }, n;
}(Component_default);
init_dist$2();
var nonShapeGraphicElements = {
	path: null,
	compoundPath: null,
	group: Group_default,
	image: Image_default,
	text: Text_default
}, inner$7 = makeInner(), GraphicComponentView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.init = function() {
		this._elMap = createHashMap();
	}, n.prototype.render = function(t, n, r) {
		t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, r);
	}, n.prototype._updateElements = function(t) {
		var n = t.useElOptionsToUpdate();
		if (n) {
			var r = this._elMap, a = this.group, o = t.get("z"), c = t.get("zlevel");
			each(n, function(n) {
				var l = convertOptionIdName(n.id, null), u = l == null ? null : r.get(l), d = convertOptionIdName(n.parentId, null), f = d == null ? a : r.get(d), p = n.type, h = n.style;
				p === "text" && h && n.hv && n.hv[1] && (h.textVerticalAlign = h.textBaseline = h.verticalAlign = h.align = null);
				var g = n.textContent, _ = n.textConfig;
				if (h && isEC4CompatibleStyle(h, p, !!_, !!g)) {
					var v = convertFromEC4CompatibleStyle(h, p, !0);
					!_ && v.textConfig && (_ = n.textConfig = v.textConfig), !g && v.textContent && (g = v.textContent);
				}
				var y = getCleanedElOption(n);
				process$1.env.NODE_ENV !== "production" && u && assert(f === u.parent, "Changing parent is not supported.");
				var b = n.$action || "merge", x = b === "merge", S = b === "replace";
				if (x) {
					var C = !u, w = u;
					C ? w = createEl(l, f, n.type, r) : (w && (inner$7(w).isNew = !1), stopPreviousKeyframeAnimationAndRestore(w)), w && (applyUpdateTransition(w, y, t, { isInit: C }), updateCommonAttrs(w, n, o, c));
				} else if (S) {
					removeEl$1(u, n, r, t);
					var T = createEl(l, f, n.type, r);
					T && (applyUpdateTransition(T, y, t, { isInit: !0 }), updateCommonAttrs(T, n, o, c));
				} else b === "remove" && (updateLeaveTo(u, n), removeEl$1(u, n, r, t));
				var E = r.get(l);
				if (E && g) if (x) {
					var D = E.getTextContent();
					D ? D.attr(g) : E.setTextContent(new Text_default(g));
				} else S && E.setTextContent(new Text_default(g));
				if (E) {
					var O = n.clipPath;
					if (O) {
						var A = O.type, j = void 0, C = !1;
						if (x) {
							var M = E.getClipPath();
							C = !M || inner$7(M).type !== A, j = C ? newEl(A) : M;
						} else S && (C = !0, j = newEl(A));
						E.setClipPath(j), applyUpdateTransition(j, O, t, { isInit: C }), applyKeyframeAnimation(j, O.keyframeAnimation, t);
					}
					var N = inner$7(E);
					E.setTextConfig(_), N.option = n, setEventData(E, t, n), setTooltipConfig({
						el: E,
						componentModel: t,
						itemName: E.name,
						itemTooltipOption: n.tooltip
					}), applyKeyframeAnimation(E, n.keyframeAnimation, t);
				}
			});
		}
	}, n.prototype._relocate = function(t, n) {
		for (var r = t.option.elements, a = this.group, o = this._elMap, s = n.getWidth(), c = n.getHeight(), l = ["x", "y"], u = 0; u < r.length; u++) {
			var d = r[u], f = convertOptionIdName(d.id, null), p = f == null ? null : o.get(f);
			if (!(!p || !p.isGroup)) {
				var h = p.parent, g = h === a, _ = inner$7(p), v = inner$7(h);
				_.width = parsePercent$1(_.option.width, g ? s : v.width) || 0, _.height = parsePercent$1(_.option.height, g ? c : v.height) || 0;
			}
		}
		for (var u = r.length - 1; u >= 0; u--) {
			var d = r[u], f = convertOptionIdName(d.id, null), p = f == null ? null : o.get(f);
			if (p) {
				var h = p.parent, v = inner$7(h), y = h === a ? {
					width: s,
					height: c
				} : {
					width: v.width,
					height: v.height
				}, b = {}, x = positionElement(p, d, y, null, {
					hv: d.hv,
					boundingMode: d.bounding
				}, b);
				if (!inner$7(p).isNew && x) {
					for (var S = d.transition, C = {}, w = 0; w < l.length; w++) {
						var T = l[w], E = b[T];
						S && (isTransitionAll(S) || indexOf(S, T) >= 0) ? C[T] = E : p[T] = E;
					}
					updateProps(p, C, t, 0);
				} else p.attr(b);
			}
		}
	}, n.prototype._clear = function() {
		var t = this, n = this._elMap;
		n.each(function(r) {
			removeEl$1(r, inner$7(r).option, n, t._lastGraphicModel);
		}), this._elMap = createHashMap();
	}, n.prototype.dispose = function() {
		this._clear();
	}, n.type = "graphic", n;
}(Component_default$1);
function newEl(t) {
	process$1.env.NODE_ENV !== "production" && assert(t, "graphic type MUST be set");
	var n = hasOwn(nonShapeGraphicElements, t) ? nonShapeGraphicElements[t] : getShapeClass(t);
	process$1.env.NODE_ENV !== "production" && assert(n, "graphic type " + t + " can not be found");
	var r = new n({});
	return inner$7(r).type = t, r;
}
function createEl(t, n, r, a) {
	var o = newEl(r);
	return n.add(o), a.set(t, o), inner$7(o).id = t, inner$7(o).isNew = !0, o;
}
function removeEl$1(t, n, r, a) {
	t && t.parent && (t.type === "group" && t.traverse(function(t) {
		removeEl$1(t, n, r, a);
	}), applyLeaveTransition(t, n, a), r.removeKey(inner$7(t).id));
}
function updateCommonAttrs(t, n, r, a) {
	t.isGroup || each([
		["cursor", Displayable_default.prototype.cursor],
		["zlevel", a || 0],
		["z", r || 0],
		["z2", 0]
	], function(r) {
		var a = r[0];
		hasOwn(n, a) ? t[a] = retrieve2(n[a], r[1]) : t[a] ?? (t[a] = r[1]);
	}), each(keys(n), function(r) {
		if (r.indexOf("on") === 0) {
			var a = n[r];
			t[r] = isFunction(a) ? a : null;
		}
	}), hasOwn(n, "draggable") && (t.draggable = n.draggable), n.name != null && (t.name = n.name), n.id != null && (t.id = n.id);
}
function getCleanedElOption(t) {
	return t = extend({}, t), each([
		"id",
		"parentId",
		"$action",
		"hv",
		"bounding",
		"textContent",
		"clipPath"
	].concat(LOCATION_PARAMS), function(n) {
		delete t[n];
	}), t;
}
function setEventData(t, n, r) {
	var a = getECData(t).eventData;
	!t.silent && !t.ignore && !a && (a = getECData(t).eventData = {
		componentType: "graphic",
		componentIndex: n.componentIndex,
		name: t.name
	}), a && (a.info = r.info);
}
function install$30(t) {
	t.registerComponentModel(GraphicComponentModel), t.registerComponentView(GraphicComponentView), t.registerPreprocessor(function(t) {
		var n = t.graphic;
		isArray(n) ? !n[0] || !n[0].elements ? t.graphic = [{ elements: n }] : t.graphic = [t.graphic[0]] : n && !n.elements && (t.graphic = [{ elements: [n] }]);
	});
}
init_dist$2();
var DATA_ZOOM_AXIS_DIMENSIONS = [
	"x",
	"y",
	"radius",
	"angle",
	"single"
], SERIES_COORDS = [
	"cartesian2d",
	"polar",
	"singleAxis"
];
function isCoordSupported(t) {
	return indexOf(SERIES_COORDS, t.get("coordinateSystem")) >= 0;
}
function getAxisMainType(t) {
	return process$1.env.NODE_ENV !== "production" && assert(t), t + "Axis";
}
function findEffectedDataZooms(t, n) {
	var r = createHashMap(), a = [], o = createHashMap();
	t.eachComponent({
		mainType: "dataZoom",
		query: n
	}, function(t) {
		o.get(t.uid) || l(t);
	});
	var s;
	do
		s = !1, t.eachComponent("dataZoom", c);
	while (s);
	function c(t) {
		!o.get(t.uid) && u(t) && (l(t), s = !0);
	}
	function l(t) {
		o.set(t.uid, !0), a.push(t), d(t);
	}
	function u(t) {
		var n = !1;
		return t.eachTargetAxis(function(t, a) {
			var o = r.get(t);
			o && o[a] && (n = !0);
		}), n;
	}
	function d(t) {
		t.eachTargetAxis(function(t, n) {
			(r.get(t) || r.set(t, []))[n] = !0;
		});
	}
	return a;
}
function collectReferCoordSysModelInfo(t) {
	var n = t.ecModel, r = {
		infoList: [],
		infoMap: createHashMap()
	};
	return t.eachTargetAxis(function(t, a) {
		var o = n.getComponent(getAxisMainType(t), a);
		if (o) {
			var s = o.getCoordSysModel();
			if (s) {
				var c = s.uid, l = r.infoMap.get(c);
				l || (l = {
					model: s,
					axisModels: []
				}, r.infoList.push(l), r.infoMap.set(c, l)), l.axisModels.push(o);
			}
		}
	}), r;
}
init_dist$2();
var DataZoomAxisInfo = function() {
	function t() {
		this.indexList = [], this.indexMap = [];
	}
	return t.prototype.add = function(t) {
		this.indexMap[t] || (this.indexList.push(t), this.indexMap[t] = !0);
	}, t;
}(), DataZoomModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r._autoThrottle = !0, r._noTarget = !0, r._rangePropMode = ["percent", "percent"], r;
	}
	return n.prototype.init = function(t, n, r) {
		var a = retrieveRawOption(t);
		this.settledOption = a, this.mergeDefaultAndTheme(t, r), this._doInit(a);
	}, n.prototype.mergeOption = function(t) {
		var n = retrieveRawOption(t);
		merge(this.option, t, !0), merge(this.settledOption, n, !0), this._doInit(n);
	}, n.prototype._doInit = function(t) {
		var n = this.option;
		this._setDefaultThrottle(t), this._updateRangeUse(t);
		var r = this.settledOption;
		each([["start", "startValue"], ["end", "endValue"]], function(t, a) {
			this._rangePropMode[a] === "value" && (n[t[0]] = r[t[0]] = null);
		}, this), this._resetTarget();
	}, n.prototype._resetTarget = function() {
		var t = this.get("orient", !0), n = this._targetAxisInfoMap = createHashMap();
		this._fillSpecifiedTargetAxis(n) ? this._orient = t || this._makeAutoOrientByTargetAxis() : (this._orient = t || "horizontal", this._fillAutoTargetAxisByOrient(n, this._orient)), this._noTarget = !0, n.each(function(t) {
			t.indexList.length && (this._noTarget = !1);
		}, this);
	}, n.prototype._fillSpecifiedTargetAxis = function(t) {
		var n = !1;
		return each(DATA_ZOOM_AXIS_DIMENSIONS, function(r) {
			var a = this.getReferringComponents(getAxisMainType(r), MULTIPLE_REFERRING);
			if (a.specified) {
				n = !0;
				var o = new DataZoomAxisInfo();
				each(a.models, function(t) {
					o.add(t.componentIndex);
				}), t.set(r, o);
			}
		}, this), n;
	}, n.prototype._fillAutoTargetAxisByOrient = function(t, n) {
		var r = this.ecModel, a = !0;
		if (a) {
			var o = n === "vertical" ? "y" : "x", s = r.findComponents({ mainType: o + "Axis" });
			c(s, o);
		}
		if (a) {
			var s = r.findComponents({
				mainType: "singleAxis",
				filter: function(t) {
					return t.get("orient", !0) === n;
				}
			});
			c(s, "single");
		}
		function c(n, r) {
			var o = n[0];
			if (o) {
				var s = new DataZoomAxisInfo();
				if (s.add(o.componentIndex), t.set(r, s), a = !1, r === "x" || r === "y") {
					var c = o.getReferringComponents("grid", SINGLE_REFERRING).models[0];
					c && each(n, function(t) {
						o.componentIndex !== t.componentIndex && c === t.getReferringComponents("grid", SINGLE_REFERRING).models[0] && s.add(t.componentIndex);
					});
				}
			}
		}
		a && each(DATA_ZOOM_AXIS_DIMENSIONS, function(n) {
			if (a) {
				var o = r.findComponents({
					mainType: getAxisMainType(n),
					filter: function(t) {
						return t.get("type", !0) === "category";
					}
				});
				if (o[0]) {
					var s = new DataZoomAxisInfo();
					s.add(o[0].componentIndex), t.set(n, s), a = !1;
				}
			}
		}, this);
	}, n.prototype._makeAutoOrientByTargetAxis = function() {
		var t;
		return this.eachTargetAxis(function(n) {
			!t && (t = n);
		}, this), t === "y" ? "vertical" : "horizontal";
	}, n.prototype._setDefaultThrottle = function(t) {
		if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
			var n = this.ecModel.option;
			this.option.throttle = n.animation && n.animationDurationUpdate > 0 ? 100 : 20;
		}
	}, n.prototype._updateRangeUse = function(t) {
		var n = this._rangePropMode, r = this.get("rangeMode");
		each([["start", "startValue"], ["end", "endValue"]], function(a, o) {
			var s = t[a[0]] != null, c = t[a[1]] != null;
			s && !c ? n[o] = "percent" : !s && c ? n[o] = "value" : r ? n[o] = r[o] : s && (n[o] = "percent");
		});
	}, n.prototype.noTarget = function() {
		return this._noTarget;
	}, n.prototype.getFirstTargetAxisModel = function() {
		var t;
		return this.eachTargetAxis(function(n, r) {
			t ??= this.ecModel.getComponent(getAxisMainType(n), r);
		}, this), t;
	}, n.prototype.eachTargetAxis = function(t, n) {
		this._targetAxisInfoMap.each(function(r, a) {
			each(r.indexList, function(r) {
				t.call(n, a, r);
			});
		});
	}, n.prototype.getAxisProxy = function(t, n) {
		var r = this.getAxisModel(t, n);
		if (r) return r.__dzAxisProxy;
	}, n.prototype.getAxisModel = function(t, n) {
		process$1.env.NODE_ENV !== "production" && assert(t && n != null);
		var r = this._targetAxisInfoMap.get(t);
		if (r && r.indexMap[n]) return this.ecModel.getComponent(getAxisMainType(t), n);
	}, n.prototype.setRawRange = function(t) {
		var n = this.option, r = this.settledOption;
		each([["start", "startValue"], ["end", "endValue"]], function(a) {
			(t[a[0]] != null || t[a[1]] != null) && (n[a[0]] = r[a[0]] = t[a[0]], n[a[1]] = r[a[1]] = t[a[1]]);
		}, this), this._updateRangeUse(t);
	}, n.prototype.setCalculatedRange = function(t) {
		var n = this.option;
		each([
			"start",
			"startValue",
			"end",
			"endValue"
		], function(r) {
			n[r] = t[r];
		});
	}, n.prototype.getPercentRange = function() {
		var t = this.findRepresentativeAxisProxy();
		if (t) return t.getDataPercentWindow();
	}, n.prototype.getValueRange = function(t, n) {
		if (t == null && n == null) {
			var r = this.findRepresentativeAxisProxy();
			if (r) return r.getDataValueWindow();
		} else return this.getAxisProxy(t, n).getDataValueWindow();
	}, n.prototype.findRepresentativeAxisProxy = function(t) {
		if (t) return t.__dzAxisProxy;
		for (var n, r = this._targetAxisInfoMap.keys(), a = 0; a < r.length; a++) for (var o = r[a], s = this._targetAxisInfoMap.get(o), c = 0; c < s.indexList.length; c++) {
			var l = this.getAxisProxy(o, s.indexList[c]);
			if (l.hostedBy(this)) return l;
			n ||= l;
		}
		return n;
	}, n.prototype.getRangePropMode = function() {
		return this._rangePropMode.slice();
	}, n.prototype.getOrient = function() {
		return process$1.env.NODE_ENV !== "production" && assert(this._orient), this._orient;
	}, n.type = "dataZoom", n.dependencies = [
		"xAxis",
		"yAxis",
		"radiusAxis",
		"angleAxis",
		"singleAxis",
		"series",
		"toolbox"
	], n.defaultOption = {
		z: 4,
		filterMode: "filter",
		start: 0,
		end: 100
	}, n;
}(Component_default);
function retrieveRawOption(t) {
	var n = {};
	return each([
		"start",
		"end",
		"startValue",
		"endValue",
		"throttle"
	], function(r) {
		t.hasOwnProperty(r) && (n[r] = t[r]);
	}), n;
}
var DataZoomModel_default = DataZoomModel, SelectZoomModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.type = "dataZoom.select", n;
}(DataZoomModel_default), DataZoomView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r, a) {
		this.dataZoomModel = t, this.ecModel = n, this.api = r;
	}, n.type = "dataZoom", n;
}(Component_default$1), SelectZoomView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.type = "dataZoom.select", n;
}(DataZoomView_default), each$8 = each, asc$2 = asc$1, AxisProxy = function() {
	function t(t, n, r, a) {
		this._dimName = t, this._axisIndex = n, this.ecModel = a, this._dataZoomModel = r;
	}
	return t.prototype.hostedBy = function(t) {
		return this._dataZoomModel === t;
	}, t.prototype.getDataValueWindow = function() {
		return this._valueWindow.slice();
	}, t.prototype.getDataPercentWindow = function() {
		return this._percentWindow.slice();
	}, t.prototype.getTargetSeriesModels = function() {
		var t = [];
		return this.ecModel.eachSeries(function(n) {
			if (isCoordSupported(n)) {
				var r = getAxisMainType(this._dimName), a = n.getReferringComponents(r, SINGLE_REFERRING).models[0];
				a && this._axisIndex === a.componentIndex && t.push(n);
			}
		}, this), t;
	}, t.prototype.getAxisModel = function() {
		return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
	}, t.prototype.getMinMaxSpan = function() {
		return clone$1(this._minMaxSpan);
	}, t.prototype.calculateDataWindow = function(t) {
		var n = this._dataExtent, r = this.getAxisModel().axis.scale, a = this._dataZoomModel.getRangePropMode(), o = [0, 100], s = [], c = [], l;
		each$8(["start", "end"], function(u, d) {
			var f = t[u], p = t[u + "Value"];
			a[d] === "percent" ? (f ??= o[d], p = r.parse(linearMap$2(f, o, n))) : (l = !0, p = p == null ? n[d] : r.parse(p), f = linearMap$2(p, n, o)), c[d] = p == null || isNaN(p) ? n[d] : p, s[d] = f == null || isNaN(f) ? o[d] : f;
		}), asc$2(c), asc$2(s);
		var u = this._minMaxSpan;
		l ? d(c, s, n, o, !1) : d(s, c, o, n, !0);
		function d(t, n, a, o, s) {
			var c = s ? "Span" : "ValueSpan";
			sliderMove(0, t, a, "all", u["min" + c], u["max" + c]);
			for (var l = 0; l < 2; l++) n[l] = linearMap$2(t[l], a, o, !0), s && (n[l] = r.parse(n[l]));
		}
		return {
			valueWindow: c,
			percentWindow: s
		};
	}, t.prototype.reset = function(t) {
		if (t === this._dataZoomModel) {
			var n = this.getTargetSeriesModels();
			this._dataExtent = calculateDataExtent(this, this._dimName, n), this._updateMinMaxSpan();
			var r = this.calculateDataWindow(t.settledOption);
			this._valueWindow = r.valueWindow, this._percentWindow = r.percentWindow, this._setAxisModel();
		}
	}, t.prototype.filterData = function(t, n) {
		if (t !== this._dataZoomModel) return;
		var r = this._dimName, a = this.getTargetSeriesModels(), o = t.get("filterMode"), s = this._valueWindow;
		if (o === "none") return;
		each$8(a, function(t) {
			var n = t.getData(), a = n.mapDimensionsAll(r);
			if (a.length) {
				if (o === "weakFilter") {
					var l = n.getStore(), u = map(a, function(t) {
						return n.getDimensionIndex(t);
					}, n);
					n.filterSelf(function(t) {
						for (var n, r, o, c = 0; c < a.length; c++) {
							var d = l.get(u[c], t), f = !isNaN(d), p = d < s[0], h = d > s[1];
							if (f && !p && !h) return !0;
							f && (o = !0), p && (n = !0), h && (r = !0);
						}
						return o && n && r;
					});
				} else each$8(a, function(r) {
					if (o === "empty") t.setData(n = n.map(r, function(t) {
						return c(t) ? t : NaN;
					}));
					else {
						var a = {};
						a[r] = s, n.selectRange(a);
					}
				});
				each$8(a, function(t) {
					n.setApproximateExtent(s, t);
				});
			}
		});
		function c(t) {
			return t >= s[0] && t <= s[1];
		}
	}, t.prototype._updateMinMaxSpan = function() {
		var t = this._minMaxSpan = {}, n = this._dataZoomModel, r = this._dataExtent;
		each$8(["min", "max"], function(a) {
			var o = n.get(a + "Span"), s = n.get(a + "ValueSpan");
			s != null && (s = this.getAxisModel().axis.scale.parse(s)), s == null ? o != null && (s = linearMap$2(o, [0, 100], r, !0) - r[0]) : o = linearMap$2(r[0] + s, r, [0, 100], !0), t[a + "Span"] = o, t[a + "ValueSpan"] = s;
		}, this);
	}, t.prototype._setAxisModel = function() {
		var t = this.getAxisModel(), n = this._percentWindow, r = this._valueWindow;
		if (n) {
			var a = getPixelPrecision(r, [0, 500]);
			a = Math.min(a, 20);
			var o = t.axis.scale.rawExtentInfo;
			n[0] !== 0 && o.setDeterminedMinMax("min", +r[0].toFixed(a)), n[1] !== 100 && o.setDeterminedMinMax("max", +r[1].toFixed(a)), o.freeze();
		}
	}, t;
}();
function calculateDataExtent(t, n, r) {
	var a = [Infinity, -Infinity];
	each$8(r, function(t) {
		unionAxisExtentFromData(a, t.getData(), n);
	});
	var o = t.getAxisModel(), s = ensureScaleRawExtentInfo(o.axis.scale, o, a).calculate();
	return [s.min, s.max];
}
var AxisProxy_default = AxisProxy, dataZoomProcessor_default = {
	getTargetSeries: function(t) {
		function n(n) {
			t.eachComponent("dataZoom", function(r) {
				r.eachTargetAxis(function(a, o) {
					n(a, o, t.getComponent(getAxisMainType(a), o), r);
				});
			});
		}
		n(function(t, n, r, a) {
			r.__dzAxisProxy = null;
		});
		var r = [];
		n(function(n, a, o, s) {
			o.__dzAxisProxy || (o.__dzAxisProxy = new AxisProxy_default(n, a, s, t), r.push(o.__dzAxisProxy));
		});
		var a = createHashMap();
		return each(r, function(t) {
			each(t.getTargetSeriesModels(), function(t) {
				a.set(t.uid, t);
			});
		}), a;
	},
	overallReset: function(t, n) {
		t.eachComponent("dataZoom", function(t) {
			t.eachTargetAxis(function(n, r) {
				t.getAxisProxy(n, r).reset(t);
			}), t.eachTargetAxis(function(r, a) {
				t.getAxisProxy(r, a).filterData(t, n);
			});
		}), t.eachComponent("dataZoom", function(t) {
			var n = t.findRepresentativeAxisProxy();
			if (n) {
				var r = n.getDataPercentWindow(), a = n.getDataValueWindow();
				t.setCalculatedRange({
					start: r[0],
					end: r[1],
					startValue: a[0],
					endValue: a[1]
				});
			}
		});
	}
};
function installDataZoomAction(t) {
	t.registerAction("dataZoom", function(t, n) {
		each(findEffectedDataZooms(n, t), function(n) {
			n.setRawRange({
				start: t.start,
				end: t.end,
				startValue: t.startValue,
				endValue: t.endValue
			});
		});
	});
}
var installed$1 = !1;
function installCommon$1(t) {
	installed$1 || (installed$1 = !0, t.registerProcessor(t.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor_default), installDataZoomAction(t), t.registerSubTypeDefaulter("dataZoom", function() {
		return "slider";
	}));
}
function install$52(t) {
	t.registerComponentModel(SelectZoomModel_default), t.registerComponentView(SelectZoomView_default), installCommon$1(t);
}
var ToolboxFeature = function() {
	function t() {}
	return t;
}(), features = {};
function registerFeature(t, n) {
	features[t] = n;
}
function getFeature(t) {
	return features[t];
}
var ToolboxModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.optionUpdated = function() {
		t.prototype.optionUpdated.apply(this, arguments);
		var n = this.ecModel;
		each(this.option.feature, function(t, r) {
			var a = getFeature(r);
			a && (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(n)), merge(t, a.defaultOption));
		});
	}, n.type = "toolbox", n.layoutMode = {
		type: "box",
		ignoreSize: !0
	}, n.defaultOption = {
		show: !0,
		z: 6,
		orient: "horizontal",
		left: "right",
		top: "top",
		backgroundColor: "transparent",
		borderColor: "#ccc",
		borderRadius: 0,
		borderWidth: 0,
		padding: 5,
		itemSize: 15,
		itemGap: 8,
		showTitle: !0,
		iconStyle: {
			borderColor: "#666",
			color: "none"
		},
		emphasis: { iconStyle: { borderColor: "#3E98C5" } },
		tooltip: {
			show: !1,
			position: "bottom"
		}
	}, n;
}(Component_default);
function layout(t, n, r) {
	var a = n.getBoxLayoutParams(), o = n.get("padding"), s = {
		width: r.getWidth(),
		height: r.getHeight()
	}, c = getLayoutRect(a, s, o);
	box(n.get("orient"), t, n.get("itemGap"), c.width, c.height), positionElement(t, a, s, o);
}
function makeBackground(t, n) {
	var r = normalizeCssArray(n.get("padding")), a = n.getItemStyle(["color", "opacity"]);
	return a.fill = n.get("backgroundColor"), t = new Rect_default({
		shape: {
			x: t.x - r[3],
			y: t.y - r[0],
			width: t.width + r[1] + r[3],
			height: t.height + r[0] + r[2],
			r: n.get("borderRadius")
		},
		style: a,
		silent: !0,
		z2: -1
	}), t;
}
var ToolboxView = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.render = function(t, n, r, a) {
		var o = this.group;
		if (o.removeAll(), !t.get("show")) return;
		var s = +t.get("itemSize"), c = t.get("orient") === "vertical", l = t.get("feature") || {}, u = this._features ||= {}, d = [];
		each(l, function(t, n) {
			d.push(n);
		}), new DataDiffer_default(this._featureNames || [], d).add(f).update(f).remove(curry(f, null)).execute(), this._featureNames = d;
		function f(o, s) {
			var c = d[o], f = d[s], h = l[c], g = new Model_default(h, t, t.ecModel), _;
			if (a && a.newTitle != null && a.featureName === c && (h.title = a.newTitle), c && !f) {
				if (isUserFeatureName(c)) _ = {
					onclick: g.option.onclick,
					featureName: c
				};
				else {
					var v = getFeature(c);
					if (!v) return;
					_ = new v();
				}
				u[c] = _;
			} else if (_ = u[f], !_) return;
			_.uid = getUID("toolbox-feature"), _.model = g, _.ecModel = n, _.api = r;
			var y = _ instanceof ToolboxFeature;
			if (!c && f) {
				y && _.dispose && _.dispose(n, r);
				return;
			}
			if (!g.get("show") || y && _.unusable) {
				y && _.remove && _.remove(n, r);
				return;
			}
			p(g, _, c), g.setIconStatus = function(t, n) {
				var r = this.option, a = this.iconPaths;
				r.iconStatus = r.iconStatus || {}, r.iconStatus[t] = n, a[t] && (n === "emphasis" ? enterEmphasis : leaveEmphasis)(a[t]);
			}, _ instanceof ToolboxFeature && _.render && _.render(g, n, r, a);
		}
		function p(a, l, u) {
			var d = a.getModel("iconStyle"), f = a.getModel(["emphasis", "iconStyle"]), p = l instanceof ToolboxFeature && l.getIcons ? l.getIcons() : a.get("icon"), h = a.get("title") || {}, g, _;
			isString(p) ? (g = {}, g[u] = p) : g = p, isString(h) ? (_ = {}, _[u] = h) : _ = h;
			var v = a.iconPaths = {};
			each(g, function(u, p) {
				var h = createIcon(u, {}, {
					x: -s / 2,
					y: -s / 2,
					width: s,
					height: s
				});
				h.setStyle(d.getItemStyle());
				var g = h.ensureState("emphasis");
				g.style = f.getItemStyle();
				var y = new Text_default({
					style: {
						text: _[p],
						align: f.get("textAlign"),
						borderRadius: f.get("textBorderRadius"),
						padding: f.get("textPadding"),
						fill: null,
						font: getFont({
							fontStyle: f.get("textFontStyle"),
							fontFamily: f.get("textFontFamily"),
							fontSize: f.get("textFontSize"),
							fontWeight: f.get("textFontWeight")
						}, n)
					},
					ignore: !0
				});
				h.setTextContent(y), setTooltipConfig({
					el: h,
					componentModel: t,
					itemName: p,
					formatterParamsExtra: { title: _[p] }
				}), h.__title = _[p], h.on("mouseover", function() {
					var n = f.getItemStyle(), a = c ? t.get("right") == null && t.get("left") !== "right" ? "right" : "left" : t.get("bottom") == null && t.get("top") !== "bottom" ? "bottom" : "top";
					y.setStyle({
						fill: f.get("textFill") || n.fill || n.stroke || "#000",
						backgroundColor: f.get("textBackgroundColor")
					}), h.setTextConfig({ position: f.get("textPosition") || a }), y.ignore = !t.get("showTitle"), r.enterEmphasis(this);
				}).on("mouseout", function() {
					a.get(["iconStatus", p]) !== "emphasis" && r.leaveEmphasis(this), y.hide();
				}), (a.get(["iconStatus", p]) === "emphasis" ? enterEmphasis : leaveEmphasis)(h), o.add(h), h.on("click", bind(l.onclick, l, n, r, p)), v[p] = h;
			});
		}
		layout(o, t, r), o.add(makeBackground(o.getBoundingRect(), t)), c || o.eachChild(function(t) {
			var n = t.__title, a = t.ensureState("emphasis"), c = a.textConfig ||= {}, l = t.getTextContent(), u = l && l.ensureState("emphasis");
			if (u && !isFunction(u) && n) {
				var d = u.style ||= {}, f = getBoundingRect(n, Text_default.makeFont(d)), p = t.x + o.x, h = t.y + o.y + s, g = !1;
				h + f.height > r.getHeight() && (c.position = "top", g = !0);
				var _ = g ? -5 - f.height : s + 10;
				p + f.width / 2 > r.getWidth() ? (c.position = ["100%", _], d.align = "right") : p - f.width / 2 < 0 && (c.position = [0, _], d.align = "left");
			}
		});
	}, n.prototype.updateView = function(t, n, r, a) {
		each(this._features, function(t) {
			t instanceof ToolboxFeature && t.updateView && t.updateView(t.model, n, r, a);
		});
	}, n.prototype.remove = function(t, n) {
		each(this._features, function(r) {
			r instanceof ToolboxFeature && r.remove && r.remove(t, n);
		}), this.group.removeAll();
	}, n.prototype.dispose = function(t, n) {
		each(this._features, function(r) {
			r instanceof ToolboxFeature && r.dispose && r.dispose(t, n);
		});
	}, n.type = "toolbox", n;
}(Component_default$1);
function isUserFeatureName(t) {
	return t.indexOf("my") === 0;
}
var ToolboxView_default = ToolboxView, SaveAsImage_default = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.onclick = function(t, n) {
		var r = this.model, a = r.get("name") || t.get("title.0.text") || "echarts", o = n.getZr().painter.getType() === "svg", s = o ? "svg" : r.get("type", !0) || "png", c = n.getConnectedDataURL({
			type: s,
			backgroundColor: r.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff",
			connectedBackgroundColor: r.get("connectedBackgroundColor"),
			excludeComponents: r.get("excludeComponents"),
			pixelRatio: r.get("pixelRatio")
		}), l = env_default.browser;
		if (typeof MouseEvent == "function" && (l.newEdge || !l.ie && !l.edge)) {
			var u = document.createElement("a");
			u.download = a + "." + s, u.target = "_blank", u.href = c;
			var d = new MouseEvent("click", {
				view: document.defaultView,
				bubbles: !0,
				cancelable: !1
			});
			u.dispatchEvent(d);
		} else if (window.navigator.msSaveOrOpenBlob || o) {
			var f = c.split(","), p = f[0].indexOf("base64") > -1, g = o ? decodeURIComponent(f[1]) : f[1];
			p && (g = window.atob(g));
			var _ = a + "." + s;
			if (window.navigator.msSaveOrOpenBlob) {
				for (var v = g.length, y = new Uint8Array(v); v--;) y[v] = g.charCodeAt(v);
				var b = new Blob([y]);
				window.navigator.msSaveOrOpenBlob(b, _);
			} else {
				var x = document.createElement("iframe");
				document.body.appendChild(x);
				var S = x.contentWindow, C = S.document;
				C.open("image/svg+xml", "replace"), C.write(g), C.close(), S.focus(), C.execCommand("SaveAs", !0, _), document.body.removeChild(x);
			}
		} else {
			var w = r.get("lang"), T = "<body style=\"margin:0;\"><img src=\"" + c + "\" style=\"max-width:100%;\" title=\"" + (w && w[0] || "") + "\" /></body>", E = window.open();
			E.document.write(T), E.document.title = a;
		}
	}, n.getDefaultOption = function(t) {
		return {
			show: !0,
			icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
			title: t.getLocaleModel().get([
				"toolbox",
				"saveAsImage",
				"title"
			]),
			type: "png",
			connectedBackgroundColor: "#fff",
			name: "",
			excludeComponents: ["toolbox"],
			lang: t.getLocaleModel().get([
				"toolbox",
				"saveAsImage",
				"lang"
			])
		};
	}, n;
}(ToolboxFeature), INNER_STACK_KEYWORD = "__ec_magicType_stack__", radioTypes = [["line", "bar"], ["stack"]], MagicType = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.getIcons = function() {
		var t = this.model, n = t.get("icon"), r = {};
		return each(t.get("type"), function(t) {
			n[t] && (r[t] = n[t]);
		}), r;
	}, n.getDefaultOption = function(t) {
		return {
			show: !0,
			type: [],
			icon: {
				line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
				bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
				stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
			},
			title: t.getLocaleModel().get([
				"toolbox",
				"magicType",
				"title"
			]),
			option: {},
			seriesIndex: {}
		};
	}, n.prototype.onclick = function(t, n, r) {
		var a = this.model, o = a.get(["seriesIndex", r]);
		if (seriesOptGenreator[r]) {
			var s = { series: [] };
			each(radioTypes, function(t) {
				indexOf(t, r) >= 0 && each(t, function(t) {
					a.setIconStatus(t, "normal");
				});
			}), a.setIconStatus(r, "emphasis"), t.eachComponent({
				mainType: "series",
				query: o == null ? null : { seriesIndex: o }
			}, function(t) {
				var n = t.subType, o = t.id, c = seriesOptGenreator[r](n, o, t, a);
				c && (defaults(c, t.option), s.series.push(c));
				var l = t.coordinateSystem;
				if (l && l.type === "cartesian2d" && (r === "line" || r === "bar")) {
					var u = l.getAxesByScale("ordinal")[0];
					if (u) {
						var d = u.dim + "Axis", f = t.getReferringComponents(d, SINGLE_REFERRING).models[0].componentIndex;
						s[d] = s[d] || [];
						for (var p = 0; p <= f; p++) s[d][f] = s[d][f] || {};
						s[d][f].boundaryGap = r === "bar";
					}
				}
			});
			var c, l = r;
			r === "stack" && (c = merge({
				stack: a.option.title.tiled,
				tiled: a.option.title.stack
			}, a.option.title), a.get(["iconStatus", r]) !== "emphasis" && (l = "tiled")), n.dispatchAction({
				type: "changeMagicType",
				currentType: l,
				newOption: s,
				newTitle: c,
				featureName: "magicType"
			});
		}
	}, n;
}(ToolboxFeature), seriesOptGenreator = {
	line: function(t, n, r, a) {
		if (t === "bar") return merge({
			id: n,
			type: "line",
			data: r.get("data"),
			stack: r.get("stack"),
			markPoint: r.get("markPoint"),
			markLine: r.get("markLine")
		}, a.get(["option", "line"]) || {}, !0);
	},
	bar: function(t, n, r, a) {
		if (t === "line") return merge({
			id: n,
			type: "bar",
			data: r.get("data"),
			stack: r.get("stack"),
			markPoint: r.get("markPoint"),
			markLine: r.get("markLine")
		}, a.get(["option", "bar"]) || {}, !0);
	},
	stack: function(t, n, r, a) {
		var o = r.get("stack") === INNER_STACK_KEYWORD;
		if (t === "line" || t === "bar") return a.setIconStatus("stack", o ? "normal" : "emphasis"), merge({
			id: n,
			stack: o ? "" : INNER_STACK_KEYWORD
		}, a.get(["option", "stack"]) || {}, !0);
	}
};
registerAction({
	type: "changeMagicType",
	event: "magicTypeChanged",
	update: "prepareAndUpdate"
}, function(t, n) {
	n.mergeOption(t.newOption);
});
var MagicType_default = MagicType;
init_dist$2();
var BLOCK_SPLITER = Array(60).join("-"), ITEM_SPLITER = "	";
function groupSeries(t) {
	var n = {}, r = [], a = [];
	return t.eachRawSeries(function(t) {
		var o = t.coordinateSystem;
		if (o && (o.type === "cartesian2d" || o.type === "polar")) {
			var s = o.getBaseAxis();
			if (s.type === "category") {
				var c = s.dim + "_" + s.index;
				n[c] || (n[c] = {
					categoryAxis: s,
					valueAxis: o.getOtherAxis(s),
					series: []
				}, a.push({
					axisDim: s.dim,
					axisIndex: s.index
				})), n[c].series.push(t);
			} else r.push(t);
		} else r.push(t);
	}), {
		seriesGroupByCategoryAxis: n,
		other: r,
		meta: a
	};
}
function assembleSeriesWithCategoryAxis(t) {
	var n = [];
	return each(t, function(t, r) {
		var a = t.categoryAxis, o = t.valueAxis.dim, s = [" "].concat(map(t.series, function(t) {
			return t.name;
		})), c = [a.model.getCategories()];
		each(t.series, function(t) {
			var n = t.getRawData();
			c.push(t.getRawData().mapArray(n.mapDimension(o), function(t) {
				return t;
			}));
		});
		for (var l = [s.join(ITEM_SPLITER)], u = 0; u < c[0].length; u++) {
			for (var d = [], f = 0; f < c.length; f++) d.push(c[f][u]);
			l.push(d.join(ITEM_SPLITER));
		}
		n.push(l.join("\n"));
	}), n.join("\n\n" + BLOCK_SPLITER + "\n\n");
}
function assembleOtherSeries(t) {
	return map(t, function(t) {
		var n = t.getRawData(), r = [t.name], a = [];
		return n.each(n.dimensions, function() {
			for (var t = arguments.length, o = arguments[t - 1], s = n.getName(o), c = 0; c < t - 1; c++) a[c] = arguments[c];
			r.push((s ? s + ITEM_SPLITER : "") + a.join(ITEM_SPLITER));
		}), r.join("\n");
	}).join("\n\n" + BLOCK_SPLITER + "\n\n");
}
function getContentFromModel(t) {
	var n = groupSeries(t);
	return {
		value: filter([assembleSeriesWithCategoryAxis(n.seriesGroupByCategoryAxis), assembleOtherSeries(n.other)], function(t) {
			return !!t.replace(/[\n\t\s]/g, "");
		}).join("\n\n" + BLOCK_SPLITER + "\n\n"),
		meta: n.meta
	};
}
function trim$1(t) {
	return t.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function isTSVFormat(t) {
	if (t.slice(0, t.indexOf("\n")).indexOf(ITEM_SPLITER) >= 0) return !0;
}
var itemSplitRegex = RegExp("[" + ITEM_SPLITER + "]+", "g");
function parseTSVContents(t) {
	for (var n = t.split(/\n+/g), r = trim$1(n.shift()).split(itemSplitRegex), a = [], o = map(r, function(t) {
		return {
			name: t,
			data: []
		};
	}), s = 0; s < n.length; s++) {
		var c = trim$1(n[s]).split(itemSplitRegex);
		a.push(c.shift());
		for (var l = 0; l < c.length; l++) o[l] && (o[l].data[s] = c[l]);
	}
	return {
		series: o,
		categories: a
	};
}
function parseListContents(t) {
	for (var n = t.split(/\n+/g), r = trim$1(n.shift()), a = [], o = 0; o < n.length; o++) {
		var s = trim$1(n[o]);
		if (s) {
			var c = s.split(itemSplitRegex), l = "", u = void 0, d = !1;
			isNaN(c[0]) ? (d = !0, l = c[0], c = c.slice(1), a[o] = {
				name: l,
				value: []
			}, u = a[o].value) : u = a[o] = [];
			for (var f = 0; f < c.length; f++) u.push(+c[f]);
			u.length === 1 && (d ? a[o].value = u[0] : a[o] = u[0]);
		}
	}
	return {
		name: r,
		data: a
	};
}
function parseContents(t, n) {
	var r = t.split(RegExp("\n*" + BLOCK_SPLITER + "\n*", "g")), a = { series: [] };
	return each(r, function(t, r) {
		if (isTSVFormat(t)) {
			var o = parseTSVContents(t), s = n[r], c = s.axisDim + "Axis";
			s && (a[c] = a[c] || [], a[c][s.axisIndex] = { data: o.categories }, a.series = a.series.concat(o.series));
		} else {
			var o = parseListContents(t);
			a.series.push(o);
		}
	}), a;
}
var DataView = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.onclick = function(t, n) {
		setTimeout(function() {
			n.dispatchAction({ type: "hideTip" });
		});
		var r = n.getDom(), a = this.model;
		this._dom && r.removeChild(this._dom);
		var o = document.createElement("div");
		o.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", o.style.backgroundColor = a.get("backgroundColor") || "#fff";
		var c = document.createElement("h4"), l = a.get("lang") || [];
		c.innerHTML = l[0] || a.get("title"), c.style.cssText = "margin:10px 20px", c.style.color = a.get("textColor");
		var u = document.createElement("div"), d = document.createElement("textarea");
		u.style.cssText = "overflow:auto";
		var f = a.get("optionToContent"), p = a.get("contentToOption"), h = getContentFromModel(t);
		if (isFunction(f)) {
			var g = f(n.getOption());
			isString(g) ? u.innerHTML = g : isDom(g) && u.appendChild(g);
		} else {
			d.readOnly = a.get("readOnly");
			var _ = d.style;
			_.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", _.color = a.get("textColor"), _.borderColor = a.get("textareaBorderColor"), _.backgroundColor = a.get("textareaColor"), d.value = h.value, u.appendChild(d);
		}
		var v = h.meta, y = document.createElement("div");
		y.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
		var b = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", x = document.createElement("div"), S = document.createElement("div");
		b += ";background-color:" + a.get("buttonColor"), b += ";color:" + a.get("buttonTextColor");
		var C = this;
		function w() {
			r.removeChild(o), C._dom = null;
		}
		addEventListener(x, "click", w), addEventListener(S, "click", function() {
			if (p == null && f != null || p != null && f == null) {
				process$1.env.NODE_ENV !== "production" && warn("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored."), w();
				return;
			}
			var t;
			try {
				t = isFunction(p) ? p(u, n.getOption()) : parseContents(d.value, v);
			} catch (t) {
				throw w(), Error("Data view format error " + t);
			}
			t && n.dispatchAction({
				type: "changeDataView",
				newOption: t
			}), w();
		}), x.innerHTML = l[1], S.innerHTML = l[2], S.style.cssText = x.style.cssText = b, !a.get("readOnly") && y.appendChild(S), y.appendChild(x), o.appendChild(c), o.appendChild(u), o.appendChild(y), u.style.height = r.clientHeight - 80 + "px", r.appendChild(o), this._dom = o;
	}, n.prototype.remove = function(t, n) {
		this._dom && n.getDom().removeChild(this._dom);
	}, n.prototype.dispose = function(t, n) {
		this.remove(t, n);
	}, n.getDefaultOption = function(t) {
		return {
			show: !0,
			readOnly: !1,
			optionToContent: null,
			contentToOption: null,
			icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
			title: t.getLocaleModel().get([
				"toolbox",
				"dataView",
				"title"
			]),
			lang: t.getLocaleModel().get([
				"toolbox",
				"dataView",
				"lang"
			]),
			backgroundColor: "#fff",
			textColor: "#000",
			textareaColor: "#fff",
			textareaBorderColor: "#333",
			buttonColor: "#c23531",
			buttonTextColor: "#fff"
		};
	}, n;
}(ToolboxFeature);
function tryMergeDataOption(t, n) {
	return map(t, function(t, r) {
		var a = n && n[r];
		if (isObject(a) && !isArray(a)) {
			isObject(t) && !isArray(t) || (t = { value: t });
			var o = a.name != null && t.name == null;
			return t = defaults(t, a), o && delete t.name, t;
		} else return t;
	});
}
registerAction({
	type: "changeDataView",
	event: "dataViewChanged",
	update: "prepareAndUpdate"
}, function(t, n) {
	var r = [];
	each(t.newOption.series, function(t) {
		var a = n.getSeriesByName(t.name)[0];
		if (!a) r.push(extend({ type: "scatter" }, t));
		else {
			var o = a.get("data");
			r.push({
				name: t.name,
				data: tryMergeDataOption(t.data, o)
			});
		}
	}), n.mergeOption(defaults({ series: r }, t.newOption));
});
var DataView_default = DataView, each$7 = each, inner$6 = makeInner();
function push(t, n) {
	var r = getStoreSnapshots(t);
	each$7(n, function(n, a) {
		for (var o = r.length - 1; o >= 0 && !r[o][a]; o--);
		if (o < 0) {
			var s = t.queryComponents({
				mainType: "dataZoom",
				subType: "select",
				id: a
			})[0];
			if (s) {
				var c = s.getPercentRange();
				r[0][a] = {
					dataZoomId: a,
					start: c[0],
					end: c[1]
				};
			}
		}
	}), r.push(n);
}
function pop(t) {
	var n = getStoreSnapshots(t), r = n[n.length - 1];
	n.length > 1 && n.pop();
	var a = {};
	return each$7(r, function(t, r) {
		for (var o = n.length - 1; o >= 0; o--) if (t = n[o][r], t) {
			a[r] = t;
			break;
		}
	}), a;
}
function clear$1(t) {
	inner$6(t).snapshots = null;
}
function count(t) {
	return getStoreSnapshots(t).length;
}
function getStoreSnapshots(t) {
	var n = inner$6(t);
	return n.snapshots ||= [{}], n.snapshots;
}
var RestoreOption = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.onclick = function(t, n) {
		clear$1(t), n.dispatchAction({
			type: "restore",
			from: this.uid
		});
	}, n.getDefaultOption = function(t) {
		return {
			show: !0,
			icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
			title: t.getLocaleModel().get([
				"toolbox",
				"restore",
				"title"
			])
		};
	}, n;
}(ToolboxFeature);
registerAction({
	type: "restore",
	event: "restore",
	update: "prepareAndUpdate"
}, function(t, n) {
	n.resetOption("recreate");
});
var Restore_default = RestoreOption;
init_dist$2();
var INCLUDE_FINDER_MAIN_TYPES = [
	"grid",
	"xAxis",
	"yAxis",
	"geo",
	"graph",
	"polar",
	"radiusAxis",
	"angleAxis",
	"bmap"
], BrushTargetManager = function() {
	function t(t, n, r) {
		var a = this;
		this._targetInfoList = [];
		var o = parseFinder$1(n, t);
		each(targetInfoBuilders, function(t, n) {
			(!r || !r.include || indexOf(r.include, n) >= 0) && t(o, a._targetInfoList);
		});
	}
	return t.prototype.setOutputRanges = function(t, n) {
		return this.matchOutputRanges(t, n, function(t, n, r) {
			if ((t.coordRanges ||= []).push(n), !t.coordRange) {
				t.coordRange = n;
				var a = coordConvert[t.brushType](0, r, n);
				t.__rangeOffset = {
					offset: diffProcessor[t.brushType](a.values, t.range, [1, 1]),
					xyMinMax: a.xyMinMax
				};
			}
		}), t;
	}, t.prototype.matchOutputRanges = function(t, n, r) {
		each(t, function(t) {
			var a = this.findTargetInfo(t, n);
			a && a !== !0 && each(a.coordSyses, function(a) {
				r(t, coordConvert[t.brushType](1, a, t.range, !0).values, a, n);
			});
		}, this);
	}, t.prototype.setInputRanges = function(t, n) {
		each(t, function(t) {
			var r = this.findTargetInfo(t, n);
			if (process$1.env.NODE_ENV !== "production" && (assert(!r || r === !0 || t.coordRange, "coordRange must be specified when coord index specified."), assert(!r || r !== !0 || t.range, "range must be specified in global brush.")), t.range = t.range || [], r && r !== !0) {
				t.panelId = r.panelId;
				var a = coordConvert[t.brushType](0, r.coordSys, t.coordRange), o = t.__rangeOffset;
				t.range = o ? diffProcessor[t.brushType](a.values, o.offset, getScales(a.xyMinMax, o.xyMinMax)) : a.values;
			}
		}, this);
	}, t.prototype.makePanelOpts = function(t, n) {
		return map(this._targetInfoList, function(r) {
			var a = r.getPanelRect();
			return {
				panelId: r.panelId,
				defaultBrushType: n ? n(r) : null,
				clipPath: makeRectPanelClipPath(a),
				isTargetByCursor: makeRectIsTargetByCursor(a, t, r.coordSysModel),
				getLinearBrushOtherExtent: makeLinearBrushOtherExtent(a)
			};
		});
	}, t.prototype.controlSeries = function(t, n, r) {
		var a = this.findTargetInfo(t, r);
		return a === !0 || a && indexOf(a.coordSyses, n.coordinateSystem) >= 0;
	}, t.prototype.findTargetInfo = function(t, n) {
		for (var r = this._targetInfoList, a = parseFinder$1(n, t), o = 0; o < r.length; o++) {
			var s = r[o], c = t.panelId;
			if (c) {
				if (s.panelId === c) return s;
			} else for (var l = 0; l < targetInfoMatchers.length; l++) if (targetInfoMatchers[l](a, s)) return s;
		}
		return !0;
	}, t;
}();
function formatMinMax(t) {
	return t[0] > t[1] && t.reverse(), t;
}
function parseFinder$1(t, n) {
	return parseFinder(t, n, { includeMainTypes: INCLUDE_FINDER_MAIN_TYPES });
}
var targetInfoBuilders = {
	grid: function(t, n) {
		var r = t.xAxisModels, a = t.yAxisModels, o = t.gridModels, s = createHashMap(), c = {}, l = {};
		!r && !a && !o || (each(r, function(t) {
			var n = t.axis.grid.model;
			s.set(n.id, n), c[n.id] = !0;
		}), each(a, function(t) {
			var n = t.axis.grid.model;
			s.set(n.id, n), l[n.id] = !0;
		}), each(o, function(t) {
			s.set(t.id, t), c[t.id] = !0, l[t.id] = !0;
		}), s.each(function(t) {
			var o = t.coordinateSystem, s = [];
			each(o.getCartesians(), function(t, n) {
				(indexOf(r, t.getAxis("x").model) >= 0 || indexOf(a, t.getAxis("y").model) >= 0) && s.push(t);
			}), n.push({
				panelId: "grid--" + t.id,
				gridModel: t,
				coordSysModel: t,
				coordSys: s[0],
				coordSyses: s,
				getPanelRect: panelRectBuilders.grid,
				xAxisDeclared: c[t.id],
				yAxisDeclared: l[t.id]
			});
		}));
	},
	geo: function(t, n) {
		each(t.geoModels, function(t) {
			var r = t.coordinateSystem;
			n.push({
				panelId: "geo--" + t.id,
				geoModel: t,
				coordSysModel: t,
				coordSys: r,
				coordSyses: [r],
				getPanelRect: panelRectBuilders.geo
			});
		});
	}
}, targetInfoMatchers = [function(t, n) {
	var r = t.xAxisModel, a = t.yAxisModel, o = t.gridModel;
	return !o && r && (o = r.axis.grid.model), !o && a && (o = a.axis.grid.model), o && o === n.gridModel;
}, function(t, n) {
	var r = t.geoModel;
	return r && r === n.geoModel;
}], panelRectBuilders = {
	grid: function() {
		return this.coordSys.master.getRect().clone();
	},
	geo: function() {
		var t = this.coordSys, n = t.getBoundingRect().clone();
		return n.applyTransform(getTransform$1(t)), n;
	}
}, coordConvert = {
	lineX: curry(axisConvert, 0),
	lineY: curry(axisConvert, 1),
	rect: function(t, n, r, a) {
		var o = t ? n.pointToData([r[0][0], r[1][0]], a) : n.dataToPoint([r[0][0], r[1][0]], a), s = t ? n.pointToData([r[0][1], r[1][1]], a) : n.dataToPoint([r[0][1], r[1][1]], a), c = [formatMinMax([o[0], s[0]]), formatMinMax([o[1], s[1]])];
		return {
			values: c,
			xyMinMax: c
		};
	},
	polygon: function(t, n, r, a) {
		var o = [[Infinity, -Infinity], [Infinity, -Infinity]];
		return {
			values: map(r, function(r) {
				var s = t ? n.pointToData(r, a) : n.dataToPoint(r, a);
				return o[0][0] = Math.min(o[0][0], s[0]), o[1][0] = Math.min(o[1][0], s[1]), o[0][1] = Math.max(o[0][1], s[0]), o[1][1] = Math.max(o[1][1], s[1]), s;
			}),
			xyMinMax: o
		};
	}
};
function axisConvert(t, n, r, a) {
	process$1.env.NODE_ENV !== "production" && assert(r.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
	var o = r.getAxis(["x", "y"][t]), c = formatMinMax(map([0, 1], function(t) {
		return n ? o.coordToData(o.toLocalCoord(a[t]), !0) : o.toGlobalCoord(o.dataToCoord(a[t]));
	})), l = [];
	return l[t] = c, l[1 - t] = [NaN, NaN], {
		values: c,
		xyMinMax: l
	};
}
var diffProcessor = {
	lineX: curry(axisDiffProcessor, 0),
	lineY: curry(axisDiffProcessor, 1),
	rect: function(t, n, r) {
		return [[t[0][0] - r[0] * n[0][0], t[0][1] - r[0] * n[0][1]], [t[1][0] - r[1] * n[1][0], t[1][1] - r[1] * n[1][1]]];
	},
	polygon: function(t, n, r) {
		return map(t, function(t, a) {
			return [t[0] - r[0] * n[a][0], t[1] - r[1] * n[a][1]];
		});
	}
};
function axisDiffProcessor(t, n, r, a) {
	return [n[0] - a[t] * r[0], n[1] - a[t] * r[1]];
}
function getScales(t, n) {
	var r = getSize(t), a = getSize(n), o = [r[0] / a[0], r[1] / a[1]];
	return isNaN(o[0]) && (o[0] = 1), isNaN(o[1]) && (o[1] = 1), o;
}
function getSize(t) {
	return t ? [t[0][1] - t[0][0], t[1][1] - t[1][0]] : [NaN, NaN];
}
var BrushTargetManager_default = BrushTargetManager, each$6 = each, DATA_ZOOM_ID_BASE = makeInternalComponentId("toolbox-dataZoom_"), DataZoomFeature = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.render = function(t, n, r, a) {
		this._brushController || (this._brushController = new BrushController_default(r.getZr()), this._brushController.on("brush", bind(this._onBrush, this)).mount()), updateZoomBtnStatus(t, n, this, a, r), updateBackBtnStatus(t, n);
	}, n.prototype.onclick = function(t, n, r) {
		handlers[r].call(this);
	}, n.prototype.remove = function(t, n) {
		this._brushController && this._brushController.unmount();
	}, n.prototype.dispose = function(t, n) {
		this._brushController && this._brushController.dispose();
	}, n.prototype._onBrush = function(t) {
		var n = t.areas;
		if (!t.isEnd || !n.length) return;
		var r = {}, a = this.ecModel;
		this._brushController.updateCovers([]), new BrushTargetManager_default(makeAxisFinder(this.model), a, { include: ["grid"] }).matchOutputRanges(n, a, function(t, n, r) {
			if (r.type === "cartesian2d") {
				var a = t.brushType;
				a === "rect" ? (o("x", r, n[0]), o("y", r, n[1])) : o({
					lineX: "x",
					lineY: "y"
				}[a], r, n);
			}
		}), push(a, r), this._dispatchZoomAction(r);
		function o(t, n, o) {
			var c = n.getAxis(t), l = c.model, u = s(t, l, a), d = u.findRepresentativeAxisProxy(l).getMinMaxSpan();
			(d.minValueSpan != null || d.maxValueSpan != null) && (o = sliderMove(0, o.slice(), c.scale.getExtent(), 0, d.minValueSpan, d.maxValueSpan)), u && (r[u.id] = {
				dataZoomId: u.id,
				startValue: o[0],
				endValue: o[1]
			});
		}
		function s(t, n, r) {
			var a;
			return r.eachComponent({
				mainType: "dataZoom",
				subType: "select"
			}, function(r) {
				r.getAxisModel(t, n.componentIndex) && (a = r);
			}), a;
		}
	}, n.prototype._dispatchZoomAction = function(t) {
		var n = [];
		each$6(t, function(t, r) {
			n.push(clone$1(t));
		}), n.length && this.api.dispatchAction({
			type: "dataZoom",
			from: this.uid,
			batch: n
		});
	}, n.getDefaultOption = function(t) {
		return {
			show: !0,
			filterMode: "filter",
			icon: {
				zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
				back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
			},
			title: t.getLocaleModel().get([
				"toolbox",
				"dataZoom",
				"title"
			]),
			brushStyle: {
				borderWidth: 0,
				color: "rgba(210,219,238,0.2)"
			}
		};
	}, n;
}(ToolboxFeature), handlers = {
	zoom: function() {
		var t = !this._isZoomActive;
		this.api.dispatchAction({
			type: "takeGlobalCursor",
			key: "dataZoomSelect",
			dataZoomSelectActive: t
		});
	},
	back: function() {
		this._dispatchZoomAction(pop(this.ecModel));
	}
};
function makeAxisFinder(t) {
	var n = {
		xAxisIndex: t.get("xAxisIndex", !0),
		yAxisIndex: t.get("yAxisIndex", !0),
		xAxisId: t.get("xAxisId", !0),
		yAxisId: t.get("yAxisId", !0)
	};
	return n.xAxisIndex == null && n.xAxisId == null && (n.xAxisIndex = "all"), n.yAxisIndex == null && n.yAxisId == null && (n.yAxisIndex = "all"), n;
}
function updateBackBtnStatus(t, n) {
	t.setIconStatus("back", count(n) > 1 ? "emphasis" : "normal");
}
function updateZoomBtnStatus(t, n, r, a, o) {
	var s = r._isZoomActive;
	a && a.type === "takeGlobalCursor" && (s = a.key === "dataZoomSelect" ? a.dataZoomSelectActive : !1), r._isZoomActive = s, t.setIconStatus("zoom", s ? "emphasis" : "normal");
	var c = new BrushTargetManager_default(makeAxisFinder(t), n, { include: ["grid"] }).makePanelOpts(o, function(t) {
		return t.xAxisDeclared && !t.yAxisDeclared ? "lineX" : !t.xAxisDeclared && t.yAxisDeclared ? "lineY" : "rect";
	});
	r._brushController.setPanels(c).enableBrush(s && c.length ? {
		brushType: "auto",
		brushStyle: t.getModel("brushStyle").getItemStyle()
	} : !1);
}
registerInternalOptionCreator("dataZoom", function(t) {
	var n = t.getComponent("toolbox", 0), r = ["feature", "dataZoom"];
	if (!n || n.get(r) == null) return;
	var a = n.getModel(r), o = [], s = parseFinder(t, makeAxisFinder(a));
	each$6(s.xAxisModels, function(t) {
		return c(t, "xAxis", "xAxisIndex");
	}), each$6(s.yAxisModels, function(t) {
		return c(t, "yAxis", "yAxisIndex");
	});
	function c(t, n, r) {
		var s = t.componentIndex, c = {
			type: "select",
			$fromToolbox: !0,
			filterMode: a.get("filterMode", !0) || "filter",
			id: DATA_ZOOM_ID_BASE + n + s
		};
		c[r] = s, o.push(c);
	}
	return o;
});
var DataZoom_default = DataZoomFeature;
function install$31(t) {
	t.registerComponentModel(ToolboxModel_default), t.registerComponentView(ToolboxView_default), registerFeature("saveAsImage", SaveAsImage_default), registerFeature("magicType", MagicType_default), registerFeature("dataView", DataView_default), registerFeature("dataZoom", DataZoom_default), registerFeature("restore", Restore_default), use(install$52);
}
var TooltipModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.type = "tooltip", n.dependencies = ["axisPointer"], n.defaultOption = {
		z: 60,
		show: !0,
		showContent: !0,
		trigger: "item",
		triggerOn: "mousemove|click",
		alwaysShowContent: !1,
		displayMode: "single",
		renderMode: "auto",
		confine: null,
		showDelay: 0,
		hideDelay: 100,
		transitionDuration: .4,
		enterable: !1,
		backgroundColor: "#fff",
		shadowBlur: 10,
		shadowColor: "rgba(0, 0, 0, .2)",
		shadowOffsetX: 1,
		shadowOffsetY: 2,
		borderRadius: 4,
		borderWidth: 1,
		padding: null,
		extraCssText: "",
		axisPointer: {
			type: "line",
			axis: "auto",
			animation: "auto",
			animationDurationUpdate: 200,
			animationEasingUpdate: "exponentialOut",
			crossStyle: {
				color: "#999",
				width: 1,
				type: "dashed",
				textStyle: {}
			}
		},
		textStyle: {
			color: "#666",
			fontSize: 14
		}
	}, n;
}(Component_default);
function shouldTooltipConfine(t) {
	var n = t.get("confine");
	return n == null ? t.get("renderMode") === "richText" : !!n;
}
function testStyle(t) {
	if (env_default.domSupported) {
		for (var n = document.documentElement.style, r = 0, a = t.length; r < a; r++) if (t[r] in n) return t[r];
	}
}
var TRANSFORM_VENDOR = testStyle([
	"transform",
	"webkitTransform",
	"OTransform",
	"MozTransform",
	"msTransform"
]), TRANSITION_VENDOR = testStyle([
	"webkitTransition",
	"transition",
	"OTransition",
	"MozTransition",
	"msTransition"
]);
function toCSSVendorPrefix(t, n) {
	if (!t) return n;
	n = toCamelCase(n, !0);
	var r = t.indexOf(n);
	return t = r === -1 ? n : "-" + t.slice(0, r) + "-" + n, t.toLowerCase();
}
function getComputedStyle(t, n) {
	var r = t.currentStyle || document.defaultView && document.defaultView.getComputedStyle(t);
	return r ? n ? r[n] : r : null;
}
var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition"), CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform"), gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (env_default.transform3dSupported ? "will-change:transform;" : "");
function mirrorPos(t) {
	return t = t === "left" ? "right" : t === "right" ? "left" : t === "top" ? "bottom" : "top", t;
}
function assembleArrow(t, n, r) {
	if (!isString(r) || r === "inside") return "";
	var a = t.get("backgroundColor"), o = t.get("borderWidth");
	n = convertToColorString(n);
	var s = mirrorPos(r), c = Math.max(Math.round(o) * 1.5, 6), l = "", u = CSS_TRANSFORM_VENDOR + ":", d;
	indexOf(["left", "right"], s) > -1 ? (l += "top:50%", u += "translateY(-50%) rotate(" + (d = s === "left" ? -225 : -45) + "deg)") : (l += "left:50%", u += "translateX(-50%) rotate(" + (d = s === "top" ? 225 : 45) + "deg)");
	var f = d * Math.PI / 180, p = c + o, h = p * Math.abs(Math.cos(f)) + p * Math.abs(Math.sin(f)), g = Math.round(((h - Math.SQRT2 * o) / 2 + Math.SQRT2 * o - (h - p) / 2) * 100) / 100;
	l += ";" + s + ":-" + g + "px";
	var _ = n + " solid " + o + "px;";
	return "<div style=\"" + [
		"position:absolute;width:" + c + "px;height:" + c + "px;z-index:-1;",
		l + ";" + u + ";",
		"border-bottom:" + _,
		"border-right:" + _,
		"background-color:" + a + ";"
	].join("") + "\"></div>";
}
function assembleTransition(t, n) {
	var r = "cubic-bezier(0.23,1,0.32,1)", a = " " + t / 2 + "s " + r, o = "opacity" + a + ",visibility" + a;
	return n || (a = " " + t + "s " + r, o += env_default.transformSupported ? "," + CSS_TRANSFORM_VENDOR + a : ",left" + a + ",top" + a), CSS_TRANSITION_VENDOR + ":" + o;
}
function assembleTransform(t, n, r) {
	var a = t.toFixed(0) + "px", o = n.toFixed(0) + "px";
	if (!env_default.transformSupported) return r ? "top:" + o + ";left:" + a + ";" : [["top", o], ["left", a]];
	var s = env_default.transform3dSupported, c = "translate" + (s ? "3d" : "") + "(" + a + "," + o + (s ? ",0" : "") + ")";
	return r ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + c + ";" : [
		["top", 0],
		["left", 0],
		[TRANSFORM_VENDOR, c]
	];
}
function assembleFont(t) {
	var n = [], r = t.get("fontSize"), a = t.getTextColor();
	a && n.push("color:" + a), n.push("font:" + t.getFont());
	var o = retrieve2(t.get("lineHeight"), Math.round(r * 3 / 2));
	r && n.push("line-height:" + o + "px");
	var s = t.get("textShadowColor"), c = t.get("textShadowBlur") || 0, l = t.get("textShadowOffsetX") || 0, u = t.get("textShadowOffsetY") || 0;
	return s && c && n.push("text-shadow:" + l + "px " + u + "px " + c + "px " + s), each(["decoration", "align"], function(r) {
		var a = t.get(r);
		a && n.push("text-" + r + ":" + a);
	}), n.join(";");
}
function assembleCssText(t, n, r) {
	var a = [], o = t.get("transitionDuration"), s = t.get("backgroundColor"), c = t.get("shadowBlur"), l = t.get("shadowColor"), u = t.get("shadowOffsetX"), d = t.get("shadowOffsetY"), f = t.getModel("textStyle"), p = getPaddingFromTooltipModel(t, "html"), h = u + "px " + d + "px " + c + "px " + l;
	return a.push("box-shadow:" + h), n && o && a.push(assembleTransition(o, r)), s && a.push("background-color:" + s), each([
		"width",
		"color",
		"radius"
	], function(n) {
		var r = "border-" + n, o = toCamelCase(r), s = t.get(o);
		s != null && a.push(r + ":" + s + (n === "color" ? "" : "px"));
	}), a.push(assembleFont(f)), p != null && a.push("padding:" + normalizeCssArray(p).join("px ") + "px"), a.join(";") + ";";
}
function makeStyleCoord$1(t, n, r, a, o) {
	var s = n && n.painter;
	if (r) {
		var c = s && s.getViewportRoot();
		c && transformLocalCoord(t, c, r, a, o);
	} else {
		t[0] = a, t[1] = o;
		var l = s && s.getViewportRootOffset();
		l && (t[0] += l.offsetLeft, t[1] += l.offsetTop);
	}
	t[2] = t[0] / n.getWidth(), t[3] = t[1] / n.getHeight();
}
var TooltipHTMLContent_default = function() {
	function t(t, n) {
		if (this._show = !1, this._styleCoord = [
			0,
			0,
			0,
			0
		], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, env_default.wxa) return null;
		var r = document.createElement("div");
		r.domBelongToZr = !0, this.el = r;
		var a = this._zr = t.getZr(), o = n.appendTo, s = o && (isString(o) ? document.querySelector(o) : isDom(o) ? o : isFunction(o) && o(t.getDom()));
		makeStyleCoord$1(this._styleCoord, a, s, t.getWidth() / 2, t.getHeight() / 2), (s || t.getDom()).appendChild(r), this._api = t, this._container = s;
		var c = this;
		r.onmouseenter = function() {
			c._enterable && (clearTimeout(c._hideTimeout), c._show = !0), c._inContent = !0;
		}, r.onmousemove = function(t) {
			if (t ||= window.event, !c._enterable) {
				var n = a.handler;
				normalizeEvent(a.painter.getViewportRoot(), t, !0), n.dispatch("mousemove", t);
			}
		}, r.onmouseleave = function() {
			c._inContent = !1, c._enterable && c._show && c.hideLater(c._hideDelay);
		};
	}
	return t.prototype.update = function(t) {
		if (!this._container) {
			var n = this._api.getDom(), r = getComputedStyle(n, "position"), a = n.style;
			a.position !== "absolute" && r !== "absolute" && (a.position = "relative");
		}
		var o = t.get("alwaysShowContent");
		o && this._moveIfResized(), this._alwaysShowContent = o, this.el.className = t.get("className") || "";
	}, t.prototype.show = function(t, n) {
		clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
		var r = this.el, a = r.style, o = this._styleCoord;
		r.innerHTML ? a.cssText = gCssText + assembleCssText(t, !this._firstShow, this._longHide) + assembleTransform(o[0], o[1], !0) + ("border-color:" + convertToColorString(n) + ";") + (t.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : a.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
	}, t.prototype.setContent = function(t, n, r, a, o) {
		var s = this.el;
		if (t == null) {
			s.innerHTML = "";
			return;
		}
		var c = "";
		if (isString(o) && r.get("trigger") === "item" && !shouldTooltipConfine(r) && (c = assembleArrow(r, a, o)), isString(t)) s.innerHTML = t + c;
		else if (t) {
			s.innerHTML = "", isArray(t) || (t = [t]);
			for (var l = 0; l < t.length; l++) isDom(t[l]) && t[l].parentNode !== s && s.appendChild(t[l]);
			if (c && s.childNodes.length) {
				var u = document.createElement("div");
				u.innerHTML = c, s.appendChild(u);
			}
		}
	}, t.prototype.setEnterable = function(t) {
		this._enterable = t;
	}, t.prototype.getSize = function() {
		var t = this.el;
		return t ? [t.offsetWidth, t.offsetHeight] : [0, 0];
	}, t.prototype.moveTo = function(t, n) {
		if (this.el) {
			var r = this._styleCoord;
			if (makeStyleCoord$1(r, this._zr, this._container, t, n), r[0] != null && r[1] != null) {
				var a = this.el.style;
				each(assembleTransform(r[0], r[1]), function(t) {
					a[t[0]] = t[1];
				});
			}
		}
	}, t.prototype._moveIfResized = function() {
		var t = this._styleCoord[2], n = this._styleCoord[3];
		this.moveTo(t * this._zr.getWidth(), n * this._zr.getHeight());
	}, t.prototype.hide = function() {
		var t = this, n = this.el.style;
		n.visibility = "hidden", n.opacity = "0", env_default.transform3dSupported && (n.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
			return t._longHide = !0;
		}, 500);
	}, t.prototype.hideLater = function(t) {
		this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(bind(this.hide, this), t)) : this.hide());
	}, t.prototype.isShow = function() {
		return this._show;
	}, t.prototype.dispose = function() {
		clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
		var t = this.el.parentNode;
		t && t.removeChild(this.el), this.el = this._container = null;
	}, t;
}();
init_dist$2();
var TooltipRichContent = function() {
	function t(t) {
		this._show = !1, this._styleCoord = [
			0,
			0,
			0,
			0
		], this._alwaysShowContent = !1, this._enterable = !0, this._zr = t.getZr(), makeStyleCoord(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2);
	}
	return t.prototype.update = function(t) {
		var n = t.get("alwaysShowContent");
		n && this._moveIfResized(), this._alwaysShowContent = n;
	}, t.prototype.show = function() {
		this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
	}, t.prototype.setContent = function(t, n, r, a, o) {
		var c = this;
		isObject(t) && throwError(process$1.env.NODE_ENV === "production" ? "" : "Passing DOM nodes as content is not supported in richText tooltip!"), this.el && this._zr.remove(this.el);
		var l = r.getModel("textStyle");
		this.el = new Text_default({
			style: {
				rich: n.richTextStyles,
				text: t,
				lineHeight: 22,
				borderWidth: 1,
				borderColor: a,
				textShadowColor: l.get("textShadowColor"),
				fill: r.get(["textStyle", "color"]),
				padding: getPaddingFromTooltipModel(r, "richText"),
				verticalAlign: "top",
				align: "left"
			},
			z: r.get("z")
		}), each([
			"backgroundColor",
			"borderRadius",
			"shadowColor",
			"shadowBlur",
			"shadowOffsetX",
			"shadowOffsetY"
		], function(t) {
			c.el.style[t] = r.get(t);
		}), each([
			"textShadowBlur",
			"textShadowOffsetX",
			"textShadowOffsetY"
		], function(t) {
			c.el.style[t] = l.get(t) || 0;
		}), this._zr.add(this.el);
		var u = this;
		this.el.on("mouseover", function() {
			u._enterable && (clearTimeout(u._hideTimeout), u._show = !0), u._inContent = !0;
		}), this.el.on("mouseout", function() {
			u._enterable && u._show && u.hideLater(u._hideDelay), u._inContent = !1;
		});
	}, t.prototype.setEnterable = function(t) {
		this._enterable = t;
	}, t.prototype.getSize = function() {
		var t = this.el, n = this.el.getBoundingRect(), r = calcShadowOuterSize(t.style);
		return [n.width + r.left + r.right, n.height + r.top + r.bottom];
	}, t.prototype.moveTo = function(t, n) {
		var r = this.el;
		if (r) {
			var a = this._styleCoord;
			makeStyleCoord(a, this._zr, t, n), t = a[0], n = a[1];
			var o = r.style, s = mathMaxWith0(o.borderWidth || 0), c = calcShadowOuterSize(o);
			r.x = t + s + c.left, r.y = n + s + c.top, r.markRedraw();
		}
	}, t.prototype._moveIfResized = function() {
		var t = this._styleCoord[2], n = this._styleCoord[3];
		this.moveTo(t * this._zr.getWidth(), n * this._zr.getHeight());
	}, t.prototype.hide = function() {
		this.el && this.el.hide(), this._show = !1;
	}, t.prototype.hideLater = function(t) {
		this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(bind(this.hide, this), t)) : this.hide());
	}, t.prototype.isShow = function() {
		return this._show;
	}, t.prototype.dispose = function() {
		this._zr.remove(this.el);
	}, t;
}();
function mathMaxWith0(t) {
	return Math.max(0, t);
}
function calcShadowOuterSize(t) {
	var n = mathMaxWith0(t.shadowBlur || 0), r = mathMaxWith0(t.shadowOffsetX || 0), a = mathMaxWith0(t.shadowOffsetY || 0);
	return {
		left: mathMaxWith0(n - r),
		right: mathMaxWith0(n + r),
		top: mathMaxWith0(n - a),
		bottom: mathMaxWith0(n + a)
	};
}
function makeStyleCoord(t, n, r, a) {
	t[0] = r, t[1] = a, t[2] = t[0] / n.getWidth(), t[3] = t[1] / n.getHeight();
}
var TooltipRichContent_default = TooltipRichContent, proxyRect = new Rect_default({ shape: {
	x: -1,
	y: -1,
	width: 2,
	height: 2
} }), TooltipView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.init = function(t, n) {
		if (!(env_default.node || !n.getDom())) {
			var r = t.getComponent("tooltip");
			this._tooltipContent = (this._renderMode = getTooltipRenderMode(r.get("renderMode"))) === "richText" ? new TooltipRichContent_default(n) : new TooltipHTMLContent_default(n, { appendTo: r.get("appendToBody", !0) ? "body" : r.get("appendTo", !0) });
		}
	}, n.prototype.render = function(t, n, r) {
		if (!(env_default.node || !r.getDom())) {
			this.group.removeAll(), this._tooltipModel = t, this._ecModel = n, this._api = r;
			var a = this._tooltipContent;
			a.update(t), a.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && t.get("transitionDuration") ? createOrUpdate(this, "_updatePosition", 50, "fixRate") : clear(this, "_updatePosition");
		}
	}, n.prototype._initGlobalListener = function() {
		var t = this._tooltipModel.get("triggerOn");
		register("itemTooltip", this._api, bind(function(n, r, a) {
			t !== "none" && (t.indexOf(n) >= 0 ? this._tryShow(r, a) : n === "leave" && this._hide(a));
		}, this));
	}, n.prototype._keepShow = function() {
		var t = this._tooltipModel, n = this._ecModel, r = this._api, a = t.get("triggerOn");
		if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
			var o = this;
			clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
				!r.isDisposed() && o.manuallyShowTip(t, n, r, {
					x: o._lastX,
					y: o._lastY,
					dataByCoordSys: o._lastDataByCoordSys
				});
			});
		}
	}, n.prototype.manuallyShowTip = function(t, n, r, a) {
		if (!(a.from === this.uid || env_default.node || !r.getDom())) {
			var o = makeDispatchAction(a, r);
			this._ticket = "";
			var s = a.dataByCoordSys, c = findComponentReference(a, n, r);
			if (c) {
				var l = c.el.getBoundingRect().clone();
				l.applyTransform(c.el.transform), this._tryShow({
					offsetX: l.x + l.width / 2,
					offsetY: l.y + l.height / 2,
					target: c.el,
					position: a.position,
					positionDefault: "bottom"
				}, o);
			} else if (a.tooltip && a.x != null && a.y != null) {
				var u = proxyRect;
				u.x = a.x, u.y = a.y, u.update(), getECData(u).tooltipConfig = {
					name: null,
					option: a.tooltip
				}, this._tryShow({
					offsetX: a.x,
					offsetY: a.y,
					target: u
				}, o);
			} else if (s) this._tryShow({
				offsetX: a.x,
				offsetY: a.y,
				position: a.position,
				dataByCoordSys: s,
				tooltipOption: a.tooltipOption
			}, o);
			else if (a.seriesIndex != null) {
				if (this._manuallyAxisShowTip(t, n, r, a)) return;
				var d = findPointFromSeries(a, n), f = d.point[0], p = d.point[1];
				f != null && p != null && this._tryShow({
					offsetX: f,
					offsetY: p,
					target: d.el,
					position: a.position,
					positionDefault: "bottom"
				}, o);
			} else a.x != null && a.y != null && (r.dispatchAction({
				type: "updateAxisPointer",
				x: a.x,
				y: a.y
			}), this._tryShow({
				offsetX: a.x,
				offsetY: a.y,
				position: a.position,
				target: r.getZr().findHover(a.x, a.y).target
			}, o));
		}
	}, n.prototype.manuallyHideTip = function(t, n, r, a) {
		var o = this._tooltipContent;
		this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(makeDispatchAction(a, r));
	}, n.prototype._manuallyAxisShowTip = function(t, n, r, a) {
		var o = a.seriesIndex, s = a.dataIndex, c = n.getComponent("axisPointer").coordSysAxesInfo;
		if (!(o == null || s == null || c == null)) {
			var l = n.getSeriesByIndex(o);
			if (l && buildTooltipModel([
				l.getData().getItemModel(s),
				l,
				(l.coordinateSystem || {}).model
			], this._tooltipModel).get("trigger") === "axis") return r.dispatchAction({
				type: "updateAxisPointer",
				seriesIndex: o,
				dataIndex: s,
				position: a.position
			}), !0;
		}
	}, n.prototype._tryShow = function(t, n) {
		var r = t.target;
		if (this._tooltipModel) {
			this._lastX = t.offsetX, this._lastY = t.offsetY;
			var a = t.dataByCoordSys;
			if (a && a.length) this._showAxisTooltip(a, t);
			else if (r) {
				if (getECData(r).ssrType === "legend") return;
				this._lastDataByCoordSys = null;
				var o, s;
				findEventDispatcher(r, function(t) {
					if (getECData(t).dataIndex != null) return o = t, !0;
					if (getECData(t).tooltipConfig != null) return s = t, !0;
				}, !0), o ? this._showSeriesItemTooltip(t, o, n) : s ? this._showComponentItemTooltip(t, s, n) : this._hide(n);
			} else this._lastDataByCoordSys = null, this._hide(n);
		}
	}, n.prototype._showOrMove = function(t, n) {
		var r = t.get("showDelay");
		n = bind(n, this), clearTimeout(this._showTimout), r > 0 ? this._showTimout = setTimeout(n, r) : n();
	}, n.prototype._showAxisTooltip = function(t, n) {
		var r = this._ecModel, a = this._tooltipModel, o = [n.offsetX, n.offsetY], s = buildTooltipModel([n.tooltipOption], a), c = this._renderMode, l = [], u = createTooltipMarkup("section", {
			blocks: [],
			noHeader: !0
		}), d = [], f = new TooltipMarkupStyleCreator();
		each(t, function(t) {
			each(t.dataByAxis, function(t) {
				var n = r.getComponent(t.axisDim + "Axis", t.axisIndex), o = t.value;
				if (!(!n || o == null)) {
					var s = getValueLabel(o, n.axis, r, t.seriesDataIndices, t.valueLabelOpt), p = createTooltipMarkup("section", {
						header: s,
						noHeader: !trim(s),
						sortBlocks: !0,
						blocks: []
					});
					u.blocks.push(p), each(t.seriesDataIndices, function(u) {
						var h = r.getSeriesByIndex(u.seriesIndex), g = u.dataIndexInside, _ = h.getDataParams(g);
						if (!(_.dataIndex < 0)) {
							_.axisDim = t.axisDim, _.axisIndex = t.axisIndex, _.axisType = t.axisType, _.axisId = t.axisId, _.axisValue = getAxisRawValue(n.axis, { value: o }), _.axisValueLabel = s, _.marker = f.makeTooltipMarker("item", convertToColorString(_.color), c);
							var v = normalizeTooltipFormatResult(h.formatTooltip(g, !0, null)), y = v.frag;
							if (y) {
								var b = buildTooltipModel([h], a).get("valueFormatter");
								p.blocks.push(b ? extend({ valueFormatter: b }, y) : y);
							}
							v.text && d.push(v.text), l.push(_);
						}
					});
				}
			});
		}), u.blocks.reverse(), d.reverse();
		var p = n.position, h = buildTooltipMarkup(u, f, c, s.get("order"), r.get("useUTC"), s.get("textStyle"));
		h && d.unshift(h);
		var g = c === "richText" ? "\n\n" : "<br/>", _ = d.join(g);
		this._showOrMove(s, function() {
			this._updateContentNotChangedOnAxis(t, l) ? this._updatePosition(s, p, o[0], o[1], this._tooltipContent, l) : this._showTooltipContent(s, _, l, Math.random() + "", o[0], o[1], p, null, f);
		});
	}, n.prototype._showSeriesItemTooltip = function(t, n, r) {
		var a = this._ecModel, o = getECData(n), s = o.seriesIndex, c = a.getSeriesByIndex(s), l = o.dataModel || c, u = o.dataIndex, d = o.dataType, f = l.getData(d), p = this._renderMode, h = t.positionDefault, g = buildTooltipModel([
			f.getItemModel(u),
			l,
			c && (c.coordinateSystem || {}).model
		], this._tooltipModel, h ? { position: h } : null), _ = g.get("trigger");
		if (!(_ != null && _ !== "item")) {
			var v = l.getDataParams(u, d), y = new TooltipMarkupStyleCreator();
			v.marker = y.makeTooltipMarker("item", convertToColorString(v.color), p);
			var b = normalizeTooltipFormatResult(l.formatTooltip(u, !1, d)), x = g.get("order"), S = g.get("valueFormatter"), C = b.frag, w = C ? buildTooltipMarkup(S ? extend({ valueFormatter: S }, C) : C, y, p, x, a.get("useUTC"), g.get("textStyle")) : b.text, T = "item_" + l.name + "_" + u;
			this._showOrMove(g, function() {
				this._showTooltipContent(g, w, v, T, t.offsetX, t.offsetY, t.position, t.target, y);
			}), r({
				type: "showTip",
				dataIndexInside: u,
				dataIndex: f.getRawIndex(u),
				seriesIndex: s,
				from: this.uid
			});
		}
	}, n.prototype._showComponentItemTooltip = function(t, n, r) {
		var a = this._renderMode === "html", o = getECData(n), s = o.tooltipConfig.option || {}, c = s.encodeHTMLContent;
		if (isString(s)) {
			var l = s;
			s = {
				content: l,
				formatter: l
			}, c = !0;
		}
		c && a && s.content && (s = clone$1(s), s.content = encodeHTML(s.content));
		var u = [s], d = this._ecModel.getComponent(o.componentMainType, o.componentIndex);
		d && u.push(d), u.push({ formatter: s.content });
		var f = t.positionDefault, p = buildTooltipModel(u, this._tooltipModel, f ? { position: f } : null), h = p.get("content"), g = Math.random() + "", _ = new TooltipMarkupStyleCreator();
		this._showOrMove(p, function() {
			var r = clone$1(p.get("formatterParams") || {});
			this._showTooltipContent(p, h, r, g, t.offsetX, t.offsetY, t.position, n, _);
		}), r({
			type: "showTip",
			from: this.uid
		});
	}, n.prototype._showTooltipContent = function(t, n, r, a, o, s, c, l, u) {
		if (this._ticket = "", !(!t.get("showContent") || !t.get("show"))) {
			var d = this._tooltipContent;
			d.setEnterable(t.get("enterable"));
			var f = t.get("formatter");
			c ||= t.get("position");
			var p = n, h = this._getNearestPoint([o, s], r, t.get("trigger"), t.get("borderColor")).color;
			if (f) if (isString(f)) {
				var g = t.ecModel.get("useUTC"), _ = isArray(r) ? r[0] : r, v = _ && _.axisType && _.axisType.indexOf("time") >= 0;
				p = f, v && (p = format(_.axisValue, p, g)), p = formatTpl(p, r, !0);
			} else if (isFunction(f)) {
				var y = bind(function(n, a) {
					n === this._ticket && (d.setContent(a, u, t, h, c), this._updatePosition(t, c, o, s, d, r, l));
				}, this);
				this._ticket = a, p = f(r, a, y);
			} else p = f;
			d.setContent(p, u, t, h, c), d.show(t, h), this._updatePosition(t, c, o, s, d, r, l);
		}
	}, n.prototype._getNearestPoint = function(t, n, r, a) {
		if (r === "axis" || isArray(n)) return { color: a || (this._renderMode === "html" ? "#fff" : "none") };
		if (!isArray(n)) return { color: a || n.color || n.borderColor };
	}, n.prototype._updatePosition = function(t, n, r, a, o, s, c) {
		var l = this._api.getWidth(), u = this._api.getHeight();
		n ||= t.get("position");
		var d = o.getSize(), f = t.get("align"), p = t.get("verticalAlign"), h = c && c.getBoundingRect().clone();
		if (c && h.applyTransform(c.transform), isFunction(n) && (n = n([r, a], s, o.el, h, {
			viewSize: [l, u],
			contentSize: d.slice()
		})), isArray(n)) r = parsePercent$1(n[0], l), a = parsePercent$1(n[1], u);
		else if (isObject(n)) {
			var g = n;
			g.width = d[0], g.height = d[1];
			var _ = getLayoutRect(g, {
				width: l,
				height: u
			});
			r = _.x, a = _.y, f = null, p = null;
		} else if (isString(n) && c) {
			var v = calcTooltipPosition(n, h, d, t.get("borderWidth"));
			r = v[0], a = v[1];
		} else {
			var v = refixTooltipPosition(r, a, o, l, u, f ? null : 20, p ? null : 20);
			r = v[0], a = v[1];
		}
		if (f && (r -= isCenterAlign(f) ? d[0] / 2 : f === "right" ? d[0] : 0), p && (a -= isCenterAlign(p) ? d[1] / 2 : p === "bottom" ? d[1] : 0), shouldTooltipConfine(t)) {
			var v = confineTooltipPosition(r, a, o, l, u);
			r = v[0], a = v[1];
		}
		o.moveTo(r, a);
	}, n.prototype._updateContentNotChangedOnAxis = function(t, n) {
		var r = this._lastDataByCoordSys, a = this._cbParamsList, o = !!r && r.length === t.length;
		return o && each(r, function(r, s) {
			var c = r.dataByAxis || [], l = (t[s] || {}).dataByAxis || [];
			o &&= c.length === l.length, o && each(c, function(t, r) {
				var s = l[r] || {}, c = t.seriesDataIndices || [], u = s.seriesDataIndices || [];
				o = o && t.value === s.value && t.axisType === s.axisType && t.axisId === s.axisId && c.length === u.length, o && each(c, function(t, n) {
					var r = u[n];
					o = o && t.seriesIndex === r.seriesIndex && t.dataIndex === r.dataIndex;
				}), a && each(t.seriesDataIndices, function(t) {
					var r = t.seriesIndex, s = n[r], c = a[r];
					s && c && c.data !== s.data && (o = !1);
				});
			});
		}), this._lastDataByCoordSys = t, this._cbParamsList = n, !!o;
	}, n.prototype._hide = function(t) {
		this._lastDataByCoordSys = null, t({
			type: "hideTip",
			from: this.uid
		});
	}, n.prototype.dispose = function(t, n) {
		env_default.node || !n.getDom() || (clear(this, "_updatePosition"), this._tooltipContent.dispose(), unregister("itemTooltip", n));
	}, n.type = "tooltip", n;
}(Component_default$1);
function buildTooltipModel(t, n, r) {
	var a = n.ecModel, o;
	r ? (o = new Model_default(r, a, a), o = new Model_default(n.option, o, a)) : o = n;
	for (var s = t.length - 1; s >= 0; s--) {
		var c = t[s];
		c && (c instanceof Model_default && (c = c.get("tooltip", !0)), isString(c) && (c = { formatter: c }), c && (o = new Model_default(c, o, a)));
	}
	return o;
}
function makeDispatchAction(t, n) {
	return t.dispatchAction || bind(n.dispatchAction, n);
}
function refixTooltipPosition(t, n, r, a, o, s, c) {
	var l = r.getSize(), u = l[0], d = l[1];
	return s != null && (t + u + s + 2 > a ? t -= u + s : t += s), c != null && (n + d + c > o ? n -= d + c : n += c), [t, n];
}
function confineTooltipPosition(t, n, r, a, o) {
	var s = r.getSize(), c = s[0], l = s[1];
	return t = Math.min(t + c, a) - c, n = Math.min(n + l, o) - l, t = Math.max(t, 0), n = Math.max(n, 0), [t, n];
}
function calcTooltipPosition(t, n, r, a) {
	var o = r[0], s = r[1], c = Math.ceil(Math.SQRT2 * a) + 8, l = 0, u = 0, d = n.width, f = n.height;
	switch (t) {
		case "inside":
			l = n.x + d / 2 - o / 2, u = n.y + f / 2 - s / 2;
			break;
		case "top":
			l = n.x + d / 2 - o / 2, u = n.y - s - c;
			break;
		case "bottom":
			l = n.x + d / 2 - o / 2, u = n.y + f + c;
			break;
		case "left":
			l = n.x - o - c, u = n.y + f / 2 - s / 2;
			break;
		case "right": l = n.x + d + c, u = n.y + f / 2 - s / 2;
	}
	return [l, u];
}
function isCenterAlign(t) {
	return t === "center" || t === "middle";
}
function findComponentReference(t, n, r) {
	var a = preParseFinder(t).queryOptionMap, o = a.keys()[0];
	if (!(!o || o === "series")) {
		var s = queryReferringComponents(n, o, a.get(o), {
			useDefault: !1,
			enableAll: !1,
			enableNone: !1
		}).models[0];
		if (s) {
			var c = r.getViewOfComponentModel(s), l;
			if (c.group.traverse(function(n) {
				var r = getECData(n).tooltipConfig;
				if (r && r.name === t.name) return l = n, !0;
			}), l) return {
				componentMainType: o,
				componentIndex: s.componentIndex,
				el: l
			};
		}
	}
}
var TooltipView_default = TooltipView;
function install$32(t) {
	use(install$33), t.registerComponentModel(TooltipModel_default), t.registerComponentView(TooltipView_default), t.registerAction({
		type: "showTip",
		event: "showTip",
		update: "tooltip:manuallyShowTip"
	}, noop), t.registerAction({
		type: "hideTip",
		event: "hideTip",
		update: "tooltip:manuallyHideTip"
	}, noop);
}
var DEFAULT_TOOLBOX_BTNS = [
	"rect",
	"polygon",
	"keep",
	"clear"
];
function brushPreprocessor(t, n) {
	var r = normalizeToArray(t ? t.brush : []);
	if (r.length) {
		var a = [];
		each(r, function(t) {
			var n = t.hasOwnProperty("toolbox") ? t.toolbox : [];
			n instanceof Array && (a = a.concat(n));
		});
		var o = t && t.toolbox;
		isArray(o) && (o = o[0]), o || (o = { feature: {} }, t.toolbox = [o]);
		var s = o.feature ||= {}, c = s.brush ||= {}, l = c.type ||= [];
		l.push.apply(l, a), removeDuplicate(l), n && !l.length && l.push.apply(l, DEFAULT_TOOLBOX_BTNS);
	}
}
function removeDuplicate(t) {
	var n = {};
	each(t, function(t) {
		n[t] = 1;
	}), t.length = 0, each(n, function(n, r) {
		t.push(r);
	});
}
var each$5 = each;
function hasKeys(t) {
	if (t) {
		for (var n in t) if (t.hasOwnProperty(n)) return !0;
	}
}
function createVisualMappings(t, n, r) {
	var a = {};
	return each$5(n, function(n) {
		var s = a[n] = o();
		each$5(t[n], function(t, a) {
			if (VisualMapping_default.isValidType(a)) {
				var o = {
					type: a,
					visual: t
				};
				r && r(o, n), s[a] = new VisualMapping_default(o), a === "opacity" && (o = clone$1(o), o.type = "colorAlpha", s.__hidden.__alphaForOpacity = new VisualMapping_default(o));
			}
		});
	}), a;
	function o() {
		var t = function() {};
		return t.prototype.__hidden = t.prototype, new t();
	}
}
function replaceVisualOption(t, n, r) {
	var a;
	each(r, function(t) {
		n.hasOwnProperty(t) && hasKeys(n[t]) && (a = !0);
	}), a && each(r, function(r) {
		n.hasOwnProperty(r) && hasKeys(n[r]) ? t[r] = clone$1(n[r]) : delete t[r];
	});
}
function applyVisual(t, n, r, a, o, s) {
	var c = {};
	each(t, function(t) {
		c[t] = VisualMapping_default.prepareVisualTypes(n[t]);
	});
	var l;
	function u(t) {
		return getItemVisualFromData(r, l, t);
	}
	function d(t, n) {
		setItemVisualFromData(r, l, t, n);
	}
	s == null ? r.each(f) : r.each([s], f);
	function f(t, f) {
		l = s == null ? t : f;
		var p = r.getRawDataItem(l);
		if (!(p && p.visualMap === !1)) for (var h = a.call(o, t), g = n[h], _ = c[h], v = 0, y = _.length; v < y; v++) {
			var b = _[v];
			g[b] && g[b].applyVisual(t, u, d);
		}
	}
}
function incrementalApplyVisual(t, n, r, a) {
	var o = {};
	return each(t, function(t) {
		o[t] = VisualMapping_default.prepareVisualTypes(n[t]);
	}), { progress: function(t, s) {
		var c;
		a != null && (c = s.getDimensionIndex(a));
		function l(t) {
			return getItemVisualFromData(s, d, t);
		}
		function u(t, n) {
			setItemVisualFromData(s, d, t, n);
		}
		for (var d, f = s.getStore(); (d = t.next()) != null;) {
			var p = s.getRawDataItem(d);
			if (!(p && p.visualMap === !1)) for (var h = a == null ? d : f.get(c, d), g = r(h), _ = n[g], v = o[g], y = 0, b = v.length; y < b; y++) {
				var x = v[y];
				_[x] && _[x].applyVisual(h, l, u);
			}
		}
	} };
}
function makeBrushCommonSelectorForSeries(t) {
	var n = t.brushType, r = {
		point: function(a) {
			return selector[n].point(a, r, t);
		},
		rect: function(a) {
			return selector[n].rect(a, r, t);
		}
	};
	return r;
}
var selector = {
	lineX: getLineSelectors(0),
	lineY: getLineSelectors(1),
	rect: {
		point: function(t, n, r) {
			return t && r.boundingRect.contain(t[0], t[1]);
		},
		rect: function(t, n, r) {
			return t && r.boundingRect.intersect(t);
		}
	},
	polygon: {
		point: function(t, n, r) {
			return t && r.boundingRect.contain(t[0], t[1]) && contain(r.range, t[0], t[1]);
		},
		rect: function(t, n, r) {
			var a = r.range;
			if (!t || a.length <= 1) return !1;
			var o = t.x, s = t.y, c = t.width, l = t.height, u = a[0];
			if (contain(a, o, s) || contain(a, o + c, s) || contain(a, o, s + l) || contain(a, o + c, s + l) || BoundingRect_default.create(t).contain(u[0], u[1]) || linePolygonIntersect(o, s, o + c, s, a) || linePolygonIntersect(o, s, o, s + l, a) || linePolygonIntersect(o + c, s, o + c, s + l, a) || linePolygonIntersect(o, s + l, o + c, s + l, a)) return !0;
		}
	}
};
function getLineSelectors(t) {
	var n = ["x", "y"], r = ["width", "height"];
	return {
		point: function(n, r, a) {
			if (n) {
				var o = a.range, s = n[t];
				return inLineRange(s, o);
			}
		},
		rect: function(a, o, s) {
			if (a) {
				var c = s.range, l = [a[n[t]], a[n[t]] + a[r[t]]];
				return l[1] < l[0] && l.reverse(), inLineRange(l[0], c) || inLineRange(l[1], c) || inLineRange(c[0], l) || inLineRange(c[1], l);
			}
		}
	};
}
function inLineRange(t, n) {
	return n[0] <= t && t <= n[1];
}
var STATE_LIST = ["inBrush", "outOfBrush"], DISPATCH_METHOD = "__ecBrushSelect", DISPATCH_FLAG = "__ecInBrushSelectEvent";
function layoutCovers(t) {
	t.eachComponent({ mainType: "brush" }, function(n) {
		(n.brushTargetManager = new BrushTargetManager_default(n.option, t)).setInputRanges(n.areas, t);
	});
}
function brushVisual(t, n, r) {
	var a = [], o, s;
	t.eachComponent({ mainType: "brush" }, function(t) {
		r && r.type === "takeGlobalCursor" && t.setBrushOption(r.key === "brush" ? r.brushOption : { brushType: !1 });
	}), layoutCovers(t), t.eachComponent({ mainType: "brush" }, function(n, r) {
		var c = {
			brushId: n.id,
			brushIndex: r,
			brushName: n.name,
			areas: clone$1(n.areas),
			selected: []
		};
		a.push(c);
		var l = n.option, u = l.brushLink, d = [], f = [], p = [], h = !1;
		r || (o = l.throttleType, s = l.throttleDelay);
		var g = map(n.areas, function(t) {
			var n = boundingRectBuilders[t.brushType], r = defaults({ boundingRect: n ? n(t) : void 0 }, t);
			return r.selectors = makeBrushCommonSelectorForSeries(r), r;
		}), _ = createVisualMappings(n.option, STATE_LIST, function(t) {
			t.mappingMethod = "fixed";
		});
		isArray(u) && each(u, function(t) {
			d[t] = 1;
		});
		function v(t) {
			return u === "all" || !!d[t];
		}
		function y(t) {
			return !!t.length;
		}
		t.eachSeries(function(t, n) {
			var r = p[n] = [];
			t.subType === "parallel" ? b(t, n) : x(t, n, r);
		});
		function b(t, n) {
			var r = t.coordinateSystem;
			h ||= r.hasAxisBrushed(), v(n) && r.eachActiveState(t.getData(), function(t, n) {
				t === "active" && (f[n] = 1);
			});
		}
		function x(r, a, o) {
			if (!(!r.brushSelector || brushModelNotControll(n, a)) && (each(g, function(a) {
				n.brushTargetManager.controlSeries(a, r, t) && o.push(a), h ||= y(o);
			}), v(a) && y(o))) {
				var s = r.getData();
				s.each(function(t) {
					checkInRange(r, o, s, t) && (f[t] = 1);
				});
			}
		}
		t.eachSeries(function(t, n) {
			var r = {
				seriesId: t.id,
				seriesIndex: n,
				seriesName: t.name,
				dataIndex: []
			};
			c.selected.push(r);
			var a = p[n], o = t.getData(), s = v(n) ? function(t) {
				return f[t] ? (r.dataIndex.push(o.getRawIndex(t)), "inBrush") : "outOfBrush";
			} : function(n) {
				return checkInRange(t, a, o, n) ? (r.dataIndex.push(o.getRawIndex(n)), "inBrush") : "outOfBrush";
			};
			(v(n) ? h : y(a)) && applyVisual(STATE_LIST, _, o, s);
		});
	}), dispatchAction$1(n, o, s, a, r);
}
function dispatchAction$1(t, n, r, a, o) {
	if (o) {
		var s = t.getZr();
		s[DISPATCH_FLAG] || (s[DISPATCH_METHOD] || (s[DISPATCH_METHOD] = doDispatch), createOrUpdate(s, DISPATCH_METHOD, r, n)(t, a));
	}
}
function doDispatch(t, n) {
	if (!t.isDisposed()) {
		var r = t.getZr();
		r[DISPATCH_FLAG] = !0, t.dispatchAction({
			type: "brushSelect",
			batch: n
		}), r[DISPATCH_FLAG] = !1;
	}
}
function checkInRange(t, n, r, a) {
	for (var o = 0, s = n.length; o < s; o++) {
		var c = n[o];
		if (t.brushSelector(a, r, c.selectors, c)) return !0;
	}
}
function brushModelNotControll(t, n) {
	var r = t.option.seriesIndex;
	return r != null && r !== "all" && (isArray(r) ? indexOf(r, n) < 0 : n !== r);
}
var boundingRectBuilders = {
	rect: function(t) {
		return getBoundingRectFromMinMax(t.range);
	},
	polygon: function(t) {
		for (var n, r = t.range, a = 0, o = r.length; a < o; a++) {
			n ||= [[Infinity, -Infinity], [Infinity, -Infinity]];
			var s = r[a];
			s[0] < n[0][0] && (n[0][0] = s[0]), s[0] > n[0][1] && (n[0][1] = s[0]), s[1] < n[1][0] && (n[1][0] = s[1]), s[1] > n[1][1] && (n[1][1] = s[1]);
		}
		return n && getBoundingRectFromMinMax(n);
	}
};
function getBoundingRectFromMinMax(t) {
	return new BoundingRect_default(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0]);
}
var BrushView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.init = function(t, n) {
		this.ecModel = t, this.api = n, this.model, (this._brushController = new BrushController_default(n.getZr())).on("brush", bind(this._onBrush, this)).mount();
	}, n.prototype.render = function(t, n, r, a) {
		this.model = t, this._updateController(t, n, r, a);
	}, n.prototype.updateTransform = function(t, n, r, a) {
		layoutCovers(n), this._updateController(t, n, r, a);
	}, n.prototype.updateVisual = function(t, n, r, a) {
		this.updateTransform(t, n, r, a);
	}, n.prototype.updateView = function(t, n, r, a) {
		this._updateController(t, n, r, a);
	}, n.prototype._updateController = function(t, n, r, a) {
		(!a || a.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(r)).enableBrush(t.brushOption).updateCovers(t.areas.slice());
	}, n.prototype.dispose = function() {
		this._brushController.dispose();
	}, n.prototype._onBrush = function(t) {
		var n = this.model.id, r = this.model.brushTargetManager.setOutputRanges(t.areas, this.ecModel);
		(!t.isEnd || t.removeOnClick) && this.api.dispatchAction({
			type: "brush",
			brushId: n,
			areas: clone$1(r),
			$from: n
		}), t.isEnd && this.api.dispatchAction({
			type: "brushEnd",
			brushId: n,
			areas: clone$1(r),
			$from: n
		});
	}, n.type = "brush", n;
}(Component_default$1);
init_dist$2();
var DEFAULT_OUT_OF_BRUSH_COLOR = "#ddd", BrushModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.areas = [], r.brushOption = {}, r;
	}
	return n.prototype.optionUpdated = function(t, n) {
		var r = this.option;
		!n && replaceVisualOption(r, t, ["inBrush", "outOfBrush"]);
		var a = r.inBrush = r.inBrush || {};
		r.outOfBrush = r.outOfBrush || { color: DEFAULT_OUT_OF_BRUSH_COLOR }, a.hasOwnProperty("liftZ") || (a.liftZ = 5);
	}, n.prototype.setAreas = function(t) {
		process$1.env.NODE_ENV !== "production" && (assert(isArray(t)), each(t, function(t) {
			assert(t.brushType, "Illegal areas");
		})), t && (this.areas = map(t, function(t) {
			return generateBrushOption(this.option, t);
		}, this));
	}, n.prototype.setBrushOption = function(t) {
		this.brushOption = generateBrushOption(this.option, t), this.brushType = this.brushOption.brushType;
	}, n.type = "brush", n.dependencies = [
		"geo",
		"grid",
		"xAxis",
		"yAxis",
		"parallel",
		"series"
	], n.defaultOption = {
		seriesIndex: "all",
		brushType: "rect",
		brushMode: "single",
		transformable: !0,
		brushStyle: {
			borderWidth: 1,
			color: "rgba(210,219,238,0.3)",
			borderColor: "#D2DBEE"
		},
		throttleType: "fixRate",
		throttleDelay: 0,
		removeOnClick: !0,
		z: 1e4
	}, n;
}(Component_default);
function generateBrushOption(t, n) {
	return merge({
		brushType: t.brushType,
		brushMode: t.brushMode,
		transformable: t.transformable,
		brushStyle: new Model_default(t.brushStyle).getItemStyle(),
		removeOnClick: t.removeOnClick,
		z: t.z
	}, n, !0);
}
var BrushModel_default = BrushModel, ICON_TYPES = [
	"rect",
	"polygon",
	"lineX",
	"lineY",
	"keep",
	"clear"
], Brush_default = function(t) {
	__extends(n, t);
	function n() {
		return t !== null && t.apply(this, arguments) || this;
	}
	return n.prototype.render = function(t, n, r) {
		var a, o, s;
		n.eachComponent({ mainType: "brush" }, function(t) {
			a = t.brushType, o = t.brushOption.brushMode || "single", s ||= !!t.areas.length;
		}), this._brushType = a, this._brushMode = o, each(t.get("type", !0), function(n) {
			t.setIconStatus(n, (n === "keep" ? o === "multiple" : n === "clear" ? s : n === a) ? "emphasis" : "normal");
		});
	}, n.prototype.updateView = function(t, n, r) {
		this.render(t, n, r);
	}, n.prototype.getIcons = function() {
		var t = this.model, n = t.get("icon", !0), r = {};
		return each(t.get("type", !0), function(t) {
			n[t] && (r[t] = n[t]);
		}), r;
	}, n.prototype.onclick = function(t, n, r) {
		var a = this._brushType, o = this._brushMode;
		r === "clear" ? (n.dispatchAction({
			type: "axisAreaSelect",
			intervals: []
		}), n.dispatchAction({
			type: "brush",
			command: "clear",
			areas: []
		})) : n.dispatchAction({
			type: "takeGlobalCursor",
			key: "brush",
			brushOption: {
				brushType: r === "keep" ? a : a === r ? !1 : r,
				brushMode: r === "keep" ? o === "multiple" ? "single" : "multiple" : o
			}
		});
	}, n.getDefaultOption = function(t) {
		return {
			show: !0,
			type: ICON_TYPES.slice(),
			icon: {
				rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
				polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
				lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
				lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
				keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
				clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
			},
			title: t.getLocaleModel().get([
				"toolbox",
				"brush",
				"title"
			])
		};
	}, n;
}(ToolboxFeature);
function install$34(t) {
	t.registerComponentView(BrushView_default), t.registerComponentModel(BrushModel_default), t.registerPreprocessor(brushPreprocessor), t.registerVisual(t.PRIORITY.VISUAL.BRUSH, brushVisual), t.registerAction({
		type: "brush",
		event: "brush",
		update: "updateVisual"
	}, function(t, n) {
		n.eachComponent({
			mainType: "brush",
			query: t
		}, function(n) {
			n.setAreas(t.areas);
		});
	}), t.registerAction({
		type: "brushSelect",
		event: "brushSelected",
		update: "none"
	}, noop), t.registerAction({
		type: "brushEnd",
		event: "brushEnd",
		update: "none"
	}, noop), registerFeature("brush", Brush_default);
}
var TitleModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.layoutMode = {
			type: "box",
			ignoreSize: !0
		}, r;
	}
	return n.type = "title", n.defaultOption = {
		z: 6,
		show: !0,
		text: "",
		target: "blank",
		subtext: "",
		subtarget: "blank",
		left: 0,
		top: 0,
		backgroundColor: "rgba(0,0,0,0)",
		borderColor: "#ccc",
		borderWidth: 0,
		padding: 5,
		itemGap: 10,
		textStyle: {
			fontSize: 18,
			fontWeight: "bold",
			color: "#464646"
		},
		subtextStyle: {
			fontSize: 12,
			color: "#6E7079"
		}
	}, n;
}(Component_default), TitleView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.render = function(t, n, r) {
		if (this.group.removeAll(), t.get("show")) {
			var a = this.group, o = t.getModel("textStyle"), s = t.getModel("subtextStyle"), c = t.get("textAlign"), l = retrieve2(t.get("textBaseline"), t.get("textVerticalAlign")), u = new Text_default({
				style: createTextStyle(o, {
					text: t.get("text"),
					fill: o.getTextColor()
				}, { disableBox: !0 }),
				z2: 10
			}), d = u.getBoundingRect(), f = t.get("subtext"), p = new Text_default({
				style: createTextStyle(s, {
					text: f,
					fill: s.getTextColor(),
					y: d.height + t.get("itemGap"),
					verticalAlign: "top"
				}, { disableBox: !0 }),
				z2: 10
			}), h = t.get("link"), g = t.get("sublink"), _ = t.get("triggerEvent", !0);
			u.silent = !h && !_, p.silent = !g && !_, h && u.on("click", function() {
				windowOpen(h, "_" + t.get("target"));
			}), g && p.on("click", function() {
				windowOpen(g, "_" + t.get("subtarget"));
			}), getECData(u).eventData = getECData(p).eventData = _ ? {
				componentType: "title",
				componentIndex: t.componentIndex
			} : null, a.add(u), f && a.add(p);
			var v = a.getBoundingRect(), y = t.getBoxLayoutParams();
			y.width = v.width, y.height = v.height;
			var b = getLayoutRect(y, {
				width: r.getWidth(),
				height: r.getHeight()
			}, t.get("padding"));
			c || (c = t.get("left") || t.get("right"), c === "middle" && (c = "center"), c === "right" ? b.x += b.width : c === "center" && (b.x += b.width / 2)), l || (l = t.get("top") || t.get("bottom"), l === "center" && (l = "middle"), l === "bottom" ? b.y += b.height : l === "middle" && (b.y += b.height / 2), l ||= "top"), a.x = b.x, a.y = b.y, a.markRedraw();
			var x = {
				align: c,
				verticalAlign: l
			};
			u.setStyle(x), p.setStyle(x), v = a.getBoundingRect();
			var S = b.margin, C = t.getItemStyle(["color", "opacity"]);
			C.fill = t.get("backgroundColor");
			var w = new Rect_default({
				shape: {
					x: v.x - S[3],
					y: v.y - S[0],
					width: v.width + S[1] + S[3],
					height: v.height + S[0] + S[2],
					r: t.get("borderRadius")
				},
				style: C,
				subPixelOptimize: !0,
				silent: !0
			});
			a.add(w);
		}
	}, n.type = "title", n;
}(Component_default$1);
function install$35(t) {
	t.registerComponentModel(TitleModel), t.registerComponentView(TitleView);
}
var TimelineModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.layoutMode = "box", r;
	}
	return n.prototype.init = function(t, n, r) {
		this.mergeDefaultAndTheme(t, r), this._initData();
	}, n.prototype.mergeOption = function(n) {
		t.prototype.mergeOption.apply(this, arguments), this._initData();
	}, n.prototype.setCurrentIndex = function(t) {
		t ??= this.option.currentIndex;
		var n = this._data.count();
		this.option.loop ? t = (t % n + n) % n : (t >= n && (t = n - 1), t < 0 && (t = 0)), this.option.currentIndex = t;
	}, n.prototype.getCurrentIndex = function() {
		return this.option.currentIndex;
	}, n.prototype.isIndexMax = function() {
		return this.getCurrentIndex() >= this._data.count() - 1;
	}, n.prototype.setPlayState = function(t) {
		this.option.autoPlay = !!t;
	}, n.prototype.getPlayState = function() {
		return !!this.option.autoPlay;
	}, n.prototype._initData = function() {
		var t = this.option, n = t.data || [], r = t.axisType, a = this._names = [], o;
		r === "category" ? (o = [], each(n, function(t, n) {
			var r = convertOptionIdName(getDataItemValue(t), ""), s;
			isObject(t) ? (s = clone$1(t), s.value = n) : s = n, o.push(s), a.push(r);
		})) : o = n, (this._data = new SeriesData_default([{
			name: "value",
			type: {
				category: "ordinal",
				time: "time",
				value: "number"
			}[r] || "number"
		}], this)).initData(o, a);
	}, n.prototype.getData = function() {
		return this._data;
	}, n.prototype.getCategories = function() {
		if (this.get("axisType") === "category") return this._names.slice();
	}, n.type = "timeline", n.defaultOption = {
		z: 4,
		show: !0,
		axisType: "time",
		realtime: !0,
		left: "20%",
		top: null,
		right: "20%",
		bottom: 0,
		width: null,
		height: 40,
		padding: 5,
		controlPosition: "left",
		autoPlay: !1,
		rewind: !1,
		loop: !0,
		playInterval: 2e3,
		currentIndex: 0,
		itemStyle: {},
		label: { color: "#000" },
		data: []
	}, n;
}(Component_default), SliderTimelineModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.type = "timeline.slider", n.defaultOption = inheritDefaultOption(TimelineModel_default.defaultOption, {
		backgroundColor: "rgba(0,0,0,0)",
		borderColor: "#ccc",
		borderWidth: 0,
		orient: "horizontal",
		inverse: !1,
		tooltip: { trigger: "item" },
		symbol: "circle",
		symbolSize: 12,
		lineStyle: {
			show: !0,
			width: 2,
			color: "#DAE1F5"
		},
		label: {
			position: "auto",
			show: !0,
			interval: "auto",
			rotate: 0,
			color: "#A4B1D7"
		},
		itemStyle: {
			color: "#A4B1D7",
			borderWidth: 1
		},
		checkpointStyle: {
			symbol: "circle",
			symbolSize: 15,
			color: "#316bf3",
			borderColor: "#fff",
			borderWidth: 2,
			shadowBlur: 2,
			shadowOffsetX: 1,
			shadowOffsetY: 1,
			shadowColor: "rgba(0, 0, 0, 0.3)",
			animation: !0,
			animationDuration: 300,
			animationEasing: "quinticInOut"
		},
		controlStyle: {
			show: !0,
			showPlayBtn: !0,
			showPrevBtn: !0,
			showNextBtn: !0,
			itemSize: 24,
			itemGap: 12,
			position: "left",
			playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
			stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
			nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
			prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
			prevBtnSize: 18,
			nextBtnSize: 18,
			color: "#A4B1D7",
			borderColor: "#A4B1D7",
			borderWidth: 1
		},
		emphasis: {
			label: {
				show: !0,
				color: "#6f778d"
			},
			itemStyle: { color: "#316BF3" },
			controlStyle: {
				color: "#316BF3",
				borderColor: "#316BF3",
				borderWidth: 2
			}
		},
		progress: {
			lineStyle: { color: "#316BF3" },
			itemStyle: { color: "#316BF3" },
			label: { color: "#6f778d" }
		},
		data: []
	}), n;
}(TimelineModel_default);
mixin(SliderTimelineModel, DataFormatMixin.prototype);
var SliderTimelineModel_default = SliderTimelineModel, TimelineView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.type = "timeline", n;
}(Component_default$1), TimelineAxis_default = function(t) {
	__extends(n, t);
	function n(n, r, a, o) {
		var s = t.call(this, n, r, a) || this;
		return s.type = o || "value", s;
	}
	return n.prototype.getLabelModel = function() {
		return this.model.getModel("label");
	}, n.prototype.isHorizontal = function() {
		return this.model.get("orient") === "horizontal";
	}, n;
}(Axis_default), PI = Math.PI, labelDataIndexStore = makeInner(), SliderTimelineView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.init = function(t, n) {
		this.api = n;
	}, n.prototype.render = function(t, n, r) {
		if (this.model = t, this.api = r, this.ecModel = n, this.group.removeAll(), t.get("show", !0)) {
			var a = this._layout(t, r), o = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), c = this._axis = this._createAxis(a, t);
			t.formatTooltip = function(t) {
				return createTooltipMarkup("nameValue", {
					noName: !0,
					value: c.scale.getLabel({ value: t })
				});
			}, each([
				"AxisLine",
				"AxisTick",
				"Control",
				"CurrentPointer"
			], function(n) {
				this["_render" + n](a, o, c, t);
			}, this), this._renderAxisLabel(a, s, c, t), this._position(a, t);
		}
		this._doPlayStop(), this._updateTicksStatus();
	}, n.prototype.remove = function() {
		this._clearTimer(), this.group.removeAll();
	}, n.prototype.dispose = function() {
		this._clearTimer();
	}, n.prototype._layout = function(t, n) {
		var r = t.get(["label", "position"]), a = t.get("orient"), o = getViewRect(t, n), s = r == null || r === "auto" ? a === "horizontal" ? o.y + o.height / 2 < n.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < n.getWidth() / 2 ? "+" : "-" : isString(r) ? {
			horizontal: {
				top: "-",
				bottom: "+"
			},
			vertical: {
				left: "-",
				right: "+"
			}
		}[a][r] : r, c = {
			horizontal: "center",
			vertical: s >= 0 || s === "+" ? "left" : "right"
		}, l = {
			horizontal: s >= 0 || s === "+" ? "top" : "bottom",
			vertical: "middle"
		}, u = {
			horizontal: 0,
			vertical: PI / 2
		}, d = a === "vertical" ? o.height : o.width, f = t.getModel("controlStyle"), p = f.get("show", !0), h = p ? f.get("itemSize") : 0, g = p ? f.get("itemGap") : 0, _ = h + g, v = t.get(["label", "rotate"]) || 0;
		v = v * PI / 180;
		var y, b, x, S = f.get("position", !0), C = p && f.get("showPlayBtn", !0), w = p && f.get("showPrevBtn", !0), T = p && f.get("showNextBtn", !0), E = 0, D = d;
		S === "left" || S === "bottom" ? (C && (y = [0, 0], E += _), w && (b = [E, 0], E += _), T && (x = [D - h, 0], D -= _)) : (C && (y = [D - h, 0], D -= _), w && (b = [0, 0], E += _), T && (x = [D - h, 0], D -= _));
		var O = [E, D];
		return t.get("inverse") && O.reverse(), {
			viewRect: o,
			mainLength: d,
			orient: a,
			rotation: u[a],
			labelRotation: v,
			labelPosOpt: s,
			labelAlign: t.get(["label", "align"]) || c[a],
			labelBaseline: t.get(["label", "verticalAlign"]) || t.get(["label", "baseline"]) || l[a],
			playPosition: y,
			prevBtnPosition: b,
			nextBtnPosition: x,
			axisExtent: O,
			controlSize: h,
			controlGap: g
		};
	}, n.prototype._position = function(t, n) {
		var r = this._mainGroup, a = this._labelGroup, o = t.viewRect;
		if (t.orient === "vertical") {
			var s = create$2(), c = o.x, l = o.y + o.height;
			translate(s, s, [-c, -l]), rotate(s, s, -PI / 2), translate(s, s, [c, l]), o = o.clone(), o.applyTransform(s);
		}
		var u = y(o), d = y(r.getBoundingRect()), f = y(a.getBoundingRect()), p = [r.x, r.y], h = [a.x, a.y];
		h[0] = p[0] = u[0][0];
		var g = t.labelPosOpt;
		if (g == null || isString(g)) {
			var _ = g === "+" ? 0 : 1;
			b(p, d, u, 1, _), b(h, f, u, 1, 1 - _);
		} else {
			var _ = g >= 0 ? 0 : 1;
			b(p, d, u, 1, _), h[1] = p[1] + g;
		}
		r.setPosition(p), a.setPosition(h), r.rotation = a.rotation = t.rotation, v(r), v(a);
		function v(t) {
			t.originX = u[0][0] - t.x, t.originY = u[1][0] - t.y;
		}
		function y(t) {
			return [[t.x, t.x + t.width], [t.y, t.y + t.height]];
		}
		function b(t, n, r, a, o) {
			t[a] += r[a][o] - n[a][o];
		}
	}, n.prototype._createAxis = function(t, n) {
		var r = n.getData(), a = n.get("axisType"), o = createScaleByModel(n, a);
		o.getTicks = function() {
			return r.mapArray(["value"], function(t) {
				return { value: t };
			});
		};
		var s = r.getDataExtent("value");
		o.setExtent(s[0], s[1]), o.calcNiceTicks();
		var c = new TimelineAxis_default("value", o, t.axisExtent, a);
		return c.model = n, c;
	}, n.prototype._createGroup = function(t) {
		var n = this[t] = new Group_default();
		return this.group.add(n), n;
	}, n.prototype._renderAxisLine = function(t, n, r, a) {
		var o = r.getExtent();
		if (a.get(["lineStyle", "show"])) {
			var s = new Line_default$1({
				shape: {
					x1: o[0],
					y1: 0,
					x2: o[1],
					y2: 0
				},
				style: extend({ lineCap: "round" }, a.getModel("lineStyle").getLineStyle()),
				silent: !0,
				z2: 1
			});
			n.add(s);
			var c = this._progressLine = new Line_default$1({
				shape: {
					x1: o[0],
					x2: this._currentPointer ? this._currentPointer.x : o[0],
					y1: 0,
					y2: 0
				},
				style: defaults({
					lineCap: "round",
					lineWidth: s.style.lineWidth
				}, a.getModel(["progress", "lineStyle"]).getLineStyle()),
				silent: !0,
				z2: 1
			});
			n.add(c);
		}
	}, n.prototype._renderAxisTick = function(t, n, r, a) {
		var o = this, s = a.getData(), c = r.scale.getTicks();
		this._tickSymbols = [], each(c, function(t) {
			var c = r.dataToCoord(t.value), l = s.getItemModel(t.value), u = l.getModel("itemStyle"), d = l.getModel(["emphasis", "itemStyle"]), f = l.getModel(["progress", "itemStyle"]), p = giveSymbol(l, u, n, {
				x: c,
				y: 0,
				onclick: bind(o._changeTimeline, o, t.value)
			});
			p.ensureState("emphasis").style = d.getItemStyle(), p.ensureState("progress").style = f.getItemStyle(), enableHoverEmphasis(p);
			var h = getECData(p);
			l.get("tooltip") ? (h.dataIndex = t.value, h.dataModel = a) : h.dataIndex = h.dataModel = null, o._tickSymbols.push(p);
		});
	}, n.prototype._renderAxisLabel = function(t, n, r, a) {
		var o = this;
		if (r.getLabelModel().get("show")) {
			var s = a.getData(), c = r.getViewLabels();
			this._tickLabels = [], each(c, function(a) {
				var c = a.tickValue, l = s.getItemModel(c), u = l.getModel("label"), d = l.getModel(["emphasis", "label"]), f = l.getModel(["progress", "label"]), p = new Text_default({
					x: r.dataToCoord(a.tickValue),
					y: 0,
					rotation: t.labelRotation - t.rotation,
					onclick: bind(o._changeTimeline, o, c),
					silent: !1,
					style: createTextStyle(u, {
						text: a.formattedLabel,
						align: t.labelAlign,
						verticalAlign: t.labelBaseline
					})
				});
				p.ensureState("emphasis").style = createTextStyle(d), p.ensureState("progress").style = createTextStyle(f), n.add(p), enableHoverEmphasis(p), labelDataIndexStore(p).dataIndex = c, o._tickLabels.push(p);
			});
		}
	}, n.prototype._renderControl = function(t, n, r, a) {
		var o = t.controlSize, s = t.rotation, c = a.getModel("controlStyle").getItemStyle(), l = a.getModel(["emphasis", "controlStyle"]).getItemStyle(), u = a.getPlayState(), d = a.get("inverse", !0);
		f(t.nextBtnPosition, "next", bind(this._changeTimeline, this, d ? "-" : "+")), f(t.prevBtnPosition, "prev", bind(this._changeTimeline, this, d ? "+" : "-")), f(t.playPosition, u ? "stop" : "play", bind(this._handlePlayClick, this, !u), !0);
		function f(t, r, u, d) {
			if (t) {
				var f = parsePercent(retrieve2(a.get(["controlStyle", r + "BtnSize"]), o), o), p = [
					0,
					-f / 2,
					f,
					f
				], h = makeControlIcon(a, r + "Icon", p, {
					x: t[0],
					y: t[1],
					originX: o / 2,
					originY: 0,
					rotation: d ? -s : 0,
					rectHover: !0,
					style: c,
					onclick: u
				});
				h.ensureState("emphasis").style = l, n.add(h), enableHoverEmphasis(h);
			}
		}
	}, n.prototype._renderCurrentPointer = function(t, n, r, a) {
		var o = a.getData(), s = a.getCurrentIndex(), c = o.getItemModel(s).getModel("checkpointStyle"), l = this;
		this._currentPointer = giveSymbol(c, c, this._mainGroup, {}, this._currentPointer, {
			onCreate: function(t) {
				t.draggable = !0, t.drift = bind(l._handlePointerDrag, l), t.ondragend = bind(l._handlePointerDragend, l), pointerMoveTo(t, l._progressLine, s, r, a, !0);
			},
			onUpdate: function(t) {
				pointerMoveTo(t, l._progressLine, s, r, a);
			}
		});
	}, n.prototype._handlePlayClick = function(t) {
		this._clearTimer(), this.api.dispatchAction({
			type: "timelinePlayChange",
			playState: t,
			from: this.uid
		});
	}, n.prototype._handlePointerDrag = function(t, n, r) {
		this._clearTimer(), this._pointerChangeTimeline([r.offsetX, r.offsetY]);
	}, n.prototype._handlePointerDragend = function(t) {
		this._pointerChangeTimeline([t.offsetX, t.offsetY], !0);
	}, n.prototype._pointerChangeTimeline = function(t, n) {
		var r = this._toAxisCoord(t)[0], a = this._axis, o = asc$1(a.getExtent().slice());
		r > o[1] && (r = o[1]), r < o[0] && (r = o[0]), this._currentPointer.x = r, this._currentPointer.markRedraw();
		var s = this._progressLine;
		s && (s.shape.x2 = r, s.dirty());
		var c = this._findNearestTick(r), l = this.model;
		(n || c !== l.getCurrentIndex() && l.get("realtime")) && this._changeTimeline(c);
	}, n.prototype._doPlayStop = function() {
		var t = this;
		this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
			var n = t.model;
			t._changeTimeline(n.getCurrentIndex() + (n.get("rewind", !0) ? -1 : 1));
		}, this.model.get("playInterval")));
	}, n.prototype._toAxisCoord = function(t) {
		return applyTransform$1(t, this._mainGroup.getLocalTransform(), !0);
	}, n.prototype._findNearestTick = function(t) {
		var n = this.model.getData(), r = Infinity, a, o = this._axis;
		return n.each(["value"], function(n, s) {
			var c = o.dataToCoord(n), l = Math.abs(c - t);
			l < r && (r = l, a = s);
		}), a;
	}, n.prototype._clearTimer = function() {
		this._timer &&= (clearTimeout(this._timer), null);
	}, n.prototype._changeTimeline = function(t) {
		var n = this.model.getCurrentIndex();
		t === "+" ? t = n + 1 : t === "-" && (t = n - 1), this.api.dispatchAction({
			type: "timelineChange",
			currentIndex: t,
			from: this.uid
		});
	}, n.prototype._updateTicksStatus = function() {
		var t = this.model.getCurrentIndex(), n = this._tickSymbols, r = this._tickLabels;
		if (n) for (var a = 0; a < n.length; a++) n && n[a] && n[a].toggleState("progress", a < t);
		if (r) for (var a = 0; a < r.length; a++) r && r[a] && r[a].toggleState("progress", labelDataIndexStore(r[a]).dataIndex <= t);
	}, n.type = "timeline.slider", n;
}(TimelineView_default);
function createScaleByModel(t, n) {
	if (n ||= t.get("type"), n) switch (n) {
		case "category": return new Ordinal_default({
			ordinalMeta: t.getCategories(),
			extent: [Infinity, -Infinity]
		});
		case "time": return new Time_default({
			locale: t.ecModel.getLocaleModel(),
			useUTC: t.ecModel.get("useUTC")
		});
		default: return new Interval_default();
	}
}
function getViewRect(t, n) {
	return getLayoutRect(t.getBoxLayoutParams(), {
		width: n.getWidth(),
		height: n.getHeight()
	}, t.get("padding"));
}
function makeControlIcon(t, n, r, a) {
	var o = a.style, s = createIcon(t.get(["controlStyle", n]), a || {}, new BoundingRect_default(r[0], r[1], r[2], r[3]));
	return o && s.setStyle(o), s;
}
function giveSymbol(t, n, r, a, o, s) {
	var c = n.get("color");
	o ? (o.setColor(c), r.add(o), s && s.onUpdate(o)) : (o = createSymbol(t.get("symbol"), -1, -1, 2, 2, c), o.setStyle("strokeNoScale", !0), r.add(o), s && s.onCreate(o));
	var l = n.getItemStyle(["color"]);
	o.setStyle(l), a = merge({
		rectHover: !0,
		z2: 100
	}, a, !0);
	var u = normalizeSymbolSize(t.get("symbolSize"));
	a.scaleX = u[0] / 2, a.scaleY = u[1] / 2;
	var d = normalizeSymbolOffset(t.get("symbolOffset"), u);
	return d && (a.x = (a.x || 0) + d[0], a.y = (a.y || 0) + d[1]), a.rotation = (t.get("symbolRotate") || 0) * Math.PI / 180 || 0, o.attr(a), o.updateTransform(), o;
}
function pointerMoveTo(t, n, r, a, o, s) {
	if (!t.dragging) {
		var c = o.getModel("checkpointStyle"), l = a.dataToCoord(o.getData().get("value", r));
		if (s || !c.get("animation", !0)) t.attr({
			x: l,
			y: 0
		}), n && n.attr({ shape: { x2: l } });
		else {
			var u = {
				duration: c.get("animationDuration", !0),
				easing: c.get("animationEasing", !0)
			};
			t.stopAnimation(null, !0), t.animateTo({
				x: l,
				y: 0
			}, u), n && n.animateTo({ shape: { x2: l } }, u);
		}
	}
}
var SliderTimelineView_default = SliderTimelineView;
function installTimelineAction(t) {
	t.registerAction({
		type: "timelineChange",
		event: "timelineChanged",
		update: "prepareAndUpdate"
	}, function(t, n, r) {
		var a = n.getComponent("timeline");
		return a && t.currentIndex != null && (a.setCurrentIndex(t.currentIndex), !a.get("loop", !0) && a.isIndexMax() && a.getPlayState() && (a.setPlayState(!1), r.dispatchAction({
			type: "timelinePlayChange",
			playState: !1,
			from: t.from
		}))), n.resetOption("timeline", { replaceMerge: a.get("replaceMerge", !0) }), defaults({ currentIndex: a.option.currentIndex }, t);
	}), t.registerAction({
		type: "timelinePlayChange",
		event: "timelinePlayChanged",
		update: "update"
	}, function(t, n) {
		var r = n.getComponent("timeline");
		r && t.playState != null && r.setPlayState(t.playState);
	});
}
function timelinePreprocessor(t) {
	var n = t && t.timeline;
	isArray(n) || (n = n ? [n] : []), each(n, function(t) {
		t && compatibleEC2(t);
	});
}
function compatibleEC2(t) {
	var n = t.type, r = {
		number: "value",
		time: "time"
	};
	if (r[n] && (t.axisType = r[n], delete t.type), transferItem(t), has$1(t, "controlPosition")) {
		var a = t.controlStyle ||= {};
		has$1(a, "position") || (a.position = t.controlPosition), a.position === "none" && !has$1(a, "show") && (a.show = !1, delete a.position), delete t.controlPosition;
	}
	each(t.data || [], function(t) {
		isObject(t) && !isArray(t) && (!has$1(t, "value") && has$1(t, "name") && (t.value = t.name), transferItem(t));
	});
}
function transferItem(t) {
	var n = t.itemStyle ||= {}, r = n.emphasis ||= {}, a = t.label || t.label || {}, o = a.normal ||= {}, s = {
		normal: 1,
		emphasis: 1
	};
	each(a, function(t, n) {
		!s[n] && !has$1(o, n) && (o[n] = t);
	}), r.label && !has$1(a, "emphasis") && (a.emphasis = r.label, delete r.label);
}
function has$1(t, n) {
	return t.hasOwnProperty(n);
}
function install$36(t) {
	t.registerComponentModel(SliderTimelineModel_default), t.registerComponentView(SliderTimelineView_default), t.registerSubTypeDefaulter("timeline", function() {
		return "slider";
	}), installTimelineAction(t), t.registerPreprocessor(timelinePreprocessor);
}
function checkMarkerInSeries(t, n) {
	if (!t) return !1;
	for (var r = isArray(t) ? t : [t], a = 0; a < r.length; a++) if (r[a] && r[a][n]) return !0;
	return !1;
}
init_dist$2();
function fillLabel(t) {
	defaultEmphasis(t, "label", ["show"]);
}
var inner$5 = makeInner(), MarkerModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.createdBySelf = !1, r;
	}
	return n.prototype.init = function(t, n, r) {
		if (process$1.env.NODE_ENV !== "production" && this.type === "marker") throw Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
		this.mergeDefaultAndTheme(t, r), this._mergeOption(t, r, !1, !0);
	}, n.prototype.isAnimationEnabled = function() {
		if (env_default.node) return !1;
		var t = this.__hostSeries;
		return this.getShallow("animation") && t && t.isAnimationEnabled();
	}, n.prototype.mergeOption = function(t, n) {
		this._mergeOption(t, n, !1, !1);
	}, n.prototype._mergeOption = function(t, n, r, a) {
		var o = this.mainType;
		r || n.eachSeries(function(t) {
			var r = t.get(this.mainType, !0), s = inner$5(t)[o];
			if (!r || !r.data) {
				inner$5(t)[o] = null;
				return;
			}
			s ? s._mergeOption(r, n, !0) : (a && fillLabel(r), each(r.data, function(t) {
				t instanceof Array ? (fillLabel(t[0]), fillLabel(t[1])) : fillLabel(t);
			}), s = this.createMarkerModelFromSeries(r, this, n), extend(s, {
				mainType: this.mainType,
				seriesIndex: t.seriesIndex,
				name: t.name,
				createdBySelf: !0
			}), s.__hostSeries = t), inner$5(t)[o] = s;
		}, this);
	}, n.prototype.formatTooltip = function(t, n, r) {
		var a = this.getData(), o = this.getRawValue(t), s = a.getName(t);
		return createTooltipMarkup("section", {
			header: this.name,
			blocks: [createTooltipMarkup("nameValue", {
				name: s,
				value: o,
				noName: !s,
				noValue: o == null
			})]
		});
	}, n.prototype.getData = function() {
		return this._data;
	}, n.prototype.setData = function(t) {
		this._data = t;
	}, n.prototype.getDataParams = function(t, n) {
		var r = DataFormatMixin.prototype.getDataParams.call(this, t, n), a = this.__hostSeries;
		return a && (r.seriesId = a.id, r.seriesName = a.name, r.seriesType = a.subType), r;
	}, n.getMarkerModelFromSeries = function(t, n) {
		return inner$5(t)[n];
	}, n.type = "marker", n.dependencies = [
		"series",
		"grid",
		"polar",
		"geo"
	], n;
}(Component_default);
mixin(MarkerModel, DataFormatMixin.prototype);
var MarkerModel_default = MarkerModel, MarkPointModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.createMarkerModelFromSeries = function(t, r, a) {
		return new n(t, r, a);
	}, n.type = "markPoint", n.defaultOption = {
		z: 5,
		symbol: "pin",
		symbolSize: 50,
		tooltip: { trigger: "item" },
		label: {
			show: !0,
			position: "inside"
		},
		itemStyle: { borderWidth: 2 },
		emphasis: { label: { show: !0 } }
	}, n;
}(MarkerModel_default);
function hasXOrY(t) {
	return !(isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y)));
}
function hasXAndY(t) {
	return !isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y));
}
function markerTypeCalculatorWithExtent(t, n, r, a, o, s) {
	var c = [], l = isDimensionStacked(n, a) ? n.getCalculationInfo("stackResultDimension") : a, u = numCalculate(n, l, t), d = n.indicesOfNearest(l, u)[0];
	c[o] = n.get(r, d), c[s] = n.get(l, d);
	var f = n.get(a, d), p = getPrecision(n.get(a, d));
	return p = Math.min(p, 20), p >= 0 && (c[s] = +c[s].toFixed(p)), [c, f];
}
var markerTypeCalculator = {
	min: curry(markerTypeCalculatorWithExtent, "min"),
	max: curry(markerTypeCalculatorWithExtent, "max"),
	average: curry(markerTypeCalculatorWithExtent, "average"),
	median: curry(markerTypeCalculatorWithExtent, "median")
};
function dataTransform(t, n) {
	if (n) {
		var r = t.getData(), a = t.coordinateSystem, o = a && a.dimensions;
		if (!hasXAndY(n) && !isArray(n.coord) && isArray(o)) {
			var s = getAxisInfo(n, r, a, t);
			if (n = clone$1(n), n.type && markerTypeCalculator[n.type] && s.baseAxis && s.valueAxis) {
				var c = indexOf(o, s.baseAxis.dim), l = indexOf(o, s.valueAxis.dim), u = markerTypeCalculator[n.type](r, s.baseDataDim, s.valueDataDim, c, l);
				n.coord = u[0], n.value = u[1];
			} else n.coord = [n.xAxis == null ? n.radiusAxis : n.xAxis, n.yAxis == null ? n.angleAxis : n.yAxis];
		}
		if (n.coord == null || !isArray(o)) n.coord = [];
		else for (var d = n.coord, f = 0; f < 2; f++) markerTypeCalculator[d[f]] && (d[f] = numCalculate(r, r.mapDimension(o[f]), d[f]));
		return n;
	}
}
function getAxisInfo(t, n, r, a) {
	var o = {};
	return t.valueIndex != null || t.valueDim != null ? (o.valueDataDim = t.valueIndex == null ? t.valueDim : n.getDimension(t.valueIndex), o.valueAxis = r.getAxis(dataDimToCoordDim(a, o.valueDataDim)), o.baseAxis = r.getOtherAxis(o.valueAxis), o.baseDataDim = n.mapDimension(o.baseAxis.dim)) : (o.baseAxis = a.getBaseAxis(), o.valueAxis = r.getOtherAxis(o.baseAxis), o.baseDataDim = n.mapDimension(o.baseAxis.dim), o.valueDataDim = n.mapDimension(o.valueAxis.dim)), o;
}
function dataDimToCoordDim(t, n) {
	var r = t.getData().getDimensionInfo(n);
	return r && r.coordDim;
}
function dataFilter(t, n) {
	return t && t.containData && n.coord && !hasXOrY(n) ? t.containData(n.coord) : !0;
}
function zoneFilter(t, n, r) {
	return t && t.containZone && n.coord && r.coord && !hasXOrY(n) && !hasXOrY(r) ? t.containZone(n.coord, r.coord) : !0;
}
function createMarkerDimValueGetter(t, n) {
	return t ? function(t, r, a, o) {
		return parseDataValue(o < 2 ? t.coord && t.coord[o] : t.value, n[o]);
	} : function(t, r, a, o) {
		return parseDataValue(t.value, n[o]);
	};
}
function numCalculate(t, n, r) {
	if (r === "average") {
		var a = 0, o = 0;
		return t.each(n, function(t, n) {
			isNaN(t) || (a += t, o++);
		}), a / o;
	} else if (r === "median") return t.getMedian(n);
	else return t.getDataExtent(n)[r === "max" ? 1 : 0];
}
var inner$4 = makeInner(), MarkerView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.init = function() {
		this.markerGroupMap = createHashMap();
	}, n.prototype.render = function(t, n, r) {
		var a = this, o = this.markerGroupMap;
		o.each(function(t) {
			inner$4(t).keep = !1;
		}), n.eachSeries(function(t) {
			var o = MarkerModel_default.getMarkerModelFromSeries(t, a.type);
			o && a.renderSeries(t, o, n, r);
		}), o.each(function(t) {
			!inner$4(t).keep && a.group.remove(t.group);
		});
	}, n.prototype.markKeep = function(t) {
		inner$4(t).keep = !0;
	}, n.prototype.toggleBlurSeries = function(t, n) {
		var r = this;
		each(t, function(t) {
			var a = MarkerModel_default.getMarkerModelFromSeries(t, r.type);
			a && a.getData().eachItemGraphicEl(function(t) {
				t && (n ? enterBlur(t) : leaveBlur(t));
			});
		});
	}, n.type = "marker", n;
}(Component_default$1);
function updateMarkerLayout(t, n, r) {
	var a = n.coordinateSystem;
	t.each(function(o) {
		var s = t.getItemModel(o), c, l = parsePercent$1(s.get("x"), r.getWidth()), u = parsePercent$1(s.get("y"), r.getHeight());
		if (!isNaN(l) && !isNaN(u)) c = [l, u];
		else if (n.getMarkerPosition) c = n.getMarkerPosition(t.getValues(t.dimensions, o));
		else if (a) {
			var d = t.get(a.dimensions[0], o), f = t.get(a.dimensions[1], o);
			c = a.dataToPoint([d, f]);
		}
		isNaN(l) || (c[0] = l), isNaN(u) || (c[1] = u), t.setItemLayout(o, c);
	});
}
var MarkPointView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.updateTransform = function(t, n, r) {
		n.eachSeries(function(t) {
			var n = MarkerModel_default.getMarkerModelFromSeries(t, "markPoint");
			n && (updateMarkerLayout(n.getData(), t, r), this.markerGroupMap.get(t.id).updateLayout());
		}, this);
	}, n.prototype.renderSeries = function(t, n, r, a) {
		var o = t.coordinateSystem, s = t.id, c = t.getData(), l = this.markerGroupMap, u = l.get(s) || l.set(s, new SymbolDraw_default()), d = createData(o, t, n);
		n.setData(d), updateMarkerLayout(n.getData(), t, a), d.each(function(t) {
			var r = d.getItemModel(t), a = r.getShallow("symbol"), o = r.getShallow("symbolSize"), s = r.getShallow("symbolRotate"), l = r.getShallow("symbolOffset"), u = r.getShallow("symbolKeepAspect");
			if (isFunction(a) || isFunction(o) || isFunction(s) || isFunction(l)) {
				var f = n.getRawValue(t), p = n.getDataParams(t);
				isFunction(a) && (a = a(f, p)), isFunction(o) && (o = o(f, p)), isFunction(s) && (s = s(f, p)), isFunction(l) && (l = l(f, p));
			}
			var h = r.getModel("itemStyle").getItemStyle(), g = getVisualFromData(c, "color");
			h.fill ||= g, d.setItemVisual(t, {
				symbol: a,
				symbolSize: o,
				symbolRotate: s,
				symbolOffset: l,
				symbolKeepAspect: u,
				style: h
			});
		}), u.updateData(d), this.group.add(u.group), d.eachItemGraphicEl(function(t) {
			t.traverse(function(t) {
				getECData(t).dataModel = n;
			});
		}), this.markKeep(u), u.group.silent = n.get("silent") || t.get("silent");
	}, n.type = "markPoint", n;
}(MarkerView_default);
function createData(t, n, r) {
	var a = t ? map(t && t.dimensions, function(t) {
		return extend(extend({}, n.getData().getDimensionInfo(n.getData().mapDimension(t)) || {}), {
			name: t,
			ordinalMeta: null
		});
	}) : [{
		name: "value",
		type: "float"
	}], o = new SeriesData_default(a, r), s = map(r.get("data"), curry(dataTransform, n));
	t && (s = filter(s, curry(dataFilter, t)));
	var c = createMarkerDimValueGetter(!!t, a);
	return o.initData(s, null, c), o;
}
var MarkPointView_default = MarkPointView;
function install$37(t) {
	t.registerComponentModel(MarkPointModel_default), t.registerComponentView(MarkPointView_default), t.registerPreprocessor(function(t) {
		checkMarkerInSeries(t.series, "markPoint") && (t.markPoint = t.markPoint || {});
	});
}
var MarkLineModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.createMarkerModelFromSeries = function(t, r, a) {
		return new n(t, r, a);
	}, n.type = "markLine", n.defaultOption = {
		z: 5,
		symbol: ["circle", "arrow"],
		symbolSize: [8, 16],
		symbolOffset: 0,
		precision: 2,
		tooltip: { trigger: "item" },
		label: {
			show: !0,
			position: "end",
			distance: 5
		},
		lineStyle: { type: "dashed" },
		emphasis: {
			label: { show: !0 },
			lineStyle: { width: 3 }
		},
		animationEasing: "linear"
	}, n;
}(MarkerModel_default);
init_dist$2();
var inner$3 = makeInner(), markLineTransform = function(t, n, r, a) {
	var o = t.getData(), c;
	if (isArray(a)) c = a;
	else {
		var l = a.type;
		if (l === "min" || l === "max" || l === "average" || l === "median" || a.xAxis != null || a.yAxis != null) {
			var u = void 0, d = void 0;
			if (a.yAxis != null || a.xAxis != null) u = n.getAxis(a.yAxis == null ? "x" : "y"), d = retrieve(a.yAxis, a.xAxis);
			else {
				var f = getAxisInfo(a, o, n, t);
				u = f.valueAxis, d = numCalculate(o, getStackedDimension(o, f.valueDataDim), l);
			}
			var p = u.dim === "x" ? 0 : 1, h = 1 - p, g = clone$1(a), _ = { coord: [] };
			g.type = null, g.coord = [], g.coord[h] = -Infinity, _.coord[h] = Infinity;
			var v = r.get("precision");
			v >= 0 && isNumber(d) && (d = +d.toFixed(Math.min(v, 20))), g.coord[p] = _.coord[p] = d, c = [
				g,
				_,
				{
					type: l,
					valueIndex: a.valueIndex,
					value: d
				}
			];
		} else process$1.env.NODE_ENV !== "production" && logError("Invalid markLine data."), c = [];
	}
	var y = [
		dataTransform(t, c[0]),
		dataTransform(t, c[1]),
		extend({}, c[2])
	];
	return y[2].type = y[2].type || null, merge(y[2], y[0]), merge(y[2], y[1]), y;
};
function isInfinity$1(t) {
	return !isNaN(t) && !isFinite(t);
}
function ifMarkLineHasOnlyDim(t, n, r, a) {
	var o = 1 - t, s = a.dimensions[t];
	return isInfinity$1(n[o]) && isInfinity$1(r[o]) && n[t] === r[t] && a.getAxis(s).containData(n[t]);
}
function markLineFilter(t, n) {
	if (t.type === "cartesian2d") {
		var r = n[0].coord, a = n[1].coord;
		if (r && a && (ifMarkLineHasOnlyDim(1, r, a, t) || ifMarkLineHasOnlyDim(0, r, a, t))) return !0;
	}
	return dataFilter(t, n[0]) && dataFilter(t, n[1]);
}
function updateSingleMarkerEndLayout(t, n, r, a, o) {
	var s = a.coordinateSystem, c = t.getItemModel(n), l, u = parsePercent$1(c.get("x"), o.getWidth()), d = parsePercent$1(c.get("y"), o.getHeight());
	if (!isNaN(u) && !isNaN(d)) l = [u, d];
	else {
		if (a.getMarkerPosition) l = a.getMarkerPosition(t.getValues(t.dimensions, n));
		else {
			var f = s.dimensions, p = t.get(f[0], n), h = t.get(f[1], n);
			l = s.dataToPoint([p, h]);
		}
		if (isCoordinateSystemType(s, "cartesian2d")) {
			var g = s.getAxis("x"), _ = s.getAxis("y"), f = s.dimensions;
			isInfinity$1(t.get(f[0], n)) ? l[0] = g.toGlobalCoord(g.getExtent()[r ? 0 : 1]) : isInfinity$1(t.get(f[1], n)) && (l[1] = _.toGlobalCoord(_.getExtent()[r ? 0 : 1]));
		}
		isNaN(u) || (l[0] = u), isNaN(d) || (l[1] = d);
	}
	t.setItemLayout(n, l);
}
var MarkLineView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.updateTransform = function(t, n, r) {
		n.eachSeries(function(t) {
			var n = MarkerModel_default.getMarkerModelFromSeries(t, "markLine");
			if (n) {
				var a = n.getData(), o = inner$3(n).from, s = inner$3(n).to;
				o.each(function(n) {
					updateSingleMarkerEndLayout(o, n, !0, t, r), updateSingleMarkerEndLayout(s, n, !1, t, r);
				}), a.each(function(t) {
					a.setItemLayout(t, [o.getItemLayout(t), s.getItemLayout(t)]);
				}), this.markerGroupMap.get(t.id).updateLayout();
			}
		}, this);
	}, n.prototype.renderSeries = function(t, n, r, a) {
		var o = t.coordinateSystem, s = t.id, c = t.getData(), l = this.markerGroupMap, u = l.get(s) || l.set(s, new LineDraw_default());
		this.group.add(u.group);
		var d = createList$1(o, t, n), f = d.from, p = d.to, h = d.line;
		inner$3(n).from = f, inner$3(n).to = p, n.setData(h);
		var g = n.get("symbol"), _ = n.get("symbolSize"), v = n.get("symbolRotate"), y = n.get("symbolOffset");
		isArray(g) || (g = [g, g]), isArray(_) || (_ = [_, _]), isArray(v) || (v = [v, v]), isArray(y) || (y = [y, y]), d.from.each(function(t) {
			b(f, t, !0), b(p, t, !1);
		}), h.each(function(t) {
			var n = h.getItemModel(t).getModel("lineStyle").getLineStyle();
			h.setItemLayout(t, [f.getItemLayout(t), p.getItemLayout(t)]), n.stroke ??= f.getItemVisual(t, "style").fill, h.setItemVisual(t, {
				fromSymbolKeepAspect: f.getItemVisual(t, "symbolKeepAspect"),
				fromSymbolOffset: f.getItemVisual(t, "symbolOffset"),
				fromSymbolRotate: f.getItemVisual(t, "symbolRotate"),
				fromSymbolSize: f.getItemVisual(t, "symbolSize"),
				fromSymbol: f.getItemVisual(t, "symbol"),
				toSymbolKeepAspect: p.getItemVisual(t, "symbolKeepAspect"),
				toSymbolOffset: p.getItemVisual(t, "symbolOffset"),
				toSymbolRotate: p.getItemVisual(t, "symbolRotate"),
				toSymbolSize: p.getItemVisual(t, "symbolSize"),
				toSymbol: p.getItemVisual(t, "symbol"),
				style: n
			});
		}), u.updateData(h), d.line.eachItemGraphicEl(function(t) {
			getECData(t).dataModel = n, t.traverse(function(t) {
				getECData(t).dataModel = n;
			});
		});
		function b(n, r, o) {
			var s = n.getItemModel(r);
			updateSingleMarkerEndLayout(n, r, o, t, a);
			var l = s.getModel("itemStyle").getItemStyle();
			l.fill ??= getVisualFromData(c, "color"), n.setItemVisual(r, {
				symbolKeepAspect: s.get("symbolKeepAspect"),
				symbolOffset: retrieve2(s.get("symbolOffset", !0), y[o ? 0 : 1]),
				symbolRotate: retrieve2(s.get("symbolRotate", !0), v[o ? 0 : 1]),
				symbolSize: retrieve2(s.get("symbolSize"), _[o ? 0 : 1]),
				symbol: retrieve2(s.get("symbol", !0), g[o ? 0 : 1]),
				style: l
			});
		}
		this.markKeep(u), u.group.silent = n.get("silent") || t.get("silent");
	}, n.type = "markLine", n;
}(MarkerView_default);
function createList$1(t, n, r) {
	var a = t ? map(t && t.dimensions, function(t) {
		return extend(extend({}, n.getData().getDimensionInfo(n.getData().mapDimension(t)) || {}), {
			name: t,
			ordinalMeta: null
		});
	}) : [{
		name: "value",
		type: "float"
	}], o = new SeriesData_default(a, r), s = new SeriesData_default(a, r), c = new SeriesData_default([], r), l = map(r.get("data"), curry(markLineTransform, n, t, r));
	t && (l = filter(l, curry(markLineFilter, t)));
	var u = createMarkerDimValueGetter(!!t, a);
	return o.initData(map(l, function(t) {
		return t[0];
	}), null, u), s.initData(map(l, function(t) {
		return t[1];
	}), null, u), c.initData(map(l, function(t) {
		return t[2];
	})), c.hasItemOption = !0, {
		from: o,
		to: s,
		line: c
	};
}
var MarkLineView_default = MarkLineView;
function install$38(t) {
	t.registerComponentModel(MarkLineModel_default), t.registerComponentView(MarkLineView_default), t.registerPreprocessor(function(t) {
		checkMarkerInSeries(t.series, "markLine") && (t.markLine = t.markLine || {});
	});
}
var MarkAreaModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.createMarkerModelFromSeries = function(t, r, a) {
		return new n(t, r, a);
	}, n.type = "markArea", n.defaultOption = {
		z: 1,
		tooltip: { trigger: "item" },
		animation: !1,
		label: {
			show: !0,
			position: "top"
		},
		itemStyle: { borderWidth: 0 },
		emphasis: { label: {
			show: !0,
			position: "top"
		} }
	}, n;
}(MarkerModel_default), inner$2 = makeInner(), markAreaTransform = function(t, n, r, a) {
	var o = a[0], s = a[1];
	if (!(!o || !s)) {
		var c = dataTransform(t, o), l = dataTransform(t, s), u = c.coord, d = l.coord;
		u[0] = retrieve(u[0], -Infinity), u[1] = retrieve(u[1], -Infinity), d[0] = retrieve(d[0], Infinity), d[1] = retrieve(d[1], Infinity);
		var f = mergeAll([
			{},
			c,
			l
		]);
		return f.coord = [c.coord, l.coord], f.x0 = c.x, f.y0 = c.y, f.x1 = l.x, f.y1 = l.y, f;
	}
};
function isInfinity(t) {
	return !isNaN(t) && !isFinite(t);
}
function ifMarkAreaHasOnlyDim(t, n, r, a) {
	var o = 1 - t;
	return isInfinity(n[o]) && isInfinity(r[o]);
}
function markAreaFilter(t, n) {
	var r = n.coord[0], a = n.coord[1], o = {
		coord: r,
		x: n.x0,
		y: n.y0
	}, s = {
		coord: a,
		x: n.x1,
		y: n.y1
	};
	return isCoordinateSystemType(t, "cartesian2d") ? r && a && (ifMarkAreaHasOnlyDim(1, r, a, t) || ifMarkAreaHasOnlyDim(0, r, a, t)) ? !0 : zoneFilter(t, o, s) : dataFilter(t, o) || dataFilter(t, s);
}
function getSingleMarkerEndPoint(t, n, r, a, o) {
	var s = a.coordinateSystem, c = t.getItemModel(n), l, u = parsePercent$1(c.get(r[0]), o.getWidth()), d = parsePercent$1(c.get(r[1]), o.getHeight());
	if (!isNaN(u) && !isNaN(d)) l = [u, d];
	else {
		if (a.getMarkerPosition) {
			var f = t.getValues(["x0", "y0"], n), p = t.getValues(["x1", "y1"], n), h = s.clampData(f), g = s.clampData(p), _ = [];
			r[0] === "x0" ? _[0] = h[0] > g[0] ? p[0] : f[0] : _[0] = h[0] > g[0] ? f[0] : p[0], r[1] === "y0" ? _[1] = h[1] > g[1] ? p[1] : f[1] : _[1] = h[1] > g[1] ? f[1] : p[1], l = a.getMarkerPosition(_, r, !0);
		} else {
			var v = t.get(r[0], n), y = t.get(r[1], n), b = [v, y];
			s.clampData && s.clampData(b, b), l = s.dataToPoint(b, !0);
		}
		if (isCoordinateSystemType(s, "cartesian2d")) {
			var x = s.getAxis("x"), S = s.getAxis("y"), v = t.get(r[0], n), y = t.get(r[1], n);
			isInfinity(v) ? l[0] = x.toGlobalCoord(x.getExtent()[r[0] === "x0" ? 0 : 1]) : isInfinity(y) && (l[1] = S.toGlobalCoord(S.getExtent()[r[1] === "y0" ? 0 : 1]));
		}
		isNaN(u) || (l[0] = u), isNaN(d) || (l[1] = d);
	}
	return l;
}
var dimPermutations = [
	["x0", "y0"],
	["x1", "y0"],
	["x1", "y1"],
	["x0", "y1"]
], MarkAreaView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.updateTransform = function(t, n, r) {
		n.eachSeries(function(t) {
			var n = MarkerModel_default.getMarkerModelFromSeries(t, "markArea");
			if (n) {
				var a = n.getData();
				a.each(function(n) {
					var o = map(dimPermutations, function(o) {
						return getSingleMarkerEndPoint(a, n, o, t, r);
					});
					a.setItemLayout(n, o), a.getItemGraphicEl(n).setShape("points", o);
				});
			}
		}, this);
	}, n.prototype.renderSeries = function(t, n, r, a) {
		var o = t.coordinateSystem, s = t.id, c = t.getData(), l = this.markerGroupMap, u = l.get(s) || l.set(s, { group: new Group_default() });
		this.group.add(u.group), this.markKeep(u);
		var d = createList(o, t, n);
		n.setData(d), d.each(function(n) {
			var r = map(dimPermutations, function(r) {
				return getSingleMarkerEndPoint(d, n, r, t, a);
			}), s = o.getAxis("x").scale, l = o.getAxis("y").scale, u = s.getExtent(), f = l.getExtent(), p = [s.parse(d.get("x0", n)), s.parse(d.get("x1", n))], h = [l.parse(d.get("y0", n)), l.parse(d.get("y1", n))];
			asc$1(p), asc$1(h);
			var g = u[0] > p[1] || u[1] < p[0] || f[0] > h[1] || f[1] < h[0];
			d.setItemLayout(n, {
				points: r,
				allClipped: g
			});
			var _ = d.getItemModel(n).getModel("itemStyle").getItemStyle(), v = getVisualFromData(c, "color");
			_.fill || (_.fill = v, isString(_.fill) && (_.fill = modifyAlpha(_.fill, .4))), _.stroke ||= v, d.setItemVisual(n, "style", _);
		}), d.diff(inner$2(u).data).add(function(t) {
			var n = d.getItemLayout(t);
			if (!n.allClipped) {
				var r = new Polygon_default({ shape: { points: n.points } });
				d.setItemGraphicEl(t, r), u.group.add(r);
			}
		}).update(function(t, r) {
			var a = inner$2(u).data.getItemGraphicEl(r), o = d.getItemLayout(t);
			o.allClipped ? a && u.group.remove(a) : (a ? updateProps(a, { shape: { points: o.points } }, n, t) : a = new Polygon_default({ shape: { points: o.points } }), d.setItemGraphicEl(t, a), u.group.add(a));
		}).remove(function(t) {
			var n = inner$2(u).data.getItemGraphicEl(t);
			u.group.remove(n);
		}).execute(), d.eachItemGraphicEl(function(t, r) {
			var a = d.getItemModel(r), o = d.getItemVisual(r, "style");
			t.useStyle(d.getItemVisual(r, "style")), setLabelStyle(t, getLabelStatesModels(a), {
				labelFetcher: n,
				labelDataIndex: r,
				defaultText: d.getName(r) || "",
				inheritColor: isString(o.fill) ? modifyAlpha(o.fill, 1) : "#000"
			}), setStatesStylesFromModel(t, a), toggleHoverEmphasis(t, null, null, a.get(["emphasis", "disabled"])), getECData(t).dataModel = n;
		}), inner$2(u).data = d, u.group.silent = n.get("silent") || t.get("silent");
	}, n.type = "markArea", n;
}(MarkerView_default);
function createList(t, n, r) {
	var a, o, s = [
		"x0",
		"y0",
		"x1",
		"y1"
	];
	if (t) {
		var c = map(t && t.dimensions, function(t) {
			var r = n.getData();
			return extend(extend({}, r.getDimensionInfo(r.mapDimension(t)) || {}), {
				name: t,
				ordinalMeta: null
			});
		});
		o = map(s, function(t, n) {
			return {
				name: t,
				type: c[n % 2].type
			};
		}), a = new SeriesData_default(o, r);
	} else o = [{
		name: "value",
		type: "float"
	}], a = new SeriesData_default(o, r);
	var l = map(r.get("data"), curry(markAreaTransform, n, t, r));
	t && (l = filter(l, curry(markAreaFilter, t)));
	var u = t ? function(t, n, r, a) {
		var s = t.coord[Math.floor(a / 2)][a % 2];
		return parseDataValue(s, o[a]);
	} : function(t, n, r, a) {
		return parseDataValue(t.value, o[a]);
	};
	return a.initData(l, null, u), a.hasItemOption = !0, a;
}
var MarkAreaView_default = MarkAreaView;
function install$39(t) {
	t.registerComponentModel(MarkAreaModel_default), t.registerComponentView(MarkAreaView_default), t.registerPreprocessor(function(t) {
		checkMarkerInSeries(t.series, "markArea") && (t.markArea = t.markArea || {});
	});
}
var getDefaultSelectorOptions = function(t, n) {
	if (n === "all") return {
		type: "all",
		title: t.getLocaleModel().get([
			"legend",
			"selector",
			"all"
		])
	};
	if (n === "inverse") return {
		type: "inverse",
		title: t.getLocaleModel().get([
			"legend",
			"selector",
			"inverse"
		])
	};
}, LegendModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.layoutMode = {
			type: "box",
			ignoreSize: !0
		}, r;
	}
	return n.prototype.init = function(t, n, r) {
		this.mergeDefaultAndTheme(t, r), t.selected = t.selected || {}, this._updateSelector(t);
	}, n.prototype.mergeOption = function(n, r) {
		t.prototype.mergeOption.call(this, n, r), this._updateSelector(n);
	}, n.prototype._updateSelector = function(t) {
		var n = t.selector, r = this.ecModel;
		n === !0 && (n = t.selector = ["all", "inverse"]), isArray(n) && each(n, function(t, a) {
			isString(t) && (t = { type: t }), n[a] = merge(t, getDefaultSelectorOptions(r, t.type));
		});
	}, n.prototype.optionUpdated = function() {
		this._updateData(this.ecModel);
		var t = this._data;
		if (t[0] && this.get("selectedMode") === "single") {
			for (var n = !1, r = 0; r < t.length; r++) {
				var a = t[r].get("name");
				if (this.isSelected(a)) {
					this.select(a), n = !0;
					break;
				}
			}
			!n && this.select(t[0].get("name"));
		}
	}, n.prototype._updateData = function(t) {
		var n = [], r = [];
		t.eachRawSeries(function(a) {
			var o = a.name;
			r.push(o);
			var s;
			if (a.legendVisualProvider) {
				var c = a.legendVisualProvider.getAllNames();
				t.isSeriesFiltered(a) || (r = r.concat(c)), c.length ? n = n.concat(c) : s = !0;
			} else s = !0;
			s && isNameSpecified(a) && n.push(a.name);
		}), this._availableNames = r;
		var a = this.get("data") || n, o = createHashMap();
		this._data = filter(map(a, function(t) {
			return (isString(t) || isNumber(t)) && (t = { name: t }), o.get(t.name) ? null : (o.set(t.name, !0), new Model_default(t, this, this.ecModel));
		}, this), function(t) {
			return !!t;
		});
	}, n.prototype.getData = function() {
		return this._data;
	}, n.prototype.select = function(t) {
		var n = this.option.selected;
		if (this.get("selectedMode") === "single") {
			var r = this._data;
			each(r, function(t) {
				n[t.get("name")] = !1;
			});
		}
		n[t] = !0;
	}, n.prototype.unSelect = function(t) {
		this.get("selectedMode") !== "single" && (this.option.selected[t] = !1);
	}, n.prototype.toggleSelected = function(t) {
		var n = this.option.selected;
		n.hasOwnProperty(t) || (n[t] = !0), this[n[t] ? "unSelect" : "select"](t);
	}, n.prototype.allSelect = function() {
		var t = this._data, n = this.option.selected;
		each(t, function(t) {
			n[t.get("name", !0)] = !0;
		});
	}, n.prototype.inverseSelect = function() {
		var t = this._data, n = this.option.selected;
		each(t, function(t) {
			var r = t.get("name", !0);
			n.hasOwnProperty(r) || (n[r] = !0), n[r] = !n[r];
		});
	}, n.prototype.isSelected = function(t) {
		var n = this.option.selected;
		return !(n.hasOwnProperty(t) && !n[t]) && indexOf(this._availableNames, t) >= 0;
	}, n.prototype.getOrient = function() {
		return this.get("orient") === "vertical" ? {
			index: 1,
			name: "vertical"
		} : {
			index: 0,
			name: "horizontal"
		};
	}, n.type = "legend.plain", n.dependencies = ["series"], n.defaultOption = {
		z: 4,
		show: !0,
		orient: "horizontal",
		left: "center",
		top: 0,
		align: "auto",
		backgroundColor: "rgba(0,0,0,0)",
		borderColor: "#ccc",
		borderRadius: 0,
		borderWidth: 0,
		padding: 5,
		itemGap: 10,
		itemWidth: 25,
		itemHeight: 14,
		symbolRotate: "inherit",
		symbolKeepAspect: !0,
		inactiveColor: "#ccc",
		inactiveBorderColor: "#ccc",
		inactiveBorderWidth: "auto",
		itemStyle: {
			color: "inherit",
			opacity: "inherit",
			borderColor: "inherit",
			borderWidth: "auto",
			borderCap: "inherit",
			borderJoin: "inherit",
			borderDashOffset: "inherit",
			borderMiterLimit: "inherit"
		},
		lineStyle: {
			width: "auto",
			color: "inherit",
			inactiveColor: "#ccc",
			inactiveWidth: 2,
			opacity: "inherit",
			type: "inherit",
			cap: "inherit",
			join: "inherit",
			dashOffset: "inherit",
			miterLimit: "inherit"
		},
		textStyle: { color: "#333" },
		selectedMode: !0,
		selector: !1,
		selectorLabel: {
			show: !0,
			borderRadius: 10,
			padding: [
				3,
				5,
				3,
				5
			],
			fontSize: 12,
			fontFamily: "sans-serif",
			color: "#666",
			borderWidth: 1,
			borderColor: "#666"
		},
		emphasis: { selectorLabel: {
			show: !0,
			color: "#eee",
			backgroundColor: "#666"
		} },
		selectorPosition: "auto",
		selectorItemGap: 7,
		selectorButtonGap: 10,
		tooltip: { show: !1 }
	}, n;
}(Component_default);
init_dist$2();
var curry$1 = curry, each$4 = each, Group$1 = Group_default, LegendView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.newlineDisabled = !1, r;
	}
	return n.prototype.init = function() {
		this.group.add(this._contentGroup = new Group$1()), this.group.add(this._selectorGroup = new Group$1()), this._isFirstRender = !0;
	}, n.prototype.getContentGroup = function() {
		return this._contentGroup;
	}, n.prototype.getSelectorGroup = function() {
		return this._selectorGroup;
	}, n.prototype.render = function(t, n, r) {
		var a = this._isFirstRender;
		if (this._isFirstRender = !1, this.resetInner(), t.get("show", !0)) {
			var o = t.get("align"), s = t.get("orient");
			(!o || o === "auto") && (o = t.get("left") === "right" && s === "vertical" ? "right" : "left");
			var c = t.get("selector", !0), l = t.get("selectorPosition", !0);
			c && (!l || l === "auto") && (l = s === "horizontal" ? "end" : "start"), this.renderInner(o, t, n, r, c, s, l);
			var u = t.getBoxLayoutParams(), d = {
				width: r.getWidth(),
				height: r.getHeight()
			}, f = t.get("padding"), p = getLayoutRect(u, d, f), h = this.layoutInner(t, o, p, a, c, l), g = getLayoutRect(defaults({
				width: h.width,
				height: h.height
			}, u), d, f);
			this.group.x = g.x - h.x, this.group.y = g.y - h.y, this.group.markRedraw(), this.group.add(this._backgroundEl = makeBackground(h, t));
		}
	}, n.prototype.resetInner = function() {
		this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
	}, n.prototype.renderInner = function(t, n, r, a, o, c, l) {
		var u = this.getContentGroup(), d = createHashMap(), f = n.get("selectedMode"), p = [];
		r.eachRawSeries(function(t) {
			!t.get("legendHoverLink") && p.push(t.id);
		}), each$4(n.getData(), function(o, c) {
			var l = o.get("name");
			if (!this.newlineDisabled && (l === "" || l === "\n")) {
				var h = new Group$1();
				h.newline = !0, u.add(h);
				return;
			}
			var g = r.getSeriesByName(l)[0];
			if (!d.get(l)) {
				if (g) {
					var _ = g.getData(), v = _.getVisual("legendLineStyle") || {}, y = _.getVisual("legendIcon"), b = _.getVisual("style"), x = this._createItem(g, l, c, o, n, t, v, b, y, f, a);
					x.on("click", curry$1(dispatchSelectAction, l, null, a, p)).on("mouseover", curry$1(dispatchHighlightAction, g.name, null, a, p)).on("mouseout", curry$1(dispatchDownplayAction, g.name, null, a, p)), r.ssr && x.eachChild(function(t) {
						var n = getECData(t);
						n.seriesIndex = g.seriesIndex, n.dataIndex = c, n.ssrType = "legend";
					}), d.set(l, !0);
				} else r.eachRawSeries(function(s) {
					if (!d.get(l) && s.legendVisualProvider) {
						var u = s.legendVisualProvider;
						if (!u.containName(l)) return;
						var h = u.indexOfName(l), g = u.getItemVisual(h, "style"), _ = u.getItemVisual(h, "legendIcon"), v = parse(g.fill);
						v && v[3] === 0 && (v[3] = .2, g = extend(extend({}, g), { fill: stringify(v, "rgba") }));
						var y = this._createItem(s, l, c, o, n, t, {}, g, _, f, a);
						y.on("click", curry$1(dispatchSelectAction, null, l, a, p)).on("mouseover", curry$1(dispatchHighlightAction, null, l, a, p)).on("mouseout", curry$1(dispatchDownplayAction, null, l, a, p)), r.ssr && y.eachChild(function(t) {
							var n = getECData(t);
							n.seriesIndex = s.seriesIndex, n.dataIndex = c, n.ssrType = "legend";
						}), d.set(l, !0);
					}
				}, this);
				process$1.env.NODE_ENV !== "production" && (d.get(l) || console.warn(l + " series not exists. Legend data should be same with series name or data name."));
			}
		}, this), o && this._createSelector(o, n, a, c, l);
	}, n.prototype._createSelector = function(t, n, r, a, o) {
		var s = this.getSelectorGroup();
		each$4(t, function(t) {
			var a = t.type, o = new Text_default({
				style: {
					x: 0,
					y: 0,
					align: "center",
					verticalAlign: "middle"
				},
				onclick: function() {
					r.dispatchAction({
						type: a === "all" ? "legendAllSelect" : "legendInverseSelect",
						legendId: n.id
					});
				}
			});
			s.add(o), setLabelStyle(o, {
				normal: n.getModel("selectorLabel"),
				emphasis: n.getModel(["emphasis", "selectorLabel"])
			}, { defaultText: t.title }), enableHoverEmphasis(o);
		});
	}, n.prototype._createItem = function(t, n, r, a, o, s, c, l, u, d, f) {
		var p = t.visualDrawType, h = o.get("itemWidth"), g = o.get("itemHeight"), _ = o.isSelected(n), v = a.get("symbolRotate"), y = a.get("symbolKeepAspect"), b = a.get("icon");
		u = b || u || "roundRect";
		var x = getLegendStyle(u, a, c, l, p, _, f), S = new Group$1(), C = a.getModel("textStyle");
		if (isFunction(t.getLegendIcon) && (!b || b === "inherit")) S.add(t.getLegendIcon({
			itemWidth: h,
			itemHeight: g,
			icon: u,
			iconRotate: v,
			itemStyle: x.itemStyle,
			lineStyle: x.lineStyle,
			symbolKeepAspect: y
		}));
		else {
			var w = b === "inherit" && t.getData().getVisual("symbol") ? v === "inherit" ? t.getData().getVisual("symbolRotate") : v : 0;
			S.add(getDefaultLegendIcon({
				itemWidth: h,
				itemHeight: g,
				icon: u,
				iconRotate: w,
				itemStyle: x.itemStyle,
				lineStyle: x.lineStyle,
				symbolKeepAspect: y
			}));
		}
		var T = s === "left" ? h + 5 : -5, E = s, D = o.get("formatter"), O = n;
		isString(D) && D ? O = D.replace("{name}", n ?? "") : isFunction(D) && (O = D(n));
		var A = _ ? C.getTextColor() : a.get("inactiveColor");
		S.add(new Text_default({ style: createTextStyle(C, {
			text: O,
			x: T,
			y: g / 2,
			fill: A,
			align: E,
			verticalAlign: "middle"
		}, { inheritColor: A }) }));
		var j = new Rect_default({
			shape: S.getBoundingRect(),
			style: { fill: "transparent" }
		}), M = a.getModel("tooltip");
		return M.get("show") && setTooltipConfig({
			el: j,
			componentModel: o,
			itemName: n,
			itemTooltipOption: M.option
		}), S.add(j), S.eachChild(function(t) {
			t.silent = !0;
		}), j.silent = !d, this.getContentGroup().add(S), enableHoverEmphasis(S), S.__legendDataIndex = r, S;
	}, n.prototype.layoutInner = function(t, n, r, a, o, s) {
		var c = this.getContentGroup(), l = this.getSelectorGroup();
		box(t.get("orient"), c, t.get("itemGap"), r.width, r.height);
		var u = c.getBoundingRect(), d = [-u.x, -u.y];
		if (l.markRedraw(), c.markRedraw(), o) {
			box("horizontal", l, t.get("selectorItemGap", !0));
			var f = l.getBoundingRect(), p = [-f.x, -f.y], h = t.get("selectorButtonGap", !0), g = t.getOrient().index, _ = g === 0 ? "width" : "height", v = g === 0 ? "height" : "width", y = g === 0 ? "y" : "x";
			s === "end" ? p[g] += u[_] + h : d[g] += f[_] + h, p[1 - g] += u[v] / 2 - f[v] / 2, l.x = p[0], l.y = p[1], c.x = d[0], c.y = d[1];
			var b = {
				x: 0,
				y: 0
			};
			return b[_] = u[_] + h + f[_], b[v] = Math.max(u[v], f[v]), b[y] = Math.min(0, f[y] + p[1 - g]), b;
		} else return c.x = d[0], c.y = d[1], this.group.getBoundingRect();
	}, n.prototype.remove = function() {
		this.getContentGroup().removeAll(), this._isFirstRender = !0;
	}, n.type = "legend.plain", n;
}(Component_default$1);
function getLegendStyle(t, n, r, a, o, s, c) {
	function l(t, n) {
		t.lineWidth === "auto" && (t.lineWidth = n.lineWidth > 0 ? 2 : 0), each$4(t, function(r, a) {
			t[a] === "inherit" && (t[a] = n[a]);
		});
	}
	var u = n.getModel("itemStyle"), d = u.getItemStyle(), f = t.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", p = u.getShallow("decal");
	d.decal = !p || p === "inherit" ? a.decal : createOrUpdatePatternFromDecal(p, c), d.fill === "inherit" && (d.fill = a[o]), d.stroke === "inherit" && (d.stroke = a[f]), d.opacity === "inherit" && (d.opacity = (o === "fill" ? a : r).opacity), l(d, a);
	var h = n.getModel("lineStyle"), g = h.getLineStyle();
	if (l(g, r), d.fill === "auto" && (d.fill = a.fill), d.stroke === "auto" && (d.stroke = a.fill), g.stroke === "auto" && (g.stroke = a.fill), !s) {
		var _ = n.get("inactiveBorderWidth"), v = d[f];
		d.lineWidth = _ === "auto" ? a.lineWidth > 0 && v ? 2 : 0 : d.lineWidth, d.fill = n.get("inactiveColor"), d.stroke = n.get("inactiveBorderColor"), g.stroke = h.get("inactiveColor"), g.lineWidth = h.get("inactiveWidth");
	}
	return {
		itemStyle: d,
		lineStyle: g
	};
}
function getDefaultLegendIcon(t) {
	var n = t.icon || "roundRect", r = createSymbol(n, 0, 0, t.itemWidth, t.itemHeight, t.itemStyle.fill, t.symbolKeepAspect);
	return r.setStyle(t.itemStyle), r.rotation = (t.iconRotate || 0) * Math.PI / 180, r.setOrigin([t.itemWidth / 2, t.itemHeight / 2]), n.indexOf("empty") > -1 && (r.style.stroke = r.style.fill, r.style.fill = "#fff", r.style.lineWidth = 2), r;
}
function dispatchSelectAction(t, n, r, a) {
	dispatchDownplayAction(t, n, r, a), r.dispatchAction({
		type: "legendToggleSelect",
		name: t ?? n
	}), dispatchHighlightAction(t, n, r, a);
}
function isUseHoverLayer(t) {
	for (var n = t.getZr().storage.getDisplayList(), r, a = 0, o = n.length; a < o && !(r = n[a].states.emphasis);) a++;
	return r && r.hoverLayer;
}
function dispatchHighlightAction(t, n, r, a) {
	isUseHoverLayer(r) || r.dispatchAction({
		type: "highlight",
		seriesName: t,
		name: n,
		excludeSeriesId: a
	});
}
function dispatchDownplayAction(t, n, r, a) {
	isUseHoverLayer(r) || r.dispatchAction({
		type: "downplay",
		seriesName: t,
		name: n,
		excludeSeriesId: a
	});
}
var LegendView_default = LegendView;
function legendFilter(t) {
	var n = t.findComponents({ mainType: "legend" });
	n && n.length && t.filterSeries(function(t) {
		for (var r = 0; r < n.length; r++) if (!n[r].isSelected(t.name)) return !1;
		return !0;
	});
}
function legendSelectActionHandler(t, n, r) {
	var a = t === "allSelect" || t === "inverseSelect", o = {}, s = [];
	r.eachComponent({
		mainType: "legend",
		query: n
	}, function(r) {
		a ? r[t]() : r[t](n.name), makeSelectedMap(r, o), s.push(r.componentIndex);
	});
	var c = {};
	return r.eachComponent("legend", function(t) {
		each(o, function(n, r) {
			t[n ? "select" : "unSelect"](r);
		}), makeSelectedMap(t, c);
	}), a ? {
		selected: c,
		legendIndex: s
	} : {
		name: n.name,
		selected: c
	};
}
function makeSelectedMap(t, n) {
	var r = n || {};
	return each(t.getData(), function(n) {
		var a = n.get("name");
		if (!(a === "\n" || a === "")) {
			var o = t.isSelected(a);
			hasOwn(r, a) ? r[a] = r[a] && o : r[a] = o;
		}
	}), r;
}
function installLegendAction(t) {
	t.registerAction("legendToggleSelect", "legendselectchanged", curry(legendSelectActionHandler, "toggleSelected")), t.registerAction("legendAllSelect", "legendselectall", curry(legendSelectActionHandler, "allSelect")), t.registerAction("legendInverseSelect", "legendinverseselect", curry(legendSelectActionHandler, "inverseSelect")), t.registerAction("legendSelect", "legendselected", curry(legendSelectActionHandler, "select")), t.registerAction("legendUnSelect", "legendunselected", curry(legendSelectActionHandler, "unSelect"));
}
function install$50(t) {
	t.registerComponentModel(LegendModel_default), t.registerComponentView(LegendView_default), t.registerProcessor(t.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter), t.registerSubTypeDefaulter("legend", function() {
		return "plain";
	}), installLegendAction(t);
}
var ScrollableLegendModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.setScrollDataIndex = function(t) {
		this.option.scrollDataIndex = t;
	}, n.prototype.init = function(n, r, a) {
		var o = getLayoutParams(n);
		t.prototype.init.call(this, n, r, a), mergeAndNormalizeLayoutParams(this, n, o);
	}, n.prototype.mergeOption = function(n, r) {
		t.prototype.mergeOption.call(this, n, r), mergeAndNormalizeLayoutParams(this, this.option, n);
	}, n.type = "legend.scroll", n.defaultOption = inheritDefaultOption(LegendModel_default.defaultOption, {
		scrollDataIndex: 0,
		pageButtonItemGap: 5,
		pageButtonGap: null,
		pageButtonPosition: "end",
		pageFormatter: "{current}/{total}",
		pageIcons: {
			horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
			vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
		},
		pageIconColor: "#2f4554",
		pageIconInactiveColor: "#aaa",
		pageIconSize: 15,
		pageTextStyle: { color: "#333" },
		animationDurationUpdate: 800
	}), n;
}(LegendModel_default);
function mergeAndNormalizeLayoutParams(t, n, r) {
	var a = t.getOrient(), o = [1, 1];
	o[a.index] = 0, mergeLayoutParam(n, r, {
		type: "box",
		ignoreSize: !!o
	});
}
var ScrollableLegendModel_default = ScrollableLegendModel, Group = Group_default, WH = ["width", "height"], XY = ["x", "y"], ScrollableLegendView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.newlineDisabled = !0, r._currentIndex = 0, r;
	}
	return n.prototype.init = function() {
		t.prototype.init.call(this), this.group.add(this._containerGroup = new Group()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new Group());
	}, n.prototype.resetInner = function() {
		t.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
	}, n.prototype.renderInner = function(n, r, a, o, s, c, l) {
		var u = this;
		t.prototype.renderInner.call(this, n, r, a, o, s, c, l);
		var d = this._controllerGroup, f = r.get("pageIconSize", !0), p = isArray(f) ? f : [f, f];
		g("pagePrev", 0);
		var h = r.getModel("pageTextStyle");
		d.add(new Text_default({
			name: "pageText",
			style: {
				text: "xx/xx",
				fill: h.getTextColor(),
				font: h.getFont(),
				verticalAlign: "middle",
				align: "center"
			},
			silent: !0
		})), g("pageNext", 1);
		function g(t, n) {
			var a = t + "DataIndex", s = createIcon(r.get("pageIcons", !0)[r.getOrient().name][n], { onclick: bind(u._pageGo, u, a, r, o) }, {
				x: -p[0] / 2,
				y: -p[1] / 2,
				width: p[0],
				height: p[1]
			});
			s.name = t, d.add(s);
		}
	}, n.prototype.layoutInner = function(t, n, r, a, o, s) {
		var c = this.getSelectorGroup(), l = t.getOrient().index, u = WH[l], d = XY[l], f = WH[1 - l], p = XY[1 - l];
		o && box("horizontal", c, t.get("selectorItemGap", !0));
		var h = t.get("selectorButtonGap", !0), g = c.getBoundingRect(), _ = [-g.x, -g.y], v = clone$1(r);
		o && (v[u] = r[u] - g[u] - h);
		var y = this._layoutContentAndController(t, a, v, l, u, f, p, d);
		if (o) {
			if (s === "end") _[l] += y[u] + h;
			else {
				var b = g[u] + h;
				_[l] -= b, y[d] -= b;
			}
			y[u] += g[u] + h, _[1 - l] += y[p] + y[f] / 2 - g[f] / 2, y[f] = Math.max(y[f], g[f]), y[p] = Math.min(y[p], g[p] + _[1 - l]), c.x = _[0], c.y = _[1], c.markRedraw();
		}
		return y;
	}, n.prototype._layoutContentAndController = function(t, n, r, a, o, s, c, l) {
		var u = this.getContentGroup(), d = this._containerGroup, f = this._controllerGroup;
		box(t.get("orient"), u, t.get("itemGap"), a ? r.width : null, a ? null : r.height), box("horizontal", f, t.get("pageButtonItemGap", !0));
		var p = u.getBoundingRect(), h = f.getBoundingRect(), g = this._showController = p[o] > r[o], _ = [-p.x, -p.y];
		n || (_[a] = u[l]);
		var v = [0, 0], y = [-h.x, -h.y], b = retrieve2(t.get("pageButtonGap", !0), t.get("itemGap", !0));
		g && (t.get("pageButtonPosition", !0) === "end" ? y[a] += r[o] - h[o] : v[a] += h[o] + b), y[1 - a] += p[s] / 2 - h[s] / 2, u.setPosition(_), d.setPosition(v), f.setPosition(y);
		var x = {
			x: 0,
			y: 0
		};
		if (x[o] = g ? r[o] : p[o], x[s] = Math.max(p[s], h[s]), x[c] = Math.min(0, h[c] + y[1 - a]), d.__rectSize = r[o], g) {
			var S = {
				x: 0,
				y: 0
			};
			S[o] = Math.max(r[o] - h[o] - b, 0), S[s] = x[s], d.setClipPath(new Rect_default({ shape: S })), d.__rectSize = S[o];
		} else f.eachChild(function(t) {
			t.attr({
				invisible: !0,
				silent: !0
			});
		});
		var C = this._getPageInfo(t);
		return C.pageIndex != null && updateProps(u, {
			x: C.contentPosition[0],
			y: C.contentPosition[1]
		}, g ? t : null), this._updatePageInfoView(t, C), x;
	}, n.prototype._pageGo = function(t, n, r) {
		var a = this._getPageInfo(n)[t];
		a != null && r.dispatchAction({
			type: "legendScroll",
			scrollDataIndex: a,
			legendId: n.id
		});
	}, n.prototype._updatePageInfoView = function(t, n) {
		var r = this._controllerGroup;
		each(["pagePrev", "pageNext"], function(a) {
			var o = n[a + "DataIndex"] != null, s = r.childOfName(a);
			s && (s.setStyle("fill", o ? t.get("pageIconColor", !0) : t.get("pageIconInactiveColor", !0)), s.cursor = o ? "pointer" : "default");
		});
		var a = r.childOfName("pageText"), o = t.get("pageFormatter"), s = n.pageIndex, c = s == null ? 0 : s + 1, l = n.pageCount;
		a && o && a.setStyle("text", isString(o) ? o.replace("{current}", c == null ? "" : c + "").replace("{total}", l == null ? "" : l + "") : o({
			current: c,
			total: l
		}));
	}, n.prototype._getPageInfo = function(t) {
		var n = t.get("scrollDataIndex", !0), r = this.getContentGroup(), a = this._containerGroup.__rectSize, o = t.getOrient().index, s = WH[o], c = XY[o], l = this._findTargetItemIndex(n), u = r.children(), d = u[l], f = u.length, p = f ? 1 : 0, h = {
			contentPosition: [r.x, r.y],
			pageCount: p,
			pageIndex: p - 1,
			pagePrevDataIndex: null,
			pageNextDataIndex: null
		};
		if (!d) return h;
		var g = x(d);
		h.contentPosition[o] = -g.s;
		for (var _ = l + 1, v = g, y = g, b = null; _ <= f; ++_) b = x(u[_]), (!b && y.e > v.s + a || b && !S(b, v.s)) && (v = y.i > v.i ? y : b, v && (h.pageNextDataIndex ??= v.i, ++h.pageCount)), y = b;
		for (var _ = l - 1, v = g, y = g, b = null; _ >= -1; --_) b = x(u[_]), (!b || !S(y, b.s)) && v.i < y.i && (y = v, h.pagePrevDataIndex ??= v.i, ++h.pageCount, ++h.pageIndex), v = b;
		return h;
		function x(t) {
			if (t) {
				var n = t.getBoundingRect(), r = n[c] + t[c];
				return {
					s: r,
					e: r + n[s],
					i: t.__legendDataIndex
				};
			}
		}
		function S(t, n) {
			return t.e >= n && t.s <= n + a;
		}
	}, n.prototype._findTargetItemIndex = function(t) {
		if (!this._showController) return 0;
		var n, r = this.getContentGroup(), a;
		return r.eachChild(function(r, o) {
			var s = r.__legendDataIndex;
			a == null && s != null && (a = o), s === t && (n = o);
		}), n ?? a;
	}, n.type = "legend.scroll", n;
}(LegendView_default);
function installScrollableLegendAction(t) {
	t.registerAction("legendScroll", "legendscroll", function(t, n) {
		var r = t.scrollDataIndex;
		r != null && n.eachComponent({
			mainType: "legend",
			subType: "scroll",
			query: t
		}, function(t) {
			t.setScrollDataIndex(r);
		});
	});
}
function install$51(t) {
	use(install$50), t.registerComponentModel(ScrollableLegendModel_default), t.registerComponentView(ScrollableLegendView_default), installScrollableLegendAction(t);
}
function install$40(t) {
	use(install$50), use(install$51);
}
var InsideZoomModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.type = "dataZoom.inside", n.defaultOption = inheritDefaultOption(DataZoomModel_default.defaultOption, {
		disabled: !1,
		zoomLock: !1,
		zoomOnMouseWheel: !0,
		moveOnMouseMove: !0,
		moveOnMouseWheel: !1,
		preventDefaultMouseMove: !0
	}), n;
}(DataZoomModel_default), inner$1 = makeInner();
function setViewInfoToCoordSysRecord(t, n, r) {
	inner$1(t).coordSysRecordMap.each(function(t) {
		var a = t.dataZoomInfoMap.get(n.uid);
		a && (a.getRange = r);
	});
}
function disposeCoordSysRecordIfNeeded(t, n) {
	for (var r = inner$1(t).coordSysRecordMap, a = r.keys(), o = 0; o < a.length; o++) {
		var s = a[o], c = r.get(s), l = c.dataZoomInfoMap;
		if (l) {
			var u = n.uid;
			l.get(u) && (l.removeKey(u), l.keys().length || disposeCoordSysRecord(r, c));
		}
	}
}
function disposeCoordSysRecord(t, n) {
	if (n) {
		t.removeKey(n.model.uid);
		var r = n.controller;
		r && r.dispose();
	}
}
function createCoordSysRecord(t, n) {
	var r = {
		model: n,
		containsPoint: curry(containsPoint, n),
		dispatchAction: curry(dispatchAction, t),
		dataZoomInfoMap: null,
		controller: null
	}, a = r.controller = new RoamController_default(t.getZr());
	return each([
		"pan",
		"zoom",
		"scrollMove"
	], function(t) {
		a.on(t, function(n) {
			var a = [];
			r.dataZoomInfoMap.each(function(o) {
				if (n.isAvailableBehavior(o.model.option)) {
					var s = (o.getRange || {})[t], c = s && s(o.dzReferCoordSysInfo, r.model.mainType, r.controller, n);
					!o.model.get("disabled", !0) && c && a.push({
						dataZoomId: o.model.id,
						start: c[0],
						end: c[1]
					});
				}
			}), a.length && r.dispatchAction(a);
		});
	}), r;
}
function dispatchAction(t, n) {
	t.isDisposed() || t.dispatchAction({
		type: "dataZoom",
		animation: {
			easing: "cubicOut",
			duration: 100
		},
		batch: n
	});
}
function containsPoint(t, n, r, a) {
	return t.coordinateSystem.containPoint([r, a]);
}
function mergeControllerParams(t) {
	var n, r = "type_", a = {
		type_true: 2,
		type_move: 1,
		type_false: 0,
		type_undefined: -1
	}, o = !0;
	return t.each(function(t) {
		var s = t.model, c = s.get("disabled", !0) ? !1 : s.get("zoomLock", !0) ? "move" : !0;
		a[r + c] > a[r + n] && (n = c), o &&= s.get("preventDefaultMouseMove", !0);
	}), {
		controlType: n,
		opt: {
			zoomOnMouseWheel: !0,
			moveOnMouseMove: !0,
			moveOnMouseWheel: !0,
			preventDefaultMouseMove: !!o
		}
	};
}
function installDataZoomRoamProcessor(t) {
	t.registerProcessor(t.PRIORITY.PROCESSOR.FILTER, function(t, n) {
		var r = inner$1(n), a = r.coordSysRecordMap ||= createHashMap();
		a.each(function(t) {
			t.dataZoomInfoMap = null;
		}), t.eachComponent({
			mainType: "dataZoom",
			subType: "inside"
		}, function(t) {
			each(collectReferCoordSysModelInfo(t).infoList, function(r) {
				var o = r.model.uid, s = a.get(o) || a.set(o, createCoordSysRecord(n, r.model));
				(s.dataZoomInfoMap ||= createHashMap()).set(t.uid, {
					dzReferCoordSysInfo: r,
					model: t,
					getRange: null
				});
			});
		}), a.each(function(t) {
			var n = t.controller, r, o = t.dataZoomInfoMap;
			if (o) {
				var s = o.keys()[0];
				s != null && (r = o.get(s));
			}
			if (!r) {
				disposeCoordSysRecord(a, t);
				return;
			}
			var c = mergeControllerParams(o);
			n.enable(c.controlType, c.opt), n.setPointerChecker(t.containsPoint), createOrUpdate(t, "dispatchAction", r.model.get("throttle", !0), "fixRate");
		});
	});
}
var InsideZoomView = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n.type = "dataZoom.inside", n;
	}
	return n.prototype.render = function(n, r, a) {
		if (t.prototype.render.apply(this, arguments), n.noTarget()) {
			this._clear();
			return;
		}
		this.range = n.getPercentRange(), setViewInfoToCoordSysRecord(a, n, {
			pan: bind(getRangeHandlers.pan, this),
			zoom: bind(getRangeHandlers.zoom, this),
			scrollMove: bind(getRangeHandlers.scrollMove, this)
		});
	}, n.prototype.dispose = function() {
		this._clear(), t.prototype.dispose.apply(this, arguments);
	}, n.prototype._clear = function() {
		disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel), this.range = null;
	}, n.type = "dataZoom.inside", n;
}(DataZoomView_default), getRangeHandlers = {
	zoom: function(t, n, r, a) {
		var o = this.range, s = o.slice(), c = t.axisModels[0];
		if (c) {
			var l = getDirectionInfo[n](null, [a.originX, a.originY], c, r, t), u = (l.signal > 0 ? l.pixelStart + l.pixelLength - l.pixel : l.pixel - l.pixelStart) / l.pixelLength * (s[1] - s[0]) + s[0], d = Math.max(1 / a.scale, 0);
			s[0] = (s[0] - u) * d + u, s[1] = (s[1] - u) * d + u;
			var f = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
			if (sliderMove(0, s, [0, 100], 0, f.minSpan, f.maxSpan), this.range = s, o[0] !== s[0] || o[1] !== s[1]) return s;
		}
	},
	pan: makeMover(function(t, n, r, a, o, s) {
		var c = getDirectionInfo[a]([s.oldX, s.oldY], [s.newX, s.newY], n, o, r);
		return c.signal * (t[1] - t[0]) * c.pixel / c.pixelLength;
	}),
	scrollMove: makeMover(function(t, n, r, a, o, s) {
		return getDirectionInfo[a]([0, 0], [s.scrollDelta, s.scrollDelta], n, o, r).signal * (t[1] - t[0]) * s.scrollDelta;
	})
};
function makeMover(t) {
	return function(n, r, a, o) {
		var s = this.range, c = s.slice(), l = n.axisModels[0];
		if (l && (sliderMove(t(c, l, n, r, a, o), c, [0, 100], "all"), this.range = c, s[0] !== c[0] || s[1] !== c[1])) return c;
	};
}
var getDirectionInfo = {
	grid: function(t, n, r, a, o) {
		var s = r.axis, c = {}, l = o.model.coordinateSystem.getRect();
		return t ||= [0, 0], s.dim === "x" ? (c.pixel = n[0] - t[0], c.pixelLength = l.width, c.pixelStart = l.x, c.signal = s.inverse ? 1 : -1) : (c.pixel = n[1] - t[1], c.pixelLength = l.height, c.pixelStart = l.y, c.signal = s.inverse ? -1 : 1), c;
	},
	polar: function(t, n, r, a, o) {
		var s = r.axis, c = {}, l = o.model.coordinateSystem, u = l.getRadiusAxis().getExtent(), d = l.getAngleAxis().getExtent();
		return t = t ? l.pointToCoord(t) : [0, 0], n = l.pointToCoord(n), r.mainType === "radiusAxis" ? (c.pixel = n[0] - t[0], c.pixelLength = u[1] - u[0], c.pixelStart = u[0], c.signal = s.inverse ? 1 : -1) : (c.pixel = n[1] - t[1], c.pixelLength = d[1] - d[0], c.pixelStart = d[0], c.signal = s.inverse ? -1 : 1), c;
	},
	singleAxis: function(t, n, r, a, o) {
		var s = r.axis, c = o.model.coordinateSystem.getRect(), l = {};
		return t ||= [0, 0], s.orient === "horizontal" ? (l.pixel = n[0] - t[0], l.pixelLength = c.width, l.pixelStart = c.x, l.signal = s.inverse ? 1 : -1) : (l.pixel = n[1] - t[1], l.pixelLength = c.height, l.pixelStart = c.y, l.signal = s.inverse ? -1 : 1), l;
	}
}, InsideZoomView_default = InsideZoomView;
function install$42(t) {
	installCommon$1(t), t.registerComponentModel(InsideZoomModel_default), t.registerComponentView(InsideZoomView_default), installDataZoomRoamProcessor(t);
}
var SliderZoomModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.type = "dataZoom.slider", n.layoutMode = "box", n.defaultOption = inheritDefaultOption(DataZoomModel_default.defaultOption, {
		show: !0,
		right: "ph",
		top: "ph",
		width: "ph",
		height: "ph",
		left: null,
		bottom: null,
		borderColor: "#d2dbee",
		borderRadius: 3,
		backgroundColor: "rgba(47,69,84,0)",
		dataBackground: {
			lineStyle: {
				color: "#d2dbee",
				width: .5
			},
			areaStyle: {
				color: "#d2dbee",
				opacity: .2
			}
		},
		selectedDataBackground: {
			lineStyle: {
				color: "#8fb0f7",
				width: .5
			},
			areaStyle: {
				color: "#8fb0f7",
				opacity: .2
			}
		},
		fillerColor: "rgba(135,175,274,0.2)",
		handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
		handleSize: "100%",
		handleStyle: {
			color: "#fff",
			borderColor: "#ACB8D1"
		},
		moveHandleSize: 7,
		moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
		moveHandleStyle: {
			color: "#D2DBEE",
			opacity: .7
		},
		showDetail: !0,
		showDataShadow: "auto",
		realtime: !0,
		zoomLock: !1,
		textStyle: { color: "#6E7079" },
		brushSelect: !0,
		brushStyle: { color: "rgba(135,175,274,0.15)" },
		emphasis: {
			handleLabel: { show: !0 },
			handleStyle: { borderColor: "#8FB0F7" },
			moveHandleStyle: { color: "#8FB0F7" }
		}
	}), n;
}(DataZoomModel_default);
init_dist$2();
var Rect = Rect_default, DEFAULT_LOCATION_EDGE_GAP = 7, DEFAULT_FRAME_BORDER_WIDTH = 1, DEFAULT_FILLER_SIZE = 30, DEFAULT_MOVE_HANDLE_SIZE = 7, HORIZONTAL = "horizontal", VERTICAL = "vertical", LABEL_GAP = 5, SHOW_DATA_SHADOW_SERIES_TYPE = [
	"line",
	"bar",
	"candlestick",
	"scatter"
], REALTIME_ANIMATION_CONFIG = {
	easing: "cubicOut",
	duration: 100,
	delay: 0
}, SliderZoomView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r._displayables = {}, r;
	}
	return n.prototype.init = function(t, n) {
		this.api = n, this._onBrush = bind(this._onBrush, this), this._onBrushEnd = bind(this._onBrushEnd, this);
	}, n.prototype.render = function(n, r, a, o) {
		if (t.prototype.render.apply(this, arguments), createOrUpdate(this, "_dispatchZoomAction", n.get("throttle"), "fixRate"), this._orient = n.getOrient(), n.get("show") === !1) {
			this.group.removeAll();
			return;
		}
		if (n.noTarget()) {
			this._clear(), this.group.removeAll();
			return;
		}
		(!o || o.type !== "dataZoom" || o.from !== this.uid) && this._buildView(), this._updateView();
	}, n.prototype.dispose = function() {
		this._clear(), t.prototype.dispose.apply(this, arguments);
	}, n.prototype._clear = function() {
		clear(this, "_dispatchZoomAction");
		var t = this.api.getZr();
		t.off("mousemove", this._onBrush), t.off("mouseup", this._onBrushEnd);
	}, n.prototype._buildView = function() {
		var t = this.group;
		t.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
		var n = this._displayables.sliderGroup = new Group_default();
		this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(n), this._positionGroup();
	}, n.prototype._resetLocation = function() {
		var t = this.dataZoomModel, n = this.api, r = t.get("brushSelect") ? DEFAULT_MOVE_HANDLE_SIZE : 0, a = this._findCoordRect(), o = {
			width: n.getWidth(),
			height: n.getHeight()
		}, s = this._orient === HORIZONTAL ? {
			right: o.width - a.x - a.width,
			top: o.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - r,
			width: a.width,
			height: DEFAULT_FILLER_SIZE
		} : {
			right: DEFAULT_LOCATION_EDGE_GAP,
			top: a.y,
			width: DEFAULT_FILLER_SIZE,
			height: a.height
		}, c = getLayoutParams(t.option);
		each([
			"right",
			"top",
			"width",
			"height"
		], function(t) {
			c[t] === "ph" && (c[t] = s[t]);
		});
		var l = getLayoutRect(c, o);
		this._location = {
			x: l.x,
			y: l.y
		}, this._size = [l.width, l.height], this._orient === VERTICAL && this._size.reverse();
	}, n.prototype._positionGroup = function() {
		var t = this.group, n = this._location, r = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), o = a && a.get("inverse"), s = this._displayables.sliderGroup, c = (this._dataShadowInfo || {}).otherAxisInverse;
		s.attr(r === HORIZONTAL && !o ? {
			scaleY: c ? 1 : -1,
			scaleX: 1
		} : r === HORIZONTAL && o ? {
			scaleY: c ? 1 : -1,
			scaleX: -1
		} : r === VERTICAL && !o ? {
			scaleY: c ? -1 : 1,
			scaleX: 1,
			rotation: Math.PI / 2
		} : {
			scaleY: c ? -1 : 1,
			scaleX: -1,
			rotation: Math.PI / 2
		});
		var l = t.getBoundingRect([s]);
		t.x = n.x - l.x, t.y = n.y - l.y, t.markRedraw();
	}, n.prototype._getViewExtent = function() {
		return [0, this._size[0]];
	}, n.prototype._renderBackground = function() {
		var t = this.dataZoomModel, n = this._size, r = this._displayables.sliderGroup, a = t.get("brushSelect");
		r.add(new Rect({
			silent: !0,
			shape: {
				x: 0,
				y: 0,
				width: n[0],
				height: n[1]
			},
			style: { fill: t.get("backgroundColor") },
			z2: -40
		}));
		var o = new Rect({
			shape: {
				x: 0,
				y: 0,
				width: n[0],
				height: n[1]
			},
			style: { fill: "transparent" },
			z2: 0,
			onclick: bind(this._onClickPanel, this)
		}), s = this.api.getZr();
		a ? (o.on("mousedown", this._onBrushStart, this), o.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), r.add(o);
	}, n.prototype._renderDataShadow = function() {
		var t = this._dataShadowInfo = this._prepareDataShadowInfo();
		if (this._displayables.dataShadowSegs = [], !t) return;
		var n = this._size, r = this._shadowSize || [], a = t.series, o = a.getRawData(), s = a.getShadowDim && a.getShadowDim(), c = s && o.getDimensionInfo(s) ? a.getShadowDim() : t.otherDim;
		if (c == null) return;
		var l = this._shadowPolygonPts, u = this._shadowPolylinePts;
		if (o !== this._shadowData || c !== this._shadowDim || n[0] !== r[0] || n[1] !== r[1]) {
			var d = o.getDataExtent(c), f = (d[1] - d[0]) * .3;
			d = [d[0] - f, d[1] + f];
			var p = [0, n[1]], h = [0, n[0]], g = [[n[0], 0], [0, 0]], _ = [], v = h[1] / (o.count() - 1), y = 0, b = Math.round(o.count() / n[0]), x;
			o.each([c], function(t, n) {
				if (b > 0 && n % b) {
					y += v;
					return;
				}
				var r = t == null || isNaN(t) || t === "", a = r ? 0 : linearMap$2(t, d, p, !0);
				r && !x && n ? (g.push([g[g.length - 1][0], 0]), _.push([_[_.length - 1][0], 0])) : !r && x && (g.push([y, 0]), _.push([y, 0])), g.push([y, a]), _.push([y, a]), y += v, x = r;
			}), l = this._shadowPolygonPts = g, u = this._shadowPolylinePts = _;
		}
		this._shadowData = o, this._shadowDim = c, this._shadowSize = [n[0], n[1]];
		var S = this.dataZoomModel;
		function C(t) {
			var n = S.getModel(t ? "selectedDataBackground" : "dataBackground"), r = new Group_default(), a = new Polygon_default({
				shape: { points: l },
				segmentIgnoreThreshold: 1,
				style: n.getModel("areaStyle").getAreaStyle(),
				silent: !0,
				z2: -20
			}), o = new Polyline_default$1({
				shape: { points: u },
				segmentIgnoreThreshold: 1,
				style: n.getModel("lineStyle").getLineStyle(),
				silent: !0,
				z2: -19
			});
			return r.add(a), r.add(o), r;
		}
		for (var w = 0; w < 3; w++) {
			var T = C(w === 1);
			this._displayables.sliderGroup.add(T), this._displayables.dataShadowSegs.push(T);
		}
	}, n.prototype._prepareDataShadowInfo = function() {
		var t = this.dataZoomModel, n = t.get("showDataShadow");
		if (n !== !1) {
			var r, a = this.ecModel;
			return t.eachTargetAxis(function(o, s) {
				each(t.getAxisProxy(o, s).getTargetSeriesModels(), function(t) {
					if (!r && !(n !== !0 && indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, t.get("type")) < 0)) {
						var c = a.getComponent(getAxisMainType(o), s).axis, l = getOtherDim(o), u, d = t.coordinateSystem;
						l != null && d.getOtherAxis && (u = d.getOtherAxis(c).inverse), l = t.getData().mapDimension(l), r = {
							thisAxis: c,
							series: t,
							thisDim: o,
							otherDim: l,
							otherAxisInverse: u
						};
					}
				}, this);
			}, this), r;
		}
	}, n.prototype._renderHandle = function() {
		var t = this.group, n = this._displayables, r = n.handles = [null, null], a = n.handleLabels = [null, null], o = this._displayables.sliderGroup, c = this._size, l = this.dataZoomModel, u = this.api, d = l.get("borderRadius") || 0, f = l.get("brushSelect"), p = n.filler = new Rect({
			silent: f,
			style: { fill: l.get("fillerColor") },
			textConfig: { position: "inside" }
		});
		o.add(p), o.add(new Rect({
			silent: !0,
			subPixelOptimize: !0,
			shape: {
				x: 0,
				y: 0,
				width: c[0],
				height: c[1],
				r: d
			},
			style: {
				stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
				lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
				fill: "rgba(0,0,0,0)"
			}
		})), each([0, 1], function(n) {
			var c = l.get("handleIcon");
			!symbolBuildProxies[c] && c.indexOf("path://") < 0 && c.indexOf("image://") < 0 && (c = "path://" + c, process$1.env.NODE_ENV !== "production" && deprecateLog("handleIcon now needs 'path://' prefix when using a path string"));
			var u = createSymbol(c, -1, 0, 2, 2, null, !0);
			u.attr({
				cursor: getCursor$1(this._orient),
				draggable: !0,
				drift: bind(this._onDragMove, this, n),
				ondragend: bind(this._onDragEnd, this),
				onmouseover: bind(this._showDataInfo, this, !0),
				onmouseout: bind(this._showDataInfo, this, !1),
				z2: 5
			});
			var d = u.getBoundingRect();
			this._handleHeight = parsePercent$1(l.get("handleSize"), this._size[1]), this._handleWidth = d.width / d.height * this._handleHeight, u.setStyle(l.getModel("handleStyle").getItemStyle()), u.style.strokeNoScale = !0, u.rectHover = !0, u.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), enableHoverEmphasis(u);
			var f = l.get("handleColor");
			f != null && (u.style.fill = f), o.add(r[n] = u);
			var p = l.getModel("textStyle"), h = (l.get("handleLabel") || {}).show || !1;
			t.add(a[n] = new Text_default({
				silent: !0,
				invisible: !h,
				style: createTextStyle(p, {
					x: 0,
					y: 0,
					text: "",
					verticalAlign: "middle",
					align: "center",
					fill: p.getTextColor(),
					font: p.getFont()
				}),
				z2: 10
			}));
		}, this);
		var h = p;
		if (f) {
			var g = parsePercent$1(l.get("moveHandleSize"), c[1]), _ = n.moveHandle = new Rect_default({
				style: l.getModel("moveHandleStyle").getItemStyle(),
				silent: !0,
				shape: {
					r: [
						0,
						0,
						2,
						2
					],
					y: c[1] - .5,
					height: g
				}
			}), v = g * .8, y = n.moveHandleIcon = createSymbol(l.get("moveHandleIcon"), -v / 2, -v / 2, v, v, "#fff", !0);
			y.silent = !0, y.y = c[1] + g / 2 - .5, _.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
			var b = Math.min(c[1] / 2, Math.max(g, 10));
			h = n.moveZone = new Rect_default({
				invisible: !0,
				shape: {
					y: c[1] - b,
					height: g + b
				}
			}), h.on("mouseover", function() {
				u.enterEmphasis(_);
			}).on("mouseout", function() {
				u.leaveEmphasis(_);
			}), o.add(_), o.add(y), o.add(h);
		}
		h.attr({
			draggable: !0,
			cursor: getCursor$1(this._orient),
			drift: bind(this._onDragMove, this, "all"),
			ondragstart: bind(this._showDataInfo, this, !0),
			ondragend: bind(this._onDragEnd, this),
			onmouseover: bind(this._showDataInfo, this, !0),
			onmouseout: bind(this._showDataInfo, this, !1)
		});
	}, n.prototype._resetInterval = function() {
		var t = this._range = this.dataZoomModel.getPercentRange(), n = this._getViewExtent();
		this._handleEnds = [linearMap$2(t[0], [0, 100], n, !0), linearMap$2(t[1], [0, 100], n, !0)];
	}, n.prototype._updateInterval = function(t, n) {
		var r = this.dataZoomModel, a = this._handleEnds, o = this._getViewExtent(), s = r.findRepresentativeAxisProxy().getMinMaxSpan(), c = [0, 100];
		sliderMove(n, a, o, r.get("zoomLock") ? "all" : t, s.minSpan == null ? null : linearMap$2(s.minSpan, c, o, !0), s.maxSpan == null ? null : linearMap$2(s.maxSpan, c, o, !0));
		var l = this._range, u = this._range = asc$1([linearMap$2(a[0], o, c, !0), linearMap$2(a[1], o, c, !0)]);
		return !l || l[0] !== u[0] || l[1] !== u[1];
	}, n.prototype._updateView = function(t) {
		var n = this._displayables, r = this._handleEnds, a = asc$1(r.slice()), o = this._size;
		each([0, 1], function(t) {
			var a = n.handles[t], s = this._handleHeight;
			a.attr({
				scaleX: s / 2,
				scaleY: s / 2,
				x: r[t] + (t ? -1 : 1),
				y: o[1] / 2 - s / 2
			});
		}, this), n.filler.setShape({
			x: a[0],
			y: 0,
			width: a[1] - a[0],
			height: o[1]
		});
		var s = {
			x: a[0],
			width: a[1] - a[0]
		};
		n.moveHandle && (n.moveHandle.setShape(s), n.moveZone.setShape(s), n.moveZone.getBoundingRect(), n.moveHandleIcon && n.moveHandleIcon.attr("x", s.x + s.width / 2));
		for (var c = n.dataShadowSegs, l = [
			0,
			a[0],
			a[1],
			o[0]
		], u = 0; u < c.length; u++) {
			var d = c[u], f = d.getClipPath();
			f || (f = new Rect_default(), d.setClipPath(f)), f.setShape({
				x: l[u],
				y: 0,
				width: l[u + 1] - l[u],
				height: o[1]
			});
		}
		this._updateDataInfo(t);
	}, n.prototype._updateDataInfo = function(t) {
		var n = this.dataZoomModel, r = this._displayables, a = r.handleLabels, o = this._orient, s = ["", ""];
		if (n.get("showDetail")) {
			var c = n.findRepresentativeAxisProxy();
			if (c) {
				var l = c.getAxisModel().axis, u = this._range, d = t ? c.calculateDataWindow({
					start: u[0],
					end: u[1]
				}).valueWindow : c.getDataValueWindow();
				s = [this._formatLabel(d[0], l), this._formatLabel(d[1], l)];
			}
		}
		var f = asc$1(this._handleEnds.slice());
		p.call(this, 0), p.call(this, 1);
		function p(t) {
			var n = getTransform$1(r.handles[t].parent, this.group), c = transformDirection(t === 0 ? "right" : "left", n), l = this._handleWidth / 2 + LABEL_GAP, u = applyTransform$1([f[t] + (t === 0 ? -l : l), this._size[1] / 2], n);
			a[t].setStyle({
				x: u[0],
				y: u[1],
				verticalAlign: o === HORIZONTAL ? "middle" : c,
				align: o === HORIZONTAL ? c : "center",
				text: s[t]
			});
		}
	}, n.prototype._formatLabel = function(t, n) {
		var r = this.dataZoomModel, a = r.get("labelFormatter"), o = r.get("labelPrecision");
		(o == null || o === "auto") && (o = n.getPixelPrecision());
		var s = t == null || isNaN(t) ? "" : n.type === "category" || n.type === "time" ? n.scale.getLabel({ value: Math.round(t) }) : t.toFixed(Math.min(o, 20));
		return isFunction(a) ? a(t, s) : isString(a) ? a.replace("{value}", s) : s;
	}, n.prototype._showDataInfo = function(t) {
		var n = (this.dataZoomModel.get("handleLabel") || {}).show || !1, r = this.dataZoomModel.getModel(["emphasis", "handleLabel"]).get("show") || !1, a = t || this._dragging ? r : n, o = this._displayables, s = o.handleLabels;
		s[0].attr("invisible", !a), s[1].attr("invisible", !a), o.moveHandle && this.api[a ? "enterEmphasis" : "leaveEmphasis"](o.moveHandle, 1);
	}, n.prototype._onDragMove = function(t, n, r, a) {
		this._dragging = !0, stop(a.event);
		var o = this._displayables.sliderGroup.getLocalTransform(), s = applyTransform$1([n, r], o, !0), c = this._updateInterval(t, s[0]), l = this.dataZoomModel.get("realtime");
		this._updateView(!l), c && l && this._dispatchZoomAction(!0);
	}, n.prototype._onDragEnd = function() {
		this._dragging = !1, this._showDataInfo(!1), !this.dataZoomModel.get("realtime") && this._dispatchZoomAction(!1);
	}, n.prototype._onClickPanel = function(t) {
		var n = this._size, r = this._displayables.sliderGroup.transformCoordToLocal(t.offsetX, t.offsetY);
		if (!(r[0] < 0 || r[0] > n[0] || r[1] < 0 || r[1] > n[1])) {
			var a = this._handleEnds, o = (a[0] + a[1]) / 2, s = this._updateInterval("all", r[0] - o);
			this._updateView(), s && this._dispatchZoomAction(!1);
		}
	}, n.prototype._onBrushStart = function(t) {
		var n = t.offsetX, r = t.offsetY;
		this._brushStart = new Point_default(n, r), this._brushing = !0, this._brushStartTime = +/* @__PURE__ */ new Date();
	}, n.prototype._onBrushEnd = function(t) {
		if (this._brushing) {
			var n = this._displayables.brushRect;
			if (this._brushing = !1, n) {
				n.attr("ignore", !0);
				var r = n.shape;
				if (!(+/* @__PURE__ */ new Date() - this._brushStartTime < 200 && Math.abs(r.width) < 5)) {
					var a = this._getViewExtent(), o = [0, 100];
					this._range = asc$1([linearMap$2(r.x, a, o, !0), linearMap$2(r.x + r.width, a, o, !0)]), this._handleEnds = [r.x, r.x + r.width], this._updateView(), this._dispatchZoomAction(!1);
				}
			}
		}
	}, n.prototype._onBrush = function(t) {
		this._brushing && (stop(t.event), this._updateBrushRect(t.offsetX, t.offsetY));
	}, n.prototype._updateBrushRect = function(t, n) {
		var r = this._displayables, a = this.dataZoomModel, o = r.brushRect;
		o || (o = r.brushRect = new Rect({
			silent: !0,
			style: a.getModel("brushStyle").getItemStyle()
		}), r.sliderGroup.add(o)), o.attr("ignore", !1);
		var s = this._brushStart, c = this._displayables.sliderGroup, l = c.transformCoordToLocal(t, n), u = c.transformCoordToLocal(s.x, s.y), d = this._size;
		l[0] = Math.max(Math.min(d[0], l[0]), 0), o.setShape({
			x: u[0],
			y: 0,
			width: l[0] - u[0],
			height: d[1]
		});
	}, n.prototype._dispatchZoomAction = function(t) {
		var n = this._range;
		this.api.dispatchAction({
			type: "dataZoom",
			from: this.uid,
			dataZoomId: this.dataZoomModel.id,
			animation: t ? REALTIME_ANIMATION_CONFIG : null,
			start: n[0],
			end: n[1]
		});
	}, n.prototype._findCoordRect = function() {
		var t, n = collectReferCoordSysModelInfo(this.dataZoomModel).infoList;
		if (!t && n.length) {
			var r = n[0].model.coordinateSystem;
			t = r.getRect && r.getRect();
		}
		if (!t) {
			var a = this.api.getWidth(), o = this.api.getHeight();
			t = {
				x: a * .2,
				y: o * .2,
				width: a * .6,
				height: o * .6
			};
		}
		return t;
	}, n.type = "dataZoom.slider", n;
}(DataZoomView_default);
function getOtherDim(t) {
	return {
		x: "y",
		y: "x",
		radius: "angle",
		angle: "radius"
	}[t];
}
function getCursor$1(t) {
	return t === "vertical" ? "ns-resize" : "ew-resize";
}
var SliderZoomView_default = SliderZoomView;
function install$43(t) {
	t.registerComponentModel(SliderZoomModel_default), t.registerComponentView(SliderZoomView_default), installCommon$1(t);
}
function install$41(t) {
	use(install$42), use(install$43);
}
var visualDefault = { get: function(t, n, r) {
	var a = clone$1((defaultOption[t] || {})[n]);
	return r && isArray(a) ? a[a.length - 1] : a;
} }, defaultOption = {
	color: {
		active: ["#006edd", "#e0ffff"],
		inactive: ["rgba(0,0,0,0)"]
	},
	colorHue: {
		active: [0, 360],
		inactive: [0, 0]
	},
	colorSaturation: {
		active: [.3, 1],
		inactive: [0, 0]
	},
	colorLightness: {
		active: [.9, .5],
		inactive: [0, 0]
	},
	colorAlpha: {
		active: [.3, 1],
		inactive: [0, 0]
	},
	opacity: {
		active: [.3, 1],
		inactive: [0, 0]
	},
	symbol: {
		active: [
			"circle",
			"roundRect",
			"diamond"
		],
		inactive: ["none"]
	},
	symbolSize: {
		active: [10, 50],
		inactive: [0, 0]
	}
}, visualDefault_default = visualDefault, mapVisual = VisualMapping_default.mapVisual, eachVisual = VisualMapping_default.eachVisual, isArray$1 = isArray, each$3 = each, asc = asc$1, linearMap$1 = linearMap$2, VisualMapModel_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.stateList = ["inRange", "outOfRange"], r.replacableOptionKeys = [
			"inRange",
			"outOfRange",
			"target",
			"controller",
			"color"
		], r.layoutMode = {
			type: "box",
			ignoreSize: !0
		}, r.dataBound = [-Infinity, Infinity], r.targetVisuals = {}, r.controllerVisuals = {}, r;
	}
	return n.prototype.init = function(t, n, r) {
		this.mergeDefaultAndTheme(t, r);
	}, n.prototype.optionUpdated = function(t, n) {
		var r = this.option;
		!n && replaceVisualOption(r, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
	}, n.prototype.resetVisual = function(t) {
		var n = this.stateList;
		t = bind(t, this), this.controllerVisuals = createVisualMappings(this.option.controller, n, t), this.targetVisuals = createVisualMappings(this.option.target, n, t);
	}, n.prototype.getItemSymbol = function() {
		return null;
	}, n.prototype.getTargetSeriesIndices = function() {
		var t = this.option.seriesIndex, n = [];
		return t == null || t === "all" ? this.ecModel.eachSeries(function(t, r) {
			n.push(r);
		}) : n = normalizeToArray(t), n;
	}, n.prototype.eachTargetSeries = function(t, n) {
		each(this.getTargetSeriesIndices(), function(r) {
			var a = this.ecModel.getSeriesByIndex(r);
			a && t.call(n, a);
		}, this);
	}, n.prototype.isTargetSeries = function(t) {
		var n = !1;
		return this.eachTargetSeries(function(r) {
			r === t && (n = !0);
		}), n;
	}, n.prototype.formatValueText = function(t, n, r) {
		var a = this.option, o = a.precision, s = this.dataBound, c = a.formatter, l;
		r ||= ["<", ">"], isArray(t) && (t = t.slice(), l = !0);
		var u = n ? t : l ? [d(t[0]), d(t[1])] : d(t);
		if (isString(c)) return c.replace("{value}", l ? u[0] : u).replace("{value2}", l ? u[1] : u);
		if (isFunction(c)) return l ? c(t[0], t[1]) : c(t);
		if (l) return t[0] === s[0] ? r[0] + " " + u[1] : t[1] === s[1] ? r[1] + " " + u[0] : u[0] + " - " + u[1];
		return u;
		function d(t) {
			return t === s[0] ? "min" : t === s[1] ? "max" : (+t).toFixed(Math.min(o, 20));
		}
	}, n.prototype.resetExtent = function() {
		var t = this.option;
		this._dataExtent = asc([t.min, t.max]);
	}, n.prototype.getDataDimensionIndex = function(t) {
		var n = this.option.dimension;
		if (n != null) return t.getDimensionIndex(n);
		for (var r = t.dimensions, a = r.length - 1; a >= 0; a--) {
			var o = r[a], s = t.getDimensionInfo(o);
			if (!s.isCalculationCoord) return s.storeDimIndex;
		}
	}, n.prototype.getExtent = function() {
		return this._dataExtent.slice();
	}, n.prototype.completeVisualOption = function() {
		var t = this.ecModel, n = this.option, r = {
			inRange: n.inRange,
			outOfRange: n.outOfRange
		}, a = n.target ||= {}, o = n.controller ||= {};
		merge(a, r), merge(o, r);
		var s = this.isCategory();
		c.call(this, a), c.call(this, o), l.call(this, a, "inRange", "outOfRange"), u.call(this, o);
		function c(r) {
			isArray$1(n.color) && !r.inRange && (r.inRange = { color: n.color.slice().reverse() }), r.inRange = r.inRange || { color: t.get("gradientColor") };
		}
		function l(t, n, r) {
			var a = t[n], o = t[r];
			a && !o && (o = t[r] = {}, each$3(a, function(t, n) {
				if (VisualMapping_default.isValidType(n)) {
					var r = visualDefault_default.get(n, "inactive", s);
					r != null && (o[n] = r, n === "color" && !o.hasOwnProperty("opacity") && !o.hasOwnProperty("colorAlpha") && (o.opacity = [0, 0]));
				}
			}));
		}
		function u(t) {
			var n = (t.inRange || {}).symbol || (t.outOfRange || {}).symbol, r = (t.inRange || {}).symbolSize || (t.outOfRange || {}).symbolSize, a = this.get("inactiveColor"), o = this.getItemSymbol() || "roundRect";
			each$3(this.stateList, function(c) {
				var l = this.itemSize, u = t[c];
				u ||= t[c] = { color: s ? a : [a] }, u.symbol ??= n && clone$1(n) || (s ? o : [o]), u.symbolSize ??= r && clone$1(r) || (s ? l[0] : [l[0], l[0]]), u.symbol = mapVisual(u.symbol, function(t) {
					return t === "none" ? o : t;
				});
				var d = u.symbolSize;
				if (d != null) {
					var f = -Infinity;
					eachVisual(d, function(t) {
						t > f && (f = t);
					}), u.symbolSize = mapVisual(d, function(t) {
						return linearMap$1(t, [0, f], [0, l[0]], !0);
					});
				}
			}, this);
		}
	}, n.prototype.resetItemSize = function() {
		this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
	}, n.prototype.isCategory = function() {
		return !!this.option.categories;
	}, n.prototype.setSelected = function(t) {}, n.prototype.getSelected = function() {
		return null;
	}, n.prototype.getValueState = function(t) {
		return null;
	}, n.prototype.getVisualMeta = function(t) {
		return null;
	}, n.type = "visualMap", n.dependencies = ["series"], n.defaultOption = {
		show: !0,
		z: 4,
		seriesIndex: "all",
		min: 0,
		max: 200,
		left: 0,
		right: null,
		top: null,
		bottom: 0,
		itemWidth: null,
		itemHeight: null,
		inverse: !1,
		orient: "vertical",
		backgroundColor: "rgba(0,0,0,0)",
		borderColor: "#ccc",
		contentColor: "#5793f3",
		inactiveColor: "#aaa",
		borderWidth: 0,
		padding: 5,
		textGap: 10,
		precision: 0,
		textStyle: { color: "#333" }
	}, n;
}(Component_default), DEFAULT_BAR_BOUND = [20, 140], ContinuousModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.optionUpdated = function(n, r) {
		t.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(t) {
			t.mappingMethod = "linear", t.dataExtent = this.getExtent();
		}), this._resetRange();
	}, n.prototype.resetItemSize = function() {
		t.prototype.resetItemSize.apply(this, arguments);
		var n = this.itemSize;
		(n[0] == null || isNaN(n[0])) && (n[0] = DEFAULT_BAR_BOUND[0]), (n[1] == null || isNaN(n[1])) && (n[1] = DEFAULT_BAR_BOUND[1]);
	}, n.prototype._resetRange = function() {
		var t = this.getExtent(), n = this.option.range;
		!n || n.auto ? (t.auto = 1, this.option.range = t) : isArray(n) && (n[0] > n[1] && n.reverse(), n[0] = Math.max(n[0], t[0]), n[1] = Math.min(n[1], t[1]));
	}, n.prototype.completeVisualOption = function() {
		t.prototype.completeVisualOption.apply(this, arguments), each(this.stateList, function(t) {
			var n = this.option.controller[t].symbolSize;
			n && n[0] !== n[1] && (n[0] = n[1] / 3);
		}, this);
	}, n.prototype.setSelected = function(t) {
		this.option.range = t.slice(), this._resetRange();
	}, n.prototype.getSelected = function() {
		var t = this.getExtent(), n = asc$1((this.get("range") || []).slice());
		return n[0] > t[1] && (n[0] = t[1]), n[1] > t[1] && (n[1] = t[1]), n[0] < t[0] && (n[0] = t[0]), n[1] < t[0] && (n[1] = t[0]), n;
	}, n.prototype.getValueState = function(t) {
		var n = this.option.range, r = this.getExtent();
		return (n[0] <= r[0] || n[0] <= t) && (n[1] >= r[1] || t <= n[1]) ? "inRange" : "outOfRange";
	}, n.prototype.findTargetDataIndices = function(t) {
		var n = [];
		return this.eachTargetSeries(function(r) {
			var a = [], o = r.getData();
			o.each(this.getDataDimensionIndex(o), function(n, r) {
				t[0] <= n && n <= t[1] && a.push(r);
			}, this), n.push({
				seriesId: r.id,
				dataIndex: a
			});
		}, this), n;
	}, n.prototype.getVisualMeta = function(t) {
		var n = getColorStopValues(this, "outOfRange", this.getExtent()), r = getColorStopValues(this, "inRange", this.option.range.slice()), a = [];
		function o(n, r) {
			a.push({
				value: n,
				color: t(n, r)
			});
		}
		for (var s = 0, c = 0, l = r.length, u = n.length; c < u && (!r.length || n[c] <= r[0]); c++) n[c] < r[s] && o(n[c], "outOfRange");
		for (var d = 1; s < l; s++, d = 0) d && a.length && o(r[s], "outOfRange"), o(r[s], "inRange");
		for (var d = 1; c < u; c++) (!r.length || r[r.length - 1] < n[c]) && (d &&= (a.length && o(a[a.length - 1].value, "outOfRange"), 0), o(n[c], "outOfRange"));
		var f = a.length;
		return {
			stops: a,
			outerColors: [f ? a[0].color : "transparent", f ? a[f - 1].color : "transparent"]
		};
	}, n.type = "visualMap.continuous", n.defaultOption = inheritDefaultOption(VisualMapModel_default.defaultOption, {
		align: "auto",
		calculable: !1,
		hoverLink: !0,
		realtime: !0,
		handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
		handleSize: "120%",
		handleStyle: {
			borderColor: "#fff",
			borderWidth: 1
		},
		indicatorIcon: "circle",
		indicatorSize: "50%",
		indicatorStyle: {
			borderColor: "#fff",
			borderWidth: 2,
			shadowBlur: 2,
			shadowOffsetX: 1,
			shadowOffsetY: 1,
			shadowColor: "rgba(0,0,0,0.2)"
		}
	}), n;
}(VisualMapModel_default);
function getColorStopValues(t, n, r) {
	if (r[0] === r[1]) return r.slice();
	for (var a = 200, o = (r[1] - r[0]) / a, s = r[0], c = [], l = 0; l <= a && s < r[1]; l++) c.push(s), s += o;
	return c.push(r[1]), c;
}
var ContinuousModel_default = ContinuousModel, VisualMapView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r.autoPositionValues = {
			left: 1,
			right: 1,
			top: 1,
			bottom: 1
		}, r;
	}
	return n.prototype.init = function(t, n) {
		this.ecModel = t, this.api = n;
	}, n.prototype.render = function(t, n, r, a) {
		if (this.visualMapModel = t, t.get("show") === !1) {
			this.group.removeAll();
			return;
		}
		this.doRender(t, n, r, a);
	}, n.prototype.renderBackground = function(t) {
		var n = this.visualMapModel, r = normalizeCssArray(n.get("padding") || 0), a = t.getBoundingRect();
		t.add(new Rect_default({
			z2: -1,
			silent: !0,
			shape: {
				x: a.x - r[3],
				y: a.y - r[0],
				width: a.width + r[3] + r[1],
				height: a.height + r[0] + r[2]
			},
			style: {
				fill: n.get("backgroundColor"),
				stroke: n.get("borderColor"),
				lineWidth: n.get("borderWidth")
			}
		}));
	}, n.prototype.getControllerVisual = function(t, n, r) {
		r ||= {};
		var a = r.forceState, o = this.visualMapModel, s = {};
		n === "color" && (s.color = o.get("contentColor"));
		function c(t) {
			return s[t];
		}
		function l(t, n) {
			s[t] = n;
		}
		var u = o.controllerVisuals[a || o.getValueState(t)];
		return each(VisualMapping_default.prepareVisualTypes(u), function(a) {
			var o = u[a];
			r.convertOpacityToAlpha && a === "opacity" && (a = "colorAlpha", o = u.__alphaForOpacity), VisualMapping_default.dependsOn(a, n) && o && o.applyVisual(t, c, l);
		}), s[n];
	}, n.prototype.positionGroup = function(t) {
		var n = this.visualMapModel, r = this.api;
		positionElement(t, n.getBoxLayoutParams(), {
			width: r.getWidth(),
			height: r.getHeight()
		});
	}, n.prototype.doRender = function(t, n, r, a) {}, n.type = "visualMap", n;
}(Component_default$1), paramsSet = [[
	"left",
	"right",
	"width"
], [
	"top",
	"bottom",
	"height"
]];
function getItemAlign(t, n, r) {
	var a = t.option, o = a.align;
	if (o != null && o !== "auto") return o;
	for (var s = {
		width: n.getWidth(),
		height: n.getHeight()
	}, c = a.orient === "horizontal" ? 1 : 0, l = paramsSet[c], u = [
		0,
		null,
		10
	], d = {}, f = 0; f < 3; f++) d[paramsSet[1 - c][f]] = u[f], d[l[f]] = f === 2 ? r[0] : a[l[f]];
	var p = [[
		"x",
		"width",
		3
	], [
		"y",
		"height",
		0
	]][c], h = getLayoutRect(d, s, a.padding);
	return l[(h.margin[p[2]] || 0) + h[p[0]] + h[p[1]] * .5 < s[p[1]] * .5 ? 0 : 1];
}
function makeHighDownBatch(t, n) {
	return each(t || [], function(t) {
		t.dataIndex != null && (t.dataIndexInside = t.dataIndex, t.dataIndex = null), t.highlightKey = "visualMap" + (n ? n.componentIndex : "");
	}), t;
}
var linearMap = linearMap$2, each$2 = each, mathMin = Math.min, mathMax = Math.max, HOVER_LINK_SIZE = 12, HOVER_LINK_OUT = 6, ContinuousView = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r._shapes = {}, r._dataInterval = [], r._handleEnds = [], r._hoverLinkDataIndices = [], r;
	}
	return n.prototype.init = function(n, r) {
		t.prototype.init.call(this, n, r), this._hoverLinkFromSeriesMouseOver = bind(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = bind(this._hideIndicator, this);
	}, n.prototype.doRender = function(t, n, r, a) {
		(!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView();
	}, n.prototype._buildView = function() {
		this.group.removeAll();
		var t = this.visualMapModel, n = this.group;
		this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(n);
		var r = t.get("text");
		this._renderEndsText(n, r, 0), this._renderEndsText(n, r, 1), this._updateView(!0), this.renderBackground(n), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(n);
	}, n.prototype._renderEndsText = function(t, n, r) {
		if (n) {
			var a = n[1 - r];
			a = a == null ? "" : a + "";
			var o = this.visualMapModel, s = o.get("textGap"), c = o.itemSize, l = this._shapes.mainGroup, u = this._applyTransform([c[0] / 2, r === 0 ? -s : c[1] + s], l), d = this._applyTransform(r === 0 ? "bottom" : "top", l), f = this._orient, p = this.visualMapModel.textStyleModel;
			this.group.add(new Text_default({ style: createTextStyle(p, {
				x: u[0],
				y: u[1],
				verticalAlign: f === "horizontal" ? "middle" : d,
				align: f === "horizontal" ? d : "center",
				text: a
			}) }));
		}
	}, n.prototype._renderBar = function(t) {
		var n = this.visualMapModel, r = this._shapes, a = n.itemSize, o = this._orient, s = this._useHandle, c = getItemAlign(n, this.api, a), l = r.mainGroup = this._createBarGroup(c), u = new Group_default();
		l.add(u), u.add(r.outOfRange = createPolygon()), u.add(r.inRange = createPolygon(null, s ? getCursor(this._orient) : null, bind(this._dragHandle, this, "all", !1), bind(this._dragHandle, this, "all", !0))), u.setClipPath(new Rect_default({ shape: {
			x: 0,
			y: 0,
			width: a[0],
			height: a[1],
			r: 3
		} }));
		var d = n.textStyleModel.getTextRect("国"), f = mathMax(d.width, d.height);
		s && (r.handleThumbs = [], r.handleLabels = [], r.handleLabelPoints = [], this._createHandle(n, l, 0, a, f, o), this._createHandle(n, l, 1, a, f, o)), this._createIndicator(n, l, a, f, o), t.add(l);
	}, n.prototype._createHandle = function(t, n, r, a, o, s) {
		var c = bind(this._dragHandle, this, r, !1), l = bind(this._dragHandle, this, r, !0), u = parsePercent(t.get("handleSize"), a[0]), d = createSymbol(t.get("handleIcon"), -u / 2, -u / 2, u, u, null, !0), f = getCursor(this._orient);
		d.attr({
			cursor: f,
			draggable: !0,
			drift: c,
			ondragend: l,
			onmousemove: function(t) {
				stop(t.event);
			}
		}), d.x = a[0] / 2, d.useStyle(t.getModel("handleStyle").getItemStyle()), d.setStyle({
			strokeNoScale: !0,
			strokeFirst: !0
		}), d.style.lineWidth *= 2, d.ensureState("emphasis").style = t.getModel(["emphasis", "handleStyle"]).getItemStyle(), setAsHighDownDispatcher(d, !0), n.add(d);
		var p = this.visualMapModel.textStyleModel, h = new Text_default({
			cursor: f,
			draggable: !0,
			drift: c,
			onmousemove: function(t) {
				stop(t.event);
			},
			ondragend: l,
			style: createTextStyle(p, {
				x: 0,
				y: 0,
				text: ""
			})
		});
		h.ensureState("blur").style = { opacity: .1 }, h.stateTransition = { duration: 200 }, this.group.add(h);
		var g = [u, 0], _ = this._shapes;
		_.handleThumbs[r] = d, _.handleLabelPoints[r] = g, _.handleLabels[r] = h;
	}, n.prototype._createIndicator = function(t, n, r, a, o) {
		var s = parsePercent(t.get("indicatorSize"), r[0]), c = createSymbol(t.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, !0);
		c.attr({
			cursor: "move",
			invisible: !0,
			silent: !0,
			x: r[0] / 2
		});
		var l = t.getModel("indicatorStyle").getItemStyle();
		if (c instanceof Image_default) {
			var u = c.style;
			c.useStyle(extend({
				image: u.image,
				x: u.x,
				y: u.y,
				width: u.width,
				height: u.height
			}, l));
		} else c.useStyle(l);
		n.add(c);
		var d = this.visualMapModel.textStyleModel, f = new Text_default({
			silent: !0,
			invisible: !0,
			style: createTextStyle(d, {
				x: 0,
				y: 0,
				text: ""
			})
		});
		this.group.add(f);
		var p = [(o === "horizontal" ? a / 2 : HOVER_LINK_OUT) + r[0] / 2, 0], h = this._shapes;
		h.indicator = c, h.indicatorLabel = f, h.indicatorLabelPoint = p, this._firstShowIndicator = !0;
	}, n.prototype._dragHandle = function(t, n, r, a) {
		if (this._useHandle) {
			if (this._dragging = !n, !n) {
				var o = this._applyTransform([r, a], this._shapes.mainGroup, !0);
				this._updateInterval(t, o[1]), this._hideIndicator(), this._updateView();
			}
			n === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
				type: "selectDataRange",
				from: this.uid,
				visualMapId: this.visualMapModel.id,
				selected: this._dataInterval.slice()
			}), n ? !this._hovering && this._clearHoverLinkToSeries() : useHoverLinkOnHandle(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1);
		}
	}, n.prototype._resetInterval = function() {
		var t = this.visualMapModel, n = this._dataInterval = t.getSelected(), r = t.getExtent(), a = [0, t.itemSize[1]];
		this._handleEnds = [linearMap(n[0], r, a, !0), linearMap(n[1], r, a, !0)];
	}, n.prototype._updateInterval = function(t, n) {
		n ||= 0;
		var r = this.visualMapModel, a = this._handleEnds, o = [0, r.itemSize[1]];
		sliderMove(n, a, o, t, 0);
		var s = r.getExtent();
		this._dataInterval = [linearMap(a[0], o, s, !0), linearMap(a[1], o, s, !0)];
	}, n.prototype._updateView = function(t) {
		var n = this.visualMapModel, r = n.getExtent(), a = this._shapes, o = [0, n.itemSize[1]], s = t ? o : this._handleEnds, c = this._createBarVisual(this._dataInterval, r, s, "inRange"), l = this._createBarVisual(r, r, o, "outOfRange");
		a.inRange.setStyle({ fill: c.barColor }).setShape("points", c.barPoints), a.outOfRange.setStyle({ fill: l.barColor }).setShape("points", l.barPoints), this._updateHandle(s, c);
	}, n.prototype._createBarVisual = function(t, n, r, a) {
		var o = {
			forceState: a,
			convertOpacityToAlpha: !0
		}, s = this._makeColorGradient(t, o), c = [this.getControllerVisual(t[0], "symbolSize", o), this.getControllerVisual(t[1], "symbolSize", o)], l = this._createBarPoints(r, c);
		return {
			barColor: new LinearGradient_default(0, 0, 0, 1, s),
			barPoints: l,
			handlesColor: [s[0].color, s[s.length - 1].color]
		};
	}, n.prototype._makeColorGradient = function(t, n) {
		var r = 100, a = [], o = (t[1] - t[0]) / r;
		a.push({
			color: this.getControllerVisual(t[0], "color", n),
			offset: 0
		});
		for (var s = 1; s < r; s++) {
			var c = t[0] + o * s;
			if (c > t[1]) break;
			a.push({
				color: this.getControllerVisual(c, "color", n),
				offset: s / r
			});
		}
		return a.push({
			color: this.getControllerVisual(t[1], "color", n),
			offset: 1
		}), a;
	}, n.prototype._createBarPoints = function(t, n) {
		var r = this.visualMapModel.itemSize;
		return [
			[r[0] - n[0], t[0]],
			[r[0], t[0]],
			[r[0], t[1]],
			[r[0] - n[1], t[1]]
		];
	}, n.prototype._createBarGroup = function(t) {
		var n = this._orient, r = this.visualMapModel.get("inverse");
		return new Group_default(n === "horizontal" && !r ? {
			scaleX: t === "bottom" ? 1 : -1,
			rotation: Math.PI / 2
		} : n === "horizontal" && r ? {
			scaleX: t === "bottom" ? -1 : 1,
			rotation: -Math.PI / 2
		} : n === "vertical" && !r ? {
			scaleX: t === "left" ? 1 : -1,
			scaleY: -1
		} : { scaleX: t === "left" ? 1 : -1 });
	}, n.prototype._updateHandle = function(t, n) {
		if (this._useHandle) {
			var r = this._shapes, a = this.visualMapModel, o = r.handleThumbs, s = r.handleLabels, c = a.itemSize, l = a.getExtent(), u = this._applyTransform("left", r.mainGroup);
			each$2([0, 1], function(d) {
				var f = o[d];
				f.setStyle("fill", n.handlesColor[d]), f.y = t[d];
				var p = linearMap(t[d], [0, c[1]], l, !0), h = this.getControllerVisual(p, "symbolSize");
				f.scaleX = f.scaleY = h / c[0], f.x = c[0] - h / 2;
				var g = applyTransform$1(r.handleLabelPoints[d], getTransform$1(f, this.group));
				if (this._orient === "horizontal") {
					var _ = u === "left" || u === "top" ? (c[0] - h) / 2 : (c[0] - h) / -2;
					g[1] += _;
				}
				s[d].setStyle({
					x: g[0],
					y: g[1],
					text: a.formatValueText(this._dataInterval[d]),
					verticalAlign: "middle",
					align: this._orient === "vertical" ? this._applyTransform("left", r.mainGroup) : "center"
				});
			}, this);
		}
	}, n.prototype._showIndicator = function(t, n, r, a) {
		var o = this.visualMapModel, s = o.getExtent(), c = o.itemSize, l = [0, c[1]], u = this._shapes, d = u.indicator;
		if (d) {
			d.attr("invisible", !1);
			var f = this.getControllerVisual(t, "color", { convertOpacityToAlpha: !0 }), p = this.getControllerVisual(t, "symbolSize"), h = linearMap(t, s, l, !0), g = c[0] - p / 2, _ = {
				x: d.x,
				y: d.y
			};
			d.y = h, d.x = g;
			var v = applyTransform$1(u.indicatorLabelPoint, getTransform$1(d, this.group)), y = u.indicatorLabel;
			y.attr("invisible", !1);
			var b = this._applyTransform("left", u.mainGroup), x = this._orient === "horizontal";
			y.setStyle({
				text: (r || "") + o.formatValueText(n),
				verticalAlign: x ? b : "middle",
				align: x ? "center" : b
			});
			var S = {
				x: g,
				y: h,
				style: { fill: f }
			}, C = { style: {
				x: v[0],
				y: v[1]
			} };
			if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
				var w = {
					duration: 100,
					easing: "cubicInOut",
					additive: !0
				};
				d.x = _.x, d.y = _.y, d.animateTo(S, w), y.animateTo(C, w);
			} else d.attr(S), y.attr(C);
			this._firstShowIndicator = !1;
			var T = this._shapes.handleLabels;
			if (T) for (var E = 0; E < T.length; E++) this.api.enterBlur(T[E]);
		}
	}, n.prototype._enableHoverLinkToSeries = function() {
		var t = this;
		this._shapes.mainGroup.on("mousemove", function(n) {
			if (t._hovering = !0, !t._dragging) {
				var r = t.visualMapModel.itemSize, a = t._applyTransform([n.offsetX, n.offsetY], t._shapes.mainGroup, !0, !0);
				a[1] = mathMin(mathMax(0, a[1]), r[1]), t._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= r[0]);
			}
		}).on("mouseout", function() {
			t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries();
		});
	}, n.prototype._enableHoverLinkFromSeries = function() {
		var t = this.api.getZr();
		this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
	}, n.prototype._doHoverLinkToSeries = function(t, n) {
		var r = this.visualMapModel, a = r.itemSize;
		if (r.option.hoverLink) {
			var o = [0, a[1]], s = r.getExtent();
			t = mathMin(mathMax(o[0], t), o[1]);
			var c = getHalfHoverLinkSize(r, s, o), l = [t - c, t + c], u = linearMap(t, o, s, !0), d = [linearMap(l[0], o, s, !0), linearMap(l[1], o, s, !0)];
			l[0] < o[0] && (d[0] = -Infinity), l[1] > o[1] && (d[1] = Infinity), n && (d[0] === -Infinity ? this._showIndicator(u, d[1], "< ", c) : d[1] === Infinity ? this._showIndicator(u, d[0], "> ", c) : this._showIndicator(u, u, "≈ ", c));
			var f = this._hoverLinkDataIndices, p = [];
			(n || useHoverLinkOnHandle(r)) && (p = this._hoverLinkDataIndices = r.findTargetDataIndices(d));
			var h = compressBatches(f, p);
			this._dispatchHighDown("downplay", makeHighDownBatch(h[0], r)), this._dispatchHighDown("highlight", makeHighDownBatch(h[1], r));
		}
	}, n.prototype._hoverLinkFromSeriesMouseOver = function(t) {
		var n;
		if (findEventDispatcher(t.target, function(t) {
			var r = getECData(t);
			if (r.dataIndex != null) return n = r, !0;
		}, !0), n) {
			var r = this.ecModel.getSeriesByIndex(n.seriesIndex), a = this.visualMapModel;
			if (a.isTargetSeries(r)) {
				var o = r.getData(n.dataType), s = o.getStore().get(a.getDataDimensionIndex(o), n.dataIndex);
				isNaN(s) || this._showIndicator(s, s);
			}
		}
	}, n.prototype._hideIndicator = function() {
		var t = this._shapes;
		t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0);
		var n = this._shapes.handleLabels;
		if (n) for (var r = 0; r < n.length; r++) this.api.leaveBlur(n[r]);
	}, n.prototype._clearHoverLinkToSeries = function() {
		this._hideIndicator();
		var t = this._hoverLinkDataIndices;
		this._dispatchHighDown("downplay", makeHighDownBatch(t, this.visualMapModel)), t.length = 0;
	}, n.prototype._clearHoverLinkFromSeries = function() {
		this._hideIndicator();
		var t = this.api.getZr();
		t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator);
	}, n.prototype._applyTransform = function(t, n, r, a) {
		var o = getTransform$1(n, a ? null : this.group);
		return isArray(t) ? applyTransform$1(t, o, r) : transformDirection(t, o, r);
	}, n.prototype._dispatchHighDown = function(t, n) {
		n && n.length && this.api.dispatchAction({
			type: t,
			batch: n
		});
	}, n.prototype.dispose = function() {
		this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
	}, n.type = "visualMap.continuous", n;
}(VisualMapView_default);
function createPolygon(t, n, r, a) {
	return new Polygon_default({
		shape: { points: t },
		draggable: !!r,
		cursor: n,
		drift: r,
		onmousemove: function(t) {
			stop(t.event);
		},
		ondragend: a
	});
}
function getHalfHoverLinkSize(t, n, r) {
	var a = HOVER_LINK_SIZE / 2, o = t.get("hoverLinkDataSize");
	return o && (a = linearMap(o, n, r, !0) / 2), a;
}
function useHoverLinkOnHandle(t) {
	return !!(t.get("hoverLinkOnHandle") ?? t.get("realtime"));
}
function getCursor(t) {
	return t === "vertical" ? "ns-resize" : "ew-resize";
}
var ContinuousView_default = ContinuousView, visualMapActionInfo = {
	type: "selectDataRange",
	event: "dataRangeSelected",
	update: "update"
}, visualMapActionHander = function(t, n) {
	n.eachComponent({
		mainType: "visualMap",
		query: t
	}, function(n) {
		n.setSelected(t.selected);
	});
}, visualMapEncodingHandlers = [{
	createOnAllSeries: !0,
	reset: function(t, n) {
		var r = [];
		return n.eachComponent("visualMap", function(n) {
			var a = t.pipelineContext;
			!n.isTargetSeries(t) || a && a.large || r.push(incrementalApplyVisual(n.stateList, n.targetVisuals, bind(n.getValueState, n), n.getDataDimensionIndex(t.getData())));
		}), r;
	}
}, {
	createOnAllSeries: !0,
	reset: function(t, n) {
		var r = t.getData(), a = [];
		n.eachComponent("visualMap", function(n) {
			if (n.isTargetSeries(t)) {
				var o = n.getVisualMeta(bind(getColorVisual, null, t, n)) || {
					stops: [],
					outerColors: []
				}, s = n.getDataDimensionIndex(r);
				s >= 0 && (o.dimension = s, a.push(o));
			}
		}), t.getData().setVisual("visualMeta", a);
	}
}];
function getColorVisual(t, n, r, a) {
	for (var o = n.targetVisuals[a], s = VisualMapping_default.prepareVisualTypes(o), c = { color: getVisualFromData(t.getData(), "color") }, l = 0, u = s.length; l < u; l++) {
		var d = s[l], f = o[d === "opacity" ? "__alphaForOpacity" : d];
		f && f.applyVisual(r, p, h);
	}
	return c.color;
	function p(t) {
		return c[t];
	}
	function h(t, n) {
		c[t] = n;
	}
}
var each$1 = each;
function visualMapPreprocessor(t) {
	var n = t && t.visualMap;
	isArray(n) || (n = n ? [n] : []), each$1(n, function(t) {
		if (t) {
			has(t, "splitList") && !has(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
			var n = t.pieces;
			n && isArray(n) && each$1(n, function(t) {
				isObject(t) && (has(t, "start") && !has(t, "min") && (t.min = t.start), has(t, "end") && !has(t, "max") && (t.max = t.end));
			});
		}
	});
}
function has(t, n) {
	return t && t.hasOwnProperty && t.hasOwnProperty(n);
}
var installed = !1;
function installCommon(t) {
	installed || (installed = !0, t.registerSubTypeDefaulter("visualMap", function(t) {
		return !t.categories && (!(t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) || t.calculable) ? "continuous" : "piecewise";
	}), t.registerAction(visualMapActionInfo, visualMapActionHander), each(visualMapEncodingHandlers, function(n) {
		t.registerVisual(t.PRIORITY.VISUAL.COMPONENT, n);
	}), t.registerPreprocessor(visualMapPreprocessor));
}
function install$45(t) {
	t.registerComponentModel(ContinuousModel_default), t.registerComponentView(ContinuousView_default), installCommon(t);
}
init_dist$2();
var PiecewiseModel = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r._pieceList = [], r;
	}
	return n.prototype.optionUpdated = function(n, r) {
		t.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
		var a = this._mode = this._determineMode();
		this._pieceList = [], resetMethods[this._mode].call(this, this._pieceList), this._resetSelected(n, r);
		var o = this.option.categories;
		this.resetVisual(function(t, n) {
			a === "categories" ? (t.mappingMethod = "category", t.categories = clone$1(o)) : (t.dataExtent = this.getExtent(), t.mappingMethod = "piecewise", t.pieceList = map(this._pieceList, function(t) {
				return t = clone$1(t), n !== "inRange" && (t.visual = null), t;
			}));
		});
	}, n.prototype.completeVisualOption = function() {
		var n = this.option, r = {}, a = VisualMapping_default.listVisualTypes(), o = this.isCategory();
		each(n.pieces, function(t) {
			each(a, function(n) {
				t.hasOwnProperty(n) && (r[n] = 1);
			});
		}), each(r, function(t, r) {
			var a = !1;
			each(this.stateList, function(t) {
				a = a || s(n, t, r) || s(n.target, t, r);
			}, this), !a && each(this.stateList, function(t) {
				(n[t] || (n[t] = {}))[r] = visualDefault_default.get(r, t === "inRange" ? "active" : "inactive", o);
			});
		}, this);
		function s(t, n, r) {
			return t && t[n] && t[n].hasOwnProperty(r);
		}
		t.prototype.completeVisualOption.apply(this, arguments);
	}, n.prototype._resetSelected = function(t, n) {
		var r = this.option, a = this._pieceList, o = (n ? r : t).selected || {};
		if (r.selected = o, each(a, function(t, n) {
			var r = this.getSelectedMapKey(t);
			o.hasOwnProperty(r) || (o[r] = !0);
		}, this), r.selectedMode === "single") {
			var s = !1;
			each(a, function(t, n) {
				var r = this.getSelectedMapKey(t);
				o[r] && (s ? o[r] = !1 : s = !0);
			}, this);
		}
	}, n.prototype.getItemSymbol = function() {
		return this.get("itemSymbol");
	}, n.prototype.getSelectedMapKey = function(t) {
		return this._mode === "categories" ? t.value + "" : t.index + "";
	}, n.prototype.getPieceList = function() {
		return this._pieceList;
	}, n.prototype._determineMode = function() {
		var t = this.option;
		return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
	}, n.prototype.setSelected = function(t) {
		this.option.selected = clone$1(t);
	}, n.prototype.getValueState = function(t) {
		var n = VisualMapping_default.findPieceIndex(t, this._pieceList);
		return n == null ? "outOfRange" : this.option.selected[this.getSelectedMapKey(this._pieceList[n])] ? "inRange" : "outOfRange";
	}, n.prototype.findTargetDataIndices = function(t) {
		var n = [], r = this._pieceList;
		return this.eachTargetSeries(function(a) {
			var o = [], s = a.getData();
			s.each(this.getDataDimensionIndex(s), function(n, a) {
				VisualMapping_default.findPieceIndex(n, r) === t && o.push(a);
			}, this), n.push({
				seriesId: a.id,
				dataIndex: o
			});
		}, this), n;
	}, n.prototype.getRepresentValue = function(t) {
		var n;
		if (this.isCategory()) n = t.value;
		else if (t.value != null) n = t.value;
		else {
			var r = t.interval || [];
			n = r[0] === -Infinity && r[1] === Infinity ? 0 : (r[0] + r[1]) / 2;
		}
		return n;
	}, n.prototype.getVisualMeta = function(t) {
		if (this.isCategory()) return;
		var n = [], r = ["", ""], a = this;
		function o(o, s) {
			var c = a.getRepresentValue({ interval: o });
			s ||= a.getValueState(c);
			var l = t(c, s);
			o[0] === -Infinity ? r[0] = l : o[1] === Infinity ? r[1] = l : n.push({
				value: o[0],
				color: l
			}, {
				value: o[1],
				color: l
			});
		}
		var s = this._pieceList.slice();
		if (!s.length) s.push({ interval: [-Infinity, Infinity] });
		else {
			var c = s[0].interval[0];
			c !== -Infinity && s.unshift({ interval: [-Infinity, c] }), c = s[s.length - 1].interval[1], c !== Infinity && s.push({ interval: [c, Infinity] });
		}
		var l = -Infinity;
		return each(s, function(t) {
			var n = t.interval;
			n && (n[0] > l && o([l, n[0]], "outOfRange"), o(n.slice()), l = n[1]);
		}, this), {
			stops: n,
			outerColors: r
		};
	}, n.type = "visualMap.piecewise", n.defaultOption = inheritDefaultOption(VisualMapModel_default.defaultOption, {
		selected: null,
		minOpen: !1,
		maxOpen: !1,
		align: "auto",
		itemWidth: 20,
		itemHeight: 14,
		itemSymbol: "roundRect",
		pieces: null,
		categories: null,
		splitNumber: 5,
		selectedMode: "multiple",
		itemGap: 10,
		hoverLink: !0
	}), n;
}(VisualMapModel_default), resetMethods = {
	splitNumber: function(t) {
		var n = this.option, r = Math.min(n.precision, 20), a = this.getExtent(), o = n.splitNumber;
		o = Math.max(parseInt(o, 10), 1), n.splitNumber = o;
		for (var s = (a[1] - a[0]) / o; +s.toFixed(r) !== s && r < 5;) r++;
		n.precision = r, s = +s.toFixed(r), n.minOpen && t.push({
			interval: [-Infinity, a[0]],
			close: [0, 0]
		});
		for (var c = 0, l = a[0]; c < o; l += s, c++) {
			var u = c === o - 1 ? a[1] : l + s;
			t.push({
				interval: [l, u],
				close: [1, 1]
			});
		}
		n.maxOpen && t.push({
			interval: [a[1], Infinity],
			close: [0, 0]
		}), reformIntervals(t), each(t, function(t, n) {
			t.index = n, t.text = this.formatValueText(t.interval);
		}, this);
	},
	categories: function(t) {
		var n = this.option;
		each(n.categories, function(n) {
			t.push({
				text: this.formatValueText(n, !0),
				value: n
			});
		}, this), normalizeReverse(n, t);
	},
	pieces: function(t) {
		var n = this.option;
		each(n.pieces, function(n, r) {
			isObject(n) || (n = { value: n });
			var a = {
				text: "",
				index: r
			};
			if (n.label != null && (a.text = n.label), n.hasOwnProperty("value")) {
				var o = a.value = n.value;
				a.interval = [o, o], a.close = [1, 1];
			} else {
				for (var c = a.interval = [], l = a.close = [0, 0], u = [
					1,
					0,
					1
				], d = [-Infinity, Infinity], f = [], p = 0; p < 2; p++) {
					for (var h = [[
						"gte",
						"gt",
						"min"
					], [
						"lte",
						"lt",
						"max"
					]][p], g = 0; g < 3 && c[p] == null; g++) c[p] = n[h[g]], l[p] = u[g], f[p] = g === 2;
					c[p] ?? (c[p] = d[p]);
				}
				f[0] && c[1] === Infinity && (l[0] = 0), f[1] && c[0] === -Infinity && (l[1] = 0), process$1.env.NODE_ENV !== "production" && c[0] > c[1] && console.warn("Piece " + r + "is illegal: " + c + " lower bound should not greater then uppper bound."), c[0] === c[1] && l[0] && l[1] && (a.value = c[0]);
			}
			a.visual = VisualMapping_default.retrieveVisuals(n), t.push(a);
		}, this), normalizeReverse(n, t), reformIntervals(t), each(t, function(t) {
			var n = t.close, r = [["<", "≤"][n[1]], [">", "≥"][n[0]]];
			t.text = t.text || this.formatValueText(t.value == null ? t.interval : t.value, !1, r);
		}, this);
	}
};
function normalizeReverse(t, n) {
	var r = t.inverse;
	(t.orient === "vertical" ? !r : r) && n.reverse();
}
var PiecewiseModel_default = PiecewiseModel, PiecewiseView_default = function(t) {
	__extends(n, t);
	function n() {
		var r = t !== null && t.apply(this, arguments) || this;
		return r.type = n.type, r;
	}
	return n.prototype.doRender = function() {
		var t = this.group;
		t.removeAll();
		var n = this.visualMapModel, r = n.get("textGap"), a = n.textStyleModel, o = a.getFont(), s = a.getTextColor(), c = this._getItemAlign(), l = n.itemSize, u = this._getViewData(), d = u.endsText, f = retrieve(n.get("showLabel", !0), !d), p = !n.get("selectedMode");
		d && this._renderEndsText(t, d[0], l, f, c), each(u.viewPieceList, function(a) {
			var u = a.piece, d = new Group_default();
			d.onclick = bind(this._onItemClick, this, u), this._enableHoverLink(d, a.indexInModelPieceList);
			var h = n.getRepresentValue(u);
			if (this._createItemSymbol(d, h, [
				0,
				0,
				l[0],
				l[1]
			], p), f) {
				var g = this.visualMapModel.getValueState(h);
				d.add(new Text_default({
					style: {
						x: c === "right" ? -r : l[0] + r,
						y: l[1] / 2,
						text: u.text,
						verticalAlign: "middle",
						align: c,
						font: o,
						fill: s,
						opacity: g === "outOfRange" ? .5 : 1
					},
					silent: p
				}));
			}
			t.add(d);
		}, this), d && this._renderEndsText(t, d[1], l, f, c), box(n.get("orient"), t, n.get("itemGap")), this.renderBackground(t), this.positionGroup(t);
	}, n.prototype._enableHoverLink = function(t, n) {
		var r = this;
		t.on("mouseover", function() {
			return a("highlight");
		}).on("mouseout", function() {
			return a("downplay");
		});
		var a = function(t) {
			var a = r.visualMapModel;
			a.option.hoverLink && r.api.dispatchAction({
				type: t,
				batch: makeHighDownBatch(a.findTargetDataIndices(n), a)
			});
		};
	}, n.prototype._getItemAlign = function() {
		var t = this.visualMapModel, n = t.option;
		if (n.orient === "vertical") return getItemAlign(t, this.api, t.itemSize);
		var r = n.align;
		return (!r || r === "auto") && (r = "left"), r;
	}, n.prototype._renderEndsText = function(t, n, r, a, o) {
		if (n) {
			var s = new Group_default(), c = this.visualMapModel.textStyleModel;
			s.add(new Text_default({ style: createTextStyle(c, {
				x: a ? o === "right" ? r[0] : 0 : r[0] / 2,
				y: r[1] / 2,
				verticalAlign: "middle",
				align: a ? o : "center",
				text: n
			}) })), t.add(s);
		}
	}, n.prototype._getViewData = function() {
		var t = this.visualMapModel, n = map(t.getPieceList(), function(t, n) {
			return {
				piece: t,
				indexInModelPieceList: n
			};
		}), r = t.get("text"), a = t.get("orient"), o = t.get("inverse");
		return (a === "horizontal" ? o : !o) ? n.reverse() : r &&= r.slice().reverse(), {
			viewPieceList: n,
			endsText: r
		};
	}, n.prototype._createItemSymbol = function(t, n, r, a) {
		var o = createSymbol(this.getControllerVisual(n, "symbol"), r[0], r[1], r[2], r[3], this.getControllerVisual(n, "color"));
		o.silent = a, t.add(o);
	}, n.prototype._onItemClick = function(t) {
		var n = this.visualMapModel, r = n.option, a = r.selectedMode;
		if (a) {
			var o = clone$1(r.selected), s = n.getSelectedMapKey(t);
			a === "single" || a === !0 ? (o[s] = !0, each(o, function(t, n) {
				o[n] = n === s;
			})) : o[s] = !o[s], this.api.dispatchAction({
				type: "selectDataRange",
				from: this.uid,
				visualMapId: this.visualMapModel.id,
				selected: o
			});
		}
	}, n.type = "visualMap.piecewise", n;
}(VisualMapView_default);
function install$46(t) {
	t.registerComponentModel(PiecewiseModel_default), t.registerComponentView(PiecewiseView_default), installCommon(t);
}
function install$44(t) {
	use(install$45), use(install$46);
}
var DEFAULT_OPTION = {
	label: { enabled: !0 },
	decal: { show: !1 }
}, inner = makeInner(), decalPaletteScope = {};
function ariaVisual(t, n) {
	var r = t.getModel("aria");
	if (!r.get("enabled")) return;
	var a = clone$1(DEFAULT_OPTION);
	merge(a.label, t.getLocaleModel().get("aria"), !1), merge(r.option, a, !1), o(), s();
	function o() {
		if (r.getModel("decal").get("show")) {
			var n = createHashMap();
			t.eachSeries(function(t) {
				if (!t.isColorBySeries()) {
					var r = n.get(t.type);
					r || (r = {}, n.set(t.type, r)), inner(t).scope = r;
				}
			}), t.eachRawSeries(function(n) {
				if (t.isSeriesFiltered(n)) return;
				if (isFunction(n.enableAriaDecal)) {
					n.enableAriaDecal();
					return;
				}
				var r = n.getData();
				if (n.isColorBySeries()) {
					var a = getDecalFromPalette(n.ecModel, n.name, decalPaletteScope, t.getSeriesCount()), o = r.getVisual("decal");
					r.setVisual("decal", d(o, a));
				} else {
					var s = n.getRawData(), c = {}, l = inner(n).scope;
					r.each(function(t) {
						var n = r.getRawIndex(t);
						c[n] = t;
					});
					var u = s.count();
					s.each(function(t) {
						var a = c[t], o = s.getName(t) || t + "", f = getDecalFromPalette(n.ecModel, o, l, u), p = r.getItemVisual(a, "decal");
						r.setItemVisual(a, "decal", d(p, f));
					});
				}
				function d(t, n) {
					var r = t ? extend(extend({}, n), t) : n;
					return r.dirty = !0, r;
				}
			});
		}
	}
	function s() {
		var a = n.getZr().dom;
		if (a) {
			var o = t.getLocaleModel().get("aria"), s = r.getModel("label");
			if (s.option = defaults(s.option, o), s.get("enabled")) {
				if (a.setAttribute("role", "img"), s.get("description")) {
					a.setAttribute("aria-label", s.get("description"));
					return;
				}
				var d = t.getSeriesCount(), f = s.get(["data", "maxCount"]) || 10, p = s.get(["series", "maxCount"]) || 10, h = Math.min(d, p), g;
				if (!(d < 1)) {
					var _ = l();
					g = _ ? c(s.get(["general", "withTitle"]), { title: _ }) : s.get(["general", "withoutTitle"]);
					var v = [], y = d > 1 ? s.get([
						"series",
						"multiple",
						"prefix"
					]) : s.get([
						"series",
						"single",
						"prefix"
					]);
					g += c(y, { seriesCount: d }), t.eachSeries(function(t, n) {
						if (n < h) {
							var r = void 0, a = t.get("name") ? "withName" : "withoutName";
							r = d > 1 ? s.get([
								"series",
								"multiple",
								a
							]) : s.get([
								"series",
								"single",
								a
							]), r = c(r, {
								seriesId: t.seriesIndex,
								seriesName: t.get("name"),
								seriesType: u(t.subType)
							});
							var o = t.getData();
							if (o.count() > f) {
								var l = s.get(["data", "partialData"]);
								r += c(l, { displayCnt: f });
							} else r += s.get(["data", "allData"]);
							for (var p = s.get([
								"data",
								"separator",
								"middle"
							]), g = s.get([
								"data",
								"separator",
								"end"
							]), _ = s.get(["data", "excludeDimensionId"]), y = [], b = 0; b < o.count(); b++) if (b < f) {
								var x = o.getName(b), S = _ ? filter(o.getValues(b), function(t, n) {
									return indexOf(_, n) === -1;
								}) : o.getValues(b), C = s.get(["data", x ? "withName" : "withoutName"]);
								y.push(c(C, {
									name: x,
									value: S.join(p)
								}));
							}
							r += y.join(p) + g, v.push(r);
						}
					});
					var b = s.getModel([
						"series",
						"multiple",
						"separator"
					]), x = b.get("middle"), S = b.get("end");
					g += v.join(x) + S, a.setAttribute("aria-label", g);
				}
			}
		}
	}
	function c(t, n) {
		if (!isString(t)) return t;
		var r = t;
		return each(n, function(t, n) {
			r = r.replace(RegExp("\\{\\s*" + n + "\\s*\\}", "g"), t);
		}), r;
	}
	function l() {
		var n = t.get("title");
		return n && n.length && (n = n[0]), n && n.text;
	}
	function u(n) {
		var r = t.getLocaleModel().get(["series", "typeNames"]);
		return r[n] || r.chart;
	}
}
function ariaPreprocessor(t) {
	if (!(!t || !t.aria)) {
		var n = t.aria;
		n.show != null && (n.enabled = n.show), n.label = n.label || {}, each([
			"description",
			"general",
			"series",
			"data"
		], function(t) {
			n[t] != null && (n.label[t] = n[t]);
		});
	}
}
function install$47(t) {
	t.registerPreprocessor(ariaPreprocessor), t.registerVisual(t.PRIORITY.VISUAL.ARIA, ariaVisual);
}
init_dist$2();
var RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {
	value: "eq",
	"<": "lt",
	"<=": "lte",
	">": "gt",
	">=": "gte",
	"=": "eq",
	"!=": "ne",
	"<>": "ne"
}, RegExpEvaluator = function() {
	function t(t) {
		if ((this._condVal = isString(t) ? new RegExp(t) : isRegExp(t) ? t : null) == null) {
			var n = "";
			process$1.env.NODE_ENV !== "production" && (n = makePrintable("Illegal regexp", t, "in")), throwError(n);
		}
	}
	return t.prototype.evaluate = function(t) {
		var n = typeof t;
		return isString(n) ? this._condVal.test(t) : isNumber(n) ? this._condVal.test(t + "") : !1;
	}, t;
}(), ConstConditionInternal = function() {
	function t() {}
	return t.prototype.evaluate = function() {
		return this.value;
	}, t;
}(), AndConditionInternal = function() {
	function t() {}
	return t.prototype.evaluate = function() {
		for (var t = this.children, n = 0; n < t.length; n++) if (!t[n].evaluate()) return !1;
		return !0;
	}, t;
}(), OrConditionInternal = function() {
	function t() {}
	return t.prototype.evaluate = function() {
		for (var t = this.children, n = 0; n < t.length; n++) if (t[n].evaluate()) return !0;
		return !1;
	}, t;
}(), NotConditionInternal = function() {
	function t() {}
	return t.prototype.evaluate = function() {
		return !this.child.evaluate();
	}, t;
}(), RelationalConditionInternal = function() {
	function t() {}
	return t.prototype.evaluate = function() {
		for (var t = !!this.valueParser, n = this.getValue, r = n(this.valueGetterParam), a = t ? this.valueParser(r) : null, o = 0; o < this.subCondList.length; o++) if (!this.subCondList[o].evaluate(t ? a : r)) return !1;
		return !0;
	}, t;
}();
function parseOption(t, n) {
	if (t === !0 || t === !1) {
		var r = new ConstConditionInternal();
		return r.value = t, r;
	}
	var a = "";
	return isObjectNotArray(t) || (process$1.env.NODE_ENV !== "production" && (a = makePrintable("Illegal config. Expect a plain object but actually", t)), throwError(a)), t.and ? parseAndOrOption("and", t, n) : t.or ? parseAndOrOption("or", t, n) : t.not ? parseNotOption(t, n) : parseRelationalOption(t, n);
}
function parseAndOrOption(t, n, r) {
	var a = n[t], o = "";
	process$1.env.NODE_ENV !== "production" && (o = makePrintable("\"and\"/\"or\" condition should only be `" + t + ": [...]` and must not be empty array.", "Illegal condition:", n)), isArray(a) || throwError(o), a.length || throwError(o);
	var c = t === "and" ? new AndConditionInternal() : new OrConditionInternal();
	return c.children = map(a, function(t) {
		return parseOption(t, r);
	}), c.children.length || throwError(o), c;
}
function parseNotOption(t, n) {
	var r = t.not, a = "";
	process$1.env.NODE_ENV !== "production" && (a = makePrintable("\"not\" condition should only be `not: {}`.", "Illegal condition:", t)), isObjectNotArray(r) || throwError(a);
	var o = new NotConditionInternal();
	return o.child = parseOption(r, n), o.child || throwError(a), o;
}
function parseRelationalOption(t, n) {
	for (var r = "", a = n.prepareGetValue(t), o = [], c = keys(t), l = t.parser, u = l ? getRawValueParser(l) : null, d = 0; d < c.length; d++) {
		var f = c[d];
		if (!(f === "parser" || n.valueGetterAttrMap.get(f))) {
			var p = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, f) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[f] : f, h = t[f], g = u ? u(h) : h, _ = createFilterComparator(p, g) || p === "reg" && new RegExpEvaluator(g);
			_ || (process$1.env.NODE_ENV !== "production" && (r = makePrintable("Illegal relational operation: \"" + f + "\" in condition:", t)), throwError(r)), o.push(_);
		}
	}
	o.length || (process$1.env.NODE_ENV !== "production" && (r = makePrintable("Relational condition must have at least one operator.", "Illegal condition:", t)), throwError(r));
	var v = new RelationalConditionInternal();
	return v.valueGetterParam = a, v.valueParser = u, v.getValue = n.getValue, v.subCondList = o, v;
}
function isObjectNotArray(t) {
	return isObject(t) && !isArrayLike(t);
}
var ConditionalExpressionParsed = function() {
	function t(t, n) {
		this._cond = parseOption(t, n);
	}
	return t.prototype.evaluate = function() {
		return this._cond.evaluate();
	}, t;
}();
function parseConditionalExpression(t, n) {
	return new ConditionalExpressionParsed(t, n);
}
init_dist$2();
var filterTransform = {
	type: "echarts:filter",
	transform: function(t) {
		for (var n = t.upstream, r, a = parseConditionalExpression(t.config, {
			valueGetterAttrMap: createHashMap({ dimension: !0 }),
			prepareGetValue: function(t) {
				var r = "", a = t.dimension;
				hasOwn(t, "dimension") || (process$1.env.NODE_ENV !== "production" && (r = makePrintable("Relation condition must has prop \"dimension\" specified.", "Illegal condition:", t)), throwError(r));
				var o = n.getDimensionInfo(a);
				return o || (process$1.env.NODE_ENV !== "production" && (r = makePrintable("Can not find dimension info via: " + a + ".\n", "Existing dimensions: ", n.cloneAllDimensionInfo(), ".\n", "Illegal condition:", t, ".\n")), throwError(r)), { dimIdx: o.index };
			},
			getValue: function(t) {
				return n.retrieveValueFromItem(r, t.dimIdx);
			}
		}), o = [], c = 0, l = n.count(); c < l; c++) r = n.getRawDataItem(c), a.evaluate() && o.push(r);
		return { data: o };
	}
};
init_dist$2();
var sampleLog = "";
process$1.env.NODE_ENV !== "production" && (sampleLog = [
	"Valid config is like:",
	"{ dimension: \"age\", order: \"asc\" }",
	"or [{ dimension: \"age\", order: \"asc\"], { dimension: \"date\", order: \"desc\" }]"
].join(" "));
var sortTransform = {
	type: "echarts:sort",
	transform: function(t) {
		var n = t.upstream, r = t.config, a = "", o = normalizeToArray(r);
		o.length || (process$1.env.NODE_ENV !== "production" && (a = "Empty `config` in sort transform."), throwError(a));
		var c = [];
		each(o, function(t) {
			var r = t.dimension, o = t.order, l = t.parser, u = t.incomparable;
			if (r ?? (process$1.env.NODE_ENV !== "production" && (a = "Sort transform config must has \"dimension\" specified." + sampleLog), throwError(a)), o !== "asc" && o !== "desc" && (process$1.env.NODE_ENV !== "production" && (a = "Sort transform config must has \"order\" specified." + sampleLog), throwError(a)), u && u !== "min" && u !== "max") {
				var d = "";
				process$1.env.NODE_ENV !== "production" && (d = "incomparable must be \"min\" or \"max\" rather than \"" + u + "\"."), throwError(d);
			}
			if (o !== "asc" && o !== "desc") {
				var f = "";
				process$1.env.NODE_ENV !== "production" && (f = "order must be \"asc\" or \"desc\" rather than \"" + o + "\"."), throwError(f);
			}
			var p = n.getDimensionInfo(r);
			p || (process$1.env.NODE_ENV !== "production" && (a = makePrintable("Can not find dimension info via: " + r + ".\n", "Existing dimensions: ", n.cloneAllDimensionInfo(), ".\n", "Illegal config:", t, ".\n")), throwError(a));
			var h = l ? getRawValueParser(l) : null;
			l && !h && (process$1.env.NODE_ENV !== "production" && (a = makePrintable("Invalid parser name " + l + ".\n", "Illegal config:", t, ".\n")), throwError(a)), c.push({
				dimIdx: p.index,
				parser: h,
				comparator: new SortOrderComparator(o, u)
			});
		});
		var l = n.sourceFormat;
		l !== "arrayRows" && l !== "objectRows" && (process$1.env.NODE_ENV !== "production" && (a = "sourceFormat \"" + l + "\" is not supported yet"), throwError(a));
		for (var u = [], d = 0, f = n.count(); d < f; d++) u.push(n.getRawDataItem(d));
		return u.sort(function(t, r) {
			for (var a = 0; a < c.length; a++) {
				var o = c[a], s = n.retrieveValueFromItem(t, o.dimIdx), l = n.retrieveValueFromItem(r, o.dimIdx);
				o.parser && (s = o.parser(s), l = o.parser(l));
				var u = o.comparator.evaluate(s, l);
				if (u !== 0) return u;
			}
			return 0;
		}), { data: u };
	}
};
function install$49(t) {
	t.registerTransform(filterTransform), t.registerTransform(sortTransform);
}
var DatasetModel = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n.type = "dataset", n;
	}
	return n.prototype.init = function(n, r, a) {
		t.prototype.init.call(this, n, r, a), this._sourceManager = new SourceManager(this), disableTransformOptionMerge(this);
	}, n.prototype.mergeOption = function(n, r) {
		t.prototype.mergeOption.call(this, n, r), disableTransformOptionMerge(this);
	}, n.prototype.optionUpdated = function() {
		this._sourceManager.dirty();
	}, n.prototype.getSourceManager = function() {
		return this._sourceManager;
	}, n.type = "dataset", n.defaultOption = { seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN }, n;
}(Component_default), DatasetView = function(t) {
	__extends(n, t);
	function n() {
		var n = t !== null && t.apply(this, arguments) || this;
		return n.type = "dataset", n;
	}
	return n.type = "dataset", n;
}(Component_default$1);
function install$48(t) {
	t.registerComponentModel(DatasetModel), t.registerComponentView(DatasetView);
}
var CMD = PathProxy_default.CMD;
function aroundEqual(t, n) {
	return Math.abs(t - n) < 1e-5;
}
function pathToBezierCurves(t) {
	var n = t.data, r = t.len(), a = [], o, s = 0, c = 0, l = 0, u = 0;
	function d(t, n) {
		o && o.length > 2 && a.push(o), o = [t, n];
	}
	function f(t, n, r, a) {
		aroundEqual(t, r) && aroundEqual(n, a) || o.push(t, n, r, a, r, a);
	}
	function p(t, n, r, a, s, c) {
		var l = Math.abs(n - t), u = Math.tan(l / 4) * 4 / 3, d = n < t ? -1 : 1, f = Math.cos(t), p = Math.sin(t), h = Math.cos(n), g = Math.sin(n), _ = f * s + r, v = p * c + a, y = h * s + r, b = g * c + a, x = s * u * d, S = c * u * d;
		o.push(_ - x * p, v + S * f, y + x * g, b - S * h, y, b);
	}
	for (var h, g, _, v, y = 0; y < r;) {
		var b = n[y++], x = y === 1;
		switch (x && (s = n[y], c = n[y + 1], l = s, u = c, (b === CMD.L || b === CMD.C || b === CMD.Q) && (o = [l, u])), b) {
			case CMD.M:
				s = l = n[y++], c = u = n[y++], d(l, u);
				break;
			case CMD.L:
				h = n[y++], g = n[y++], f(s, c, h, g), s = h, c = g;
				break;
			case CMD.C:
				o.push(n[y++], n[y++], n[y++], n[y++], s = n[y++], c = n[y++]);
				break;
			case CMD.Q:
				h = n[y++], g = n[y++], _ = n[y++], v = n[y++], o.push(s + 2 / 3 * (h - s), c + 2 / 3 * (g - c), _ + 2 / 3 * (h - _), v + 2 / 3 * (g - v), _, v), s = _, c = v;
				break;
			case CMD.A:
				var S = n[y++], C = n[y++], w = n[y++], T = n[y++], E = n[y++], D = n[y++] + E;
				y += 1;
				var O = !n[y++];
				h = Math.cos(E) * w + S, g = Math.sin(E) * T + C, x ? (l = h, u = g, d(l, u)) : f(s, c, h, g), s = Math.cos(D) * w + S, c = Math.sin(D) * T + C;
				for (var A = (O ? -1 : 1) * Math.PI / 2, j = E; O ? j > D : j < D; j += A) {
					var M = O ? Math.max(j + A, D) : Math.min(j + A, D);
					p(j, M, S, C, w, T);
				}
				break;
			case CMD.R:
				l = s = n[y++], u = c = n[y++], h = l + n[y++], g = u + n[y++], d(h, u), f(h, u, h, g), f(h, g, l, g), f(l, g, l, u), f(l, u, h, u);
				break;
			case CMD.Z:
				o && f(s, c, l, u), s = l, c = u;
				break;
		}
	}
	return o && o.length > 2 && a.push(o), a;
}
function adpativeBezier(t, n, r, a, o, s, c, l, u, d) {
	if (aroundEqual(t, r) && aroundEqual(n, a) && aroundEqual(o, c) && aroundEqual(s, l)) {
		u.push(c, l);
		return;
	}
	var f = 2 / d, p = f * f, h = c - t, g = l - n, _ = Math.sqrt(h * h + g * g);
	h /= _, g /= _;
	var v = r - t, y = a - n, b = o - c, x = s - l, S = v * v + y * y, C = b * b + x * x;
	if (S < p && C < p) {
		u.push(c, l);
		return;
	}
	var w = h * v + g * y, T = -h * b - g * x, E = S - w * w, D = C - T * T;
	if (E < p && w >= 0 && D < p && T >= 0) {
		u.push(c, l);
		return;
	}
	var O = [], A = [];
	cubicSubdivide(t, r, o, c, .5, O), cubicSubdivide(n, a, s, l, .5, A), adpativeBezier(O[0], A[0], O[1], A[1], O[2], A[2], O[3], A[3], u, d), adpativeBezier(O[4], A[4], O[5], A[5], O[6], A[6], O[7], A[7], u, d);
}
function pathToPolygons(t, n) {
	var r = pathToBezierCurves(t), a = [];
	n ||= 1;
	for (var o = 0; o < r.length; o++) {
		var s = r[o], c = [], l = s[0], u = s[1];
		c.push(l, u);
		for (var d = 2; d < s.length;) {
			var f = s[d++], p = s[d++], h = s[d++], g = s[d++], _ = s[d++], v = s[d++];
			adpativeBezier(l, u, f, p, h, g, _, v, c, n), l = _, u = v;
		}
		a.push(c);
	}
	return a;
}
function getDividingGrids(t, n, r) {
	var a = t[n], o = t[1 - n], s = Math.abs(a / o), c = Math.ceil(Math.sqrt(s * r)), l = Math.floor(r / c);
	l === 0 && (l = 1, c = r);
	for (var u = [], d = 0; d < c; d++) u.push(l);
	var f = r - c * l;
	if (f > 0) for (var d = 0; d < f; d++) u[d % c] += 1;
	return u;
}
function divideSector(t, n, r) {
	for (var a = t.r0, o = t.r, s = t.startAngle, c = t.endAngle, l = Math.abs(c - s), u = l * o, d = o - a, f = u > Math.abs(d), p = getDividingGrids([u, d], f ? 0 : 1, n), h = (f ? l : d) / p.length, g = 0; g < p.length; g++) for (var _ = (f ? d : l) / p[g], v = 0; v < p[g]; v++) {
		var y = {};
		f ? (y.startAngle = s + h * g, y.endAngle = s + h * (g + 1), y.r0 = a + _ * v, y.r = a + _ * (v + 1)) : (y.startAngle = s + _ * v, y.endAngle = s + _ * (v + 1), y.r0 = a + h * g, y.r = a + h * (g + 1)), y.clockwise = t.clockwise, y.cx = t.cx, y.cy = t.cy, r.push(y);
	}
}
function divideRect(t, n, r) {
	for (var a = t.width, o = t.height, s = a > o, c = getDividingGrids([a, o], s ? 0 : 1, n), l = s ? "width" : "height", u = s ? "height" : "width", d = s ? "x" : "y", f = s ? "y" : "x", p = t[l] / c.length, h = 0; h < c.length; h++) for (var g = t[u] / c[h], _ = 0; _ < c[h]; _++) {
		var v = {};
		v[d] = h * p, v[f] = _ * g, v[l] = p, v[u] = g, v.x += t.x, v.y += t.y, r.push(v);
	}
}
function crossProduct2d(t, n, r, a) {
	return t * a - r * n;
}
function lineLineIntersect(t, n, r, a, o, s, c, l) {
	var u = r - t, d = a - n, f = c - o, p = l - s, h = crossProduct2d(f, p, u, d);
	if (Math.abs(h) < 1e-6) return null;
	var g = crossProduct2d(t - o, n - s, f, p) / h;
	return g < 0 || g > 1 ? null : new Point_default(g * u + t, g * d + n);
}
function projPtOnLine(t, n, r) {
	var a = new Point_default();
	Point_default.sub(a, r, n), a.normalize();
	var o = new Point_default();
	return Point_default.sub(o, t, n), o.dot(a);
}
function addToPoly(t, n) {
	var r = t[t.length - 1];
	r && r[0] === n[0] && r[1] === n[1] || t.push(n);
}
function splitPolygonByLine(t, n, r) {
	for (var a = t.length, o = [], s = 0; s < a; s++) {
		var c = t[s], l = t[(s + 1) % a], u = lineLineIntersect(c[0], c[1], l[0], l[1], n.x, n.y, r.x, r.y);
		u && o.push({
			projPt: projPtOnLine(u, n, r),
			pt: u,
			idx: s
		});
	}
	if (o.length < 2) return [{ points: t }, { points: t }];
	o.sort(function(t, n) {
		return t.projPt - n.projPt;
	});
	var d = o[0], f = o[o.length - 1];
	if (f.idx < d.idx) {
		var p = d;
		d = f, f = p;
	}
	for (var h = [d.pt.x, d.pt.y], g = [f.pt.x, f.pt.y], _ = [h], v = [g], s = d.idx + 1; s <= f.idx; s++) addToPoly(_, t[s].slice());
	addToPoly(_, g), addToPoly(_, h);
	for (var s = f.idx + 1; s <= d.idx + a; s++) addToPoly(v, t[s % a].slice());
	return addToPoly(v, h), addToPoly(v, g), [{ points: _ }, { points: v }];
}
function binaryDividePolygon(t) {
	var n = t.points, r = [], a = [];
	fromPoints(n, r, a);
	var o = new BoundingRect_default(r[0], r[1], a[0] - r[0], a[1] - r[1]), s = o.width, c = o.height, l = o.x, u = o.y, d = new Point_default(), f = new Point_default();
	return s > c ? (d.x = f.x = l + s / 2, d.y = u, f.y = u + c) : (d.y = f.y = u + c / 2, d.x = l, f.x = l + s), splitPolygonByLine(n, d, f);
}
function binaryDivideRecursive(t, n, r, a) {
	if (r === 1) a.push(n);
	else {
		var o = Math.floor(r / 2), s = t(n);
		binaryDivideRecursive(t, s[0], o, a), binaryDivideRecursive(t, s[1], r - o, a);
	}
	return a;
}
function clone(t, n) {
	for (var r = [], a = 0; a < n; a++) r.push(clonePath(t));
	return r;
}
function copyPathProps(t, n) {
	n.setStyle(t.style), n.z = t.z, n.z2 = t.z2, n.zlevel = t.zlevel;
}
function polygonConvert(t) {
	for (var n = [], r = 0; r < t.length;) n.push([t[r++], t[r++]]);
	return n;
}
function split(t, n) {
	var r = [], a = t.shape, o;
	switch (t.type) {
		case "rect":
			divideRect(a, n, r), o = Rect_default;
			break;
		case "sector":
			divideSector(a, n, r), o = Sector_default;
			break;
		case "circle":
			divideSector({
				r0: 0,
				r: a.r,
				startAngle: 0,
				endAngle: Math.PI * 2,
				cx: a.cx,
				cy: a.cy
			}, n, r), o = Sector_default;
			break;
		default:
			var s = t.getComputedTransform(), c = s ? Math.sqrt(Math.max(s[0] * s[0] + s[1] * s[1], s[2] * s[2] + s[3] * s[3])) : 1, l = map(pathToPolygons(t.getUpdatedPathProxy(), c), function(t) {
				return polygonConvert(t);
			}), u = l.length;
			if (u === 0) binaryDivideRecursive(binaryDividePolygon, { points: l[0] }, n, r);
			else if (u === n) for (var d = 0; d < u; d++) r.push({ points: l[d] });
			else {
				var f = 0, p = map(l, function(t) {
					var n = [], r = [];
					fromPoints(t, n, r);
					var a = (r[1] - n[1]) * (r[0] - n[0]);
					return f += a, {
						poly: t,
						area: a
					};
				});
				p.sort(function(t, n) {
					return n.area - t.area;
				});
				for (var h = n, d = 0; d < u; d++) {
					var g = p[d];
					if (h <= 0) break;
					var _ = d === u - 1 ? h : Math.ceil(g.area / f * n);
					_ < 0 || (binaryDivideRecursive(binaryDividePolygon, { points: g.poly }, _, r), h -= _);
				}
			}
			o = Polygon_default;
			break;
	}
	if (!o) return clone(t, n);
	for (var v = [], d = 0; d < r.length; d++) {
		var y = new o();
		y.setShape(r[d]), copyPathProps(t, y), v.push(y);
	}
	return v;
}
function alignSubpath(t, n) {
	var r = t.length, a = n.length;
	if (r === a) return [t, n];
	for (var o = [], s = [], c = r < a ? t : n, l = Math.min(r, a), u = Math.abs(a - r) / 6, d = (l - 2) / 6, f = Math.ceil(u / d) + 1, p = [c[0], c[1]], h = u, g = 2; g < l;) {
		var _ = c[g - 2], v = c[g - 1], y = c[g++], b = c[g++], x = c[g++], S = c[g++], C = c[g++], w = c[g++];
		if (h <= 0) {
			p.push(y, b, x, S, C, w);
			continue;
		}
		for (var T = Math.min(h, f - 1) + 1, E = 1; E <= T; E++) {
			var D = E / T;
			cubicSubdivide(_, y, x, C, D, o), cubicSubdivide(v, b, S, w, D, s), _ = o[3], v = s[3], p.push(o[1], s[1], o[2], s[2], _, v), y = o[5], b = s[5], x = o[6], S = s[6];
		}
		h -= T - 1;
	}
	return c === t ? [p, n] : [t, p];
}
function createSubpath(t, n) {
	for (var r = t.length, a = t[r - 2], o = t[r - 1], s = [], c = 0; c < n.length;) s[c++] = a, s[c++] = o;
	return s;
}
function alignBezierCurves(t, n) {
	for (var r, a, o, s = [], c = [], l = 0; l < Math.max(t.length, n.length); l++) {
		var u = t[l], d = n[l], f = void 0, p = void 0;
		u ? d ? (r = alignSubpath(u, d), f = r[0], p = r[1], a = f, o = p) : (p = createSubpath(o || u, u), f = u) : (f = createSubpath(a || d, d), p = d), s.push(f), c.push(p);
	}
	return [s, c];
}
function centroid(t) {
	for (var n = 0, r = 0, a = 0, o = t.length, s = 0, c = o - 2; s < o; c = s, s += 2) {
		var l = t[c], u = t[c + 1], d = t[s], f = t[s + 1], p = l * f - d * u;
		n += p, r += (l + d) * p, a += (u + f) * p;
	}
	return n === 0 ? [t[0] || 0, t[1] || 0] : [
		r / n / 3,
		a / n / 3,
		n
	];
}
function findBestRingOffset(t, n, r, a) {
	for (var o = (t.length - 2) / 6, s = Infinity, c = 0, l = t.length, u = l - 2, d = 0; d < o; d++) {
		for (var f = d * 6, p = 0, h = 0; h < l; h += 2) {
			var g = h === 0 ? f : (f + h - 2) % u + 2, _ = t[g] - r[0], v = t[g + 1] - r[1], y = n[h] - a[0], b = n[h + 1] - a[1], x = y - _, S = b - v;
			p += x * x + S * S;
		}
		p < s && (s = p, c = d);
	}
	return c;
}
function reverse(t) {
	for (var n = [], r = t.length, a = 0; a < r; a += 2) n[a] = t[r - a - 2], n[a + 1] = t[r - a - 1];
	return n;
}
function findBestMorphingRotation(t, n, r, a) {
	for (var o = [], s, c = 0; c < t.length; c++) {
		var l = t[c], u = n[c], d = centroid(l), f = centroid(u);
		s ??= d[2] < 0 != f[2] < 0;
		var p = [], h = [], g = 0, _ = Infinity, v = [], y = l.length;
		s && (l = reverse(l));
		for (var b = findBestRingOffset(l, u, d, f) * 6, x = y - 2, S = 0; S < x; S += 2) {
			var C = (b + S) % x + 2;
			p[S + 2] = l[C] - d[0], p[S + 3] = l[C + 1] - d[1];
		}
		if (p[0] = l[b] - d[0], p[1] = l[b + 1] - d[1], r > 0) for (var w = a / r, T = -a / 2; T <= a / 2; T += w) {
			for (var E = Math.sin(T), D = Math.cos(T), O = 0, S = 0; S < l.length; S += 2) {
				var A = p[S], j = p[S + 1], M = u[S] - f[0], N = u[S + 1] - f[1], P = M * D - N * E, F = M * E + N * D;
				v[S] = P, v[S + 1] = F;
				var I = P - A, L = F - j;
				O += I * I + L * L;
			}
			if (O < _) {
				_ = O, g = T;
				for (var R = 0; R < v.length; R++) h[R] = v[R];
			}
		}
		else for (var z = 0; z < y; z += 2) h[z] = u[z] - f[0], h[z + 1] = u[z + 1] - f[1];
		o.push({
			from: p,
			to: h,
			fromCp: d,
			toCp: f,
			rotation: -g
		});
	}
	return o;
}
function isCombineMorphing(t) {
	return t.__isCombineMorphing;
}
var SAVED_METHOD_PREFIX = "__mOriginal_";
function saveAndModifyMethod(t, n, r) {
	var a = SAVED_METHOD_PREFIX + n, o = t[a] || t[n];
	t[a] || (t[a] = t[n]);
	var s = r.replace, c = r.after, l = r.before;
	t[n] = function() {
		var t = arguments, n;
		return l && l.apply(this, t), n = s ? s.apply(this, t) : o.apply(this, t), c && c.apply(this, t), n;
	};
}
function restoreMethod(t, n) {
	var r = SAVED_METHOD_PREFIX + n;
	t[r] && (t[n] = t[r], t[r] = null);
}
function applyTransformOnBeziers(t, n) {
	for (var r = 0; r < t.length; r++) for (var a = t[r], o = 0; o < a.length;) {
		var s = a[o], c = a[o + 1];
		a[o++] = n[0] * s + n[2] * c + n[4], a[o++] = n[1] * s + n[3] * c + n[5];
	}
}
function prepareMorphPath(t, n) {
	var r = t.getUpdatedPathProxy(), a = n.getUpdatedPathProxy(), o = alignBezierCurves(pathToBezierCurves(r), pathToBezierCurves(a)), s = o[0], c = o[1], l = t.getComputedTransform(), u = n.getComputedTransform();
	function d() {
		this.transform = null;
	}
	l && applyTransformOnBeziers(s, l), u && applyTransformOnBeziers(c, u), saveAndModifyMethod(n, "updateTransform", { replace: d }), n.transform = null;
	var f = findBestMorphingRotation(s, c, 10, Math.PI), p = [];
	saveAndModifyMethod(n, "buildPath", { replace: function(t) {
		for (var r = n.__morphT, a = 1 - r, o = [], s = 0; s < f.length; s++) {
			var c = f[s], l = c.from, u = c.to, d = c.rotation * r, h = c.fromCp, g = c.toCp, _ = Math.sin(d), v = Math.cos(d);
			lerp(o, h, g, r);
			for (var y = 0; y < l.length; y += 2) {
				var b = l[y], x = l[y + 1], S = u[y], C = u[y + 1], w = b * a + S * r, T = x * a + C * r;
				p[y] = w * v - T * _ + o[0], p[y + 1] = w * _ + T * v + o[1];
			}
			var E = p[0], D = p[1];
			t.moveTo(E, D);
			for (var y = 2; y < l.length;) {
				var S = p[y++], C = p[y++], O = p[y++], A = p[y++], j = p[y++], M = p[y++];
				E === S && D === C && O === j && A === M ? t.lineTo(j, M) : t.bezierCurveTo(S, C, O, A, j, M), E = j, D = M;
			}
		}
	} });
}
function morphPath(t, n, r) {
	if (!t || !n) return n;
	var a = r.done, o = r.during;
	prepareMorphPath(t, n), n.__morphT = 0;
	function s() {
		restoreMethod(n, "buildPath"), restoreMethod(n, "updateTransform"), n.__morphT = -1, n.createPathProxy(), n.dirtyShape();
	}
	return n.animateTo({ __morphT: 1 }, defaults({
		during: function(t) {
			n.dirtyShape(), o && o(t);
		},
		done: function() {
			s(), a && a();
		}
	}, r)), n;
}
function hilbert(t, n, r, a, o, s) {
	var c = 16;
	t = o === r ? 0 : Math.round(32767 * (t - r) / (o - r)), n = s === a ? 0 : Math.round(32767 * (n - a) / (s - a));
	for (var l = 0, u, d = (1 << c) / 2; d > 0; d /= 2) {
		var f = 0, p = 0;
		(t & d) > 0 && (f = 1), (n & d) > 0 && (p = 1), l += d * d * (3 * f ^ p), p === 0 && (f === 1 && (t = d - 1 - t, n = d - 1 - n), u = t, t = n, n = u);
	}
	return l;
}
function sortPaths(t) {
	var n = Infinity, r = Infinity, a = -Infinity, o = -Infinity;
	return map(map(t, function(t) {
		var s = t.getBoundingRect(), c = t.getComputedTransform(), l = s.x + s.width / 2 + (c ? c[4] : 0), u = s.y + s.height / 2 + (c ? c[5] : 0);
		return n = Math.min(l, n), r = Math.min(u, r), a = Math.max(l, a), o = Math.max(u, o), [l, u];
	}), function(s, c) {
		return {
			cp: s,
			z: hilbert(s[0], s[1], n, r, a, o),
			path: t[c]
		};
	}).sort(function(t, n) {
		return t.z - n.z;
	}).map(function(t) {
		return t.path;
	});
}
function defaultDividePath(t) {
	return split(t.path, t.count);
}
function createEmptyReturn() {
	return {
		fromIndividuals: [],
		toIndividuals: [],
		count: 0
	};
}
function combineMorph(t, n, r) {
	var a = [];
	function o(t) {
		for (var n = 0; n < t.length; n++) {
			var r = t[n];
			isCombineMorphing(r) ? o(r.childrenRef()) : r instanceof Path_default && a.push(r);
		}
	}
	o(t);
	var s = a.length;
	if (!s) return createEmptyReturn();
	var c = (r.dividePath || defaultDividePath)({
		path: n,
		count: s
	});
	if (c.length !== s) return console.error("Invalid morphing: unmatched splitted path"), createEmptyReturn();
	a = sortPaths(a), c = sortPaths(c);
	for (var l = r.done, u = r.during, d = r.individualDelay, f = new Transformable_default(), p = 0; p < s; p++) {
		var h = a[p], g = c[p];
		g.parent = n, g.copyTransform(f), d || prepareMorphPath(h, g);
	}
	n.__isCombineMorphing = !0, n.childrenRef = function() {
		return c;
	};
	function _(t) {
		for (var n = 0; n < c.length; n++) c[n].addSelfToZr(t);
	}
	saveAndModifyMethod(n, "addSelfToZr", { after: function(t) {
		_(t);
	} }), saveAndModifyMethod(n, "removeSelfFromZr", { after: function(t) {
		for (var n = 0; n < c.length; n++) c[n].removeSelfFromZr(t);
	} });
	function v() {
		n.__isCombineMorphing = !1, n.__morphT = -1, n.childrenRef = null, restoreMethod(n, "addSelfToZr"), restoreMethod(n, "removeSelfFromZr");
	}
	var y = c.length;
	if (d) for (var b = y, x = function() {
		b--, b === 0 && (v(), l && l());
	}, p = 0; p < y; p++) {
		var S = d ? defaults({
			delay: (r.delay || 0) + d(p, y, a[p], c[p]),
			done: x
		}, r) : r;
		morphPath(a[p], c[p], S);
	}
	else n.__morphT = 0, n.animateTo({ __morphT: 1 }, defaults({
		during: function(t) {
			for (var r = 0; r < y; r++) {
				var a = c[r];
				a.__morphT = n.__morphT, a.dirtyShape();
			}
			u && u(t);
		},
		done: function() {
			v();
			for (var n = 0; n < t.length; n++) restoreMethod(t[n], "updateTransform");
			l && l();
		}
	}, r));
	return n.__zr && _(n.__zr), {
		fromIndividuals: a,
		toIndividuals: c,
		count: y
	};
}
function separateMorph(t, n, r) {
	var a = n.length, o = [], s = r.dividePath || defaultDividePath;
	function c(t) {
		for (var n = 0; n < t.length; n++) {
			var r = t[n];
			isCombineMorphing(r) ? c(r.childrenRef()) : r instanceof Path_default && o.push(r);
		}
	}
	if (isCombineMorphing(t)) {
		c(t.childrenRef());
		var l = o.length;
		if (l < a) for (var u = 0, d = l; d < a; d++) o.push(clonePath(o[u++ % l]));
		o.length = a;
	} else {
		o = s({
			path: t,
			count: a
		});
		for (var f = t.getComputedTransform(), d = 0; d < o.length; d++) o[d].setLocalTransform(f);
		if (o.length !== a) return console.error("Invalid morphing: unmatched splitted path"), createEmptyReturn();
	}
	o = sortPaths(o), n = sortPaths(n);
	for (var p = r.individualDelay, d = 0; d < a; d++) {
		var h = p ? defaults({ delay: (r.delay || 0) + p(d, a, o[d], n[d]) }, r) : r;
		morphPath(o[d], n[d], h);
	}
	return {
		fromIndividuals: o,
		toIndividuals: n,
		count: n.length
	};
}
function isMultiple(t) {
	return isArray(t[0]);
}
function prepareMorphBatches(t, n) {
	for (var r = [], a = t.length, o = 0; o < a; o++) r.push({
		one: t[o],
		many: []
	});
	for (var o = 0; o < n.length; o++) {
		var s = n[o].length, c = void 0;
		for (c = 0; c < s; c++) r[c % a].many.push(n[o][c]);
	}
	for (var l = 0, o = a - 1; o >= 0; o--) if (!r[o].many.length) {
		var u = r[l].many;
		if (u.length <= 1) if (l) l = 0;
		else return r;
		var s = u.length, d = Math.ceil(s / 2);
		r[o].many = u.slice(d, s), r[l].many = u.slice(0, d), l++;
	}
	return r;
}
var pathDividers = {
	clone: function(t) {
		for (var n = [], r = 1 - (1 - t.path.style.opacity) ** (1 / t.count), a = 0; a < t.count; a++) {
			var o = clonePath(t.path);
			o.setStyle("opacity", r), n.push(o);
		}
		return n;
	},
	split: null
};
function applyMorphAnimation(t, n, r, a, o, s) {
	if (!t.length || !n.length) return;
	var c = getAnimationConfig("update", a, o);
	if (!(c && c.duration > 0)) return;
	var l = a.getModel("universalTransition").get("delay"), u = Object.assign({ setToFinal: !0 }, c), d, f;
	isMultiple(t) && (d = t, f = n), isMultiple(n) && (d = n, f = t);
	function p(t, n, a, o, c) {
		var d = t.many, f = t.one;
		if (d.length === 1 && !c) {
			var h = n ? d[0] : f, g = n ? f : d[0];
			if (isCombineMorphing(h)) p({
				many: [h],
				one: g
			}, !0, a, o, !0);
			else {
				var _ = l ? defaults({ delay: l(a, o) }, u) : u;
				morphPath(h, g, _), s(h, g, h, g, _);
			}
		} else for (var v = defaults({
			dividePath: pathDividers[r],
			individualDelay: l && function(t, n, r, s) {
				return l(t + a, o);
			}
		}, u), y = n ? combineMorph(d, f, v) : separateMorph(f, d, v), b = y.fromIndividuals, x = y.toIndividuals, S = b.length, C = 0; C < S; C++) {
			var _ = l ? defaults({ delay: l(C, S) }, u) : u;
			s(b[C], x[C], n ? d[C] : t.one, n ? t.one : d[C], _);
		}
	}
	for (var h = d ? d === t : t.length > n.length, g = d ? prepareMorphBatches(f, d) : prepareMorphBatches(h ? n : t, [h ? t : n]), _ = 0, v = 0; v < g.length; v++) _ += g[v].many.length;
	for (var y = 0, v = 0; v < g.length; v++) p(g[v], h, y, _), y += g[v].many.length;
}
function getPathList(t) {
	if (!t) return [];
	if (isArray(t)) {
		for (var n = [], r = 0; r < t.length; r++) n.push(getPathList(t[r]));
		return n;
	}
	var a = [];
	return t.traverse(function(t) {
		t instanceof Path_default && !t.disableMorphing && !t.invisible && !t.ignore && a.push(t);
	}), a;
}
init_dist$2();
var DATA_COUNT_THRESHOLD = 1e4, TRANSITION_NONE = 0, TRANSITION_P2C = 1, TRANSITION_C2P = 2, getUniversalTransitionGlobalStore = makeInner();
function getDimension(t, n) {
	for (var r = t.dimensions, a = 0; a < r.length; a++) {
		var o = t.getDimensionInfo(r[a]);
		if (o && o.otherDims[n] === 0) return r[a];
	}
}
function getValueByDimension(t, n, r) {
	var a = t.getDimensionInfo(r), o = a && a.ordinalMeta;
	if (a) {
		var s = t.get(a.name, n);
		return o && o.categories[s] || s + "";
	}
}
function getGroupId(t, n, r, a) {
	var o = getDimension(t, a ? "itemChildGroupId" : "itemGroupId");
	if (o) return getValueByDimension(t, n, o);
	var s = t.getRawDataItem(n), c = a ? "childGroupId" : "groupId";
	if (s && s[c]) return s[c] + "";
	if (!a) return r || t.getId(n);
}
function flattenDataDiffItems(t) {
	var n = [];
	return each(t, function(t) {
		var r = t.data, a = t.dataGroupId;
		if (r.count() > DATA_COUNT_THRESHOLD) {
			process$1.env.NODE_ENV !== "production" && warn("Universal transition is disabled on large data > 10k.");
			return;
		}
		for (var o = r.getIndices(), c = 0; c < o.length; c++) n.push({
			data: r,
			groupId: getGroupId(r, c, a, !1),
			childGroupId: getGroupId(r, c, a, !0),
			divide: t.divide,
			dataIndex: c
		});
	}), n;
}
function fadeInElement(t, n, r) {
	t.traverse(function(t) {
		t instanceof Path_default && initProps(t, { style: { opacity: 0 } }, n, {
			dataIndex: r,
			isFrom: !0
		});
	});
}
function removeEl(t) {
	if (t.parent) {
		var n = t.getComputedTransform();
		t.setLocalTransform(n), t.parent.remove(t);
	}
}
function stopAnimation(t) {
	t.stopAnimation(), t.isGroup && t.traverse(function(t) {
		t.stopAnimation();
	});
}
function animateElementStyles(t, n, r) {
	var a = getAnimationConfig("update", r, n);
	a && t.traverse(function(t) {
		if (t instanceof Displayable_default) {
			var n = getOldStyle(t);
			n && t.animateFrom({ style: n }, a);
		}
	});
}
function isAllIdSame(t, n) {
	var r = t.length;
	if (r !== n.length) return !1;
	for (var a = 0; a < r; a++) {
		var o = t[a], s = n[a];
		if (o.data.getId(o.dataIndex) !== s.data.getId(s.dataIndex)) return !1;
	}
	return !0;
}
function transitionBetween(t, n, r) {
	var a = flattenDataDiffItems(t), o = flattenDataDiffItems(n);
	function s(t, n, r, a, o) {
		(r || t) && n.animateFrom({ style: r && r !== t ? extend(extend({}, r.style), t.style) : t.style }, o);
	}
	var c = !1, l = TRANSITION_NONE, u = createHashMap(), d = createHashMap();
	a.forEach(function(t) {
		t.groupId && u.set(t.groupId, !0), t.childGroupId && d.set(t.childGroupId, !0);
	});
	for (var f = 0; f < o.length; f++) {
		var p = o[f].groupId;
		if (d.get(p)) {
			l = TRANSITION_P2C;
			break;
		}
		var h = o[f].childGroupId;
		if (h && u.get(h)) {
			l = TRANSITION_C2P;
			break;
		}
	}
	function g(t, n) {
		return function(r) {
			var a = r.data, o = r.dataIndex;
			return n ? a.getId(o) : t ? l === TRANSITION_P2C ? r.childGroupId : r.groupId : l === TRANSITION_C2P ? r.childGroupId : r.groupId;
		};
	}
	var _ = isAllIdSame(a, o), v = {};
	if (!_) for (var f = 0; f < o.length; f++) {
		var y = o[f], b = y.data.getItemGraphicEl(y.dataIndex);
		b && (v[b.id] = !0);
	}
	function x(t, n) {
		var r = a[n], l = o[t], u = l.data.hostModel, d = r.data.getItemGraphicEl(r.dataIndex), f = l.data.getItemGraphicEl(l.dataIndex);
		if (d === f) {
			f && animateElementStyles(f, l.dataIndex, u);
			return;
		}
		d && v[d.id] || f && (stopAnimation(f), d ? (stopAnimation(d), removeEl(d), c = !0, applyMorphAnimation(getPathList(d), getPathList(f), l.divide, u, t, s)) : fadeInElement(f, u, t));
	}
	new DataDiffer_default(a, o, g(!0, _), g(!1, _), null, "multiple").update(x).updateManyToOne(function(t, n) {
		var r = o[t], l = r.data, u = l.hostModel, d = l.getItemGraphicEl(r.dataIndex), f = filter(map(n, function(t) {
			return a[t].data.getItemGraphicEl(a[t].dataIndex);
		}), function(t) {
			return t && t !== d && !v[t.id];
		});
		d && (stopAnimation(d), f.length ? (each(f, function(t) {
			stopAnimation(t), removeEl(t);
		}), c = !0, applyMorphAnimation(getPathList(f), getPathList(d), r.divide, u, t, s)) : fadeInElement(d, u, r.dataIndex));
	}).updateOneToMany(function(t, n) {
		var r = a[n], l = r.data.getItemGraphicEl(r.dataIndex);
		if (!(l && v[l.id])) {
			var u = filter(map(t, function(t) {
				return o[t].data.getItemGraphicEl(o[t].dataIndex);
			}), function(t) {
				return t && t !== l;
			}), d = o[t[0]].data.hostModel;
			u.length && (each(u, function(t) {
				return stopAnimation(t);
			}), l ? (stopAnimation(l), removeEl(l), c = !0, applyMorphAnimation(getPathList(l), getPathList(u), r.divide, d, t[0], s)) : each(u, function(n) {
				return fadeInElement(n, d, t[0]);
			}));
		}
	}).updateManyToMany(function(t, n) {
		new DataDiffer_default(n, t, function(t) {
			return a[t].data.getId(a[t].dataIndex);
		}, function(t) {
			return o[t].data.getId(o[t].dataIndex);
		}).update(function(r, a) {
			x(t[r], n[a]);
		}).execute();
	}).execute(), c && each(n, function(t) {
		var n = t.data.hostModel, a = n && r.getViewOfSeriesModel(n), o = getAnimationConfig("update", n, 0);
		a && n.isAnimationEnabled() && o && o.duration > 0 && a.group.traverse(function(t) {
			t instanceof Path_default && !t.animators.length && t.animateFrom({ style: { opacity: 0 } }, o);
		});
	});
}
function getSeriesTransitionKey(t) {
	return t.getModel("universalTransition").get("seriesKey") || t.id;
}
function convertArraySeriesKeyToString(t) {
	return isArray(t) ? t.sort().join(",") : t;
}
function getDivideShapeFromData(t) {
	if (t.hostModel) return t.hostModel.getModel("universalTransition").get("divideShape");
}
function findTransitionSeriesBatches(t, n) {
	var r = createHashMap(), a = createHashMap(), o = createHashMap();
	each(t.oldSeries, function(n, r) {
		var s = t.oldDataGroupIds[r], c = t.oldData[r], l = getSeriesTransitionKey(n), u = convertArraySeriesKeyToString(l);
		a.set(u, {
			dataGroupId: s,
			data: c
		}), isArray(l) && each(l, function(t) {
			o.set(t, {
				key: u,
				dataGroupId: s,
				data: c
			});
		});
	});
	function c(t) {
		r.get(t) && warn("Duplicated seriesKey in universalTransition " + t);
	}
	return each(n.updatedSeries, function(t) {
		if (t.isUniversalTransitionEnabled() && t.isAnimationEnabled()) {
			var n = t.get("dataGroupId"), l = t.getData(), u = getSeriesTransitionKey(t), d = convertArraySeriesKeyToString(u), f = a.get(d);
			if (f) process$1.env.NODE_ENV !== "production" && c(d), r.set(d, {
				oldSeries: [{
					dataGroupId: f.dataGroupId,
					divide: getDivideShapeFromData(f.data),
					data: f.data
				}],
				newSeries: [{
					dataGroupId: n,
					divide: getDivideShapeFromData(l),
					data: l
				}]
			});
			else if (isArray(u)) {
				process$1.env.NODE_ENV !== "production" && c(d);
				var p = [];
				each(u, function(t) {
					var n = a.get(t);
					n.data && p.push({
						dataGroupId: n.dataGroupId,
						divide: getDivideShapeFromData(n.data),
						data: n.data
					});
				}), p.length && r.set(d, {
					oldSeries: p,
					newSeries: [{
						dataGroupId: n,
						data: l,
						divide: getDivideShapeFromData(l)
					}]
				});
			} else {
				var h = o.get(u);
				if (h) {
					var g = r.get(h.key);
					g || (g = {
						oldSeries: [{
							dataGroupId: h.dataGroupId,
							data: h.data,
							divide: getDivideShapeFromData(h.data)
						}],
						newSeries: []
					}, r.set(h.key, g)), g.newSeries.push({
						dataGroupId: n,
						data: l,
						divide: getDivideShapeFromData(l)
					});
				}
			}
		}
	}), r;
}
function querySeries(t, n) {
	for (var r = 0; r < t.length; r++) if (n.seriesIndex != null && n.seriesIndex === t[r].seriesIndex || n.seriesId != null && n.seriesId === t[r].id) return r;
}
function transitionSeriesFromOpt(t, n, r, a) {
	var o = [], s = [];
	each(normalizeToArray(t.from), function(t) {
		var r = querySeries(n.oldSeries, t);
		r >= 0 && o.push({
			dataGroupId: n.oldDataGroupIds[r],
			data: n.oldData[r],
			divide: getDivideShapeFromData(n.oldData[r]),
			groupIdDim: t.dimension
		});
	}), each(normalizeToArray(t.to), function(t) {
		var a = querySeries(r.updatedSeries, t);
		if (a >= 0) {
			var o = r.updatedSeries[a].getData();
			s.push({
				dataGroupId: n.oldDataGroupIds[a],
				data: o,
				divide: getDivideShapeFromData(o),
				groupIdDim: t.dimension
			});
		}
	}), o.length > 0 && s.length > 0 && transitionBetween(o, s, a);
}
function installUniversalTransition(t) {
	t.registerUpdateLifecycle("series:beforeupdate", function(t, n, r) {
		each(normalizeToArray(r.seriesTransition), function(t) {
			each(normalizeToArray(t.to), function(t) {
				for (var n = r.updatedSeries, a = 0; a < n.length; a++) (t.seriesIndex != null && t.seriesIndex === n[a].seriesIndex || t.seriesId != null && t.seriesId === n[a].id) && (n[a][SERIES_UNIVERSAL_TRANSITION_PROP] = !0);
			});
		});
	}), t.registerUpdateLifecycle("series:transition", function(t, n, r) {
		var a = getUniversalTransitionGlobalStore(n);
		if (a.oldSeries && r.updatedSeries && r.optionChanged) {
			var o = r.seriesTransition;
			if (o) each(normalizeToArray(o), function(t) {
				transitionSeriesFromOpt(t, a, r, n);
			});
			else {
				var s = findTransitionSeriesBatches(a, r);
				each(s.keys(), function(t) {
					var r = s.get(t);
					transitionBetween(r.oldSeries, r.newSeries, n);
				});
			}
			each(r.updatedSeries, function(t) {
				t.__universalTransitionEnabled && (t[SERIES_UNIVERSAL_TRANSITION_PROP] = !1);
			});
		}
		for (var c = t.getSeries(), l = a.oldSeries = [], u = a.oldDataGroupIds = [], d = a.oldData = [], f = 0; f < c.length; f++) {
			var p = c[f].getData();
			p.count() < DATA_COUNT_THRESHOLD && (l.push(c[f]), u.push(c[f].get("dataGroupId")), d.push(p));
		}
	});
}
use([install$1]), use([install]), use([
	install$2,
	install$3,
	install$4,
	install$5,
	install$6,
	install$7,
	install$8,
	install$9,
	install$10,
	install$11,
	install$12,
	install$13,
	install$14,
	install$15,
	install$16,
	install$17,
	install$18,
	install$19,
	install$20,
	install$21,
	install$22,
	install$23
]), use(install$24), use(install$25), use(install$26), use(install$27), use(install$28), use(install$29), use(install$30), use(install$31), use(install$32), use(install$33), use(install$34), use(install$35), use(install$36), use(install$37), use(install$38), use(install$39), use(install$40), use(install$41), use(install$42), use(install$43), use(install$44), use(install$45), use(install$46), use(install$47), use(install$49), use(install$48), use(installUniversalTransition), use(installLabelLayout);
export { Axis_default as Axis, Chart_default as ChartView, Component_default as ComponentModel, Component_default$1 as ComponentView, SeriesData_default as List, Model_default as Model, PRIORITY, Series_default as SeriesModel, color_exports as color, connect, dataTool, dependencies, disConnect, disconnect, dispose, env_default as env, extendChartView, extendComponentModel, extendComponentView, extendSeriesModel, format_exports as format, getCoordinateSystemDimensions, getInstanceByDom, getInstanceById, getMap, graphic_exports as graphic, helper_exports as helper, init, brushSingle as innerDrawElementOnCanvas, matrix_exports as matrix, number_exports as number, parseGeoJSON, parseGeoJSON as parseGeoJson, registerAction, registerCoordinateSystem, registerLayout, registerLoading, registerLocale, registerMap, registerPostInit, registerPostUpdate, registerPreprocessor, registerProcessor, registerTheme, registerTransform, registerUpdateLifecycle, registerVisual, setCanvasCreator, setPlatformAPI, throttle, time_exports as time, use, util_exports as util, vector_exports as vector, version, util_exports$1 as zrUtil, zrender_exports as zrender };

//# sourceMappingURL=echarts-CWSoJGwD.js.map